{"author": "bgmanuel99", "file": "PracticasArquitecturaDeComputadores__calculo.1.c", "original_string": "int main(int argc, char** argv)\n{\n    FILE *fd;\n    fd = fopen(\"miliParalelo.txt\", \"r\");\n    get_media(fd, \"Paralelo\");\n    fd = fopen(\"mili.txt\", \"r\");\n    get_media(fd, \"Serie\");\n    return 0;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler.8.c", "original_string": "int main()\n{\n    PNODE First = NULL;\n    PNODE Last = NULL;          \n    int no = 0, iRet = 0;\n    printf(\"Enter number : \");\n    scanf(\"%d\",&no);\n    InsertFirst(&First,&Last,no);\n    printf(\"Enter number : \");\n    scanf(\"%d\",&no);\n    InsertFirst(&First,&Last,no);\n    printf(\"Enter number : \");\n    scanf(\"%d\",&no);\n    InsertFirst(&First,&Last,no);\n    printf(\"Enter number : \");\n    scanf(\"%d\",&no);\n    InsertFirst(&First,&Last,no);\n    printf(\"Contents of linked lista are \\n\");\n    Display(First, Last);\n    iRet = Count(First,Last);\n    printf(\"\\nNumber of lements are %d\\n\",iRet);\n    DeleteLast(&First,&Last);\n    DeleteFirst(&First,&Last);\n    printf(\"Contents of linked lista are \\n\");\n    Display(First, Last);\n        return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d\",temp->data);\n    printf(\"\\n\");\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__check_enemy.2.c", "original_string": "static void special_check(t_m *m, int x, int y)\n{\n    m->off_x = x;\n    m->off_y = y;\n    recursive_check(m, m->act_x + x, m->act_y + y);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__3.5.c", "original_string": "double triangulos(pontos_t *poligono, int n, int m)\n{\n    double triangulos;\n    triangulos = fatorial(n) / (fatorial(n-m) * fatorial(m));\n    return triangulos;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__reverse_the_DLL.0.c", "original_string": "int main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of element in the linked list\\n\");\n    printf(\"4.revers the linked list\\n\");\n    printf(\"5.exit\\n\");\n    int choice;\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1: printf(\"implementation\\n\");\n            creat();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of element in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"revers the linked list\\n\");\n            reverse();\n            break;\n            case 5:printf(\"exit \\n\");\n            exit(0);\n            break;\n            default:printf(\"invalied choice \\n\");\n            break;\n        }\n         printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "augustogunsch", "file": "jack-compiler__os.12.c", "original_string": "void freeosclasses(CLASS* c) {\n    freeossubroutdecs(c->subroutdecs);\n    free(c->name);\n    CLASS* next = c->next;\n    free(c);\n    if(next != NULL)\n        freeosclasses(next);\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.40.c", "original_string": "ASMBLK* translatevm(VMTRANSLATOR* t) {\n    ASMBLK* blk = copytemplate(&tbootstrap);\n    while(t->currln != NULL) {\n        mergeasmblks(blk, translateln(t));\n        t->currln = t->currln->next;\n    }\n    return blk;\n}"}
{"author": "flora0110", "file": "hw04git__4108056029_30.1.c", "original_string": "void mark(char** ans,int** see,int seen,int v,int z,int g,int monsta,int row,int col,int mirror,int dir){\n    int i,j;\n    char origin=ans[row][col];\n    if(v<0||z<0||g<0||monsta<0 || monsta>see[seen][0]){\n        return;\n    }\n    if(ans[row][col]=='x' && monsta!=0){\n        return;\n    }\n    if(ans[row][col]=='x' && monsta==0){\n        if(seen==4*n-1){\n            for(i=0;i<n+2;i++){\n                for(j=0;j<n+2;j++){\n                    printf(\"%c\",ans[i][j]);\n                }\n                printf(\"\\n\");\n            }\n            return;\n        }\n        mark(ans,see,seen+1,v,z,g,see[seen+1][0],see[seen+1][1],see[seen+1][2],0,see[seen+1][3]);\n        return;\n    }\n    if(ans[row][col]=='\\\\'){\n        mirror=1;\n        switch (dir) {\n            case 0: dir=3;break;      case 1: dir=2;break;     case 2: dir=1;break;    case 3: dir=0;break;\n        }\n    }\n    else if(ans[row][col]=='/'){\n        mirror=1;\n        switch (dir) {\n            case 0: dir=1;break;  case 1: dir=0;break;  case 2: dir=3;break;  case 3: dir=2;break;\n        }\n    }\n    int nextrow=row+orien[dir].row,nextcol=col+orien[dir].col,nextmonsta=monsta;\n    if(ans[row][col]=='Z'||ans[row][col]=='G'||ans[row][col]=='V'){\n        if(ans[row][col]=='Z') nextmonsta--;\n        if(mirror==1 && ans[row][col]=='G') nextmonsta--;\n        else if(mirror==0 && ans[row][col]=='V') nextmonsta--;\n        mark(ans,see,seen,v,z,g,nextmonsta,nextrow,nextcol,mirror,dir);\n    }\n    else if(ans[row][col]=='.'){\n        ans[row][col]='Z';\n        mark(ans,see,seen,v,z-1,g,monsta-1,nextrow,nextcol,mirror,dir);\n        if(mirror==1){\n            ans[row][col]='G';\n            mark(ans,see,seen,v,z,g-1,monsta-1,nextrow,nextcol,mirror,dir);\n            ans[row][col]='V';\n            mark(ans,see,seen,v-1,z,g,monsta,nextrow,nextcol,mirror,dir);\n        }\n        else if(mirror==0){\n            ans[row][col]='G';\n            mark(ans,see,seen,v,z,g-1,monsta,nextrow,nextcol,mirror,dir);\n            ans[row][col]='V';\n            mark(ans,see,seen,v-1,z,g,monsta-1,nextrow,nextcol,mirror,dir);\n        }\n    }\n    else mark(ans,see,seen,v,z,g,monsta,nextrow,nextcol,mirror,dir);\n    ans[row][col]=origin;\n    return;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__DemoFOTAUpdateWorkflow0.4.c", "original_string": "static void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;\n  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;\n  instance->updateInfo.version = NULL;\n  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;\n  instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_pim.1.c", "original_string": "void rstpPimFsm(RstpBridgePort *port)\n{\n   if(!port->portEnabled && port->infoIs != RSTP_INFO_IS_DISABLED)\n   {\n      rstpPimChangeState(port, RSTP_PIM_STATE_DISABLED);\n   }\n   else\n   {\n      switch(port->pimState)\n      {\n      case RSTP_PIM_STATE_DISABLED:\n         if(port->rcvdMsg)\n         {\n            rstpPimChangeState(port, RSTP_PIM_STATE_DISABLED);\n         }\n         else if(port->portEnabled)\n         {\n            rstpPimChangeState(port, RSTP_PIM_STATE_AGED);\n         }\n         else\n         {\n         }\n         break;\n      case RSTP_PIM_STATE_AGED:\n         if(port->selected && port->updtInfo)\n         {\n            rstpPimChangeState(port, RSTP_PIM_STATE_UPDATE);\n         }\n         break;\n      case RSTP_PIM_STATE_UPDATE:\n      case RSTP_PIM_STATE_SUPERIOR_DESIGNATED:\n      case RSTP_PIM_STATE_REPEATED_DESIGNATED:\n      case RSTP_PIM_STATE_INFERIOR_DESIGNATED:\n      case RSTP_PIM_STATE_NOT_DESIGNATED:\n      case RSTP_PIM_STATE_OTHER:\n         rstpPimChangeState(port, RSTP_PIM_STATE_CURRENT);\n         break;\n      case RSTP_PIM_STATE_CURRENT:\n         if(port->selected && port->updtInfo)\n         {\n            rstpPimChangeState(port, RSTP_PIM_STATE_UPDATE);\n         }\n         else if(port->infoIs == RSTP_INFO_IS_RECEIVED &&\n            port->rcvdInfoWhile == 0 && !port->updtInfo && !port->rcvdMsg)\n         {\n            rstpPimChangeState(port, RSTP_PIM_STATE_AGED);\n         }\n         else if(port->rcvdMsg && !port->updtInfo)\n         {\n            rstpPimChangeState(port, RSTP_PIM_STATE_RECEIVE);\n         }\n         else\n         {\n         }\n         break;\n      case RSTP_PIM_STATE_RECEIVE:\n         if(port->rcvdInfo == RSTP_RCVD_INFO_SUPERIOR_DESIGNATED)\n         {\n            rstpPimChangeState(port, RSTP_PIM_STATE_SUPERIOR_DESIGNATED);\n         }\n         else if(port->rcvdInfo == RSTP_RCVD_INFO_REPEATED_DESIGNATED)\n         {\n            rstpPimChangeState(port, RSTP_PIM_STATE_REPEATED_DESIGNATED);\n         }\n         else if(port->rcvdInfo == RSTP_RCVD_INFO_INFERIOR_DESIGNATED)\n         {\n            rstpPimChangeState(port, RSTP_PIM_STATE_INFERIOR_DESIGNATED);\n         }\n         else if(port->rcvdInfo == RSTP_RCVD_INFO_INFERIOR_ROOT_ALTERNATE)\n         {\n            rstpPimChangeState(port, RSTP_PIM_STATE_NOT_DESIGNATED);\n         }\n         else if(port->rcvdInfo == RSTP_RCVD_INFO_OTHER)\n         {\n            rstpPimChangeState(port, RSTP_PIM_STATE_OTHER);\n         }\n         else\n         {\n         }\n         break;\n      default:\n         rstpFsmError(port->context);\n         break;\n      }\n   }\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_4.3.c", "original_string": "int is_operator(char symbol)\n{\n    if(symbol == '^' || symbol == '/' || symbol == '*' || symbol == '+' || symbol == '-')\n        return 1;\n    else\n        return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q11.4.c", "original_string": "void display(stack* ps)\n{\n    if(ps->top > -1)\n    {\n        for(int i = 0 ; i < ps->top ; i++)\n            printf(\"%d  \", ps->item[i]);\n    }\n}"}
{"author": "jose120918", "file": "sorting_algorithms__101-cocktail_sort_list.2.c", "original_string": "void cocktail_sort_list(listint_t **list)\n{\n    listint_t *current = NULL;\n    int swapped = 1;\n    if (list)\n    {\n        current = *list;\n        while (swapped)\n        {\n            swapped = 0;\n            while (current->next)\n            {\n                if (current->n > current->next->n)\n                {\n                    swapped = swp_fwd(current, list);\n                    continue;\n                }\n                current = current->next;\n            }\n            if (!swapped)\n                break;\n            swapped = 0;\n            while (current->prev)\n            {\n                if (current->n < current->prev->n)\n                {\n                    swapped = swp_bck(current, list);\n                    continue;\n                }\n                current = current->prev;\n            }\n        }\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__reverse_the_DLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\");\n    }\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "earth429", "file": "mulpre__factorial.1.c", "original_string": "int factorial(struct NUMBER *a, struct NUMBER *b) {\n    if(getSign(a) == -1){ \n        return -2;\n    }\n    struct NUMBER tmp1, tmp2, num;\n    setInt(&num, 1);\n    int flag = 0;\n    clearByZero(b);\n    while(1){\n        if(flag == 0){\n            flag++;\n            increment(&num, &tmp1);\n            multiple(&num, &tmp, b);\n            copyNumber(&tmp, &num);\n        } else {\n            increment(&num, &tmp1);\n            multiple(b, &tmp1, &tmp2);\n            copyNumber(&tmp2, b);\n        }\n        if(numComp(&tmp1, a) == 0){ \n            break;\n        }\n    }\n    return 0;\n}"}
{"author": "theuwis", "file": "AdventOfCode2017__main27.1.c", "original_string": "void print_square(void){\n    for(int i = 0; i < GRID_SIZE; i++){\n        for(int j = 0; j < GRID_SIZE; j++){\n            switch(grid[i][j]){\n                case 0 : \n                    printf(\". \");\n                    break;\n                case 1 : \n                    printf(\"W \");\n                    break;\n                case 2 : \n                    printf(\"# \");\n                    break;\n                case 3 : \n                    printf(\"F \");\n                    break;\n            }\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__led_pattern.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | LED_ALL;\n    while(1)\n    {\n        for(int i=17; i<= 24;i++)\n        {\n        IOSET1 = 1<<i;\n        delay(1000);\n        }\n        IOCLR1 = LED_ALL;\n        delay(1000);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__mergeLL.0.c", "original_string": "node* mergeTwoLLs(node *head1, node *head2) \n{\n    node* t1 = head1;\n    node* t2 = head2;\n    node* head;\n    node* tail;\n    if(head1->data <= head2->data)\n    {\n        head = head1;\n        tail = head1;\n        t1 = t1->next;\n    }   \n    else \n    {\n        head = head2;  \n        tail = head2;\n        t2 = t2->next;\n    }\n    while(t1 != NULL && t2 != NULL)\n        if(t1->data <= t2->data)\n        {\n            tail->next = t1;\n            tail = t1;\n            t1 = t1->next;\n        }   \n        else\n        {\n            tail->next = t2;\n            tail = t2;\n            t2 = t2->next;\n        }\n    if(t1 == NULL)\n        tail->next = t2;\n    else\n        tail->next = t1;\n    return head;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__i2c_receiver.1.c", "original_string": "void i2c_config(void)\n{\n    PINSEL0 |= (1<<4)|(1<<6);           \n    PINSEL0 &= ~((1<<5)|(1<<7));\n    I2CONSET    = 1<<6;     \n    I2SCLH = 75;                \n    I2SCLL = 75;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "2lista_de_C__main17.0.c", "original_string": "int main() {\n    int primo;\n    int a;\n    int b;\n    int c;\n    printf(\"Digite um numero: \");\n    scanf(\"%d\", &a);\n    for (b=a; ; b++) {\n        primo = 1;\n        for (c=2; c<b; c++) {\n            if (b % c == 0)\n                primo = 0;\n}\n                if (primo == 1) {\n            printf(\"\\n\\nO numero a direita primo mais proximo: %d\\n\", b);\n            break;\n        }\n    }\n    for (b=a;b > 0; b--) {\n        primo = 1;\n        for (c=2; c<b; c++) {\n            if (b % c == 0)\n                primo = 0;\n}\n                if (primo == 1) {\n            printf(\"O numero a esquerda primo mais proximo: %d\\n\", b);\n            break;\n        }\n    }\n}"}
{"author": "andi-s0106", "file": "binary_trees__9-binary_tree_height.1.c", "original_string": "size_t calc_height(const binary_tree_t *tree, size_t height)\n{\n    size_t left;\n    size_t right;\n    left = height;\n    right = height;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    left = left + calc_height(tree->left, height);\n    right = right + calc_height(tree->right, height);\n    if (right > left)\n    {\n        return (right + 1);\n    }\n    return (left + 1);\n}"}
{"author": "sdukesameer", "file": "dsa__dll-ins-seq-sor-del.1.c", "original_string": "void seq_insertion(node** head, int n)\n{\n    node* dll=(node*)malloc(sizeof(node));\n    dll->data=n;\n    dll->next=*head;\n    dll->prev=NULL;\n    if (*head!=NULL)\n        (*head)->prev=dll;\n    *head=dll;\n}"}
{"author": "haon1026", "file": "linux-programming__2ET_LT_pipe.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    char buf[MAXLINE];\n    char ch = 'a';\n    int pfd[2];\n    pipe(pfd);\n    pid_t pid = fork();\n    if(pid == 0)            \n    {\n        close(pfd[0]);\n        int i;\n        while(1)\n        {\n            for(i = 0; i < MAXLINE/2; i++)\n            {\n                buf[i] = ch;\n            }\n            buf[i-1] = '\\n';\n            ch++;\n            for(; i < MAXLINE; i++)\n            {\n                buf[i] = ch;\n            }\n            buf[i-1] = '\\n';\n            ch++;\n            write(pfd[1], buf, sizeof(buf));\n            sleep(5);\n        }\n        close(pfd[1]);\n    }\n    else if(pid > 0)        \n    {\n        close(pfd[1]);\n        struct epoll_event event;               \n        struct epoll_event resevent[10];        \n        int efd = epoll_create(10);\n        event.events = EPOLLIN|EPOLLET;         \n        event.data.fd = pfd[0];\n        epoll_ctl(efd, EPOLL_CTL_ADD, pfd[0], &event);\n        int res, len;\n        while(1)\n        {\n            res = epoll_wait(efd, resevent, 10, -1);\n            if(resevent[0].data.fd == pfd[0])\n            {\n                len = read(pfd[0], buf, MAXLINE/2);\n                write(STDOUT_FILENO, buf, len);\n            }\n        }\n        close(pfd[0]);\n        close(efd);\n    }\n    else\n    {\n        perror(\"fork\");\n        exit(-1);\n    }\n    return 0;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__ft_split.1.c", "original_string": "int     main(int ac, char **av)\n{\n    if (ac > 1)\n    {\n        char **a = ft_split(av[1]);\n        printf(\"%s\\n%s\\n%s\\n\",a[0],a[1],a[2]);\n    }\n    return (0);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__last_occurence.0.c", "original_string": "int SearchLastOcc(char str[], char ch)\n{\n    int i = 0;\n    int iPos = -1;\n    if((str == NULL) || (ch == '\\0'))\n    {\n        return -1;\n    }\n    while(str[i] != '\\0')\n    {\n        if(str[i] == ch)\n        {\n            iPos = i;\n        }\n        i++;\n    }\n    return iPos;\n}"}
{"author": "theuwis", "file": "AdventOfCode2017__main8.2.c", "original_string": "void move(char * command){\n    if(strncmp(command, \"n\\0\", 2) == 0){\n        y++;\n        z--;\n    }\n    else if(strncmp(command, \"ne\", 2) == 0){\n        x++;\n        z--;\n    }\n    else if(strncmp(command, \"se\", 2) == 0){\n        x++;\n        y--;\n    }\n    else if(strncmp(command, \"s\\0\", 2) == 0){\n        y--;\n        z++;\n    }\n    else if(strncmp(command, \"sw\", 2) == 0){\n        x--;\n        z++;\n    }\n    else if(strncmp(command, \"nw\", 2) == 0){\n        x--;\n        y++;\n    }\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_7.2.c", "original_string": "void dequeue()\n{\n    struct node* temp;\n    printf(\"%d deleted.\\n\", top->data);\n    if(top == NULL)\n    {\n        printf(\"Queue is Empty\\n\");\n    }\n    else\n    {\n        temp = top;\n        top = temp->link;\n        temp->link = NULL;\n        free(temp);\n    }\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Insert_At_The_End_Of_A_Single_Linked_List.0.c", "original_string": "int main()\n{\n    int choice = 1;\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->link = NULL;\n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->link = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want to enter more node?(1/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_node(temp);\n    insert_at_end(temp,head);\n    getch();\n}"}
{"author": "earth429", "file": "mulpre__mulprec.6.c", "original_string": "int isZero(struct NUMBER *a){\n    int i;\n    for (i = 0; i < KETA;i++){\n        if(a->n[i] != 0){\n            return -1;\n        }\n    }\n    return 0;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica1-3.0.c", "original_string": "int main(int argc, char * argv[]){\n    int status;\n    pid_t pid[2]; \n    switch ( fork() ){\n            case -1: \n                perror(\"fork error:\\n\");\n                fprintf(stderr, \"errno:  %i\\n\", errno); \n                exit(EXIT_FAILURE);\n                break;\n            case 0: \n                printf(\"soy un proceso hijo con PID: %i; el PID de mi proceso padre es: %i\\n\", getpid(), getppid());\n                exit(EXIT_SUCCESS); \n            }\n    switch ( fork() ){\n            case -1: \n                perror(\"fork error:\\n\");\n                fprintf(stderr, \"errno:  %i\\n\", errno); \n                exit(EXIT_FAILURE);\n                break;\n            case 0: \n                printf(\"soy un proceso hijo con PID: %i; el PID de mi proceso padre es: %i\\n\", getpid(), getppid());\n                execlp(\"open\", \"open\", \"-t\", argv[1], argv[2], NULL); \n                exit(EXIT_SUCCESS); \n            }\n    pid[0]=wait(&status);\n    pid[1]=wait(&status);\n}"}
{"author": "sdukesameer", "file": "c__rec_binary_search.1.c", "original_string": "int main()\n{\n    int arr[MAX], pos, n, val, passes;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n        scanf(\"%d\",&arr[i]);\n    scanf(\"%d\",&val);\n    passes = bSearch(arr, n, val, &pos);\n    printf(\"%d found at index: %d. Number of passes: %d\", val, pos, passes);\n    return 0;\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__27.0.c", "original_string": "void main()\n{\n    char str1[90],str2[90];\n    int z;\n    printf(\"enter string1\");\n    gets(str1);\n    printf(\"enter string2\");\n    gets(str2);\n    z=compare(str1,str2);\n    if(z==1)\n        printf(\"equal\");\n    else\n        printf(\"notequal\");\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.7.c", "original_string": "int isvar(char* var) {\n    int i = 0;\n    while(1) {\n        if(var[i] == '\\0')\n            break;\n        if(!isdigit(var[i]))\n            return 1;\n        i++;\n    }\n    return 0;\n}"}
{"author": "Mr-JoE1", "file": "Play-with-C__dec_to_hex.0.c", "original_string": "int main()\n{\n    int number,cnt,i;\n    char    hex[32];    \n    printf(\"Enter decimal number: \");\n    scanf(\"%d\",&number);\n    cnt=0;              \n    while(number>0)\n    {\n        switch(number%16)\n        {\n            case 10:\n                hex[cnt]='A'; break;\n            case 11:\n                hex[cnt]='B'; break;\n            case 12:\n                hex[cnt]='C'; break;\n            case 13:\n                hex[cnt]='D'; break;\n            case 14:\n                hex[cnt]='E'; break;\n            case 15:\n                hex[cnt]='F'; break;\n            default:\n                hex[cnt]=(number%16)+0x30;  \n        }\n        number=number/16;\n        cnt++;\n    }\n    printf(\"Hexadecimal value is: \");\n    for(i=(cnt-1); i>=0;i--)\n        printf(\"%c\",hex[i]);\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-tree.12.c", "original_string": "void freesubroutdecs(SUBROUTDEC* sr) {\n    free(sr->debug);\n    if(sr->parameters != NULL)\n        freeparameters(sr->parameters);\n    freesubroutbody(sr->body);\n    SUBROUTDEC* next = sr->next;\n    free(sr);\n    if(next != NULL)\n        freesubroutdecs(next);\n}"}
{"author": "deessee0", "file": "Appunti-C__scambia.0.c", "original_string": "void scambia(int v[], int dim, int i, int j){\n    if(dim > 0)\n    {\n        if((i > 0) && (i <= dim-1) && (j > 0) && (j <= dim-1))\n        {\n            int tmp = v[i];\n            v[i] = v[j];\n            v[j] = tmp;\n        }\n    }\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_embos.2.c", "original_string": "bool_t osCreateStaticTask(OsTask *task, const char_t *name, OsTaskCode taskCode,\n   void *param, void *stack, size_t stackSize, int_t priority)\n{\n   OS_CreateTaskEx(task, name, priority, taskCode,\n      stack, stackSize * sizeof(uint_t), 1, param);\n   return TRUE;\n}"}
{"author": "dishanp", "file": "DSA__q110.1.c", "original_string": "void rearrange(int *arr, int n)\n{\n    int i = -1, j = 0;\n    int t;\n    while (j != n)\n    {\n        if (arr[j] % 2 == 0)\n        {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n        j++;\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__bfs-dfs.5.c", "original_string": "int dequeue(queue* q){\n    int ret=q->items[0];\n    for(int i=0; i<q->end; i++)\n        q->items[i]=q->items[i+1];\n    q->end--;\n    return ret;\n}"}
{"author": "earth429", "file": "mulpre__sub.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a, b, c;\n    int x, y;\n    x = 521;\n    y = 23;\n    setInt(&a, x);\n    setInt(&b, y);\n    printf(\"x = %d\\ny = %d\\nx - y = %d\\n\", x, y, x - y);\n    sub(&a, &b, &c);\n    dispNumberZeroSuppress(&c);\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.8.c", "original_string": "TERM* parseinnerexpression(PARSER* p) {\n    TERM* t = mkterm(innerexpression);\n    next(p);\n    t->expression = parseexpression(p);\n    checkcontent(p, \")\");\n    return t;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__inToPost.1.c", "original_string": "int prec(char ch)           \n{ \n    if (ch == '+' || ch == '-')\n        return 1; \n    if (ch == '*' || ch == '/')\n        return 2; \n    if (ch == '^')\n        return 3;  \n    return -1; \n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__16_While.1.c", "original_string": "int main()\n{\n    int contador1 = 0;\n    int contador2 = 7;\n    while(contador1 < 8)\n    {\n    printf(\"\\n\");\n    if(contador1 > 4)\n        Columna(contador2 - 1);\n    else\n        Columna(contador1 - 1);\n    --contador2;\n    ++contador1;\n    }\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__ip2.4.c", "original_string": "int main()\n{\n    NODE first=NULL;\n    NODE second=NULL;\n    NODE uni=NULL;\n    NODE in=NULL;\n    int z=0,k;\n    while (z==0)\n    {\n        printf(\"1. Insert 1\\t2. Insert 2\\t3. Display 1\\t4. Display 2\\t5. Union\\t6. Intersection\\t7. Exit\\t\");\n        scanf(\"%d\",&k);\n        switch(k)\n        {\n            case 1:\n            {\n                int i;\n                printf(\"Insert:\\t\");\n                scanf(\"%d\",&i);\n                first=insert(first,i,1);\n                break;\n            }\n            case 2:\n            {\n                int i;\n                printf(\"Insert:\\t\");\n                scanf(\"%d\",&i);\n                second=insert(second,i,1);\n                break;\n            }\n            case 3:\n            {\n                display(first);\n                break;\n            }\n            case 4:\n            {\n                display(second);\n                break;\n            }\n            case 5:\n            {\n                uni=lunion(first,second);\n                display(uni);\n                break;\n            }\n            case 6:\n            {\n                in=lintersection(first,second);\n                display(in);\n                break;\n            }\n            case 7:\n                z=1;\n        }\n    }\n    return 0;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Transpose_Matrix.2.c", "original_string": "void display(int matrix[R][C])\n{\n    int i, j = 0;\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__mcd.1.c", "original_string": "int main() {\n    int a, b;\n  int risultato;\n  printf(\"Primo numero: \");\n  scanf(\"%d\", &a);\n  printf(\"Secondo numero: \");\n  scanf(\"%d\", &b);\n    risultato = mcd(a, b);\n  printf( \"Risultato: %d\\n\", risultato ); \n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__Brute_ForceMethod.1.c", "original_string": "void main()\n{\n    int n,m,i;\n    char S[100],P[100];\n    printf(\"\\nEnter String:\");\n    scanf(\"%s\",S);\n    printf(\"\\nEnter Pattern:\");\n    scanf(\"%s\",P);\n    n=strlen(S);\n    m=strlen(P);\n    Brute_Force(S,P,n,m);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__10_For.0.c", "original_string": "int main()\n{\n    system(\"cls\"); \n    int contador = 0;\n    int X_1 = 1;\n    int X_2 = 80;\n    for(contador =1; X_1 != 41; ++contador){\n        if(contador <= 80){\n            if(contador == X_1)\n                printf(\"X\");\n            else if(contador == X_2)\n                printf(\"X\");\n            else\n                printf(\" \");\n         }else{\n             sleep(0.4);\n             system(\"cls\");\n             ++X_1;\n         --X_2;\n        contador = 1;\n         }\n    }\n        return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__B.2.c", "original_string": "int main()\n{\n    scanf (\"%lf\",&x);\n    seno = x;\n    for (int i=3,j=1; j<=iteracoes; i=i+2,j++)\n    {\n        if ((j%2) == 0)\n        {\n            seno += potencia(x,i)/fatorial(i);\n        }\n        else\n        {\n            seno -= potencia(x,i)/fatorial(i);\n        }    \n    }\n    printf (\"%.10lf\\n\", seno);\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.7.c", "original_string": "VAR* getvarmustexist(SCOPE* s, DEBUGINFO* d, const char* name) {\n    VAR* v = getvar(s, name);\n    if(v == NULL)\n        notdeclared(name, d);\n    return v;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_DLL.0.c", "original_string": "int main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of element in the linked list\\n\");\n    printf(\"4.delete the element from the last position \\n\");\n    printf(\"5.exit\\n\");\n    int choice;\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1: printf(\"implementation\\n\");\n            creat();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of element in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"delete the element from the last position \\n\");\n            delete_end();\n            break;\n            case 5:printf(\"exit \\n\");\n            exit(0);\n            break;\n            default:printf(\"invalied choice \\n\");\n            break;\n        }\n         printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "deepaliajabsingjadhav", "file": "file__write_file.0.c", "original_string": "int main()\n{\n    char name[20] = {'\\0'};\n    char arr[50] = {'\\0'};\n    int fd = 0;     \n    int ret = 0, length = 0;\n    char temp;\n    printf(\"Enter file name\\n\");\n    scanf(\"%s\",name);\n    fd = open(name,O_RDWR | O_CREAT, 0777); \n    if(fd == -1)\n    {\n        printf(\"Unable to create file\\n\");\n    }\n    else\n    {\n        printf(\"File succesfully created with fd %d\\n\",fd);\n    }\n    printf(\"Enter the data that you want to write in the file\\n\");\n    scanf(\" %[^'\\n']s\",arr);\n    length = strlen(arr);\n    ret = write(fd,arr,length);\n    if(ret == -1)\n    {\n        printf(\"Unable to write in the file\\n\");\n    }\n    else\n    {\n        printf(\"Data succesfully written in the file %d\\n\",ret);\n    }\n    close(fd);\n    return 0;\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_2_2_5.0.c", "original_string": "int main()\n{\n    int userNumber;\n    printf(\"Podaj liczbe calkowita 'n': \");\n    scanf(\"%d\", &userNumber);\n    printf(\"2 do potegi %d to: %.3f\\n\", userNumber, powerOfTwo(userNumber));\n    getchar();\n    return 0;\n}"}
{"author": "2security", "file": "Matrix__26Multiplication.2.c", "original_string": "int main()\n    {\n    int i,j,r,c,mat1[20][20],mat2[20][20];\n    printf(\"\\n Enter the row & col. for two matrix(Both should be same): \");\n    scanf(\"%d%d\",&r,&c);\n    if(r!=c)\n        printf(\"\\n For Addition matrix should be square\");\n    else\n        {       \n        printf(\"\\n Enter the first matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        printf(\"\\n Enter the second matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat2[i][j]);\n        printf(\"\\n The addtion of two matrix is:\\n\");\n        Product(mat1,mat2,r,c);\n        }\n    return 0;\n    }"}
{"author": "chandanXP", "file": "Datastructure-using-C__multiParenthesis.6.c", "original_string": "int main(){\n     char*exp = \"(8*{19*(4-2)*([9-7]})\";\n     if(parenthesisMatch(exp)){\n          printf(\"The Parenthesis are balanced.\\n\");\n     }\n     else{\n          printf(\"The Parenthesis are not balanced.\\n\");\n     }\n     return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__43.0.c", "original_string": "int main()\n{\n    int restaurante[8][4];\n    int cadeira = 1;\n    for (int i = 0; i < 8; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            switch (j)\n            {\n            case 0:\n                restaurante[i][j] = cadeira;\n                break;\n            case 1:\n                restaurante[i][j] = cadeira + 1;\n                break;\n            case 2:\n                restaurante[i][j] = cadeira + 4;\n                break;\n            case 3:\n                restaurante[i][j] = cadeira + 5;\n                break;\n            }\n        }\n        if ((i % 2) == 0)\n        {\n            cadeira += 2;\n        }\n        else\n        {\n            cadeira += 6;\n        }\n    }\n    system(\"clear\");\n    for (int i = 0; i < 8; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            printf(\"%3i\", restaurante[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__MatrixChainMultiplication.1.c", "original_string": "void putdata(int A[11][11],int row,int column)\n{\n int i,j;\n for(i=1;i<=row;i++)\n {\n   for(j=1;j<=column;j++)\n   {\n    printf(\"%d\\t\",A[i][j]);\n   }\n   printf(\"\\n\");\n }\n}"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal_cortex.1.c", "original_string": "void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)\n{ \n  uint32_t prioritygroup = 0x00U;\n  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));\n  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));\n  prioritygroup = NVIC_GetPriorityGrouping();\n  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q2_longadd.4.c", "original_string": "void disp(nptr list)\n{\n    nptr i=list->rlink;\n    while(i!=list)\n    {\n        printf(\"%d\",i->ele);\n        i=i->rlink;\n    }\n    printf(\"\\n\");\n}"}
{"author": "sdukesameer", "file": "dsa__dll-ins-seq-sor-del.0.c", "original_string": "void sort_insertion(node** head, int n)\n{\n    node* dll=(node*)malloc(sizeof(node));\n    dll->data=n;\n    dll->next=NULL;\n    dll->prev=NULL;\n    if(*head==NULL)\n        *head=dll;\n    else if(dll->data <= (*head)->data)\n    {\n        (*head)->prev=dll;\n        dll->next=*head;\n        *head=dll;\n    }\n    else\n    {\n        node* temp=*head;\n        while(temp->next != NULL && temp->next->data < dll->data)\n            temp=temp->next;\n        dll->prev=temp;\n        dll->next=temp->next;\n        temp->next=dll;\n        if(dll->next!=NULL)\n            dll->next->prev=dll;\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-statements.8.c", "original_string": "LINEBLOCK* compilestatements(SCOPE* s, STATEMENT* sts) {\n    LINEBLOCK* head = NULL;\n    while(sts != NULL) {\n        head = mergelnblks(head, compilestatement(s, sts));\n        sts = sts->next;\n    }\n    return head;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__check_multiplebit2_on_off.1.c", "original_string": "int main()\n{\n    int iNo = 0;\n    BOOL bRet = FALSE;\n    printf(\"Enter number\\n\");\n    scanf(\"%d\",&iNo);\n    bRet = CheckBit(iNo);\n    if(bRet == TRUE)\n    {\n        printf(\"6th,7th and 12th bit is on\\n\");\n    }\n    else\n    {\n        printf(\"One of the bit or all bits are Off\\n\");\n    }\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__stk-by-array.0.c", "original_string": "stack* createstack(unsigned int x)\n{\n    stack* ret=(stack* ) malloc(sizeof(stack));\n    ret->top=-1;\n    ret->size=x;\n    ret->arr=(int* )malloc(x * sizeof(int));\n    return ret;\n}"}
{"author": "dishanp", "file": "DSA__q72.1.c", "original_string": "void display(struct node *p)\n{\n    while(p)\n    {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__telephone1.0.c", "original_string": "int main()\n{\n    pthread_t thread2,thread1;\n    beg=0;\n    while(1)\n    {\n        printf(\"\\ntelephone directory\\n\");\n        printf(\"1.add\\n\");\n        printf(\"2.display\\n\");\n        printf(\"3.exit\\n\");\n        printf(\"enter your choice\\n\");\n        scanf(\"%d\",&choice);\n        switch(choice)\n        {\n            case 1:\n            pthread_create(&thread1,NULL,add_element,NULL);\n            pthread_join(thread1,NULL);\n                break;\n            case 2:\n            pthread_create(&thread2,NULL,display_dir,NULL);\n            pthread_join(thread2,NULL);\n            break;\n            case 3:\n                exit(0);\n        }\n    }\n    return 0;\n}"}
{"author": "jdes01", "file": "practicassoo__practica1ej1a.0.c", "original_string": "int main(){\n    int n=5, status;\n    printf(\"Padre con ID %d \\n\", getpid());\n    printf(\"\\n\");\n    for (int i=0; i<n; i++){\n        switch (fork()){ \n        case -1:\n            printf(\"Error en la creaci\u00f3n \\n\");\n            exit(EXIT_FAILURE);\n        case 0:\n            printf(\"Hijo %d con ID %d, padre: %d \\n\", i+1, getpid(), getppid());\n            exit(EXIT_SUCCESS); \n        default:\n            printf(\"Esperando hijo numero %d \\n\", i+1);\n            wait(&status); \n            printf(\"Hijo %d termindo con ID %d, codigo de salida: %d \\n\", i+1, getpid(), WEXITSTATUS(status)); \n            printf(\"\\n\");\n        }\n    } \n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__wdt_1.1.c", "original_string": "void delay(int ct)\n{\n    for(int i=0;i<ct;i++)\n    {\n        for(int j=0;j<6000;j++)\n        {}\n    }\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad7-RecurrencePowerFunction.1.c", "original_string": "double power(double x, int y){\n    double result = x;\n    if(x == 0) return 0;\n    if(y == 0) return 1;\n    if(y<0){\n        result = 1/x;\n        x = 1/x;\n        y = -y;\n    }\n    if(y > 0){\n        result = result * power(x, y - 1);\n    }\n    return result;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__toh.0.c", "original_string": "int move(int n, char s, char d, char a)\n{\n    if (n == 1)\n    {\n        printf(\"Move disk from %c to %c \\n\", s, d);\n        return 1;\n    }\n    else\n    {\n        int n1  = move(n - 1, s, a, d);\n        int n2 = 1; \n        printf(\"Move disk from %c to %c \\n\", s, d);\n        int n3 = move(n - 1, a, d, s);\n        return n1 + n2 + n3;\n    }\n}"}
{"author": "mandarvu", "file": "msc__problem104.1.c", "original_string": "int pal_chk(char *norm, char *rev) {\n  while (*(norm) != '\\0') {\n    if (*norm == *rev) {\n      norm++;\n      rev++;\n    }\n    else\n      return 0;\n  }\n  return 1;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__OC.1.c", "original_string": "void insert(int key,int value)\n{\n    int index=H(key);\n    struct hash* p=(struct hash*)malloc(sizeof(struct hash));\n    p->val=value;\n    p->next=NULL;\n    if(HASH[index]==NULL)\n    {\n        HASH[index]=p;\n    }\n    else\n    {\n        temp=HASH[index];\n        while(temp->next!=NULL)\n            temp=temp->next;\n        temp->next=p;\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__spi.1.c", "original_string": "void spi_data(int data)\n{\n    IOCLR0  =   (1<<7);         \n    S0SPDR = data;              \n    while(!(S0SPSR & (1<<7)));\n    IOSET0 = (1<<7);            \n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__readfile.1.c", "original_string": "void    routing(char *line)\n{\n    if (line[0] == 'R' && line[1] == ' ')\n        get_re(line);\n    else if (line[0] == 'N' && line[1] == 'O' && line[2] == ' ')\n        get_no(line);\n    else if (line[0] == 'S' && line[1] == 'O' && line[2] == ' ')\n        get_so(line);\n    else if (line[0] == 'W' && line[1] == 'E' && line[2] == ' ')\n        get_we(line);\n    else if (line[0] == 'E' && line[1] == 'A' && line[2] == ' ')\n        get_ea(line);\n    else if (line[0] == 'S' && line[1] == ' ')\n        get_s(line);\n    else if (line[0] == 'F' && line[1] == ' ')\n        get_f(line);\n    else if (line[0] == 'C' && line[1] == ' ')\n        get_c(line);\n    else if (all_params())\n        readmap(line);\n    else\n    {\n        ft_putstr(\"one or many parametres format is wrong or missing!\\n\");\n        exit(0);\n    }\n}"}
{"author": "earth429", "file": "mulpre__kaijyou.1.c", "original_string": "void tailCall(struct NUMBER *a, struct NUMBER *b, struct NUMBER *sofar){\n    struct NUMBER one, tmp1, tmp2;\n    setInt(&one, 1);\n    if(numComp(a, &one) != 1){ \n        copyNumber(sofar, b);\n    } else {\n        multiple(a, sofar, &tmp1);\n        decrement(a, &tmp2);\n        tailCall(&tmp2, b, &tmp1); \n    }\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise3.1.c", "original_string": "int main(void){\n    const int array_size =5;\n    int arr[array_size];\n    int i, j, k;\n    for(i=0 ; i<array_size ; i++){\n            scanf(\"%d\",&arr[i]);\n        }\n    printf(\"Array before sorting: \\n\");\n    for(j=0 ; j<array_size ; j++){\n            printf(\"%d\\t\",arr[j]);\n        }\n    BubbleSort(arr, array_size);\n    printf(\"\\n\");\n    printf(\"Array after sorting: \\n\");\n    for(k=0 ; k<array_size ; k++){\n        printf(\"%d\\t\",arr[k]);\n    }\n    return 0;\n    }"}
{"author": "augustogunsch", "file": "jackc__assembler.1.c", "original_string": "void expandsymbols(SYMBOLARRAY* a, int toaddn) {\n    int sum = a->count + toaddn;\n    if(sizeof(SYMBOL*) * sum > a->size) {\n        a->size = sizeof(SYMBOL*) * sum * 3;\n        a->items = (SYMBOL**)realloc(a->items, a->size);\n    }\n}"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__1-21.2.c", "original_string": "void entab(void){\n  extern char line[];\n  extern char lineS[];\n  int i, j, cont, aux;\n  i = j = 0;\n  while(line[i] != '\\0'){\n    if(line[i] == ' '){\n      aux = i;\n      cont = 0;\n      while(line[aux] == ' '){\n    ++cont;\n    ++aux;\n      }\n      if(cont % 8 == 0)\n    while(cont > 0){\n      lineS[j] = '\\t';\n      ++j;\n      cont = cont - 8;\n    }\n      else{\n    if(cont > 8){\n      while(cont >= 8){\n        lineS[j] = '\\t';\n        ++j;\n        cont = cont - 8;\n      }\n      for(int l = 0; l < cont; l++){\n        lineS[j] = ' ';\n        ++j;\n      }\n    }\n    else\n      for(int l = 0; l < cont; l++){\n        lineS[j] = ' ';\n        ++j;\n      }\n      }\n      i = aux;\n    }\n    else{\n      lineS[j] = line[i];\n      ++j;\n      ++i;\n    }\n  }\n  lineS[j] = '\\0';\n}"}
{"author": "0712023", "file": "Arduino-Mood-Light-DIY-kit__Moodlight.4.c", "original_string": "void rain_set() {\n  static int rainbow_count;\n  static int rain;\n  if ( DEBUG ) {\n    rainbow_count += 2;\n    if ( rainbow_count >= 100 ) {\n      rainbow_count = 100;\n      DEBUG = false;\n    }\n  }\n  else if ( !DEBUG ) {\n    rainbow_count -= 1;\n    if ( rainbow_count == 0 ) {\n      DEBUG = true;\n      rain++;\n      if ( rain == 6)\n        rain = 0;\n    }\n  }\n  for ( int i = 0; i < 8; i++ ) { \n    pixels.setPixelColor(i, pixels.Color( map(rainbow_count, 0, 100, 0, rainbow[rain][0]) , map(rainbow_count, 0, 100, 0, rainbow[rain][1]) , map(rainbow_count, 0, 100, 0, rainbow[rain][2]) ) );  \n    pixels.show(); \n  }\n}"}
{"author": "dishanp", "file": "DSA__q45.1.c", "original_string": "void display(struct node *p)\n{\n    while(p)\n    {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__shell_client_misc.2.c", "original_string": "error_t shellClientOpenConnection(ShellClientContext *context)\n{\n   error_t error;\n   Socket *socket;\n   SshConnection *connection;\n   error = sshInit(&context->sshContext, &context->sshConnection, 1,\n      &context->sshChannel, 1);\n   if(error)\n      return error;\n   error = sshSetOperationMode(&context->sshContext, SSH_OPERATION_MODE_CLIENT);\n   if(error)\n      return error;\n   error = sshRegisterChannelRequestCallback(&context->sshContext,\n      shellClientChannelRequestCallback, context);\n   if(error)\n      return error;\n   if(context->sshInitCallback != NULL)\n   {\n      error = context->sshInitCallback(context, &context->sshContext);\n      if(error)\n         return error;\n   }\n   socket = socketOpen(SOCKET_TYPE_STREAM, SOCKET_IP_PROTO_TCP);\n   if(socket != NULL)\n   {\n      socketBindToInterface(socket, context->interface);\n      socketSetTimeout(socket, context->timeout);\n      connection = sshOpenConnection(&context->sshContext, socket);\n      if(connection == NULL)\n      {\n         socketClose(socket);\n         error = ERROR_OPEN_FAILED;\n      }\n   }\n   else\n   {\n      error = ERROR_OPEN_FAILED;\n   }\n   return error;\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__test1.3.c", "original_string": "unsigned int crc32lql(unsigned char *string, unsigned int size) {\n    make_crc32_table();\n    unsigned int crc = 0xffffffff;\n    while(size--)\n        crc = (crc >> 8)^(crc32_table[(crc ^ *string++)&0xff]);\n    return crc;\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__stack.3.c", "original_string": "int display(void)\n{\n    int count;\n    if(stack.data == -1){\n        printf(\"Stack is empty\\n\");\n        return 0;\n    }else{\n        printf(\"The status of stack\\n\");\n        for(count = stack.data; count>=0; count--)\n        {\n            printf(\"%d\\n\",stack.stack[count]);\n        }\n    }\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__101-cocktail_sort_list.0.c", "original_string": "void swap_func(listint_t **list, listint_t *node)\n{\n    listint_t *tmp;\n    tmp = node->next;\n    if (tmp->next)\n        tmp->next->prev = node;\n    tmp->prev = node->prev;\n    node->next = tmp->next;\n    tmp->next = node;\n    if (node->prev)\n        node->prev->next = tmp;\n    node->prev = tmp;\n    if (*list == node)\n        *list = tmp;\n}"}
{"author": "jose120918", "file": "sorting_algorithms__2-selection_sort.0.c", "original_string": "void selection_sort(int *array, size_t size)\n{\n    size_t boundary = 0, min_pos, i;\n    int min, temp;\n    while (boundary < size)\n    {\n        i = boundary;\n        min = array[boundary];\n        min_pos = boundary;\n        while (i < size)\n        {\n            if (array[i] < min)\n            {\n                min = array[i];\n                min_pos = i;\n            }\n            i++;\n        }\n        if (min_pos != boundary)\n        {\n            temp = array[boundary];\n            array[boundary] = array[min_pos];\n            array[min_pos] = temp;\n            print_array(array, size);\n        }\n        boundary++;\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader.6.c", "original_string": "static bool parseFirmwareUpdateInfo(char *updateInfoString)\n{\n  memset(updateVersion, 0, sizeof(updateVersion));\n  memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n  if (strstr(updateInfoString, UPDATE_INFO_SEPARATOR) == NULL) \n  {\n    printf(\"Firmware update request with missing version and/or verification data entered\\n\");\n    return false;\n  }\n  char *parsedVersion = strtok(updateInfoString, UPDATE_INFO_DELIMITERS);\n  if (parsedVersion == NULL) \n  {\n    printf(\"Firmware update request with missing version and verification data entered\\n\");\n    return false;\n  }\n  if (strlen(parsedVersion) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) \n  {\n    printf(\"Received firmware update version too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH);\n    return false;\n  }\n  strncpy(updateVersion, parsedVersion, sizeof(updateVersion));\n  char *parsedVerificationData = strtok(NULL, UPDATE_INFO_DELIMITERS);\n  if (parsedVerificationData == NULL) \n  {\n    printf(\"Firmware update request with missing version or verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (strlen(parsedVerificationData) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n  {\n    printf(\"Received firmware update verification data too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH << 1);\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (convertHexString8ToBinData(parsedVerificationData, strlen(parsedVerificationData), updateVerificationData, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) == 0) \n  {\n    printf(\"Firmware update request with invalid verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n    return false;\n  }\n  return true;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__3.2.c", "original_string": "void le_poligono(pontos_t *poligono, int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"\\nDigite as coordenadas do %li\u00ba ponto:\\n\", i+1);\n        printf(\"\\t-> Coordenada x: \");\n        scanf(\"%lf\", &poligono[i].x);\n        getchar();\n        printf(\"\\t-> Coordenada y: \");\n        scanf(\"%lf\", &poligono[i].y);\n        getchar();\n    }\n}"}
{"author": "2security", "file": "File__7MergeTwoFile.0.c", "original_string": "void main()\n    {\n    int cf  ;\n    cf=mergefile(\"File71.txt\",\"File72.txt\",\"File7.txt\");\n    if(cf==1)\n        printf(\"Merge done\");\n    else\n        printf(\"Merge not done\");\n    getch();\n    }"}
{"author": "sdukesameer", "file": "dsa__list-ins-rem_even.2.c", "original_string": "void removeeven(node** head)\n{\n    while((*head)!=NULL && (*head)->data%2==0)\n        *head=(*head)->next;\n    node* h=*head;\n    if((*head)==NULL)\n        return;\n    while(h->next!=NULL)\n    {\n        if(h->next->data%2==0)\n            h->next=h->next->next;\n        else\n            h=h->next;\n    }\n}"}
{"author": "tadeograch", "file": "sorting_algorithms__103-merge_sort.1.c", "original_string": "void TopDownSplitMerge(int B[], int iBegin, int iEnd, int A[])\n{\n    int iMiddle, index;\n    if (iEnd - iBegin <= 1)\n        return;\n    iMiddle = (iEnd + iBegin) / 2;\n    TopDownSplitMerge(A, iBegin,  iMiddle, B);\n    TopDownSplitMerge(A, iMiddle, iEnd, B);\n    printf(\"Merging...\\n\");\n    TopDownMerge(B, iBegin, iMiddle, iEnd, A);\n    printf(\"[Done]: \");\n    for (index = iBegin; index < iEnd; index++)\n    {\n        printf(\"%d\", A[index]);\n        if (index != iEnd - 1)\n            printf(\", \");\n    }\n    printf(\"\\n\");\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.14.c", "original_string": "void traversal(struct btreeNode *myNode) {\n        int i;\n        if (myNode) {\n                for (i = 0; i < myNode->count; i++) {\n                        traversal(myNode->link[i]);\n                        printf(\"%d \", myNode->val[i + 1]);\n                }\n                traversal(myNode->link[i]);\n        }\n  }"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__string_reverse.1.c", "original_string": "int main()\n{\n    char arr[30];\n    printf(\"Please enter the string\\n\");\n    scanf(\"%[^'\\n']s\",arr);\n    StrrevX(arr);\n    printf(\"Reverse string is %s\\n\",arr);\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-statements.0.c", "original_string": "STATEMENT* mkstatement(PARSER* p, STATEMENTTYPE t) {\n    STATEMENT* s = (STATEMENT*)malloc(sizeof(STATEMENT));\n    s->type = t;\n    s->debug = getdebug(p);\n    return s;\n}"}
{"author": "earth429", "file": "mulpre__mulprec.7.c", "original_string": "int mulBy10(struct NUMBER *a, struct NUMBER *b){\n    int i;\n    clearByZero(b);\n    setSign(b, getSign(a)); \n    if(a->n[KETA - 1] != 0){\n        return -1;\n    }\n    for (i = KETA - 2; i >= 0;i--){\n        b->n[i + 1] = a->n[i];\n    }\n    b->n[0] = 0;\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-structure.5.c", "original_string": "LINEBLOCK* compilefundec(SCOPE* s, CLASS* cl, SUBROUTDEC* f) {\n    LINE* label = mksubdeclabel(cl, f);\n    LINEBLOCK* body = compilefunbody(s, cl, f);\n    appendlnbefore(body, label);\n    return body;\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.0.c", "original_string": "void strtogarbage(ASSEMBLER* a, char* str) {\n    STRINGLIST* newstr = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n    newstr->content = str;\n    newstr->next = a->garbage;\n    a->garbage = newstr;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__i2c_Tx_Rx.0.c", "original_string": "int main()\n{   \n    char i2c_rdata;\n    lcd_config();\n    i2c_init();\n    i2c_Start();\n    i2c_tx_data(0xA0);          \n    i2c_tx_data(0x41);          \n    i2c_tx_data('J');   \n    i2c_tx_data('R');   \n    i2c_tx_data('A');   \n    i2c_tx_data('M');\n    i2c_stop();\n    lcd_str(\"Data sent\");\n    delay(1000);\n    lcd_cmd(0x01);\n    i2c_Start();\n    i2c_tx_data(0xA0);          \n    i2c_tx_data(0x41);          \n    I2CONSET = (1<<2);          \n    i2c_Start();                        \n    i2c_tx_data(0xA1);          \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_stop();\n    lcd_cmd(0xC0);\n    lcd_str(\"Data from EEPROM\");\n}"}
{"author": "sdukesameer", "file": "dsa__pre-eva.7.c", "original_string": "float evaluatePrefix(char exp[])\n{\n    stack* stk=createStack(strlen(exp));\n    int i=strlen(exp)-1;\n    float f=0,s=0,t=0;\n    while (i>=0)\n    {\n        if((exp[i]==',' && exp[i-1]==',') || (exp[i]==' ' && exp[i-1]==' '))\n            i--;\n        else if((exp[i]==',' && exp[i-1]==' ') || (exp[i]==' ' && exp[i-1]==','))\n        {\n            printf(\"Invalid operator or operand encountered.\\n\");\n            return 0;\n        }\n        else if((int)exp[i]>47 && (int)exp[i]<58)\n            t=(t*10)+c2i(exp[i]);\n        else if(exp[i]==',' || exp[i]==' ')\n        {\n            push(stk,reverse(t));\n            t=0;\n        }\n        else if(isOperator(exp[i]))\n        {\n            if(stk->top-2<-1)\n            {\n                printf(\"Underflow, not enough operands.\\n\");\n                return 0;\n            }\n            f=pop(stk);\n            s=pop(stk);\n            push(stk,operation(f,exp[i],s));\n            if(i-1>-1)\n                i--;\n        }\n        else\n        {\n            printf(\"Invalid operator or operand encountered.\\n\");\n            return 0;\n        }\n        i--;\n    }\n    if(stk->top!=0)\n    {\n        printf(\"Overflow, too may operands.\\n\");\n        return 0;\n    }\n    return stk->arr[stk->top];\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad3-CharInRows.1.c", "original_string": "void wiersz_zn(char ch, int i, int j) {\n    putchar('\\n');\n    for(j; j > 0; j--){\n        for(int k = i; k > 0; k--){\n            putchar(ch);\n        }\n        putchar('\\n');\n    }\n    return;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__keypad_assign.2.c", "original_string": "void col_key1(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(COL);  \n        IODIR1 = IODIR1 | (ROW);  \n        val = (IOPIN1 & COL); \n        val = val >> 17;\n        switch(val)\n        {\n            case 0x0E: \n                lcd_data('1');\n                delay(500);\n                break;\n            case 0x0D:\n                lcd_data('2');\n                delay(500);\n                break;\n            case 0x0B:\n                lcd_data('3');\n                delay(500);\n                break;\n            case 0x07:\n                lcd_data('+');\n                delay(500);\n                break;\n        }\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Insert_At_The_End_Of_A_Single_Linked_List.1.c", "original_string": "void display_node(struct node*temp1)\n{\n    printf(\"The Elements are:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->link;\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__heap_sort.3.c", "original_string": "void printarray(int a[],int n)\n{\n    int i;\n    for(i=0;i<n;i++)\n        printf(\"%d\\t\",a[i]);\n}"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__routing2.1.c", "original_string": "int     array_is_rgb(char **colors)\n{\n    int i;\n    i = 0;\n    while (colors[i])\n    {\n        if (str_is_digits(colors[i]))\n        {\n            if (!(atoi(colors[i]) <= 255) || !(atoi(colors[i]) >= 0))\n            {\n                ft_putstr(\"Error\\n Wrong colors parametres!\");\n                exit(0);\n            }\n        }\n        else\n            return (0);\n        i++;\n    }\n    return (1);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__22_For.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Senh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X); \n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n        Suma_total += Exp(X,(i*2)+1) / Fac((i*2)+1);\n    }\n    printf(\"senh(%i) es igual a %lf\", X, (Suma_total + X));\n    return 0;\n}"}
{"author": "Theemiss", "file": "binary_trees__binary_tree_print.1.c", "original_string": "static size_t _height(const binary_tree_t *tree)\n{\n    size_t height_l;\n    size_t height_r;\n    height_l = tree->left ? 1 + _height(tree->left) : 0;\n    height_r = tree->right ? 1 + _height(tree->right) : 0;\n    return (height_l > height_r ? height_l : height_r);\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Insert_at_begin_In_the_Single_Linked_LIst.1.c", "original_string": "void display_node(struct node*temp1)\n{\n    printf(\"The elements are:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q23.5.c", "original_string": "int main()\n{\n    int z=0,k,e;\n    queue q;\n    q.front=10;\n    q.rear=10;\n    printf(\"1. Enqueue Right\\n2. Enqueue Left\\n3. Dequeue Left\\n4. Dequeue Right\\n5. Display \\n6. Exit\\n\");\n    while (z == 0)\n    {\n        printf(\"\\nCommand: \");\n        scanf(\"%d\",&k);\n        switch(k)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter String: \");\n                char *n = malloc(30);\n                scanf(\"%s\", n);\n                enqueueright(&q,n);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter String: \");\n                char *n = malloc(30);\n                scanf(\"%s\", n);\n                enqueueleft(&q,n);\n                break;\n            }\n            case 3:\n            {\n                dequeueleft(&q);\n                break;\n            }\n            case 4:\n            {\n                printf (\"\\n:::::::::OPERATION NOT ALLOWED:::::::\\n\");\n                break;\n            }\n            case 5:\n            {\n                display(&q);\n                break;\n            }\n            case 6:\n            {\n                z=1;\n            }\n        }\n    }\n}"}
{"author": "zjzj-zz", "file": "4s_Numerical__Dichotomy.1.c", "original_string": "void initial_value(double x[2] ){ \n    while( (f(x[0])>0 || f(x[1])<0) && (f(x[0])<0 || f(x[1])>0) ){\n        x[0] += 100;\n        x[1] -= 100;\n    }\n}"}
{"author": "kalpa96", "file": "Struct__myword.0.c", "original_string": "int main()\n{\n    word W;\n    char array[100];\n    FILE * fp;\n    int i=0;\n    fp = fopen(\"myword.txt\",\"a\");\n    printf(\"Enter your word: \");\n    gets(array);\n    fprintf(fp,array);\n    W.a = 0,W.e = 0,W.i = 0,W.o = 0,W.u = 0,W.other = 0;\n    while(strlen(array)>i){\n        if(array[i]=='a'||array[i]=='A'){\n            W.a=W.a + 1;\n        }\n        if(array[i]=='e'||array[i]=='E'){\n            W.e=W.e+1;\n        }\n        if(array[i]=='i'||array[i]=='I'){\n            W.i=W.i+1;\n        }\n        if(array[i]=='o'||array[i]=='O'){\n            W.o=W.o+1;\n        }\n        if(array[i]=='u'||array[i]=='U'){\n            W.u=W.u+1;\n        }\n        if(array[i] !='a' && array[i] != 'e' && array[i] != 'i' && array[i] != 'o'&& array[i] != 'u' && array[i] != 'A' && array[i] != 'E' && array[i] != 'I' && array[i] != 'O' && array[i] != 'U' ){\n            W.other=W.other+1;\n        }\n    i++;\n    }\n    fprintf(fp,\"\\t\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\",W.a,W.e,W.i,W.o,W.u,W.other,strlen(array));\n    fclose(fp);\n    fp=fopen(\"myword.txt\",\"a\");\n    fprintf(fp,\"\\n\");\n    fclose(fp);\n}"}
{"author": "HakNinja", "file": "C-Advance__1str.0.c", "original_string": "int main()\n{\n    struct student x;\n    printf(\"Enter Details:\\n\");\n    printf(\"Enter roll number:\");\n    scanf(\"%d\",&x.rno);\n    printf(\"Enter name of student:\");\n    scanf(\"%s\",x.name);\n    printf(\"Percentage:\");\n    scanf(\"%f\",&x.per);\n    printf(\"\\n--------------------------------------------------------------------------\");\n    printf(\"\\nRoll number:%d\\n\",x.rno);\n    printf(\"\\nName:%s\\n\",x.name);\n    printf(\"Percentage:%f\\n\",x.per);\n    return(0);\n}"}
{"author": "haon1026", "file": "linux-programming__stat.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    struct stat buf;\n    int ret = lstat(argv[1], &buf);\n    if(ret == -1)\n    {\n        perror(\"stat error\");\n        exit(1);\n    }\n    printf(\"file size:%d\\n\", buf.st_size);\n    printf(\"inode number:%d\\n\", buf.st_ino);\n    if(S_ISREG(buf.st_mode))\n        printf(\"%s is a regular file\\n\", argv[1]);\n    else if(S_ISDIR(buf.st_mode))\n        printf(\"%s is a directory\\n\", argv[1]);\n    else if(S_ISLNK(buf.st_mode))\n        printf(\"%s is a symbolic link\\n\", argv[1]);      \n    return 0;\n}"}
{"author": "fikepaci", "file": "monty__stack.0.c", "original_string": "void free_stack(stack_t **stack)\n{\n    stack_t *tmp = *stack;\n    while (*stack)\n    {\n        tmp = (*stack)->next;\n        free(*stack);\n        *stack = tmp;\n    }\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad10.4.c", "original_string": "treePointer AllocateMemoryForTree(char sign)\n{\n    treePointer newTreeNode = (treePointer)malloc(sizeof(struct treeNode));\n    if (!newTreeNode)\n    {\n        printf(\"Neuspjesna alokacija memorije!\\n\");\n        return newTreeNode;\n    }\n    newTreeNode->left = NULL;\n    newTreeNode->right = NULL;\n    newTreeNode->data = sign;\n    return newTreeNode;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__count_the_elem_in_LL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__InsertionOfNodeAtBeginningInLL.1.c", "original_string": "int main()\n{\n    int choice = 1;\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice)\n    {\n        newnode = (struct node*) malloc(sizeof(struct node));\n        printf(\"Enter the element in the node:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->link = NULL;\n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->link = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want to enter more nodes?(0/1)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    add_at_beginning(&temp);\n    int count = 0;\n    printf(\"THE ELEMENTS PRESENT IN THE NODE ARE\\n\");\n    while(temp!=NULL)\n    {\n        count++;\n        printf(\"%d\\t\",temp->data);\n        temp = temp->link;\n    }\n    printf(\"\\nCount : %d\",count);\n    return 0;\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__rwclient.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    int sockid,rval;\n    char a1[50],a2[50],b1[50],b2[50];\n    sockid=socket(AF_INET,SOCK_STREAM,0);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR\");\n        exit(1);\n    }\n    struct sockaddr_in s;\n    struct iovec iov[2]; \n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=connect(sockid,(struct sockaddr*)&s, sizeof(s));\n    if(rval==-1)\n    {\n        perror(\"CONN-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\nEnter the first message : \");\n    scanf(\"%s\",a1);\n    printf(\"\\nEnter the second message : \");\n    scanf(\"%s\",a2);\n    iov[0].iov_base=a1;  \n    iov[0].iov_len=50;  \n    iov[1].iov_base=a2;  \n    iov[1].iov_len=50;  \n    writev(sockid,&iov[0],2); \n    printf(\"Message sent successfully\\n\");\n    iov[0].iov_base=b1;  \n    iov[0].iov_len=50;  \n    iov[1].iov_base=b2;  \n    iov[1].iov_len=50;  \n    readv(sockid,&iov[0],2);  \n    printf(\"Server response is :  %s \\n %s\\n\",b1,b2); \n    close(sockid);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__4_75numeros.0.c", "original_string": "void Pedir_numeros(int Mayor, int menor, int Mayor_150, int negativos,int promedio_P, int contador, int num_p)\n{\n    int numero = 0;\n    if(contador <= 10){\n        printf(\"\\nIngrese por favor el numero: \");\n        scanf(\"%i\", &numero);\n        if(numero != 0){\n            if(numero > 150){\n                ++Mayor_150;    \n            }\n            if(numero > Mayor){\n                Mayor = numero;    \n            }else if(numero < menor){   \n                menor = numero;    \n            }\n            if(numero > 0){\n                ++num_p;\n                promedio_P += numero; \n            }else{\n                ++negativos;          \n            }\n            Pedir_numeros(Mayor,menor,Mayor_150,negativos,promedio_P,++contador,num_p);\n        }else{\n            Pedir_numeros(Mayor,menor,Mayor_150,negativos,promedio_P,contador,num_p);\n        }\n    }else{\n        printf(\"\\n***Fin del Ciclo***\\n\");\n        promedio_P = promedio_P / num_p;\n        printf(\"\\nCantidad de numeros mayores a 150: %i\", Mayor_150);\n        printf(\"\\nNumero mayor: %i  Numero menor: %i\", Mayor, menor);   \n        printf(\"\\nCantidad de numeros negativos encontrador: %i\", negativos);\n        printf(\"\\nPromedio positivos encontrados: %i\", promedio_P);\n    }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_extended.3.c", "original_string": "uint32_t ble_lbs_on_button_change(uint16_t conn_handle, ble_lbs_t * p_lbs, uint8_t button_state)\n{\n    ble_gatts_hvx_params_t params;\n    uint16_t len = sizeof(button_state);\n    memset(&params, 0, sizeof(params));\n    params.type   = BLE_GATT_HVX_NOTIFICATION;\n    params.handle = p_lbs->button_char_handles.value_handle;\n    params.p_data = &button_state;\n    params.p_len  = &len;\n    return sd_ble_gatts_hvx(conn_handle, &params);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__doublyLinkedList.3.c", "original_string": "struct Node *insertAtEnd(struct Node *head, int data)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     struct Node *p = head;\n     while (p->next != NULL)\n     {\n          p = p->next;\n     }\n     ptr->data = data;\n     p->next = ptr;\n     ptr->next = NULL;\n     ptr->prev = p;\n     return head;\n}"}
{"author": "dishanp", "file": "Data-Structures-And-Algorithms__q20.1.c", "original_string": "int main()\n{\n    int *arr;\n    int n, x, y, z;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n    for (int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n    ngerearrange(arr, n);\n    printf(\"Rearranged Array : \\n\");\n    for (int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d \", *(arr + i));\n    }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-central-scanner-with-whitelist__nrf_dfu_flash.3.c", "original_string": "ret_code_t nrf_dfu_flash_erase(uint32_t page_addr,\n                               uint32_t num_pages,\n                               nrf_dfu_flash_callback_t callback)\n{\n        ret_code_t rc;\n        NRF_LOG_DEBUG(\"nrf_fstorage_erase(addr=0x%p, len=%d pages), queue usage: %d\",\n                      page_addr, num_pages, m_flash_operations_pending);\n        rc = nrf_fstorage_erase(&m_fs, page_addr, num_pages, (void *)callback);\n        if ((NRF_LOG_ENABLED) && (rc == NRF_SUCCESS))\n        {\n                m_flash_operations_pending++;\n        }\n        else\n        {\n                NRF_LOG_WARNING(\"nrf_fstorage_erase() failed with error 0x%x.\", rc);\n        }\n        return rc;\n}"}
{"author": "theuwis", "file": "AdventOfCode2015__main7.0.c", "original_string": "int main(void){\n    int input[NR_ELEMENTS] = {50, 44, 11, 49, 42, 46, 18, 32, 26, 40, 21, 7, 18, 43, 10, 47, 36, 24, 22, 40};\n    int multiplier[NR_ELEMENTS] = {0};\n    int nr_combinations = 0, result = 0;\n    for(int i = 0; i < pow(2, NR_ELEMENTS); i++){\n        for(int j = 0; j < NR_ELEMENTS; j++){\n            multiplier[NR_ELEMENTS - 1 - j] = (i >> (NR_ELEMENTS - 1 -j)) & 1;\n        }\n        for(int k = 0; k < NR_ELEMENTS; k++){\n            result += input[k] * multiplier[k];\n        }\n        if(result == LITERS_TO_STORE){\n            nr_combinations++;\n        }\n        result = 0;\n    }\n    printf(\"answer=%d\\n\", nr_combinations);\n    return EXIT_SUCCESS;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-structure.9.c", "original_string": "SUBROUTDEC* parsesubroutdecs(PARSER* p, CLASS* c) {\n    SUBROUTDEC* head = parsesubroutdec(p, c);\n    SUBROUTDEC* curr = head;\n    SUBROUTDEC* nexts;\n    while(nexts = parsesubroutdec(p, c), nexts != NULL) {\n        curr->next = nexts;\n        curr = nexts;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_08.5.c", "original_string": "void countSort(int arr[], int n, int exp) {\n    int output[n]; \n    int i, count[10] = { 0 };\n    for (i = 0; i < n; i++)\n        count[(arr[i] / exp) % 10]++;\n    for (i = 1; i < 10; i++)\n        count[i] += count[i - 1];\n    for (i = n - 1; i >= 0; i--) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n    for (i = 0; i < n; i++)\n        arr[i] = output[i];\n}"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLLcircular.2.c", "original_string": "nptr insertRight(nptr head, int x)\n{\n    if (head == NULL)\n    {\n        nptr temp = createNode(x);\n        temp -> left = temp -> right = temp;\n        return temp;\n    }\n    else\n    {\n        nptr curr = head;\n        while(curr -> right != head)\n            curr = curr -> right;\n        nptr temp = createNode(x);\n        temp -> left = head -> left;\n        temp -> right = head;\n        head -> left = temp;\n        (temp -> left) -> right = temp;\n        return head;\n    }\n}"}
{"author": "dishanp", "file": "DSA__q13.1.c", "original_string": "int main()\n{\n    int *arr;\n    int n, x, y, z;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n    for (int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n    printf(\"Enter x & y : \");\n    scanf(\"%d%d\", &x,&y);\n    z = mindist(arr, n, x, y) ;\n    printf(\"The minimum distance between %d & %d : %d\\n\", x, y, z);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__DemoFOTAUpdateWorkflow0.2.c", "original_string": "void fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)\n{\n  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__server5.1.c", "original_string": "void communication(int new_socket) {\n    int n;\n    char buffer[BUFFER_SIZE] = {0}; \n    while(1) {\n        bzero(buffer, BUFFER_SIZE);\n        n = recv( new_socket , buffer, BUFFER_SIZE, 0); \n        if(n<0) {\n            printf(\"Reading Error!\\n\");\n        }\n        printf(\"Client: %s\\n\", buffer);\n        if(strncmp(buffer, \"close\", 5)==0) {\n            printf(\"Client with Socketfd: %d disconnected!\\n\", new_socket);\n            bzero(buffer, BUFFER_SIZE);\n            return;\n        }\n        bzero(buffer, BUFFER_SIZE);\n        printf(\"Enter Server's Message:\");\n        fgets(buffer, BUFFER_SIZE, stdin);\n        if(strncmp(buffer, \"close\", 5)==0) {\n            close(new_socket);\n            break;\n        }\n        send(new_socket , buffer , strlen(buffer) , 0 ); \n    }\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__selectsd.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    fd_set rdfs;\n    int rval,sockid;\n    char buf1[3],buf2[30];\n    sockid=socket(AF_INET,SOCK_STREAM,6);   \n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    struct sockaddr_in s;\n    struct timeval tv;\n    system(\"clear\");\n    if(argc<2)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(1);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=connect(sockid,(struct sockaddr *)&s,sizeof(s));\n    if(rval==-1)    \n    {\n        perror(\"CONNECT_ERR\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\n Enter the data to send:\\t\");\n    scanf(\"%s\",buf1);\n    send(sockid,(char *) buf1,sizeof(buf1),0);\n    do\n    {\n        FD_ZERO(&rdfs);\n        FD_SET(sockid,&rdfs);\n        rval=select(sockid+1,&rdfs,NULL,NULL,NULL);\n        printf(\"\\nrval of select = %d\\n\",rval);\n    }while(rval==-1);\n    if(rval>0)\n    {\n        if(FD_ISSET(sockid,&rdfs))\n        {\n            rval=recv(sockid,(char *)buf2,sizeof(buf2),0);\n            if(rval==0)\n            printf(\"\\nNo response from server\\n\");\n            else\n            printf(\"\\nServer Response is %s\\n\",buf2);\n        }\n    }\n    else\n    perror(\"SELECT_ERR\");\n    close(sockid);\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise4.0.c", "original_string": "void SelectionSorting(int arr[],const int size ){\n    int i , j , min , temp;\n    for(i = 0 ; i < (size-1) ; i++){\n        min = i;\n            for(j = i+1 ; j < size ; j++){\n                if(arr[j]<arr[min]){\n                    min = j;\n                }\n            }\n            temp = arr[i];\n            arr[i] = arr[min];\n            arr[min] = temp;\n    }\n}"}
{"author": "kalpa96", "file": "Struct__comple.1.c", "original_string": "struct complex add(struct complex n1,struct  complex n2) {\n   struct  complex temp;\n    temp.real = n1.real + n2.real;\n    temp.imag = n1.imag + n2.imag;\n    return (temp);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__BinHexConverter.3.c", "original_string": "uint8_t convertHexString8ToBinValue(char *inputStr, size_t inputStrLength)\n{\n  if (inputStrLength != 2) \n  {\n    return 0;\n  }\n  uint8_t outputValue = convertHexDigitToBinValue(inputStr[0]) << 4;\n  outputValue |= convertHexDigitToBinValue(inputStr[1]);\n  return outputValue;\n}"}
{"author": "sdukesameer", "file": "dsa__list-del-rev.1.c", "original_string": "node* insert(node* head, int data)\n{\n    if(head==NULL)\n        return createNode(head,data);\n    else\n        head->next=insert(head->next,data);\n    return head;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__display_LL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n       if(head==0)\n       {\n            head=temp=newnode;\n       }\n       else\n       {\n            temp->next=newnode;\n            temp=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n           scanf(\"%d\",& choice);\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__CE.0.c", "original_string": "int main()\n{\n    int matriz[1000][1000], n, soma, maior = INT_MIN, k0;\n    scanf(\"%i\", &n);\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            scanf(\"%i\", &matriz[i][j]);\n        }\n    }\n    for (int k = (-n + 1); k < n; k++)\n    {\n        soma = 0;\n        for (int i = 0, j; i < n; i++)\n        {\n            j = i + k;\n            if (j >= 0 && j < n)\n            {\n                soma += matriz[i][j];\n            }\n        }\n        if (soma > maior)\n        {\n            maior = soma;\n            k0 = k;\n        }\n    }\n    printf(\"%i %i\\n\", k0, maior);\n    return 0;\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__mqclient.0.c", "original_string": "void main()\n{\n    int mqid,rval,msgid;\n    message m1;\n    mqid=msgget((key_t)80,IPC_CREAT|0666);\n    if(mqid==-1)\n    {\n        perror(\"MQ-CRE-ERR\");\n        exit(1);\n    }\n    system(\"ipcs -q\");\n    printf(\"Enter the msgid : \");\n    scanf(\"%d\",&msgid);\n    m1.id=msgid;\n    printf(\"Enter the message : \");\n    scanf(\"%s\",m1.txt);\n    rval=msgsnd(mqid,(message*)&m1,sizeof(m1),0);\n    if(rval==-1)\n    perror(\"\\nMessage not sent\\n\");\n    else\n    printf(\"\\nMessage Sent successfully\\n\");\n}"}
{"author": "Dhruvik-Chevli", "file": "DAALab__graphAdjacencyList.1.c", "original_string": "void addEdge(struct Graph* graph,int src,int dst)\n{\n    struct adjLNode* newNode=(struct adjLNode*)malloc(sizeof(struct adjLNode));\n    newNode->dest=dst;\n    newNode->next=graph->arr[src].head;\n    graph->arr[src].head=newNode;\n    struct adjLNode* newNode2=(struct adjLNode*)malloc(sizeof(struct adjLNode));\n    newNode2->dest=src;\n    newNode2->next=graph->arr[dst].head;\n    graph->arr[dst].head=newNode2;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica33.0.c", "original_string": "void producirDato(int numero){                  \n    v[indiceProduccion] = numero;               \n    indiceProduccion = (indiceProduccion +1)%n; \n    for(int i=0; i<n; i++){                     \n            printf(\"|%d\", v[i]);\n    }\n    printf(\"|\");\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__unique2.6.c", "original_string": "void quicksort(int vector[], int inf, int sup){\n  int i, j, x;\n  i = inf;\n  j = sup;\n  x = vector[(i+j)/2];\n  while(i <= j){ \n      while(vector[i] < x)    \n    i++;\n      while(vector[j] > x)  \n    j--;\n      if(i<=j){\n    change(vector, i, j);\n    i++;\n    j--;\n      }\n  }\n  if(inf < j)\n    quicksort(vector, inf, j);\n  if(i < sup)\n    quicksort(vector, i, sup);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_SLL.4.c", "original_string": "void delete_at_end()\n{\n    struct node *temp,*prenode;\n    temp=head;\n    while(temp->next!=0)\n    {\n        prenode=temp;\n        temp=temp->next;\n    }\n    if(temp==head)\n    {\n        head=0;\n        free(temp);\n    }\n    else\n    {\n        prenode->next=0;\n        free(temp);\n    }\n}"}
{"author": "sdukesameer", "file": "c__selection_sort.1.c", "original_string": "void printArray(int arr[], int len){   \n    for (int i = 0; i < len; i++)\n            printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__13,_14.4.c", "original_string": "int main()\n{\n    int a, b, escolha;\n    do\n    {\n        do\n        {\n            printf(\"\\n\\t(1) MDC\\n\");\n            printf(\"\\t(2) MMC\\n\");\n            printf(\"\\t(3) Sair\\n\");\n            printf(\"\\tDigite sua escolha: \");\n            scanf(\"%i\", &escolha);\n            getchar();\n            system(\"clear\");\n        } while (escolha != 1 && escolha != 2 && escolha != 3);\n        if (escolha == 3) return 0;\n        if (escolha == 1)\n        {\n            le_mdc(&a, &b);\n            printf(\"\\nMDC(%i,%i) = %i\\n\\n\", a, b, mdc(a,b));\n        }\n        else if (escolha == 2)\n        {\n            le_mmc(&a, &b);\n            printf(\"\\nMMC(%i,%i) = %i\\n\\n\", a, b, mmc(a,b));\n        }\n        printf(\"\\nPressione ENTER para continuar: \");\n        getchar();\n        system(\"clear\");\n    } while (escolha != 3);\n    return 0;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_nus.2.c", "original_string": "static void on_hvx_tx_complete(ble_nus_t * p_nus, ble_evt_t const * p_ble_evt)\n{\n    ret_code_t                 err_code;\n    ble_nus_evt_t              evt;\n    ble_nus_client_context_t * p_client;\n    err_code = blcm_link_ctx_get(p_nus->p_link_ctx_storage,\n                                 p_ble_evt->evt.gatts_evt.conn_handle,\n                                 (void *) &p_client);\n    if (err_code != NRF_SUCCESS)\n    {\n        NRF_LOG_ERROR(\"Link context for 0x%02X connection handle could not be fetched.\",\n                      p_ble_evt->evt.gatts_evt.conn_handle);\n        return;\n    }\n    if (p_client->is_notification_enabled)\n    {\n        memset(&evt, 0, sizeof(ble_nus_evt_t));\n        evt.type        = BLE_NUS_EVT_TX_RDY;\n        evt.p_nus       = p_nus;\n        evt.conn_handle = p_ble_evt->evt.gatts_evt.conn_handle;\n        evt.p_link_ctx  = p_client;\n        p_nus->data_handler(&evt);\n    }\n}"}
{"author": "earth429", "file": "mulpre__mulprec1.4.c", "original_string": "void copyNumber(struct NUMBER *a, struct NUMBER *b){\n    int i;\n    clearByZero(b);\n    b->sign = a->sign;\n    for (i = 0; i < KETA;i++){\n        b->n[i] = a->n[i];\n    }\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__a1.3.c", "original_string": "int main() {\n    char *filename = \"Trees.txt\";\n    size_t n = num_rows(filename);\n    size_t m = num_cols(filename);\n    bool **trees = get_trees(filename, n, m);\n    size_t count = 0;\n    size_t j = 0;\n    for (size_t i = 0; i < n; i++) {\n        if (trees[i][j]) count++;\n        j = (j + 3) % m;\n    }\n    printf(\"Answer: %zu\\n\", count);\n    for (size_t i = 0; i < n; i++)\n        free(trees[i]);\n    free(trees);\n    return 0;\n}"}
{"author": "mehedi9021", "file": "C__matrix_loop.0.c", "original_string": "int main()\n{\n    int a[2][2];\n    int r1,c1;\n    for(r1=0; r1<=1; r1++)\n    {\n        for(c1=0; c1<=1; c1++)\n        {\n            scanf(\"%d\", &a[r1][c1]);\n        }\n    }\n    printf(\"The first matrix is:\\n\");\n    for(r1=0; r1<=1; r1++)\n    {\n        for(c1=0; c1<=1; c1++)\n        {\n            printf(\"%d \", a[r1][c1]);\n        }\n        printf(\"\\n\");\n    }\n    int r2,c2;\n    for(r2=0; r2<=1; r2++)\n    {\n        for(c2=0; c2<=1; c2++)\n        {\n            scanf(\"%d\", &a[r2][c2]);\n        }\n    }\n    printf(\"The Secound matrix is:\\n\");\n    for(r2=0; r2<=1; r2++)\n    {\n        for(c2=0; c2<=1; c2++)\n        {\n            printf(\"%d \", a[r2][c2]);\n        }\n        printf(\"\\n\");\n    }\n    for(r1=0; r1<=1; r1++)\n    {\n        for(c1=0; c1<=1; c1++)\n        {\n            for(r2=0; r2<=1; r2++)\n            {\n                for(c2=0; c2<=1; c2++)\n                {\n                    if(r1==r2&&c1==c2)\n                        {\n                            printf(\"Two matrices are equal\");\n                        }\n                    else\n                        {\n                            printf(\"Not equal\");\n                        }\n                }\n            }\n        }\n    }\n    return 0;\n}"}
{"author": "fikepaci", "file": "sorting_algorithms__100-shell_sort.1.c", "original_string": "void backward_insertion(int *array, int gap, int act)\n{\n    int i;\n    for (i = act - gap; i >= 0; i -= gap, act -= gap)\n    {\n        if (array[i] > array[act])\n            _swap(&array[i], &array[act]);\n        else\n            break;\n    }\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica3-1.1.c", "original_string": "void * compra(){\n    int modelo=(rand()%4)+1; \n    int cantidad=(rand()%10)+1; \n    printf(\"stock: %i %i %i %i %i \\n\",camisetas[0], camisetas[1], camisetas[2], camisetas[3], camisetas[4]);\n    printf(\"se va a comprar el modelo %i %i veces \\n\",modelo,cantidad);\n    pthread_mutex_lock(&mutex_acceso);\n        camisetas[modelo-1] = camisetas[modelo-1] - cantidad;\n    pthread_mutex_unlock(&mutex_acceso);\n    printf(\"stock: %i %i %i %i %i \\n\",camisetas[0], camisetas[1], camisetas[2], camisetas[3], camisetas[4]);\n    pthread_exit(NULL); \n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc.2.c", "original_string": "void iter_insertion(node** root, int n)\n{\n    node*** temp=&root;\n    while(**temp!=NULL)\n    {\n        if(n < (**temp)->data) *temp=&(**temp)->left;\n        else *temp=&(**temp)->right;\n    }\n    **temp=createNode(n);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_last_DLL.4.c", "original_string": "void insert_at_last()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    newnode->next=0;\n    temp=head;\n    while(temp->next!=0)\n    {\n        temp=temp->next;\n    }\n    temp->next=newnode;\n    newnode->pre=temp;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__insert_element.1.c", "original_string": "void createList(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int data, i;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter node data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n; i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter node data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=temp->next;\n    }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_9.5.c", "original_string": "void print(queue Q,int n,FILE *fp2)\n{\n    int i,l,c=0;\n    l=length(Q);\n    if (Q.front == -1)\n    {\n        fprintf(fp2,\"-1\\n\");\n        return;\n    }\n    if(n>0 || n==0)\n     {\n        if(n==0)\n          n=l;\n        if (Q.rear >= Q.front)\n         {\n          for (i = Q.front; i <= Q.rear; i++)\n            {\n                if(c<n)\n                 fprintf(fp2,\"%d\",Q.arr[i]);\n                if(i!=Q.rear)\n                 fprintf(fp2,\" \");\n                 c++;  \n              }\n             if(c<n)\n              fprintf(fp2,\" END\\n\");\n             else\n              fprintf(fp2,\"\\n\");\n          }\n        else\n        {\n          for (i = Q.front; i < Q.size; i++)\n            {\n                if(c<n)\n                 fprintf(fp2,\"%d \", Q.arr[i]);\n                c++;\n            }      \n          for (i = 0; i <= Q.rear; i++)\n            {  \n                if(c<=n)\n                 fprintf(fp2,\"%d\", Q.arr[i]);\n                c++;\n                if(i!=Q.rear)\n                 fprintf(fp2,\" \");\n            }\n            if(c<n)\n              fprintf(fp2,\" END\\n\");\n            else\n              fprintf(fp2,\"\\n\");\n         }\n    }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-central-scanner-with-whitelist__nrf_fstorage.0.c", "original_string": "ret_code_t nrf_fstorage_init(nrf_fstorage_t     * p_fs,\n                             nrf_fstorage_api_t * p_api,\n                             void               * p_param)\n{\n    NRF_FSTORAGE_PARAM_CHECK(p_fs,  NRF_ERROR_NULL);\n    NRF_FSTORAGE_PARAM_CHECK(p_api, NRF_ERROR_NULL);\n    p_fs->p_api = p_api;\n    return (p_fs->p_api)->init(p_fs, p_param);\n}"}
{"author": "augustogunsch", "file": "jackc__vm-lines.0.c", "original_string": "LINE* mkline(int size) {\n    LINE* ln = (LINE*)malloc(sizeof(LINE));\n    ln->tokens = (char**)malloc(sizeof(char*)*size);\n    ln->count = 0;\n    return ln;\n}"}
{"author": "haon1026", "file": "linux-programming__base.3.c", "original_string": "int Listen(int sockfd, int backlog)\n{\n    int ret = listen(sockfd, backlog);\n    if(ret == -1)\n    {\n        sys_err(\"listen() error\");\n    }\n    return ret;\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__odd_even_process.1.c", "original_string": "void even_file_open()\n{\n    FILE *fpe;\nprintf(\"even file opening-----\\n\");\nfpe=fopen(\"even.txt\",\"r\");\nwhile (fgets(words,sizeof(words),fpe)!=NULL)\n{\n    printf(\"\\t%s\",words);\n}\nfclose(fpe);\n}"}
{"author": "fikepaci", "file": "monty__monty_funcs_1.4.c", "original_string": "void monty_swap(stack_t **stack, unsigned int line_number)\n{\n    stack_t *tmp;\n    if ((*stack)->next == NULL || (*stack)->next->next == NULL)\n    {\n        set_op_tok_error(short_stack_error(line_number, \"swap\"));\n        return;\n    }\n    tmp = (*stack)->next->next;\n    (*stack)->next->next = tmp->next;\n    (*stack)->next->prev = tmp;\n    if (tmp->next)\n        tmp->next->prev = (*stack)->next;\n    tmp->next = (*stack)->next;\n    tmp->prev = *stack;\n    (*stack)->next = tmp;\n}"}
{"author": "davibernardos", "file": "DB-Projetos__e5.0.c", "original_string": "int main(int argc, char *argv[]) {\n    int modoJogo;\n    int jogarNovamente;\n    int jogador1;\n    int jogador2;\n    int ia;\n    int empates;\n    int vitoriasP1;\n    float porcentvitP1;\n    int vitoriasP2;\n    float porcentvitP2;\n    int vitoriasIA;\n    float porcentvitIA;\n    int contador;\n    printf(\"-^^- JOKENPO GAME by TS -^^- \\n \\n \\n\");\n    printf(\"Digite o numero de uma das opcoes abaixo:\\n 1 - Jogar Player Vs Player \\n 2- Jogar Player Vs IA\\n 3- Sair\\n\");\n    scanf(\"%d\", &modoJogo);\n    while(modoJogo != 1 && modoJogo !=2 && modoJogo !=3 ) {\n        printf(\"Opcao Invalida, digite uma opcao valida:\\n 1 - Jogar Player Vs Player \\n 2- Jogar Player Vs IA\\n 3- Sair\\n\");\n        scanf(\"%d\", &modoJogo);\n    }\n    switch (modoJogo) {\n        case 1:\n        printf(\" -^^- MODO PLAYER VS PLAYER -^^- \\n \\n \\n\");\n        jogarNovamente=1;\n        vitoriasP1=0;\n        vitoriasP2=0;\n        contador=0;\n        do {\n            printf(\"Player 1 -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador1);\n            while(jogador1 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador1);\n            }\n            printf(\"Player 2 -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador2);\n            while(jogador2 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador2);\n            }\n            if((jogador1 == 1 && jogador2 == 1) || (jogador1 == 2 && jogador2 == 2)|| (jogador1==3 && jogador2==3)) {\n                printf(\"EMPATOU! \\n\");\n                empates++;\n                contador++;\n            } else {\n                if(jogador1 == 1 && jogador2 == 2) {\n                    printf(\"PEDRA E PAPEL = VITORIA JOGADOR 2! \\n\");\n                    vitoriasP2++;\n                    contador++;\n                } else {\n                    if(jogador1==1 && jogador2 == 3) {\n                        printf(\"PEDRA E TESOURA = VITORIA JOGADOR 1! \\n\");\n                        vitoriasP1++;\n                        contador++;\n                    } else {\n                        if(jogador1==2 && jogador2==1) {\n                            printf(\"PAPEL E PEDRA = VITORIA JOGADOR 1! \\n\");\n                            vitoriasP1++;\n                            contador++;\n                        } else {\n                            if(jogador1==2 && jogador2==3) {\n                                printf(\"PAPEL E TESOURA = VITORIA JOGADOR 2! \\n\");\n                                vitoriasP2++;\n                                contador++;\n                            } else {\n                                if(jogador1==3 && jogador2==1) {\n                                    printf(\"TESOURA E PEDRA = VITORIA JOGADOR 2! \\n\");\n                                    vitoriasP2++;\n                                    contador++;\n                                } else {\n                                    printf(\"TESOURA E PAPEL = VITORIA JOGADOR 1! \\n\");\n                                    vitoriasP1++;\n                                    contador++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            printf(\"Deseja jogar Novamente? \\n 1- Sim\\n 2-Nao \\n\");\n            scanf(\"%d\", &jogarNovamente);\n            while(jogarNovamente >2) {\n                printf(\"Opcao Invalida, digite uma opcao valida:\\n 1- Sim\\n 2-Nao \\n\");\n                scanf(\"%d\", &jogarNovamente);\n            }\n        } while(jogarNovamente ==1);\n        printf(\"ESTATISTICAS: \\n\");\n        printf(\"Numero de Vezes Jogadas: %d \\n\", contador);\n        printf(\"Numero de Empates: %d \\n\", empates);\n        if(vitoriasP1 == 0 && vitoriasP2 == 0) {\n            printf(\"Porcentagem de Vitorias PLAYER 1 = 0 \\nPorcentagem de Vitorias PLAYER 2 = 0\");\n        } else {\n            porcentvitP1=(vitoriasP1*100)/(contador-empates);\n            porcentvitP2=(vitoriasP2*100)/(contador-empates);\n            printf(\"Porcentagem de Vitorias PLAYER 1 = %f \\n\", porcentvitP1);\n            printf(\"Porcentagem de Vitorias PLAYER 2 = %f \\n\", porcentvitP2);\n        }\n        break;\n    case 2:\n        printf(\" -^^- MODO PLAYER VS I.A -^^- \\n \\n \\n\");\n        jogarNovamente=1;\n        vitoriasP1=0;\n        vitoriasIA=0;\n        contador=0;\n        do {\n            printf(\"Player -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador1);\n            while(jogador1 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador1);\n            }\n            srand(time(NULL));\n            ia=(rand() % 3)+1;\n            printf(\"Jogada da maquina:\\n %d\\n\", ia);\n            if((jogador1 == 1 && ia == 1) || (jogador1 == 2 && ia == 2)|| (jogador1==3 && ia==3)) {\n                printf(\"EMPATOU! \\n\");\n                empates++;\n                contador++;\n            } else {\n                if(jogador1 == 1 && ia == 2) {\n                    printf(\"PEDRA E PAPEL = VITORIA MAQUINA! \\n\");\n                    vitoriasIA++;\n                    contador++;\n                } else {\n                    if(jogador1==1 && ia == 3) {\n                        printf(\"PEDRA E TESOURA = VITORIA JOGADOR! \\n\");\n                        vitoriasP1++;\n                        contador++;\n                    } else {\n                        if(jogador1==2 && ia==1) {\n                            printf(\"PAPEL E PEDRA = VITORIA JOGADOR! \\n\");\n                            vitoriasP1++;\n                            contador++;\n                        } else {\n                            if(jogador1==2 && ia==3) {\n                                printf(\"PAPEL E TESOURA = VITORIA MAQUINA! \\n\");\n                                vitoriasIA++;\n                                contador++;\n                            } else {\n                                if(jogador1==3 && ia==1) {\n                                    printf(\"TESOURA E PEDRA = VITORIA MAQUINA! \\n\");\n                                    vitoriasIA++;\n                                    contador++;\n                                } else {\n                                    printf(\"TESOURA E PAPEL = VITORIA JOGADOR! \\n\");\n                                    vitoriasP1++;\n                                    contador++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            printf(\"Deseja jogar Novamente? \\n 1- Sim\\n 2-Nao \\n\");\n            scanf(\"%d\", &jogarNovamente);\n            while(jogarNovamente >2) {\n                printf(\"Opcao Invalida, digite uma opcao valida:\\n 1- Sim\\n 2-Nao \\n\");\n                scanf(\"%d\", &jogarNovamente);\n            }\n        } while(jogarNovamente ==1);\n        printf(\"ESTATISTICAS: \\n\");\n        printf(\"Numero de Vezes Jogadas: %d \\n\", contador);\n        printf(\"Numero de Empates: %d \\n\", empates);\n        if(vitoriasP1 == 0 && vitoriasIA == 0) {\n            printf(\"Porcentagem de Vitorias PLAYER 1 = 0 \\nPorcentagem de Vitorias PLAYER 2 = 0\");\n        } else {\n            porcentvitP1=(vitoriasP1*100)/(contador-empates);\n            porcentvitIA=(vitoriasIA*100)/(contador-empates);\n            printf(\"Porcentagem de Vitorias PLAYER 1 = %f \\n\", porcentvitP1);\n            printf(\"Porcentagem de Vitorias da MAQUINA = %f \\n\", porcentvitIA);\n        }\n        break;\n        case 3:\n            exit(0);\n            break;\n        }\n    system(\"pause\");\n    return 0;\n}"}
{"author": "haon1026", "file": "linux-programming__deadlock2.0.c", "original_string": "void* fun1(void *arg)\n{\n    pthread_mutex_lock(&mutex1);\n    printf(\"val1 = %d\\n\", val1);\n    sleep(1);\n    pthread_mutex_lock(&mutex2);\n    val2 = 100;\n    printf(\"val2 = %d\\n\", val2);\n    pthread_mutex_unlock(&mutex2);\n    pthread_mutex_unlock(&mutex1);\n    return NULL;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__all_interrupts.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | (0xFF<<17);       \n    IODIR0 |= (1<<11);\n    timer1_config();\n    timer0_config();\n    interrupt_config();\n    while(1)\n    {\n            blink_LED(24);\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__n-rooks_castle-a.3.c", "original_string": "int main(){\n    int x=1;\n    while(x){\n        printf(\"Enter valid N i.e for no of rows and columns: \");\n        scanf(\"%d\",&N);\n        if(N>0)\n            x=0;\n    }\n    int arr[N][N];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            arr[i][j]=0;\n    rooks(arr,0);\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_pos_DCLL.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.delete the element at any position in the linked list\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4: printf(\"delete the element at any position in the linked list\\n\");\n            delete_at_pos();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "jdes01", "file": "practicassoo__practica1ej3.0.c", "original_string": "int main(int argc, char * argv[]){\n    switch (fork()){\n        case -1:\n                printf(\"ERROR\");\n                exit(EXIT_FAILURE);\n                break;\n        case 0: \n                printf(\"soy el hijo numero %d; mi padre es %d\\n\", getpid(), getppid); \n                execlp(argv[1], argv[1], NULL);\n                exit(EXIT_SUCCESS);\n                break;\n    }\n    switch (fork()){\n        case -1:\n                printf(\"ERROR\");\n                exit(EXIT_FAILURE);\n                break;\n        case 0: \n                printf(\"soy el hijo numero %d; mi padre es %d\\n\", getpid(), getppid); \n                execvp(argv[2], argv+2);\n                exit(EXIT_SUCCESS);\n                break;\n    }\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__keypad.4.c", "original_string": "void col_3(void)            \n{\n    int val;\n    IODIR1 = IODIR1 & ~COLS;        \n    IODIR1 = IODIR1 | ROWS;         \n    val = IOPIN1 & COLS;        \n    val = val >> 17;\n    switch(val)\n    {\n        case 0x0E:  lcd_data('1');  delay(200); break;\n        case 0x0D:  lcd_data('2');  delay(200); break;\n        case 0x0B:  lcd_data('3');  delay(200); break;\n        case 0x07:  lcd_data('-');  delay(200); break;\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insertion_sort.0.c", "original_string": "void insertion(int a[],int n)\n{\n    int i,j,temp;\n    for(i=1;i<n;i++)\n    {\n        temp=a[i];\n        j=i-1;\n        while(j>=0 && a[j]>temp)\n        {\n            a[j+1]=a[j];\n            j--;\n        }\n        a[j+1]=temp;\n    }\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__cub2d_utils.3.c", "original_string": "void        draw_map(void)\n{\n    g_image.img = mlx_new_image(g_vars.mlx, g_width, g_height);\n    g_image.addr = mlx_get_data_addr(g_image.img, &g_image.bits_per_pixel,\n                    &g_image.line_length, &g_image.endian);\n    norm_it(g_map_array);\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__46_col_sum_row_sum.0.c", "original_string": "int main()\n{\n  int i,j,k,r1,c1,r2,c2,row_sum = 0, col_sum = 0;\n  printf(\"Enter Value of r1, c1\\n\");\n  scanf(\"%d%d\",&r1,&c1);\n  int m1[r1][c1], sum = 0;\n  printf(\"Enter value of Matrix1\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      scanf(\"%d\",&m1[i][j]);\n    }\n  }\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      printf(\"%d \",m1[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      row_sum = row_sum + m1[i][j];\n    }\n    printf(\"Sum of Row[%d] is %d\\n\",i,row_sum);\n    row_sum = 0;\n  }\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      col_sum = col_sum + m1[j][i];\n    }\n    printf(\"Sum of col[%d] is %d\\n\",i,col_sum);\n    col_sum = 0;\n  }\n }"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__routing_utils.3.c", "original_string": "int     len_str(char *s, int i, char c)\n{\n    int len;\n    len = 0;\n    while (s[i] != c && s[i])\n    {\n        len++;\n        i++;\n    }\n    return (len);\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_9.0.c", "original_string": "int main()\n{\n    int one[8] = {55, 6, -8, -8, 10, 22, 0, 121};\n    int two[8] = {22, 1, -3, -4, 10, 21, 2, 233};\n    int three[8] = {33, 4, -9, -9, 99, 99, 0, 400};\n    unsigned int naturalNumber = 8;\n    printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n    printf(\"\\nElementy tablicy3: \");\n    for(int i = 0; i < (sizeof(three)/sizeof(three[0])); i++){\n        printf(\"%d \", three[i]);\n    }\n    printf(\"\\n\\nMieszanie tablic!!!\\n\\n\");\n    changeCells(naturalNumber, one, two, three);\n     printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n    printf(\"\\nElementy tablicy3: \");\n    for(int i = 0; i < (sizeof(three)/sizeof(three[0])); i++){\n        printf(\"%d \", three[i]);\n    }\n    getchar();;\n    return 0;\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal.24.c", "original_string": "void HAL_GetUID(uint32_t *UID)\n{\n  UID[0] = (uint32_t)(READ_REG(*((uint32_t *)UID_BASE)));\n  UID[1] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 4U))));\n  UID[2] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 8U))));\n}"}
{"author": "augustogunsch", "file": "jackc__parser-statements.2.c", "original_string": "STATEMENT* parsestatements(PARSER* p) {\n    STATEMENT* head = parsestatementnullified(p);\n    STATEMENT* curr = head;\n    STATEMENT* next;\n    while(next = parsestatementnullified(p), next != NULL) {\n        curr->next = next;\n        curr = next;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_DLL.0.c", "original_string": "int main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of element in the linked list\\n\");\n    printf(\"4.insert the element at the beginning position of linked list\\n\");\n    printf(\"5.insert the element at the last position of linked list\\n\");\n    printf(\"6.insert the element at any position of linked list\\n\");\n    printf(\"7.delete the element from beginning position from the linked list\\n\");\n    printf(\"8.delete the element from last position from the linked list\\n\");\n    printf(\"9.delete the element from any position from the linked list\\n\");\n    printf(\"10.revers the linked list\\n\");\n    printf(\"11.exit\\n\");\n    int choice;\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=12)\n    {\n        switch(choice)\n        {\n            case 1: printf(\"implementation\\n\");\n            creat();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of element in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"insert the element at the beginning position of linked list\\n\");\n            insert_beg();\n            break;\n            case 5: printf(\"insert the element at the last position of linked list\\n\");\n            insert_end();\n            break;\n            case 6:printf(\"insert the element at any position of linked list\\n\");\n            insert_at_pos();\n            break;\n            case 7:printf(\"delete the element from beginning position from the linked list\\n\");\n            delete_beg();\n            break;\n            case 8:printf(\"delete the element from last position from the linked list\\n\");\n            delete_end();\n            break;\n            case 9:printf(\"delete the element from any position from the linked list\\n\");\n            delete_at_pos();\n            break;\n            case 10:printf(\"revers the linked list\\n\");\n            reverse();\n            break;\n            case 11:printf(\"exit \\n\");\n            exit(0);\n            break;\n            default:printf(\"invalied choice \\n\");\n            break;\n        }\n         printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSL__tls_ffdhe.0.c", "original_string": "error_t tlsSelectFfdheGroup(TlsContext *context,\n   const TlsSupportedGroupList *groupList)\n{\n   error_t error;\n   uint_t i;\n   uint_t j;\n   uint_t n;\n   uint16_t namedGroup;\n   bool_t ffdheGroupFound;\n   error = ERROR_HANDSHAKE_FAILED;\n   ffdheGroupFound = FALSE;\n   context->namedGroup = TLS_GROUP_NONE;\n   if(groupList != NULL)\n   {\n      n = ntohs(groupList->length) / sizeof(uint16_t);\n      if(context->numSupportedGroups > 0)\n      {\n         for(i = 0; i < context->numSupportedGroups; i++)\n         {\n            for(j = 0; j < n; j++)\n            {\n               namedGroup = ntohs(groupList->value[j]);\n               if(namedGroup >= TLS_GROUP_FFDHE2048 &&\n                  namedGroup <= TLS_GROUP_FFDHE_MAX)\n               {\n                  ffdheGroupFound = TRUE;\n               }\n               if(context->supportedGroups[i] == namedGroup)\n               {\n                  if(tlsGetFfdheGroup(context, namedGroup) != NULL)\n                  {\n                     if(context->namedGroup == TLS_GROUP_NONE)\n                     {\n                        context->namedGroup = namedGroup;\n                     }\n                  }\n               }\n            }\n         }\n      }\n      else\n      {\n         for(j = 0; j < n; j++)\n         {\n            namedGroup = ntohs(groupList->value[j]);\n            if(namedGroup >= TLS_GROUP_FFDHE2048 &&\n               namedGroup <= TLS_GROUP_FFDHE_MAX)\n            {\n               ffdheGroupFound = TRUE;\n            }\n            if(tlsGetFfdheGroup(context, namedGroup) != NULL)\n            {\n               if(context->namedGroup == TLS_GROUP_NONE)\n               {\n                  context->namedGroup = namedGroup;\n               }\n            }\n         }\n      }\n   }\n   if(!ffdheGroupFound)\n   {\n      if(tlsGetFfdheGroup(context, TLS_GROUP_FFDHE2048) != NULL)\n      {\n         context->namedGroup = TLS_GROUP_FFDHE2048;\n      }\n      else if(tlsGetFfdheGroup(context, TLS_GROUP_FFDHE3072) != NULL)\n      {\n         context->namedGroup = TLS_GROUP_FFDHE3072;\n      }\n      else if(tlsGetFfdheGroup(context, TLS_GROUP_FFDHE4096) != NULL)\n      {\n         context->namedGroup = TLS_GROUP_FFDHE4096;\n      }\n      else\n      {\n         context->namedGroup = TLS_GROUP_NONE;\n      }\n   }\n   if(context->namedGroup != TLS_GROUP_NONE)\n   {\n      error = NO_ERROR;\n   }\n   return error;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__19_.1.c", "original_string": "void Columnas(int contador, int pibote)\n{\n    if(contador <= 40){\n        if(contador >= 40 - pibote)\n            printf(\"A\");\n        else\n            printf(\" \");\n        Columnas(++contador,pibote);\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__search_node.0.c", "original_string": "void createList(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int data, i;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter node data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n; i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter node data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=temp->next;\n    }\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__harf_notu.0.c", "original_string": "int main ()\n{\n    int n;\n    printf(\"ders notunuzu 0-100 aras\u0131nda giriniz:\");\n    scanf(\"%d\",&n);\n    if (n<=100 && n>=0)\n    {\n        if(90<=n)\n            printf(\"harf notunuz A\");\n        else if(80<=n && n<90)\n            printf(\"harf notunuz B\");\n        else if(70<=n && n<80)\n            printf(\"harf notunuz C\");   \n        else \n            printf(\"harf notunuz F\");\n    }\n    else \n    {\n        printf(\"girilen de\u011fer tan\u0131ms\u0131z\");\n        return 1;\n    }\n    return 0;\n    }"}
{"author": "earth429", "file": "mulpre__quickDivide.0.c", "original_string": "int main(int argc, char **argv)\n{\n    double t1 = time(NULL);\n    struct NUMBER a, b, c, d;\n    int x, y;\n    x = 49585;\n    y = 98;\n    setInt(&a, x);\n    setInt(&b, y);\n    printf(\"x = %d\\ny = %d\\nx / y = %d\\nx %% y = %d\\n\", x, y, x / y, x % y);\n    quickDivide(&a, &b, &c, &d);\n    dispNumberZeroSuppress(&c);\n    puts(\"\");\n    dispNumberZeroSuppress(&d);\n    puts(\"\");\n    double t2 = time(NULL);\n    printf(\"\u51e6\u7406\u6642\u9593:%f\\n\", t2 - t1);\n    return 0;\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad8AddingArrays.0.c", "original_string": "int main()\n{\n   int array1[8] = { 8, 32, -4, 43, 200, 4000, -6432, 7};\n   int array2[8] = { 2, -32, -4, 653, -199, 4010, -6432, 14};\n   int array3[8];\n   int arraySize = sizeof(array1)/sizeof(*array1);\n    addArraysPointer(array1, array2, array3, arraySize);\n    printf(\"array1: \");\n    for(int i = 0; i < arraySize; i++){\n            printf(\"%d \", array1[i]);\n    }\n    printf(\"\\n\\narray2: \");\n    for(int i = 0; i < arraySize; i++){\n            printf(\"%d \", array2[i]);\n    }\n    printf(\"\\n\\narray3: \");\n    for(int i = 0; i < arraySize; i++){\n            printf(\"%d \", array3[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "2security", "file": "String__13ReverseOrderOfWord.1.c", "original_string": "char * ReverseWord(char str[])\n    {\n        int d,s,k=0,t,j;\n        char *temp= malloc(Mystrlength(str));\n        s=Mystrlength(str)-1;\n        d=Mystrlength(str)-1;\n        while(s>0)\n            {\n            if(str[s]== ' ')    \n                {\n                    for(j=s+1;j<=d;j++)\n                        {\n                            temp[k]=str[j];     \n                            k++;\n                        }\n                    temp[k++]=' ';\n                    d=s-1;\n                }\n            s--;\n            }\n        for(j=0;j<=d;j++)\n            {\n                temp[k]=str[j]; \n                k++;    \n            }\n        temp[k]= '\\0';\n        return temp;\n    }"}
{"author": "paawankohli", "file": "DSA-LAB__orderedLL.2.c", "original_string": "void display(nptr head)\n{\n    nptr temp = head;\n    while(temp != NULL)\n    {\n        printf(\"%d --> \", temp -> data);\n        temp = temp->next;\n    }\n    printf(\"NULL\\n\");\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise18.1.c", "original_string": "int main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n    int size = 15;\n    int arr[size];\n    int maximum , element;\n    int i;\n    printf(\"Enter array elements: \");\n    for(i=0 ; i<size ; i++){\n        scanf(\"%d\",&arr[i]);\n    }\n    printf(\"\\n\");\n    printf(\"Enter required element: \");\n    scanf(\"%d\",&element);\n    maximum = LongestConsecutive(arr , size , element);\n    printf(\"Longest consecutive number of element %d is %d\",element ,maximum);\n    return 0;\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__queue.1.c", "original_string": "void enqueue(void) {\n    int value;\n    printf(\"Enter the value to insert\\n\");\n    scanf(\"%d\",&value);\n    if(rear == SIZE-1){\n        printf(\"Queue is Full!!!\\n\");\n    }else {\n        if(front == -1)\n            front = 0;\n        rear = rear +1;\n        queue[rear] = value;\n        printf(\"Inserion Success..!!!\\n\");\n    }\n}"}
{"author": "dle2005", "file": "Algorithm__Knapsack.1.c", "original_string": "bool promising(index i, int profit, int weight) {\n    index j, k;\n    int totweight;\n    float bound;\n    if(weight >= W) {\n        printf(\"x\\n\");\n        printf(\"\\n\");\n        return false;\n    }\n    else {\n        j = i+1;\n        bound = profit;\n        totweight = weight;\n        while((j <= n) && (totweight + w[j] <= W)) {\n            totweight = totweight + w[j];\n            bound = bound + p[j];\n            j++;\n        }\n        k = j;\n        if(k <= n) \n            bound = bound + (W-totweight) * p[k] / w[k];\n        printf(\"bound\\t = %.0f\\n\", bound);\n        if(bound > maxprofit) {\n            printf(\"\\n\");\n            return true;\n        }\n        else {\n            printf(\"x\\n\\n\");\n            return false;\n        }\n        return bound > maxprofit;\n    }\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__20_While.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Euler elevado a X mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    while(i <= veces){\n        Suma_total += (Exp(X,i) / Fac(i));\n        ++i;\n    }\n    printf(\"e^%i es igual a %lf\", X, (Suma_total + 1.0));\n    return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__BF.0.c", "original_string": "int main()\n{\n    char str[82];\n    int num[100000], k, n, tam;\n    long int tam_total = 0;\n    scanf(\"%i\", &n);\n    scanf(\"%i\", &k);\n    getchar();\n    for (int j = 0; j < n; j++)\n    {\n        fgets(str, 82, stdin);\n        for (int i = 0; str[i] != '\\0'; i++)\n        {\n            if (str[i] == '\\n')\n            {\n                num[i + tam_total] = ((int)str[i]);\n            }\n            else\n            {\n                num[i + tam_total] = ((int)str[i]) - k;\n                if (num[i + tam_total] < 32)\n                {\n                    num[i + tam_total] += 95;\n                }\n            }\n        }\n        tam = strlen(str);\n        tam_total += tam;\n    }\n    for (long int i = 0; i < tam_total; i++)\n    {\n        printf(\"%c\", num[i]);\n    }\n    return 0;\n}"}
{"author": "earth429", "file": "mulpre__mulprec.15.c", "original_string": "int add(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    int d; \n    int e = 0; \n    int i;\n    struct NUMBER a_abs, b_abs; \n    clearByZero(c);\n    if(getSign(a) > 0 && getSign(b) > 0){ \n        for (i = 0; i < KETA;i++){\n            d = a->n[i] + b->n[i] + e;\n            c->n[i] = d % 10;\n            e = (d - c->n[i]) / 10; \n        }\n        if(e != 0){ \n            return -1;\n        }\n    } else if(getSign(a) > 0 && getSign(b) < 0){ \n        getAbs(b, &b_abs);\n        sub(a, &b_abs, c);\n    } else if(getSign(a) < 0 && getSign(b) > 0){ \n        getAbs(a, &a_abs);\n        sub(b, &a_abs, c);\n    } else if(getSign(a) < 0 && getSign(b) < 0){ \n        getAbs(a, &a_abs);\n        getAbs(b, &b_abs);\n        add(&a_abs, &b_abs, c);\n        setSign(c, -1);\n    }\n    return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__funcoes.2.c", "original_string": "int f_de_x_taylor(int n, double at[], double x, double xf)\n{\n    double soma = 0;\n    for (int i = 0; i <= n; i++)\n    {\n        soma += (at[i] * pow(x, i)) / fatorial(i); \n        printf(\"%i %lf %lf\\n\", i + 1, soma, xf); \n        if (fabs(soma - xf) <= 0.001) \n            return 0;\n    }\n    return 0;\n}"}
{"author": "flora0110", "file": "hw01git__check2-3.1.c", "original_string": "char*** make3darr(int rows, int cols,int hei){\n    char ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__queue.5.c", "original_string": "int main() {\n   int num, n;\n   enqueue(3);\n   enqueue(5);\n   enqueue(9);\n   enqueue(1);\n   enqueue(12);\n   enqueue(15);\n   if(isFull()){\n      printf(\"Queue is full!\\n\");\n   }\n   num = dequeue();\n   printf(\"Element removed: %d\\n\",num);\n   enqueue(16);\n   enqueue(17);\n   enqueue(18);\n   printf(\"Element at front: %d\\n\",peek());\n   printf(\"Queue:  \");\n   while(!isEmpty()) {\n      n = dequeue();\n      printf(\"%d \",n);\n   }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__priorityqueue.0.c", "original_string": "void enqueue(queue *q,int n)\n{\n    if (q->rear==20)\n        printf(\"Queue Full\\n\");\n    else\n    {\n        int i,j,t;\n        q->c[(q->rear)++]=n;\n        for (i=0;i<q->rear-1;i++)\n        {\n            for (j=0;j<q->rear-i-1;j++)\n            {\n                if (q->c[j]>q->c[j+1])\n                {\n                    t=q->c[j];\n                    q->c[j]=q->c[j+1];\n                    q->c[j+1]=t;\n                }\n            }\n        }\n    }\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Paging.1.c", "original_string": "void rem_program(int id1)\n{\n    int i,k;\n    for(i=0;i<16;i++)\n    {\n        if(Mem[i]==id1)\n        {\n            Mem[i]=0;\n        }\n    }\n    for(i=0;i<index1;i++)\n    {\n        if(t[i].id==id1)\n            break;\n    }\n    t[i].id=-1;\n    t[i].size=-1;\n    for(k=0;k<16;k++)\n    {\n        if(t[i].indices[k]!=-1)\n            t[i].indices[k]=-1;\n        else\n            break;\n    }\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad4.3.c", "original_string": "int ispis(pozicija p)\n{\n    while (p != NULL)\n    {\n        printf(\"Koeficijent je: %d Eksponent je: %d\\n\", p->koeficijent, p->eksponent);\n        p = p->next;\n    }\n    return 0;\n}"}
{"author": "mandarvu", "file": "msc__problem54.1.c", "original_string": "int main() { \n  char source1[MAX], source2[MAX], target[MAX];\n  printf(\"Enter a string (Max %d characters)\\n\", MAX);\n  scanf(\"%[^\\n]%*c\", source1); \n  printf(\"Enter another string (Max %d characters)\\n\", MAX);\n  scanf(\"%[^\\n]%*c\", source2); \n  merge_string(source1, source2, target);\n  printf(\"%s\\n\", target);\n  return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__DemoFOTAUpdateWorkflow.1.c", "original_string": "void fotahub_onConnectionStatusChanged(ConnectionStatus_t status)\n{\n  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__power.1.c", "original_string": "int PowerR(int X, int Y)\n{\n    static int Result = 1;\n    if(Y != 0)\n    {\n        Result = Result * X;\n        Y--;\n        PowerR(X,Y);\n    }\n    return Result;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__delete_node_from_DLL_any_positn.1.c", "original_string": "void createList(int n)\n{\n    int i, data;\n        struct node *newNode;\n        head = (struct node *)malloc(sizeof(struct node));\n        printf(\"Enter data of 1 node: \");\n        scanf(\"%d\", &data);\n        head->data = data;\n        head->prev = NULL;\n        head->next = NULL;\n        last = head;\n        for(i=2; i<=n; i++)\n        {\n            newNode = (struct node *)malloc(sizeof(struct node));\n            printf(\"Enter data of %d node: \", i);\n            scanf(\"%d\", &data);\n            newNode->data = data;\n            newNode->prev = last; \n            newNode->next = NULL;\n            last->next = newNode; \n            last = newNode; \n        }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__binarySearchTree.4.c", "original_string": "struct Node*delete(struct Node*root, int value){\n     if(root==NULL){\n          printf(\"\\nValue: %d is not present or the tree is empty!\\n\", value);\n          return NULL;\n     }\n     else if(value<root->data){\n          root->left = delete(root->left, value);\n     }\n     else if(value>root->data){\n          root->right= delete(root->right, value);\n     }\n     else{\n          if(root->left == NULL && root->right==NULL){\n               free(root);\n               return NULL;\n          }\n          else if(root->left ==NULL || root->right==NULL){\n               struct Node*temp=root;\n               if(root->left==NULL){\n                    root=root->right;\n               }\n               else{\n                    root=root->left;\n               }\n               free(temp);\n          }\n          else{\n               struct Node*temp = findMinimum(root->right);\n               root->data=temp->data;\n               root->right= delete(root->right, temp->data);\n          }\n     }\n     return root;\n}"}
{"author": "MFarid94", "file": "Assignment4__Exercise5.1.c", "original_string": "int main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stdout , NULL , _IONBF , 0);\n    int i;\n    int array_A[SIZE];\n    int array_B[SIZE];\n    int *ptrA = array_A;\n    int *ptrB = array_B;\n    printf(\"Enter elements of array A: \");\n    for(i=0 ; i<SIZE ; i++){\n        scanf(\"%d\",ptrA);\n        ptrA++;\n    }\n    CopyArray(array_A,array_B);\n    for(i=0 ; i<SIZE ; i++){\n        printf(\"ArrayB[%d] = %d \\n\",i,*ptrB);\n        ptrB++;\n    }\n    return 0;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__rostring.1.c", "original_string": "char    **ft_split(char *str)\n{\n    int i;\n    int i2;\n    int i3;\n    char **tab;\n    i = 0;\n    i2 = 0;\n    tab = (char**)malloc(sizeof(char*) * 1000);\n    while(str[i])\n    {\n        if (str[i] > 32)\n        {\n            i3 = 0;\n            tab[i2] = (char*)malloc(sizeof(char*) * 1000);\n            while (str[i] > 32)\n                tab[i2][i3++] = str[i++];\n            tab[i2++][i3] = '\\0';\n        }\n        else\n            i++;\n    }\n    tab[i2] = 0;\n    return (tab);\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__sender0.3.c", "original_string": "int send_frame(unsigned char *frame, unsigned int frame_len){\n    FILE *file = fopen(\"pipe.bin\", \"wb+\");\n    if(file == NULL)\n    {\n        printf(\"[INFO] File open error!\\n\");\n        return 0;\n    }\n    fwrite(&frame_len,sizeof(frame_len),1,file);\n    fwrite(frame, sizeof(char), frame_len, file);\n    fclose(file);\n    printf(\"[INFO] Frame send success!\\n\");\n    return 0;\n}"}
{"author": "MFarid94", "file": "Assignment-2__Exercise6.0.c", "original_string": "char lower_to_upper(char alphabet){\n    if( alphabet >= 'a' && alphabet <= 'z' ){\n        alphabet = alphabet - 32;                                   \n    }\n    else{\n        test_case = CHECK_LOWER_FALSE;\n    }\n    return alphabet;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_any_pos_CLL.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.insert the element at any position \\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"insert the element at any position \\n\");\n            insert_at_pos();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-central-scanner-with-whitelist__nrf_ble_whitelist.3.c", "original_string": "ret_code_t nrf_ble_whitelist_clear(void)\n{\n        ret_code_t ret;\n        memset(m_whitelist_addrs, 0, sizeof(m_whitelist_addrs));\n        m_addr_cnt = 0;\n        ret = sd_ble_gap_whitelist_set(NULL, 0);\n        APP_ERROR_CHECK(ret);\n        m_whitelist_is_running = false;\n        return ret;\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__MissingCoin.0.c", "original_string": "int main()\n{\n    int n;\n    printf(\"enter the no. of coins:\");\n    scanf(\"%d\",&n);\n    int coins[n-1];\n    int i,count,j;\n    printf(\"The coins are:\\n\");\n    for(i=0;i<n-1;i++)\n    {\n        scanf(\"%d\",&coins[i]);\n    }\n    for(i=0;i<n-1;i++)\n    {                                        \n        count = 0;\n        for(j=0;j<n-1;j++)\n        {\n            if(coins[i] == coins[j])\n            {\n                count+=1;;\n            }\n        }\n        printf(\"Mising coin is:\");\n        if(count%2==1)\n        {\n            printf(\"%d\",coins[i]);\n            return 0;\n        }\n    }\n    return 0;\n}"}
{"author": "jdes01", "file": "practicassoo__practica1ej1b.0.c", "original_string": "int main(){\n    int nHijos=5, hijo, status;\n    printf(\"Padre con ID %d \\n\", getpid());\n    printf(\"\\n\");\n    for (int i=0; i<nHijos; i++){\n        hijo=fork(); \n        switch (hijo){\n        case -1:\n            printf(\"Error en la creaci\u00f3n \\n\");\n            exit(EXIT_FAILURE);\n        case 0:\n            printf(\"Hijo %d con ID %d del proceso %d \\n\", i+1, getpid(), getppid());\n            printf(\"\\n\");\n            break;\n        default:\n            printf(\"Esperando hijo numero %d \\n\", i+1);\n            wait(&status);\n            printf(\"Hijo %d termindo con ID %d, codigo de salida: %d \\n\", i+1, getpid(), WEXITSTATUS(status));\n            printf(\"\\n\");\n            exit(EXIT_SUCCESS);\n        }\n    } \n    return 0;\n}"}
{"author": "MFarid94", "file": "Assignment1__Exercise21.0.c", "original_string": "int main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);                        \n    setvbuf(stderr , NULL , _IONBF , 0);\n    int i,j,rows;\n        printf(\"Enter number of rows: \");\n        scanf(\"%d\",&rows);\n        printf(\"\\n\");\n        for(i=0;i<rows;i++)\n        {\n            if(i == rows/2){\n                continue;\n            }\n            for(j=0;j<rows;j++)\n            {\n                if(j == rows/2){\n                    continue;\n                }\n                if( (j==i) || (j==rows-i-1) )\n                {\n                    printf(\"*\");\n                }\n                else\n                {\n                    printf(\" \");\n                }\n            }\n            printf(\"\\n\");\n        }\n        return 0;\n}"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__2-3.1.c", "original_string": "int htoi(char s[]){\n  int cont = 0;\n  if(s[0] != '0' || (s[1] != 'x' && s[1] != 'X'))\n     return -1;\n  for(int i = 2; (s[i]>= '0' && s[i] <= '9') || (s[i] >= 'a' && s[i] <= 'f')\n    || (s[i] >= 'A' && s[i] <= 'F'); i++, cont++)\n    ;\n  int hexa[cont];\n  for(int i = 2; (s[i]>= '0' && s[i] <= '9') || (s[i] >= 'a' && s[i] <= 'f')\n    || (s[i] >= 'A' && s[i] <= 'F'); i++)\n    hexa[i-2] = hexa_to_int(s[i]);\n  return get_decimal(hexa, cont);\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__sw-case0.0.c", "original_string": "int main ()\n{\n    int secim ;\n    printf(\"1 giriniz\");\n    scanf(\"%d\",&secim);\n    switch(secim)\n    {\n        case(1):\n            {\n                int k=10;\n                printf(\"b\u00f6l\u00fcm:%d \",k/0);\n            }\n            break;\n            default:\n                printf(\"say\u0131n kullan\u0131c\u0131 neden 1 girmiyorsun ay\u0131p de\u011fil mi\");\n    }\n    return 0;\n    }"}
{"author": "dishanp", "file": "DSA__q34.1.c", "original_string": "void display(struct node *p)\n{\n    while(p)\n    {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__receiver.2.c", "original_string": "int output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n        if(i %9 == 0 && i!=0) printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__min_max.0.c", "original_string": "int main()\n{\n    int n,i ; \n    int max,min,maxIndis,minIndis;\n    printf(\"%s\",\"dizinin boyutunu giriniz:\")   ;\n    scanf(\"%d\",&n);\n    int arr[n];\n    for(i=0;i<n;i++)\n    {\n        printf(\"%s\\n\",\"eleman giriniz:\");\n        scanf(\"%d\",&arr[i]);\n    }\n    max=min=arr[0];\n    maxIndis=minIndis=0;\n    for(i=1;i<n;i++)\n    {\n        if(min>arr[i])\n        {\n            min=arr[i];\n            minIndis=i;\n        }\n        if(max<arr[i])\n        {\n            max=arr[i];\n            maxIndis=i;\n        }\n    }\n    printf(\"en b\u00fcy\u00fck de\u011fer:%d\\nen b\u00fcy\u00fck de\u011fer s\u0131ras\u0131:%d\\n\",max,maxIndis+1);\n    printf(\"en k\u00fc\u00e7\u00fck de\u011fer:%d\\nen k\u00fc\u00e7\u00fck de\u011fer s\u0131ras\u0131:%d\\n\",min,minIndis+1);\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_pos_DCLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__binary_representation.0.c", "original_string": "void DisplayBinary(int iValue)\n{\n    int iRem = 0;\n    if(iValue < 0)\n    {\n        iValue = -iValue;\n    }\n    while(iValue != 0)\n    {\n        iRem = iValue % 2;\n    iValue = iValue / 2;\n    printf(\"%d\",iRem);\n    }\n}"}
{"author": "mandarvu", "file": "msc__problem16.0.c", "original_string": "int main () {\n    char source[MAX], final[MAX]; \n    printf(\"Enter a string (max %d characters): \", MAX);\n    fgets(source, MAX, stdin); \n    printf(\"%s \\n\", source);\n    string_reverse(source, final); \n    printf(\"%s \\n\", final);\n    return 0;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__16_.1.c", "original_string": "void Columnas(int contador, int pibote)\n{\n    if(contador <= 20){\n        if(contador >= (10 - pibote) && contador <= (10 + pibote))\n            printf(\"Z\");\n        else\n            printf(\" \");\n        Columnas(++contador, pibote);\n    }\n}"}
{"author": "apoorvasrivastava98", "file": "C__MagicNumber.1.c", "original_string": "void magic(int n)\n{\n    int i,sum=0,num=n;\n        while (n > 0 || sum > 9) \n    { \n        if (n == 0) \n        { \n            n = sum; \n            sum = 0; \n        } \n        sum =sum + n % 10; \n        n = n / 10; \n    } \n     if(sum==1)\n     {\n         printf(\"%d is a magic number\",num);\n     }\n     else\n     {\n         printf(\"%d is not a magic number\",num);\n     }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__stp_operation.4.c", "original_string": "void stpForwardDelayTimerExpiry(StpBridgePort *port)\n{\n   StpBridgeContext *context;\n   context = port->context;\n   if(port->state == STP_PORT_STATE_LISTENING)\n   {\n      stpUpdatePortState(port, STP_PORT_STATE_LEARNING);\n      stpStartTimer(&port->forwardDelayTimer, 0);\n   }\n   else if(port->state == STP_PORT_STATE_LEARNING)\n   {\n      stpUpdatePortState(port, STP_PORT_STATE_FORWARDING);\n      if(stpDesignatedBridge(context) && port->changeDetectionEnabled)\n      {\n         stpTopologyChangeDetection(context);\n      }\n   }\n   else\n   {\n   }\n}"}
{"author": "augustogunsch", "file": "jackc__threads.4.c", "original_string": "void waitthreads(pthread_t* threads, int amount) {\n    void* status;\n    int code;\n    for(int i = 0; i < amount; i++) {\n        code = pthread_join(threads[i], &status);\n        if(code) {\n            eprintf(\"Error while joining thread %i: %s\\n\", i, strerror(code));\n            exit(code);\n        }\n    }\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-statements.3.c", "original_string": "STATEMENT* parselet(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, letstatement);\n    LETSTATEMENT* letst = (LETSTATEMENT*)malloc(sizeof(LETSTATEMENT));\n    letst->varname = parseidentifier(p);\n    if(equals(p, \"[\")) {\n        next(p);\n        letst->arrayind = parseexpression(p);\n        checkcontent(p, \"]\");\n    }\n    else\n        letst->arrayind = NULL;\n    checkcontent(p, \"=\");\n    letst->expression = parseexpression(p);\n    checkcontent(p, \";\");\n    s->type = letstatement;\n    s->letstatement = letst;\n    return s;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e92.1.c", "original_string": "void listarEventos(struct evento show[])\n{\n    int cont;\n    for(cont = 0; cont < contShow; cont++)\n    {   \n        printf(\"Evento: %s\\n\", show[cont].nome);\n        printf(\"Valor da entrada: %g\\n\", show[cont].valorIngresso);\n        printf(\"Lugares disponiveis: %d\\n\", show[cont].disponiveis);\n        printf(\"Codigo: %d \\n\\n\\n\", cont);\n    }\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__102-counting_sort.0.c", "original_string": "void counting_sort(int *array, size_t size)\n{\n    int *count = NULL, *out = NULL, max = 0, total = 0;\n    size_t i, j;\n    if (array == NULL || size < 2)\n        return;\n    for (i = 0; i < size; i++)\n    {\n        if (array[i] > max)\n            max = array[i];\n    }\n    count = malloc(sizeof(int) * (max + 1));\n    if (!count)\n        return;\n    j = max;\n    for (i = 0; i <= j; i++)\n        count[i] = 0;\n    for (i = 0; i < size; i++)\n        count[array[i]]++;\n    for (i = 0; i <= j; i++)\n    {\n        total += count[i];\n        count[i] = total;\n    }\n    print_array(count, max + 1);\n    out = malloc(sizeof(int) * size);\n    if (!out)\n    {\n        free(count);\n        return;\n    }\n    for (i = 0; i < size; i++)\n    {\n        out[--count[array[i]]] = array[i];\n    }\n    for (i = 0; i < size; i++)\n        array[i] = out[i];\n    free(out);\n    free(count);\n}"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post-a.2.c", "original_string": "list *insert(list* root, int n)\n{\n    list **temp=&root;\n    while(*temp!=NULL)\n    {\n        if(n < (*temp)->key) temp=&(*temp)->left;\n        else temp=&(*temp)->right;\n    }\n    *temp=newNode(n);\n    return root;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__BinHexConverter.1.c", "original_string": "uint8_t convertHexDigitToBinValue(char inputChr)\n{\n  if (inputChr >= '0' && inputChr <= '9') \n  {\n    return ((uint8_t)(inputChr - '0'));\n  }\n  else if (inputChr >= 'a' && inputChr <= 'f') {\n    return 10 + ((uint8_t)(inputChr - 'a'));\n  }\n  else if (inputChr >= 'A' && inputChr <= 'F') {\n    return 10 + ((uint8_t)(inputChr - 'A'));\n  }\n  return 0;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__mcd.0.c", "original_string": "int mcd(int a, int b)\n{\n    int r = a % b;\n    if(r == 0){\n        return b;\n    } else { \n        return mcd(b, r);\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__BE.0.c", "original_string": "int main()\n{\n    char str[90];\n    int num[100000], k, n, tam, tam_total = 0;\n    scanf(\"%i\", &n);\n    scanf(\"%i\", &k);\n    getchar();\n    for (int j = 0; j < n; j++)\n    {\n        fgets(str, 90, stdin);\n        for (int i = 0; str[i] != '\\0'; i++)\n        {\n            if (str[i] == '\\n')\n            {\n                num[i + tam_total] = ((int)str[i]);\n            }\n            else\n            {\n                num[i + tam_total] = ((int)str[i]) + k;\n            }\n            if (num[i + tam_total] > 126)\n            {\n                num[i + tam_total] -= 95;\n            }\n        }\n        tam = strlen(str);\n        tam_total += tam;\n    }\n    for (int i = 0; i < tam_total; i++)\n    {\n        printf(\"%c\", num[i]);\n    }\n    return 0;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-central-scanner-with-whitelist__nrf_ble_whitelist.0.c", "original_string": "ret_code_t nrf_ble_whitelist_add(ble_gap_addr_t *addr, uint8_t * whitelist_count)\n{\n        if (m_addr_cnt >= BLE_GAP_WHITELIST_ADDR_MAX_COUNT)\n                return NRF_ERROR_DATA_SIZE;\n        for (uint32_t i = 0; i < BLE_GAP_WHITELIST_ADDR_MAX_COUNT; i++)\n        {\n                if (memcmp(&m_whitelist_addrs[i], addr, sizeof(ble_gap_addr_t))==0)\n                {\n                        return NRF_ERROR_INVALID_PARAM;\n                }\n        }\n        memcpy(&m_whitelist_addrs[m_addr_cnt], addr, sizeof(ble_gap_addr_t));\n        m_addr_cnt++;\n        *whitelist_count = m_addr_cnt;\n        return NRF_SUCCESS;\n}"}
{"author": "fikepaci", "file": "monty__monty_funcs_2.4.c", "original_string": "void monty_mod(stack_t **stack, unsigned int line_number)\n{\n    if ((*stack)->next == NULL || (*stack)->next->next == NULL)\n    {\n        set_op_tok_error(short_stack_error(line_number, \"mod\"));\n        return;\n    }\n    if ((*stack)->next->n == 0)\n    {\n        set_op_tok_error(div_error(line_number));\n        return;\n    }\n    (*stack)->next->next->n %= (*stack)->next->n;\n    monty_pop(stack, line_number);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__dequeue.4.c", "original_string": "void display(queue *q)\n{\n    int i;\n    for (i=q->front;i<q->rear;i++)\n        printf(\"%d\\t\",q->c[i]);\n    printf(\"\\n\");\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__SingleLinkedList_Creation_And_Traversing.0.c", "original_string": "int main()\n{\n    int choice = 1;\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice)\n    {\n        newnode = (struct node*) malloc(sizeof(struct node));\n        printf(\"Enter the element in the node:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->link = NULL;\n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->link = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want to enter more nodes?(0/1)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    int count = 0;\n    printf(\"THE ELEMENTS PRESENT IN THE NODE ARE\\n\");\n    while(temp!=NULL)\n    {\n        count++;\n        printf(\"%d\\t\",temp->data);\n        temp = temp->link;\n    }\n    printf(\"\\nCount : %d\",count);\n    return 0;\n}"}
{"author": "DanielSalis", "file": "AED1__teste6.5.c", "original_string": "int main(){\n    int op;\n    int IDprocesso;\n    TipoLista lista;\n    iniciarLista(&lista);\n    while(op != -1){\n        scanf(\"%d\", &op);\n        if(op == -1){\n            break;\n        }\n        if(op == 1){\n            scanf(\"%d\", &IDprocesso); \n            inserir(&lista, IDprocesso);\n        }\n        else if(op == 2){\n            remover(&lista);\n        }\n        else if(op == 3){\n            imprimir(&lista);\n        }\n        else{\n            printf(\"opcao invalida\\n\");\n            break;\n        }\n    }\n    return 0;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__testingbinary.2.c", "original_string": "struct node* new_node(int x)\n{\n    struct node *p;\n    p = malloc(sizeof(struct node));\n    p->data = x;\n    p->left_child = NULL;\n    p->right_child = NULL;\n    return p;\n}"}
{"author": "dle2005", "file": "File_Structure__ftlmgr.0.c", "original_string": "int main(int argc, char *argv[])\n{   \n    char option = argv[1][0];\n    switch(option) {\n        case 'c' : optionC(argv[2], atoi(argv[3]));\n                   break;\n        case 'w' : optionW(argv[2], atoi(argv[3]), argv[4], argv[5]);\n                   break;\n        case 'r' : optionR(argv[2], atoi(argv[3]));\n                   break;\n        case 'e' : flashfp = fopen(argv[2], \"r+t\");\n                   dd_erase(atoi(argv[3]));\n                   break;\n    }\n    return 0;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e40.2.c", "original_string": "int main(int argc, char *argv[]) \n{\n    int vetorCaptcha[6];\n    char vetorUsuario[6];\n    int teste = 0;\n    srand(time(NULL));\n    srandString(vetorCaptcha);\n    printf(\"\\n\\n\");\n    do\n    {\n        printf(\"Digite corretamente o CAPTCHA acima: \");\n        gets(vetorUsuario);\n        teste = cmpString(vetorUsuario, vetorCaptcha);\n    }\n    while(teste == 0);\n    return 0;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_01.4.c", "original_string": "int main(int argc, char* argv[])\n{\n        F1 = fopen(argv[1],\"r\");\n        F2 = fopen(argv[2],\"w\");\n        char s;\n        int num;\n        int size;\n        int* A;\n        while(1)\n        {\n                fscanf(F1,\"%c\",&s);\n                if(s=='r')\n                {\n                        fscanf(F1,\"%d\", &num);\n                        size=num;\n                        A=(int*)malloc(sizeof(int)*num);\n                        read(A,num);\n                }\n                else if(s=='i')\n                {\n                        int p=inversion(A,size);\n                        fprintf(F2,\"%d\\n\",p);\n                }\n                else if(s=='d')\n                {\n                        fscanf(F1,\"%d\", &num);\n                        display(A,num);\n                }\n                else if(s=='t')\n                        break;\n        }\n    return 0;\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__NumberSeriesProgram.1.c", "original_string": "int fibonnaciSeries(int x)\n{\n    int a=0,b=1,temp;\n    int i;\n    for(i=1;i<=x;i++)\n    {\n        temp = a+b;\n        a = b;\n        b = temp;\n    }\n    printf(\"%d\",a);\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_7.0.c", "original_string": "int main()\n{\n    int choice;\n    while(1)\n    {\n        printf(\"Queue Operations : \\n\");\n        printf(\"1. Enqueue\\n\");\n        printf(\"2. Dequeue\\n\");\n        printf(\"3. Traverse\\n\");\n        printf(\"4. Exit\\n\");\n        printf(\"Enter your choice : \");\n        scanf(\"%d\", &choice);\n        switch(choice)\n        {\n        case 1:\n            enqueue();\n            break;\n        case 2:\n            dequeue();\n            break;\n        case 3:\n            traverse();\n            break;\n        case 4:\n            exit(0);\n            break;\n        default:\n            printf(\"Invalid Choice\\n\");\n        }\n    }\n    return 0;\n}"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal_gpio_ex.0.c", "original_string": "void HAL_GPIOEx_ConfigEventout(uint32_t GPIO_PortSource, uint32_t GPIO_PinSource)\n{\n  assert_param(IS_AFIO_EVENTOUT_PORT(GPIO_PortSource));\n  assert_param(IS_AFIO_EVENTOUT_PIN(GPIO_PinSource));\n  MODIFY_REG(AFIO->EVCR, (AFIO_EVCR_PORT) | (AFIO_EVCR_PIN), (GPIO_PortSource) | (GPIO_PinSource));\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__vic.3.c", "original_string": "void delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__stack_pallindrom_string.3.c", "original_string": "int pop() {\n    if (isEmpty())\n        printf(\"Stack is Empty...\\n\");\n    else {\n     string.top = string.top - 1;\n        return string.array[string.top+1];\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__pwm_single.1.c", "original_string": "void delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "Dhruvik-Chevli", "file": "DAALab__graphAdjacencyList.0.c", "original_string": "struct Graph* createGraph(int V)\n{\n    struct Graph* graph=(struct Graph*)malloc(sizeof(struct Graph));\n    graph->V=V;\n    graph->arr=(struct adjList*)malloc(V*sizeof(struct adjList));\n    for(int i=0;i<V;i++)\n    {\n        graph->arr[i].head=NULL;\n    }\n    return graph;\n}"}
{"author": "dle2005", "file": "Algorithm__Chained_Matrix_Multiplication_v2.4.c", "original_string": "void main() {\n    int n;\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"\\n\");\n    int **A = init_matrix(n);\n    int **P = init_matrix(n + 1);\n    M = init_matrix(n + 1);\n    int *d = (int *)malloc(sizeof(int) * (n + 1));\n    for(int i = 0; i < n; i++) {\n        printf(\"A%d = \", i);\n        scanf(\"%d %d\", &A[i][0], &A[i][1]);\n    }\n    printf(\"\\n\");\n    d[0] = A[0][0];\n    for(int i = 0; i < n; i++)\n        d[i + 1] = A[i][1]; \n    printf(\"bestcase = %d\\n\\n\", minmult(n, d, P));\n    printf(\"P = \\n\");\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= n; j++)\n            printf(\"%4d\", P[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    printf(\"order = \");\n    order(0, n, P);\n    printf(\"\\n\");\n    printf(\"\\n\");\n    for(int diagonal = 1; diagonal <= n - 1; diagonal++) {\n        for(int i = 1; i <= n - diagonal; i++) {\n            int j = i + diagonal;\n            printf(\"M[%d][%d] = \", i, j);\n            order(i, j, P);\n            printf(\"= %d\\n\", M[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__main.3.c", "original_string": "static void MX_GPIO_Init(void)\n{\n  __HAL_RCC_GPIOF_CLK_ENABLE();\n  __HAL_RCC_GPIOH_CLK_ENABLE();\n  __HAL_RCC_GPIOC_CLK_ENABLE();\n  __HAL_RCC_GPIOG_CLK_ENABLE();\n  __HAL_RCC_GPIOE_CLK_ENABLE();\n  __HAL_RCC_GPIOD_CLK_ENABLE();\n  __HAL_RCC_GPIOA_CLK_ENABLE();\n  __HAL_RCC_GPIOB_CLK_ENABLE();\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedInsertion.4.c", "original_string": "struct Node * insertAfterNode(struct Node *head, struct Node *previousNode, int data){\n     struct Node * ptr = (struct Node *) malloc(sizeof(struct Node));\n     ptr->data = data;\n     ptr->next = previousNode->next;\n     previousNode->next = ptr;\n     return head;\n}"}
{"author": "Oryx-Embedded", "file": "Common__path.9.c", "original_string": "bool_t pathMatch(const char_t *path, const char_t *pattern)\n{\n   size_t i = 0;\n   size_t j = 0;\n   while(pattern[j] != '\\0')\n   {\n      if(pattern[j] == '?')\n      {\n         if(path[i] == '\\0')\n         {\n            return FALSE;\n         }\n         else\n         {\n            i++;\n            j++;\n         }\n      }\n      else if(pattern[j] == '*')\n      {\n         if(path[i] == '\\0')\n         {\n            j++;\n         }\n         else if(pathMatch(path + i, pattern + j + 1))\n         {\n            return TRUE;\n         }\n         else\n         {\n            i++;\n         }\n      }\n      else\n      {\n         if(osTolower(path[i]) != osTolower(pattern[j]))\n         {\n            return FALSE;\n         }\n         else\n         {\n            i++;\n            j++;\n         }\n      }\n   }\n   if(path[i] == '\\0' && pattern[j] == '\\0')\n      return TRUE;\n   else\n      return FALSE;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__vm-lines.0.c", "original_string": "LINE* mkline(int size) {\n    LINE* ln = (LINE*)malloc(sizeof(LINE));\n    ln->tokens = (char**)malloc(sizeof(char*)*size);\n    ln->count = 0;\n    return ln;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__priorityqueue.3.c", "original_string": "int main()\n{\n    int z=0,k,e;\n    queue q;\n    q.front=0;\n    q.rear=0;\n    while (z==0)\n    {\n        printf(\"1. Enqueue \\t4. Dequeue \\t5. Display \\t6. Exit\\n\");\n        scanf(\"%d\",&k);\n        switch(k)\n        {\n            case 1:\n            {\n                scanf(\"%d\",&e);\n                enqueue(&q,e);\n                break;\n            }\n            case 2:\n            {\n                break;\n            }\n            case 3:\n            {\n                break;\n            }\n            case 4:\n            {\n                printf (\"%d\\n\",dequeue(&q));\n                break;\n            }\n            case 5:\n            {\n                display(&q);\n                break;\n            }\n            case 6:\n            {\n                z=1;\n            }\n        }\n    }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_04.1.c", "original_string": "void display(int arr2[], int n)\n{\n        int i;\n        for(i = 0; i<n; i++)\n        {\n                fprintf(F2, \"%d \", arr2[i]);\n        }\n}"}
{"author": "earth429", "file": "mulpre__doubleLog.1.c", "original_string": "int doubleLog(double *a, double x, int n) {\n    int i;\n    for (i = 0; i < n;i++){\n        *a += 2 / (2 * i + 1) * pow((x - 1) / (x + 1), 2 * i + 1);\n    }\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_SLL.3.c", "original_string": "int count()\n{\n    struct node *temp;\n    int count=0;\n    temp=head;\n    while(temp!=0)\n    {\n        count++;\n        temp=temp->next;\n    }\n    printf(\"the number of element in linked list is %d\", count);\n    printf(\"\\n\");\n    return count;\n}"}
{"author": "sdukesameer", "file": "dsa__list-ins-seq-sor.0.c", "original_string": "node* createnode(int inp)\n{\n    node* newnode=malloc(sizeof(node));\n    newnode->data=inp;\n    newnode->next=NULL;\n    return newnode;\n}"}
{"author": "2security", "file": "Array__SumArray.1.c", "original_string": "void displayarr(int arr[],int len)\n    {\n    int i;\n    printf(\"After delete operation the array is:\\n\");\n    for(i=0;i<len;i++)\n        printf(\"%d \",arr[i]);\n    }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__19_Dowhile.0.c", "original_string": "void Columna(int pibote)\n{\n    int j = 0;\n    do{\n        if(j >= 40 - pibote)\n            printf(\"A\");\n        else\n            printf(\" \");\n    ++j;\n    }while(j <= 40);\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b2.3.c", "original_string": "bool is_eye_color(char *field) {\n    return strcmp(field, \"amb\") == 0 || strcmp(field, \"blu\") == 0\n        || strcmp(field, \"brn\") == 0 || strcmp(field, \"gry\") == 0\n        || strcmp(field, \"grn\") == 0 || strcmp(field, \"hzl\") == 0\n        || strcmp(field, \"oth\") == 0;\n}"}
{"author": "flora0110", "file": "hw03git__4108056029_1-1.4.c", "original_string": "int main(){\n    FILE *rptr;\n    FILE *wptr;\n    rptr=fopen(\"test3.txt\",\"r\");\n    wptr=fopen(\"output1-1.txt\",\"w\");\n    if(rptr==NULL ||wptr==NULL){\n        printf(\"open error\\n\");\n        return 0;\n    }\n    int i,j;\n    int t,n,m;\n    fscanf(rptr,\"%d\\n\",&t);\n    printf(\"t: %d\\n\",t);\n    node* root;\n    int* arr;\n    for(i=0;i<t;i++){\n        fscanf(rptr,\"%d\\n\",&n);\n        printf(\"n: %d\\n\",n);\n        arr=(int*)malloc((n+1)*sizeof(int));\n        arr[0]=0;\n        for(j=1;j<n;j++){\n            fscanf(rptr,\"%d \",&arr[j]);\n        }\n        fscanf(rptr,\"%d\\n\",&arr[n]);\n        root=build(1,n,arr);\n        fscanf(rptr,\"%d\\n\",&m);\n        printf(\"m: %d\\n\",m);\n        char c;\n        int n1,n2;\n        for(j=0;j<m;j++){\n            fscanf(rptr,\"%c \",&c);\n            fscanf(rptr,\"%d %d\\n\",&n1,&n2);\n            if(c=='M'){\n                modify(n1,n2,1,n,root);\n            }\n            else if(c=='P'){\n                imfor ans=find(n1,n2,1,n,root);\n                fprintf(wptr,\"%d\\n\",ans.max);\n            }\n        }\n    }\n    fclose(wptr);\n    fclose(rptr);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__dequeue.2.c", "original_string": "int dequeueleft(queue *q)\n{\n    if (q->front==q->rear)\n    {\n        printf(\"Queue Empty\");\n        return -1;\n    }\n    else\n        return q->c[(q->front)++];\n}"}
{"author": "davibernardos", "file": "DB-PJ__e92.2.c", "original_string": "float pagarDinheiroInt(int contSelec , float pagamento, struct evento show[])\n{\n    float troco;\n    show[contSelec].lucro += (show[contSelec].valorIngresso * 0.9);\n    troco = pagamento - (show[contSelec].valorIngresso * 0.9);\n    show[contSelec].disponiveis--;\n    return troco;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__toggle_bit.1.c", "original_string": "int main()\n{\n    int iNo = 0, iPos = 0, iRet = 0;\n    printf(\"Enter number\\n\");\n    scanf(\"%d\",&iNo);\n    printf(\"Enter the position\\n\");\n    scanf(\"%d\",&iPos);\n    iRet = ToggleBit(iNo,iPos);\n    printf(\"Modified number after bit toggle is : %d\\n\",iRet);\n    return 0;\n}"}
{"author": "earth429", "file": "mulpre__sqrt_newton_test.0.c", "original_string": "int main(int argc, char **argv)\n{\n    int i, r, r1, r2, d;\n    srandom(time(NULL));\n    for (i = 0; i < 10;i++){\n        r = random();\n        r1 = sqrt_newton(r);\n        r2 = (int)sqrt((double)r);\n        d = r1 - r2;\n        printf(\"%6d - %6d = %d\\n\", r1, r2, d);\n    }\n    return 0;\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_8.6.c", "original_string": "int height(struct node* root)\n{\n    if(root == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        int c1 = height(root->left);\n        int c2 = height(root->right);\n        if(c1>c2)\n        {\n            return c1+1;\n        }\n        else\n        {\n            return c2+1;\n        }\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__stk-by-array.1.c", "original_string": "void push(stack* stk, int n)\n{\n    if(stk->top==(stk->size-1))\n        printf(\"OVERFLOW!\\n\");\n    else\n    {\n        stk->arr[++stk->top]=n;\n        printf(\"%d pushed to stack.\\n\",stk->arr[stk->top]);\n    }\n}"}
{"author": "dishanp", "file": "DSA__q34.0.c", "original_string": "void create(int A[], int n)\n{\n    struct node *last, *t;\n    int i;\n    first = (struct node*)malloc(sizeof(struct node));\n    first->data = A[0];\n    first->next = NULL;\n    last = first;\n    for(i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_pti.1.c", "original_string": "void rstpPtiFsm(RstpBridgePort *port)\n{\n   switch(port->ptiState)\n   {\n   case RSTP_PTI_STATE_ONE_SECOND:\n      if(port->tick)\n      {\n         rstpPtiChangeState(port, RSTP_PTI_STATE_TICK);\n      }\n      break;\n   case RSTP_PTI_STATE_TICK:\n      rstpPtiChangeState(port, RSTP_PTI_STATE_ONE_SECOND);\n      break;\n   default:\n      rstpFsmError(port->context);\n      break;\n   }\n}"}
{"author": "mehedi9021", "file": "C__2d_matrix_sum.0.c", "original_string": "int main()\n{\n    int a[5][5];\n    int r, c;\n    for(r=0; r<=1; r++)\n    {\n        for(c=0; c<=1; c++)\n        {\n            scanf(\"%d\", &a[r][c]);\n        }\n        printf(\"\\n\");\n    }\n    for(r=0; r<=1; r++)\n    {\n        for(c=0; c<=1; c++)\n        {\n            printf(\"%d \", a[r][c]);\n        }\n        printf(\"\\n\");\n    }\n    int sum=0;\n    for(r=0; r<=1; r++)\n    {\n        sum=0;\n        for(c=0; c<=1; c++)\n        {\n            sum=sum+a[r][c];\n        }\n        printf(\"\\nsum of element of row%d=%d \",r+1, sum);\n    }\n    for(c=0; c<=1; c++)\n    {\n        sum=0;\n        for(r=0; r<=1; r++)\n        {\n            sum=sum+a[r][c];\n        }\n        printf(\"\\nsum of element of coloumn %d=%d \",c+1, sum);\n    }\n    return 0;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__ex01.0.c", "original_string": "void point(){\n    glColor3f(0.0, 0.0, 1.0); \n    glPointSize(5.0f); \n    glBegin(GL_POINTS);\n        glVertex2f(0.0+up,0.0+right);\n    glEnd();\n}"}
{"author": "haon1026", "file": "linux-programming__pthread_shared.1.c", "original_string": "int main()\n{\n    srand(time(NULL));\n    pthread_t tid;\n    pthread_create(&tid, NULL, fun, NULL);\n    while (1)\n    {\n        printf(\"HELLO \");\n        sleep(rand()%3);\n        printf(\"WORLD\\n\");\n        sleep(rand()%3);\n    }\n    pthread_join(tid, NULL);\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_CLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the list is %d\\n\",c);\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__primos.0.c", "original_string": "int main(){\n    int resultado, primo = 0, no_primo = 0;\n    for(int numero = 1; numero <= 10000; numero++) {\n        resultado = es_primo(numero);\n        if(resultado == 1){\n            primo++;\n        } else {\n            no_primo++;\n        }\n    } \n    printf(\"Numero de primos %d, numero de no primos %d\\n\", primo, no_primo);\n    return 0;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__delete_node_from_DLL_any_positn.0.c", "original_string": "int main()\n{\n    int n, data, choice=1;\n    head = NULL;\n    last = NULL;\n    printf(\"Enter the total number of nodes in list: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    printf(\"Enter the node position which you want to delete: \");\n    scanf(\"%d\", &n);\n    deleteFromN(n);\n    displayList();\n    return 0;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_6.4.c", "original_string": "int dequeue(node* head)\n{\n  node p;\n  int dequeued;\n  if(*head==NULL)\n      return -1;\n  dequeued=(*head)->data;\n  p=(*head)->next;\n  free(*head);\n  *head=p;\n  return dequeued;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__i2c_read.2.c", "original_string": "void i2c_start(void)\n{\n    I2CONCLR = 1<<3;\n    I2CONSET = 1<<5;        \n    while(!(I2CONSET & (1<<3)));    \n    I2CONCLR = 1<<3;        \n    I2CONCLR = 1<<5;        \n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__nrf_dfu_flash.2.c", "original_string": "ret_code_t nrf_dfu_flash_store(uint32_t dest,\n                               void const * p_src,\n                               uint32_t len,\n                               nrf_dfu_flash_callback_t callback)\n{\n        ret_code_t rc;\n        NRF_LOG_DEBUG(\"nrf_fstorage_write(addr=%p, src=%p, len=%d bytes), queue usage: %d\",\n                      dest, p_src, len, m_flash_operations_pending);\n        rc = nrf_fstorage_write(&m_fs, dest, p_src, len, (void *)callback);\n        if ((NRF_LOG_ENABLED) && (rc == NRF_SUCCESS))\n        {\n                m_flash_operations_pending++;\n        }\n        else\n        {\n                NRF_LOG_WARNING(\"nrf_fstorage_write() failed with error 0x%x.\", rc);\n        }\n        return rc;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.4.c", "original_string": "TERM* parseint(PARSER* p) {\n    TERM* t = mkterm(intconstant);\n    t->integer = atoi(p->current->token);\n    next(p);\n    return t;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler.6.c", "original_string": "void InsertAtPos(PPNODE Head, PPNODE Tail, int value, int pos)\n{\n    int count = 0, i= 0;\n    PNODE temp = *Head;\n    PNODE newn = NULL;\n    count = Count(*Head, *Tail);\n    if((pos < 1) || (pos > (count + 1)))\n    {\n        return;\n    }\n    if(pos == 1)\n    {\n        InsertFirst(Head, Tail, value);\n    }\n    else if(pos == count + 1)\n    {\n        InsertLast(Head,Tail,value);\n    }\n    else\n    {\n        newn= (PNODE)malloc(sizeof(NODE));\n        newn->next = NULL;\n        newn->prev = NULL;\n        newn->data = value;\n        for(i = 1; i< pos-1; i++)\n        {\n            temp = temp->next;\n        }\n        newn->next = temp->next;\n        temp->next->prev = newn;\n        temp->next = newn;\n        newn->prev = temp;\n    }\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client_archive.5.c", "original_string": "int main(int argc, char **argv)\n{\n    if (argc != 2)\n    {\n        printf(\"Usage: %s <port>\\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n    char *ip = \"127.0.0.1\";\n    int port = atoi(argv[1]);\n    signal(SIGINT, catch_ctrl_c_and_exit);\n    printf(\"Please enter your name: \");\n    fgets(name, 32, stdin);\n    str_trim_lf(name, strlen(name));\n    if (strlen(name) > 32 || strlen(name) < 2)\n    {\n        printf(\"Name must be less than 30 and more than 2 characters.\\n\");\n        return EXIT_FAILURE;\n    }\n    struct sockaddr_in server_addr;\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = inet_addr(ip);\n    server_addr.sin_port = htons(port);\n    int err = connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));\n    if (err == -1)\n    {\n        printf(\"ERROR: connect\\n\");\n        return EXIT_FAILURE;\n    }\n    strcpy(new_entry_message, name);\n    strcat(new_entry_message, \" joined!\");\n    send(sockfd, new_entry_message, 32, 0);\n    printf(\"=== WELCOME TO THE CHATROOM ===\\n\");\n    pthread_t send_msg_thread;\n    if (pthread_create(&send_msg_thread, NULL, (void *)send_msg_handler, NULL) != 0)\n    {\n        printf(\"ERROR: pthread\\n\");\n        return EXIT_FAILURE;\n    }\n    pthread_t recv_msg_thread;\n    if (pthread_create(&recv_msg_thread, NULL, (void *)recv_msg_handler, NULL) != 0)\n    {\n        printf(\"ERROR: pthread\\n\");\n        return EXIT_FAILURE;\n    }\n    while (1)\n    {\n        if (flag)\n        {\n            printf(\"\\nBye.\\n\");\n            break;\n        }\n    }\n    close(sockfd);\n    return EXIT_SUCCESS;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e51.0.c", "original_string": "int main(int argc, char *argv[]) \n{\n    float valorIngresso, meiaEntrada, valorPago, troco;\n    int opcao, capacidadeMaxima, tipoIngresso, x, y, quantidadeVendido, quantidadeRestante;\n    char evento;    \n    capacidadeMaxima = 0;\n    quantidadeRestante = 1;\n    x = 0;\n    y = 0;\n    printf(\"\\t____________________________________________________________\\n\");\n    printf(\"\\n\");\n    printf(\"\\t| Ingresso++ - Meu sistema de gestao de venda de ingressos |\\n\");\n    printf(\"\\n\");\n    printf(\"\\t____________________________________________________________\\n\");\n    printf(\"\\n\");\n    while (y == 0)\n    {\n        while (x <= 50)\n        {\n            printf(\"_\");\n            x++;                \n        }\n        x = 0;\n        printf(\"\\n\");           \n        printf(\"\\n1) Cadastro de Evento.\\n\");\n        printf(\"2) Compre seu ingresso.\\n\");\n        printf(\"3) Sair.\\n\");\n        printf(\"\\n\");       \n        printf(\"Digite a opcao desejada: \");\n        scanf(\"%d\", &opcao);\n        printf(\"\\n\");\n        switch (opcao)\n        {\n            case 1:\n                printf(\"\\t-Digite o nome do evento: \");\n                scanf(\"%s\", &evento);\n                printf(\"\\n\\t-Informe a capacidade maxima de pessoas: \");\n                scanf(\"%d\", &capacidadeMaxima);\n                printf(\"\\n\\t-Digite o valor de cada ingresso: \");\n                scanf(\"%g\", &valorIngresso);\n                meiaEntrada = valorIngresso * 0.4;\n                quantidadeVendido = 0;  \n                quantidadeRestante = capacidadeMaxima;      \n            break;\n            case 2:\n                if (capacidadeMaxima == 0)\n                {\n                    printf(\"Nao ha evento cadastrado\\n\");   \n                }\n                else\n                {       \n                    if(quantidadeRestante <= 0)\n                    {\n                    printf(\"Ingresso Esgotados!\\n\");\n                    }\n                    else\n                    {                       \n                        printf(\"\\t_______________________________________\\n\");\n                        printf(\"\\n\\t| ADQUIRA SEU INGRESSO PARA O EVENTO. |\\n\");\n                        printf(\"\\t_______________________________________\\n\");\n                        printf(\"\\n\\t\\tO valor do evento eh: R$%.2f \\n\\t\\t(Meia entrada: R$%.2f)\\n\", valorIngresso, meiaEntrada);\n                        printf(\"\\nEscolha o tipo de ingresso:\\n\");\n                        printf(\"\\n\\t-Digite 1 para inteira.\\n\");\n                        printf(\"\\t-Digite 2 para meia.\\n\\n\\t\\t\");   \n                        scanf(\"%d\", &tipoIngresso); \n                        switch (tipoIngresso) \n                        {\n                            case 1: \n                                printf(\"\\n\\nInsira o dinheiro: \");\n                                scanf(\"%g\", &valorPago);\n                                if (valorPago < valorIngresso)\n                                {\n                                        printf(\"Valor pago insuficiente!\\n\");                       \n                                }\n                                else\n                                {\n                                    if (valorPago > valorIngresso)  \n                                    {\n                                        troco = valorPago - valorIngresso;                                  \n                                        printf(\"\\nSeu troco eh: R$%g\\n\", troco);                            \n                                    }\n                                        printf(\"\\nCompra concluida!\\n\");\n                                        quantidadeVendido++;                                    \n                                }\n                            break; \n                            case 2: \n                                printf(\"Insira o dinheiro: \");\n                                scanf(\"%g\", &valorPago);\n                                if (valorPago < meiaEntrada)\n                                {\n                                    printf(\"Valor pago insuficiente!\\n\");                       \n                                }\n                                else\n                                {\n                                    if (valorPago > meiaEntrada)\n                                    {\n                                        troco = valorPago - meiaEntrada;                                    \n                                        printf(\"\\nSeu troco eh: R$%g\\n\", troco);                            \n                                    }\n                                    printf(\"\\nCompra concluida!\\n\");\n                                    quantidadeVendido++;\n                                }               \n                            break;\n                            default:\n                                printf(\"Opcao invalida.\\n\");\n                            break;\n                        } \n                    quantidadeRestante = capacidadeMaxima - quantidadeVendido;\n                printf(\"\\n\\tQuantidade de entrada inteira restantes: %d\\n\", quantidadeRestante);                \n                printf(\"\\tQuantidade de meia entrada restantes: %d\\n\", quantidadeRestante);\n                    }\n                }\n            break; \n            case 3:\n                y = 1;\n            break;  \n            default:\n                printf(\"Opcao invalida.\\n\");\n            break;  \n        } \n    } \n    return 0;\n}"}
{"author": "revathy16296", "file": "rtos_lab_asssignment_1__4_file.0.c", "original_string": "int main()\n{ \nFILE *fp;\nint n,sum=0;\nfloat product=1,average;\nint array[SI];\nfp=fopen(\"file.txt\",\"w+\");\nprintf(\"inside the file called 'file.txt'\");\nprintf(\"\\n ------writing to the file------\\n\");\nprintf(\"enter the  number of elements in array\\n\");\nscanf(\"%d\",&n);\nprintf(\"enter the elements in the array\\n\");\nfor(i=0;i<n;i++)\n{\n    scanf(\"%d\",&array[i]);\n}\n    for(i=0;i<n;i++)\n    {\n        sum=sum+array[i];\n    }\n    average=sum/n;\n    for(i=0;i<n;i++)\n    {\n        product=product*array[i];\n    }\nfclose(fp);\nfp=fopen(\"file.txt\",\"r\");\nprintf(\"\\n----reading from the file----\\n\");\nprintf(\"the array elements are \\n\");\nfor(i=0;i<n;i++)\n{\n    printf(\"%d\\t\",array[i]);\n}\nprintf(\"\\nthe sum of number is %d\\n\",sum);\nprintf(\"the average is %f\\n\",average);\nprintf(\"product of number is %f\",product);\nfclose(fp);\nreturn 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__multi_led.1.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_07.3.c", "original_string": "void form_binary(int a[],int n,int q,int bin[n][q])\n{\n  int i,j,num;\n  for(i=0;i<n;i++)\n   {\n    num=a[i];\n    j=q-1;\n    while(num>0)\n      {\n           bin[i][j]=num%2;\n           num/=2;\n           j--;\n      }\n   }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__1.5.c", "original_string": "void imprime_aluno(aluno_t aluno)\n{\n    printf(\"\\nNome: %s\\n\", aluno.nome);\n    printf(\"Idade: %i\\n\", aluno.idade);\n    printf(\"Semestre: %i\\n\", aluno.semestre);\n    printf(\"Renda mensal: %f\\n\", aluno.renda_mensal);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__insertAfter.4.c", "original_string": "int main()\n{\n    nptr head = NULL;\n    int ch, ele, key;\n    printf(\"0. Exit      1. Insert Front      2. Insert After      3. Display\\n\");\n    do\n    {\n        printf(\"Command: \");\n        scanf(\"%d\", &ch);\n        switch(ch)\n        {\n            case 1: printf(\"Element: \");\n                    scanf(\"%d\", &ele);\n                    insertFront(head, ele);\n                    break;\n            case 2: printf(\"Element and key element to insert after: \");\n                    scanf(\"%d %d\", &ele, &key);\n                    insertAfter(head, ele, key);\n                    break;\n            case 3: display(head);\n        }\n    }while(ch != 0);\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__arreglo_uni_dinamico_calloc.1.c", "original_string": "void leer_calorias(int a[], int tam){\n    for (int i = 0; i < tam; i++){\n        printf(\"Ingrese las calorias consumidas en el dia: \");\n        scanf(\"%d\", &a[i]);\n    }\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__unique.6.c", "original_string": "void quicksort(int vector[], int inf, int sup){\n  int i, j, x;\n  i = inf;\n  j = sup;\n  x = vector[(i+j)/2];\n  while(i <= j){ \n      while(vector[i] < x)    \n    i++;\n      while(vector[j] > x)  \n    j--;\n      if(i<=j){\n    change(vector, i, j);\n    i++;\n    j--;\n      }\n  }\n  if(inf < j)\n    quicksort(vector, inf, j);\n  if(i < sup)\n    quicksort(vector, i, sup);\n}"}
{"author": "dishanp", "file": "DSA__q62.3.c", "original_string": "int main()\n{\n    int m, n;\n    printf(\"Enter number of rows : \");\n    scanf(\"%d\", &m);\n    printf(\"Enter number of columns : \");\n    scanf(\"%d\", &n);\n    int **mat ;\n    mat = (int**)malloc(m*sizeof(int*));\n    for(int i = 0 ; i < m ; i++)\n    {\n        mat[i] = (int*)malloc(n*sizeof(int));\n    }\n    for(int i = 0 ; i < m ; i++)\n    {\n        for(int j = 0 ; j < n ; j++)\n        {\n            printf(\"Enter element at row %d, column %d : \", i, j);\n            scanf(\"%d\", &mat[i][j]);\n        }\n    }\n    printf(\"Before sorting : \\n\");\n    for(int i = 0 ; i < m ; i++)\n    {\n        for (int j = 0 ; j < n ; j++)\n        {\n            printf(\"%d \", mat[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    rowsort(mat, m ,n);\n    printf(\"After Sorting Rows : \\n\");\n    for(int i = 0 ; i < m ; i++)\n    {\n        for (int j = 0 ; j < n ; j++)\n        {\n            printf(\"%d \", mat[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    colsort(mat, m, n);\n    printf(\"After Sorting Columns : \\n\");\n    for(int i = 0 ; i < m ; i++)\n    {\n        for (int j = 0 ; j < n ; j++)\n        {\n            printf(\"%d \", mat[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_msp.3.c", "original_string": "static void HAL_FMC_MspDeInit(void){\n  if (FMC_DeInitialized) {\n    return;\n  }\n  FMC_DeInitialized = 1;\n  __HAL_RCC_FMC_CLK_DISABLE();\n  HAL_GPIO_DeInit(GPIOF, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 \n                          |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_11|GPIO_PIN_12 \n                          |GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15);\n  HAL_GPIO_DeInit(GPIOC, GPIO_PIN_0);\n  HAL_GPIO_DeInit(GPIOG, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5 \n                          |GPIO_PIN_8|GPIO_PIN_15);\n  HAL_GPIO_DeInit(GPIOE, GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 \n                          |GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 \n                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1);\n  HAL_GPIO_DeInit(GPIOD, GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 \n                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1);\n  HAL_GPIO_DeInit(GPIOB, GPIO_PIN_5|GPIO_PIN_6);\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__readmap.0.c", "original_string": "int     check_char(char *mapline, char c)\n{\n    int i;\n    i = 0;\n    while (mapline[i])\n    {\n        if (mapline[i] != c)\n            return (0);\n        i++;\n    }\n    return (1);\n}"}
{"author": "theuwis", "file": "project-euler__main8.0.c", "original_string": "int main(void){\n    int i, j;\n    long answer = 0;\n    bool is_prime = true;\n    for(i = 2; i < 2000000; i++){\n        for(j = 2; j <= i/2; j++){\n            if(i % j == 0){\n                is_prime = false;\n                break;\n            }\n        }\n        if(is_prime){\n            answer += i;\n        }\n        is_prime = true;\n    }\n    printf(\"answer=%ld\\n\", answer);\n    return EXIT_SUCCESS;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__sftp_server_directory.5.c", "original_string": "SftpFileObject *sftpServerFindDir(SftpServerSession *session,\n   const SshBinaryString *handle)\n{\n   uint_t i;\n   SftpServerContext *context;\n   SftpFileObject *fileObject;\n   context = session->context;\n   if(handle->length == sizeof(uint32_t))\n   {\n      for(i = 0; i < context->numFileObjects; i++)\n      {\n         fileObject = &context->fileObjects[i];\n         if(fileObject->type == SSH_FILEXFER_TYPE_DIRECTORY &&\n            fileObject->session == session &&\n            fileObject->handle == LOAD32BE(handle->value))\n         {\n            return fileObject;\n         }\n      }\n   }\n   return NULL;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__tokenizer.5.c", "original_string": "TOKEN* appendtoken(TOKEN* curitem, STRING* token, char* file, int definedat) {\n    append(token, '\\0');\n    return appendtokenraw(curitem, token, definedat, gettokentype(token, file, definedat));\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q14.3.c", "original_string": "int main()\n{\n    int z=0,k,e;\n    queue q;\n    q.front=0;\n    q.rear=0;\n    printf(\"1. Enqueue \\t2. Dequeue \\t3. Display \\t4. Exit\\n\");\n    while (z==0)\n    {\n        printf(\"\\nCommand: \");\n        scanf(\"%d\",&k);\n        switch(k)\n        {\n            case 1:\n                    printf(\"Enter element : \");\n                    scanf(\"%d\",&e);\n                    enqueue(&q,e);\n                    break;\n            case 2:\n                    printf (\"%d dequed. \\n\", dequeue(&q));\n                    break;\n            case 3:\n                    display(&q);\n                    break;\n            case 4:\n                    z=1;\n        }\n    }\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__unique.0.c", "original_string": "int main(){\n  int t, x;\n  scanf(\"%d\", &t);\n  for(int i = 1; i <= t; i++){\n    int numbers[9] = {0};\n    scanf(\"%d\", &x);\n    if(x < 10)\n      printf(\"%d\\n\", x);\n    else{\n      if(x > 45)\n        printf(\"-%d\\n\", 1);\n      else{\n    get_numbers(x, 9, numbers, 0);\n    quicksort(numbers, 0, 9);\n    imprime(numbers);\n    }\n    }\n  }\n}"}
{"author": "augustogunsch", "file": "jackc__parser-structure.13.c", "original_string": "void parsevardeccommon(PARSER* p, VARDEC* v) {\n    v->typeclass = p->current->type;\n    v->primitive = isprimitive(p->current);\n    v->type = parsetype(p);\n    STRINGLIST* currstr = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n    v->names = currstr;\n    v->debug = getdebug(p);\n    v->names->content = parseidentifier(p);\n    while(!strcmp(p->current->token, \",\")) {\n        next(p);\n        STRINGLIST* nextstr = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n        nextstr->content = parseidentifier(p);\n        currstr->next = nextstr;\n        currstr = nextstr;\n    }\n    currstr->next = NULL;\n    checkcontent(p, \";\");\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__strcap.1.c", "original_string": "int main()\n{\n    char arr[30];\n    int iRet = 0;\n    printf(\"Please enter the string\\n\");\n    scanf(\"%[^'\\n']s\",arr);\n    iRet = StrlenCap(arr);\n    printf(\"Total number of capital characters are %d\\n\",iRet);\n    return 0;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Selection_Sort.2.c", "original_string": "void selection_sort(int array[MAX], int length)\n{\n    int i, j, temp, pointer = 0;\n    int size = length;\n    for(i=0; i<size-1; i++)\n    {\n        pointer = i;\n        for(j=i+1; j<size; j++)\n        {\n            if(array[pointer] > array[j])\n            {\n                pointer = j;\n            }\n            if(pointer != i)\n            {\n                temp = array[pointer];\n                array[pointer] = array[i];\n                array[i] = temp;\n            }\n        }\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_any_pos_DLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__4.0.c", "original_string": "void le_retangulo(rect_t *retangulo)\n{\n    printf(\"\\nDigite as coordenadas do ret\u00e2ngulo:\\n\");\n    printf(\"\\n\\tPonto superior esquerdo:\\n\");\n    printf(\"\\t-> Coordenada x: \");\n    scanf(\"%lf\", &retangulo->sup_esq.x);\n    getchar();\n    printf(\"\\t-> Coordenada y: \");\n    scanf(\"%lf\", &retangulo->sup_esq.y);\n    getchar();\n    printf(\"\\n\\tPonto inferior direito:\\n\");\n    printf(\"\\t-> Coordenada x: \");\n    scanf(\"%lf\", &retangulo->inf_dir.x);\n    getchar();\n    printf(\"\\t-> Coordenada y: \");\n    scanf(\"%lf\", &retangulo->inf_dir.y);\n    getchar();\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__check_mate.4.c", "original_string": "int     check_rook(char **tab, int row, int col, int size)\n{\n    int     r;\n    int     c;\n    r = row - 1;\n    c = col;\n    while (r >= 0 && !is_piece(tab[r][c]))\n        if (tab[r--][c] == 'K')\n            return (1);\n    r = row;\n    c = col + 1;\n    while (c < size && !is_piece(tab[r][c]))\n        if (tab[r][c++] == 'K')\n            return (1);\n    r = row + 1;\n    c = col;\n    while (r < size && !is_piece(tab[r][c]))\n        if (tab[r++][c] == 'K')\n            return (1);\n    r = row;\n    c = col - 1;\n    while (c >= 0 && !is_piece(tab[r][c]))\n        if (tab[r][c--] == 'K')\n            return (1);\n    return (0);\n}"}
{"author": "augustogunsch", "file": "jack-compiler__os.9.c", "original_string": "CLASS* mksys(CLASS* os) {\n    CLASS* sysclass = mkosclass(os, \"Sys\");\n    adddec(sysclass, function, \"void\", \"halt\");\n    adddec(sysclass, function, \"void\", \"error\");\n    adddec(sysclass, function, \"void\", \"wait\");\n    return sysclass;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__search_node.3.c", "original_string": "int main()\n{\n    int n, key;\n    printf(\"Enter the total number of nodes: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    printf(\"display:\\n\");\n    print();\n    printf(\"srch:\");\n    scanf(\"%d\", &key);\n    search(key);\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_DLL.10.c", "original_string": "void reverse()\n{\n    struct node *currentnode,*nextnode,*prenode;\n    prenode=0;\n    currentnode=nextnode=head;\n    while(nextnode!=0)\n    {\n        nextnode=nextnode->next;\n        currentnode->next=prenode;\n        currentnode->pre=nextnode;\n        prenode=currentnode;\n        currentnode=nextnode;\n    }\n    head=prenode;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__4,_5,_6.0.c", "original_string": "void le_numero(int *n)\n{\n    do\n    {\n        printf(\"\\nDigite um inteiro positivo: \");\n        scanf(\"%i\", n);\n        getchar();\n        system(\"clear\");\n    } while (n < 0);\n}"}
{"author": "Oryx-Embedded", "file": "Common__str.4.c", "original_string": "error_t strSafeCopy(char_t *dest, const char_t *src, size_t destSize)\n{\n   size_t n;\n   if(dest == NULL || src == NULL || destSize < 1)\n      return ERROR_INVALID_PARAMETER;\n   n = osStrlen(src);\n   n = MIN(n, destSize - 1);\n   osStrncpy(dest, src, n);\n   dest[n] = '\\0';\n   return NO_ERROR;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.9.c", "original_string": "void mergeNodes(struct btreeNode *myNode, int pos) {\n        int j = 1;\n        struct btreeNode *x1 = myNode->link[pos], *x2 = myNode->link[pos - 1];\n        x2->count++;\n        x2->val[x2->count] = myNode->val[pos];\n        x2->link[x2->count] = myNode->link[0];\n        while (j <= x1->count) {\n                x2->count++;\n                x2->val[x2->count] = x1->val[j];\n                x2->link[x2->count] = x1->link[j];\n                j++;\n        }\n        j = pos;\n        while (j < myNode->count) {\n                myNode->val[j] = myNode->val[j + 1];\n                myNode->link[j] = myNode->link[j + 1];\n                j++;\n        }\n        myNode->count--;\n        free(x1);\n  }"}
{"author": "sdukesameer", "file": "dsa__post-eva.4.c", "original_string": "int isOperator(char ch)\n{\n    if (ch=='+' || ch=='-' || ch=='*' || ch=='/')\n        return 1;\n    else\n        return 0;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__catavento.6.c", "original_string": "void mouse(int botao, int estado, int x, int y)\n{\n    glutIdleFunc(anima);\n    switch (botao)\n    {\n    case GLUT_LEFT_BUTTON:\n        if (estado == GLUT_DOWN){\n            opcao = 1;\n        }\n        break;\n    case GLUT_RIGHT_BUTTON:\n        if (estado == GLUT_DOWN){\n            opcao = 2;\n        }\n        break;\n    default:\n        break;\n    }\n    glutPostRedisplay();\n}"}
{"author": "earth429", "file": "mulpre__divide.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a, b, c, d;\n    int return_val;\n    int x, y;\n    x = 5;\n    y = 3;\n    setInt(&a, x);\n    setInt(&b, y);\n    printf(\"x = %d\\ny = %d\\nx / y = %d\\nx %% y = %d\", x, y, x / y, x % y);\n    return_val = divide(&a, &b, &c, &d);\n    dispNumberZeroSuppress(&c);\n    dispNumberZeroSuppress(&d);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n    return 0;\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__BinarySearch.3.c", "original_string": "int binary_search(int x[50],int n,int item)\n       {\n        int i,lb=0,ub=n-1,mid;\n        count++;\n        while(lb<=ub)\n        {\n         count++;\n         mid=(lb+ub)/2;\n         count++;\n         if(x[mid]==item)\n            {\n            count++;\n            return mid;\n            count++;\n            }\n         else if(item>x[mid])\n            {\n            count++;\n            lb=mid+1;\n            count++;\n            }\n         else\n            {\n            count++;\n            ub=mid-1;\n            count++;\n            }\n        }\n        count++;\n        return -1;\n        count++;\n       }"}
{"author": "ankitraj311", "file": "Socket-thread__test_thread.1.c", "original_string": "int main()\n{\n  pthread_t id;\n  for(int i = 0; i<3; i++)\n  {\n    pthread_create(&id, NULL, thread_fun, (void *)&id);\n  }\n  pthread_join(id,NULL);\n  pthread_exit(NULL);\n}"}
{"author": "augustogunsch", "file": "jack-compiler__util.6.c", "original_string": "STRINGLIST* onestr(const char* str) {\n    STRINGLIST* strlist = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n    strlist->content = ezheapstr(str);\n    strlist->next = NULL;\n    return strlist;\n}"}
{"author": "flora0110", "file": "hw01git__check_ans_2-10.1.c", "original_string": "char*** make3darr(int rows, int cols,int hei){\n    char ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}"}
{"author": "Theemiss", "file": "simple_shell__history.0.c", "original_string": "int history(char *input)\n{\n    char *filename = \".simple_shell_history\";\n    ssize_t fd, w;\n    int len = 0;\n    if (!filename)\n        return (-1);\n    fd = open(filename, O_CREAT | O_RDWR | O_APPEND, 00600);\n    if (fd < 0)\n        return (-1);\n    if (input)\n    {\n        while (input[len])\n            len++;\n        w = write(fd, input, len);\n        if (w < 0)\n            return (-1);\n    }\n    return (1);\n}"}
{"author": "MartinMarinovich", "file": "MarinovichMartinLABIPP1G-__menu0.0.c", "original_string": "int menu (int *opcionMenu)\n{\n    int error = -1;\n    int opcion;\n    if(opcionMenu != NULL)\n    {\n        printf(\"*** ABM Service de Notebooks ***\\n\\n\");\n        printf(\"1  Alta Notebook\\n\");\n        printf(\"2  Modificar Notebook\\n\");\n        printf(\"3  Baja Notebook\\n\");\n        printf(\"4  Listar Notebook\\n\");\n        printf(\"5  Listar Marcas\\n\");\n        printf(\"6  Listar Tipos\\n\");\n        printf(\"7  Listar Servicios\\n\");\n        printf(\"8  Alta Trabajo\\n\");\n        printf(\"9  Listar Trabajos\\n\");\n        printf(\"10 Listar x Tipo\\n\");\n        printf(\"11 Listar x Marca\\n\");\n        printf(\"12 Contar x Marca y Tipo\\n\");\n        printf(\"13 Listar Notebooks separadas x cada Marca\\n\");\n        printf(\"14 Mostrar Marcas mas elegidas \\n\");\n        printf(\"15 Mostrar Notebooks mas baratas \\n\");\n        printf(\"16 Listar trabajos por ID notebook\\n\");\n        printf(\"17 Listar total a pagar por ID notebook\\n\");\n        printf(\"18 Mostrar Notebooks por Servicio\\n\");\n        printf(\"19 Mostrar servicio por fecha\\n\");\n        printf(\"20 Salir\\n\");\n        if(!utn_getNumeroInt(&opcion,\"\\nIngrese la opcion deseada\\n\",\"Error, opcion invalida\\n\",1,20, 4))\n        {\n            *opcionMenu = opcion;\n        }\n        error = 0;\n    }\n    return error;\n}"}
{"author": "ankitraj311", "file": "450_babbar__1_reverse_using_1array.0.c", "original_string": "int main()\n{\n  int arr[100],no,j=0,temp=0,mid=0;\n  printf(\"Enter length of array\");\n  scanf(\"%d\",&no);\n  for(int i = 0; i<no; i++)\n  {\n    scanf(\"%d\",&arr[i]);\n  }\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n  if(no%2 == 0)\n  {\n   mid = no/2;\n  }\n  else\n  {\n    mid = (no-1)/2;\n  }\n  for(int i = no-1; i>=mid; i--)\n  {\n    temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    j++;\n  }\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n}"}
{"author": "sdukesameer", "file": "dsa__list-ins-seq-sor.3.c", "original_string": "void print(node** head)\n{\n    if(*head==NULL)\n        printf(\"STACK EMPTY\\n\");\n    else\n    {\n        node* h=*head;\n        printf(\"      STACK      \\n\");\n        while(h!=NULL)\n        {\n            printf(\"\\t%d\\n\",h->data);\n            h=h->next;\n        }\n    }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ili9341_ext.11.c", "original_string": "static void ili9341_buffer_draw(uint16_t x, uint16_t y, uint16_t width, uint16_t height, void * p_data, uint32_t length)\n{\n    uint32_t spi_max_length, spi_length;\n    set_addr_window(x, y, x + width - 1, y + height - 1);\n    nrf_gpio_pin_set(ILI9341_DC_PIN);\n    spi_max_length = 250; \n    do\n    {\n        spi_length = (length > spi_max_length) ? spi_max_length : length;\n        spi_write(p_data, spi_length);\n        length -= spi_length;\n        p_data += spi_length;        \n    }while(length > 0);\n    nrf_gpio_pin_clear(ILI9341_DC_PIN);    \n}"}
{"author": "theuwis", "file": "AdventOfCode2016__main4.0.c", "original_string": "int main(){\n   char * msg = \"abbhdwsy\", * dummy = NULL;\n   char code[9]; int code_counter = 0;\n   long index = 0;\n   size_t len = 0;\n   uint8_t * md5_result;\n   clock_t start = clock(), diff;\n   while(1){\n      asprintf(&dummy,\"%s%ld\" , msg, index);\n      len = strlen(dummy);\n      md5(dummy, len);\n      md5_result = (uint8_t *) &h0;\n      char str[10];\n      sprintf(str, \"%2.2X%2.2X%2.2X%2.2X\", md5_result[0], md5_result[1], md5_result[2], md5_result[3]);\n      if(strncmp(str, \"00000\", 5) == 0){\n         printf(\"hash found - input=%s - MD5=%s - index=%ld\\n\", dummy, str, index);\n         code[code_counter] = str[5];\n         code_counter++;\n         code[code_counter] = '\\0';\n         if(code_counter >= 8){\n            printf(\"done! code=%s\\n\", code);\n            diff = clock() - start;\n            int msec = diff * 1000 / CLOCKS_PER_SEC;\n            printf(\"time: %ds %dms\", msec/1000, msec%1000);\n            break;\n         }\n         else{\n            printf(\"current code = %s\\n\\n\", code);\n         }\n      }\n      index++;\n   }\n   return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__sftp_server_directory.2.c", "original_string": "error_t sftpServerOpenDir(SftpServerSession *session,\n   const SshString *path, uint32_t *handle)\n{\n   error_t error;\n   uint_t i;\n   uint_t perm;\n   SftpServerContext *context;\n   SftpFileObject *fileObject;\n   context = session->context;\n   error = sftpServerGetPath(session, path, context->path,\n      SFTP_SERVER_MAX_PATH_LEN);\n   if(error)\n      return error;\n   perm = sftpServerGetFilePermissions(session, context->path);\n   if((perm & SFTP_FILE_PERM_READ) == 0)\n      return ERROR_ACCESS_DENIED;\n   for(i = 0; i < context->numFileObjects; i++)\n   {\n      fileObject = &context->fileObjects[i];\n      if(fileObject->type == SSH_FILEXFER_TYPE_INVALID)\n      {\n         break;\n      }\n   }\n   if(i < context->numFileObjects)\n   {\n      fileObject->dir = fsOpenDir(context->path);\n      if(fileObject->dir != NULL)\n      {\n         fileObject->type = SSH_FILEXFER_TYPE_DIRECTORY;\n         fileObject->session = session;\n         fileObject->size = 0;\n         fileObject->offset = 0;\n         fileObject->file = NULL;\n         osStrcpy(fileObject->path, context->path);\n         fileObject->handle = sftpServerGenerateHandle(session);\n         *handle = fileObject->handle;\n         error = NO_ERROR;\n      }\n      else\n      {\n         error = ERROR_OPEN_FAILED;\n      }\n   }\n   else\n   {\n      error = ERROR_OUT_OF_RESOURCES;\n   }\n   return error;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__reverse_single_linked_list.0.c", "original_string": "void createList(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int data, i;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter node data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n; i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter node data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=temp->next;\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__90.3.c", "original_string": "void exibe_reprovados(FILE *arq)\n{\n    aluno_t aluno;\n    int media;\n    while (fread(&aluno, sizeof(aluno_t), 1, arq) != 0)\n    {\n        media = ((aluno.prova[0] * 2) + (aluno.prova[1] * 3) + (aluno.prova[2] * 3) + (aluno.trab[0] + aluno.trab[1])) / 10;\n        if (media < 6.0)\n        {\n            printf(\"\\nNome: %s\\n\", aluno.nome);\n            printf(\"\\t-> Prova 1: %i\\n\", aluno.prova[0]);\n            printf(\"\\t-> Prova 2: %i\\n\", aluno.prova[1]);\n            printf(\"\\t-> Prova 3: %i\\n\", aluno.prova[3]);\n            printf(\"\\t-> Trabalho 1: %i\\n\", aluno.trab[0]);\n            printf(\"\\t-> Trabalho 2: %i\\n\", aluno.trab[1]);\n        }\n    }\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__39_Add_n_Matrix.0.c", "original_string": "int main()\n{\n  int i,j,k,r1,c1,r2,c2,flag = 0;\n  printf(\"Enter Value of r1, c1, r2, c2\\n\");\n  scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n  int m1[r1][c1], m2[r2][c2], add_array[r1][c1], mul[r1][c2];\n  printf(\"Enter value of Matrix1\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      scanf(\"%d\",&m1[i][j]);\n    }\n  }\n  do\n  {\n    printf(\"Enter value of Matrix2\\n\");\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        scanf(\"%d\",&m2[i][j]);\n      }\n    }\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        add_array[i][j] = m1[i][j] + m2[i][j];\n      }\n    }\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        printf(\"%.2d \",add_array[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        m1[i][j] = add_array[i][j];\n    add_array[i][j] = 0;\n      }\n    }\n    printf(\"Enter 1 To Add more Matrix\\n\");\n    scanf(\"%d\",&flag);\n  }while(flag);\n}"}
{"author": "fikepaci", "file": "sorting_algorithms__100-shell_sort.2.c", "original_string": "void shell_sort(int *array, size_t size)\n{\n    unsigned int gap = 1, i, j;\n    if (array == NULL)\n        return;\n    if (size < 2)\n        return;\n    while (gap < size / 3)\n        gap = gap * 3 + 1;\n    while (gap > 0)\n    {\n        for (i = 0, j = gap; j < size; i++, j++)\n        {\n            if (array[i] > array[j])\n            {\n                _swap(&array[i], &array[j]);\n                backward_insertion(array, gap, i);\n            }\n        }\n        print_array(array, size);\n        gap /= 3;\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__loop_create_pthread.1.c", "original_string": "void* thread_fun(void *arg)\n{\n    int i = (int)arg;\n    sleep(i);\n    printf(\"I'm %dth thread:pid = %d, tid = %lu\\n\", i+1, getpid(), pthread_self());\n    return NULL;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__buzzer.1.c", "original_string": "void delay(int ct)\n{\n    for(int i=0;i<ct;++i)\n    {\n        for(int j=0;j<6000;j++)\n        {}\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__multiple_isr.0.c", "original_string": "int main()\n{\n        IODIR1 = IODIR1| LED_ALL;\n        PINSEL0 = PINSEL0 | (1<<29); \n        PINSEL0 = PINSEL0 & ~(1<<28);\n        timer_config();\n        intr_config();\n        while(1)\n        {\n            blink_led(17);\n        }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BST.5.c", "original_string": "void preorder(struct tree* root)\n{\n    if(root!=NULL)\n    {\n        printf(\"\\t%d\",root->val);\n        preorder(root->left);\n        preorder(root->right);\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__pthread_join.1.c", "original_string": "void* thread_fun(void *arg)\n{\n    struct thrd *tval;\n    tval = malloc(sizeof(struct thrd));\n    tval->var = 100;\n    strcpy(tval->str, \"hello thread\");\n    return (void *)tval;\n}"}
{"author": "revathy16296", "file": "rtos_lab_asssignment_1__5_tele_dir.0.c", "original_string": "int main()\n{\n    FILE *fp;\n    struct tele cust[50];\n    struct tele temp;\n    int choice,limit,beg=0,i,j,c,count=0;\n    while(1)\n    {\n        printf(\"\\ntelephone directory\\n\");\n        printf(\"1.add\\n\");\n        printf(\"2.display\\n\");\n        printf(\"3.exit\\n\");\n        printf(\"enter your choice\\n\");\n        scanf(\"%d\",&choice);\n        switch(choice)\n        {\n            case 1:\n            fp=fopen(\"details.txt\",\"w+\");\n                printf(\"enter the number of customers\\n\");\n                scanf(\"%d\",&limit);\n                for(i=beg;i<limit+beg;i++)\n                {\n                    printf(\"enter the name of customer no %d:\\t\",i+1);\n                    scanf(\"%s\",cust[i].name);\n                    printf(\"enter the sir name:\\t\");\n                    scanf(\"%s\",cust[i].sir_name);\n                    printf(\"enter the phone number\\t\");\n                    scanf(\"%s\",cust[i].number);\n                }\n                beg=limit+beg;\n                for(i=0;i<beg;i++)\n                {\n                    for(j=0;j<beg-1;j++)\n                    {\n                        c=strcmp(cust[j].name,cust[j+1].name);\n                        if(c>0)\n                        {\n                            temp=cust[j];\n                            cust[j]=cust[j+1];\n                            cust[j+1]=temp;\n                    }}\n                }\n                fclose(fp);\n                break;\n            case 2:\n                printf(\"\\ncustomer details\\n\");\n                fp=fopen(\"details.txt\",\"r\");\n                if(fp==NULL)\n                {\n                    printf(\"error!\");\n                    exit(1);\n                }\n                for (i=0;i<beg;i++)\n                {\n                    fread(&cust,sizeof(struct tele),1,fp);\n                    printf(\"(%d) %s %s\\t :%s\\n\",i+1,cust[i].name,cust[i].sir_name,cust[i].number);\n                }\n                fclose(fp);\n                break;\n            case 3:\n                exit(0);\n        }\n    }\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-structure.8.c", "original_string": "LINEBLOCK* compilesubroutdec(SCOPE* s, CLASS* cl, SUBROUTDEC* sd) {\n    SCOPE* myscope = mkscope(s);\n    LINEBLOCK* blk;\n    if(sd->parameters != NULL)\n        addparameters(myscope, sd->subroutclass == method, sd->parameters);\n    if(sd->subroutclass == function)\n        blk = compilefundec(myscope, cl, sd);\n    else if(sd->subroutclass == constructor)\n        blk = compileconstructor(myscope, cl, sd);\n    else\n        blk = compilemethod(myscope, cl, sd);\n    freescope(myscope);\n    return blk;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__brainfuck.2.c", "original_string": "int     main(int argc, char **av)\n{\n    if (argc > 1)\n        brainfuck(av[1]);\n    else\n        write(1, \"\\n\", 1);\n    return (0);\n}"}
{"author": "earth429", "file": "mulpre__factorial.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a, b;\n    int return_val;\n    int x;\n    x = 5;\n    setInt(&a, x);\n    return_val = factorial(&a, &b);\n    dispNumberZeroSuppress(&b);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__LRU.3.c", "original_string": "void main()\n{\n    int i,j,PFR=0;\n    for(i=0;i<3;i++)\n        Queue[i]=-1;\n    printf(\"\\nEnter the number of pages : \");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter the page : \");\n        scanf(\"%d\",&page[i]);\n    }\n    for(i=0;i<n;i++)\n    {\n        if(isthere(page[i])==-1)\n        {\n            enqueue(page[i],i);\n            PFR=PFR+1;\n        }\n        printf(\"\\nStatus : \");\n        for(j=0;j<3;j++)\n            printf(\"%d\\t\",Queue[j]);\n    }\n    printf(\"\\nPage Fault Rate is : %d\",PFR);\n}"}
{"author": "mandarvu", "file": "msc__problem10.0.c", "original_string": "int main()\n{\n    int A[3][3],B[3][3],AB[3][3]={{0,0,0},{0,0,0},{0,0,0}};\n    int ii,row,col;\n    printf(\"Enter a 3*3 matrix A row wise.\");\n    for (ii = 0; ii < 3; ii++)\n    {\n        printf(\"\\nRow %d >>> \",ii + 1);\n        scanf(\"%d %d %d\",(*(A + ii)+0),(*(A + ii)+1),(*(A +ii)+2));\n    }\n    printf(\"The matrix is A =\\n\\n\");\n    for (ii = 0;ii < 3; ii++)\n        printf(\"\\t%d\\t%d\\t%d\\n\",*(*(A + ii)+0),*(*(A + ii)+1),*(*(A +ii)+2));\n    printf(\"Enter a 3*3 matrix B row wise.\");\n    for (ii = 0; ii < 3; ii++)\n    {\n        printf(\"\\nRow %d >>> \",ii + 1);\n        scanf(\"%d %d %d\",(*(B + ii)+0),(*(B + ii)+1),(*(B +ii)+2));\n    }\n    printf(\"The matrix is B =\\n\\n\");\n    for (ii = 0;ii < 3; ii++)\n        printf(\"\\t%d\\t%d\\t%d\\n\",*(*(B + ii)+0),*(*(B + ii)+1),*(*(B +ii)+2));\n    for (row=0;row<3;row++)\n    {\n        for (col=0;col<3;col++)\n        {\n            for (ii=0;ii<3;ii++)\n            {\n                *(*(AB+row)+col) += *(*(A+row)+ii) * *(*(B+ii)+col);\n            }\n        }\n    }\n    printf(\"The matrix is AB =\\n\\n\");\n    for (ii = 0;ii < 3; ii++)\n        printf(\"\\t%d\\t%d\\t%d\\n\",*(*(AB + ii)+0),*(*(AB + ii)+1),*(*(AB +ii)+2));\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__DemoFOTAUpdateWorkflowNVSFlashPersistence.1.c", "original_string": "int16_t loadState(void)\n{\n  int16_t state = 0;\n  nvs_handle *nvsHandle = ((nvs_handle *)(malloc(sizeof(nvs_handle))));\n  if (nvsHandle == NULL) \n  {\n    return 0;\n  }\n  if (nvs_open(DEMO_PRODUCT_STORAGE_NAMESPACE, NVS_READONLY, nvsHandle) == ESP_OK) \n  {\n    nvs_get_u8(*nvsHandle, DEMO_PRODUCT_FLASH_STORE_KEY, ((uint8_t *)(&state)));\n  }\n  nvs_close(*nvsHandle);\n  free(nvsHandle);\n  if (state == -1) \n  {\n    return 0;\n  }\n  return state;\n}"}
{"author": "SugumaranEvil", "file": "Linux_programming__flock1.0.c", "original_string": "int main()\n{\n    int file_des;\n    ssize_t wt;\n    char arr[]=\"mara_mani\";  \n    file_des = open(\"./text\",O_RDWR);\n    perror(\"open\");             \n    wt = write(file_des,arr,9); \n    perror(\"write\");  \n    flock(file_des,LOCK_UN);    \n    perror(\"flock\");\n    close(file_des);            \n}"}
{"author": "2security", "file": "Array__ReverseArray.0.c", "original_string": "int main()\n    {\n    int *arr,temp,n,i,j;\n    printf(\"Enter how many numbers you want to store into array\");\n    scanf(\"%d\",&n);\n    arr=(int *)malloc(n*sizeof(int *)); \n    printf(\"Enter %d elements\",n);\n    for(i=0;i<n;i++)\n    scanf(\"%d\",&arr[i]);        \n    printf(\"Original array: \");\n    displaymatrix(arr,n);\n    for(i=n-1,j=0;i>j;i--,j++)      \n        {\n        temp=arr[i];\n        arr[i]=arr[j];\n        arr[j]=temp;\n        }\n    printf(\"\\nReversed array: \");\n    displaymatrix(arr,n);           \n    return 0;\n    }"}
{"author": "augustogunsch", "file": "jackc__tokenizer.11.c", "original_string": "bool isidentifier(STRING* tk) {\n    if(isdigit(tk->str[0]))\n        return false;\n    int count = tk->count - 1;\n    for(int i = 0; i < count; i++)\n        if(!isalnum(tk->str[i]) && tk->str[i] != '_')\n            return false;\n    return true;\n}"}
{"author": "jdes01", "file": "practicassoo__practica2ej3.2.c", "original_string": "void rellenaVector(int *vector, int numeroElementos){\n    srand( time(NULL) );\n    for (int i = 0; i < numeroElementos; ++i){ vector[i] = (rand() % 9) + 1; }\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__23_first_two_max.0.c", "original_string": "int main()\n{\n  int i,j,k,no,array1[100],array2[100],max1=0,max2=0,count=0;\n  printf(\"Enter Length of Array\\n\");\n  scanf(\"%d\",&no);\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  max1 = array1[0];\n  for(i=1; i<no; i++)\n  {\n    if(max1 < array1[i])\n    {\n      max1 = array1[i];\n      count = i;\n    }\n  }\n  for(j=0, i=0; i<no-1; i++,j++)\n  {\n    if(i < count)\n    {       \n      array2[i] = array1[j];\n    }\n    if(i >= count)\n    {\n    array2[i] = array1[j+1];\n    }\n  }\n  for(i=0; i<no-1; i++)\n  {\n    printf(\"%d \",array2[i]);\n  }\n}"}
{"author": "sdukesameer", "file": "c__sum-of-digits-all-even-odd.2.c", "original_string": "int oddsum(int n)\n{\n    int ans=0,f;\n    if(n<0)\n        n=-n;\n    if (n>0)\n    {\n        while(n>0)\n        {\n            f=n%10;\n            if(f%2!=0)\n                ans+=f;\n            n=n/10;\n        }\n    }\n    return ans;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post-a.6.c", "original_string": "int main() \n{ \n    int ch;\n    list* root=NULL;\n    while(1)\n    {\n        printf(\"\\n\");\n        printf(\"1. Insertion Using Recursive Function\\n\");\n        printf(\"2. Insertion Using Iterative Function\\n\");\n        printf(\"3. In-order Traversal  using a Recursive Function\\n\");\n        printf(\"4. Pre-order Traversal  using a Recursive Function\\n\");\n        printf(\"5. Post-order Traversal  using a Recursive Function\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            root=rec_insert(root,n);\n            printf(\"%d inserted in Binary Tree\\n\",n);\n        }\n        else if(ch==2)\n        {\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            root=insert(root,n);\n            printf(\"%d inserted in Binary Tree\\n\",n);\n        }\n        else if(ch==3)\n        {\n            printf(\"IN-ORDER\\n\");\n            inorder(root);\n        }\n        else if(ch==4)\n        {\n            printf(\"PRE-ORDER\\n\");\n            preorder(root);\n        }\n        else if(ch==5)\n        {\n            printf(\"POST-ORDER\\n\");\n            postorder(root);\n        }\n        else if(ch==6)\n        {\n            printf(\"Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid Choice.\\n\");\n    }\n    return 0; \n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_print_combn.3.c", "original_string": "void comb2(int *numeros,int a,int b)\n{\n  while(a<=8)\n       {\n        while(b<=9)\n            {\n              printf(\"%i%i, \",numeros[a],numeros[b]);    \n              b=b+1;\n            }\n        a=a+1;\n        b=a+1;\n       }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_nus_c.5.c", "original_string": "void ble_nus_c_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context)\n{\n        ble_nus_c_t * p_ble_nus_c = (ble_nus_c_t *)p_context;\n        if ((p_ble_nus_c == NULL) || (p_ble_evt == NULL))\n        {\n                return;\n        }\n        if ( (p_ble_nus_c->conn_handle != BLE_CONN_HANDLE_INVALID)\n             &&(p_ble_nus_c->conn_handle != p_ble_evt->evt.gap_evt.conn_handle)\n             )\n        {\n                return;\n        }\n        switch (p_ble_evt->header.evt_id)\n        {\n        case BLE_GATTC_EVT_HVX:\n                on_hvx(p_ble_nus_c, p_ble_evt);\n                break;\n        case BLE_GATTC_EVT_WRITE_RSP:\n                on_write_rsp(p_ble_nus_c, p_ble_evt);\n                break;\n        case BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE:\n                break;\n        case BLE_GAP_EVT_DISCONNECTED:\n                if (p_ble_evt->evt.gap_evt.conn_handle == p_ble_nus_c->conn_handle\n                    && p_ble_nus_c->evt_handler != NULL)\n                {\n                        ble_nus_c_evt_t nus_c_evt;\n                        nus_c_evt.evt_type = BLE_NUS_C_EVT_DISCONNECTED;\n                        nus_c_evt.conn_handle = p_ble_evt->evt.gap_evt.conn_handle;\n                        p_ble_nus_c->conn_handle = BLE_CONN_HANDLE_INVALID;\n                        p_ble_nus_c->evt_handler(p_ble_nus_c, &nus_c_evt);\n                }\n                break;\n        default:\n                break;\n        }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__is.1.c", "original_string": "int is_king(t_m *m, int x, int y)\n{\n    char    c;\n    c = m->av[y][x];\n    if (c == 'K')\n        return (1);\n    else\n        return (0);\n}"}
{"author": "davibernardos", "file": "DB-PJ__e20.5.c", "original_string": "bool verificarCaptchaMatematico(char *conta, int resultado){\n    int resultadoReal, valorA, valorB, simbolo;\n    valorA=real(conta[0]);\n    valorB=real(conta[2]);\n    simbolo=conta[1];\n    if (conta[1]==42){\n        resultadoReal=valorA*valorB;\n    } else {\n        resultadoReal=valorA+valorB;\n    }\n    if (resultadoReal==resultado) {\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__delete_node_manually.0.c", "original_string": "void print(){\nstruct node*temp;\ntemp=head;\nwhile(temp!=NULL)\n{\n    printf(\"%d\\n\", temp->data);\n    temp=temp->next;\n}\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_7.1.c", "original_string": "void enqueue()\n{\n    struct node* temp;\n    temp = (struct node*)malloc(sizeof(struct node));\n    printf(\"Enter an element to insert : \");\n    scanf(\"%d\", &temp->data);\n    temp->link = NULL;\n    if(top == NULL)\n    {\n        top = temp;\n    }\n    else\n    {\n        struct node* p;\n        p = top;\n        while(p->link != NULL)\n        {\n            p = p->link;\n        }\n        p->link = temp;\n    }\n}"}
{"author": "Theemiss", "file": "simple_shell___strtok.0.c", "original_string": "unsigned int check_delim(char c, const char *str)\n{\n    unsigned int i;\n    for (i = 0; str[i] != '\\0'; i++)\n    {\n        if (c == str[i])\n            return (1);\n    }\n    return (0);\n}"}
{"author": "theuwis", "file": "project-euler__main3.0.c", "original_string": "int main(void){\n    long answer = 1;\n    int div_nr;\n    bool div_by_nr = true;\n    while(1){\n        for(div_nr = 1; div_nr <= 20; div_nr++){\n            if(answer % div_nr != 0){\n                div_by_nr = false;\n                break;\n            }\n        }\n        if(div_by_nr){\n            break;\n        }\n        div_by_nr = true;\n        answer++;\n    }\n    printf(\"answer=%ld\\n\", answer);\n    return EXIT_SUCCESS;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__fibonacci.0.c", "original_string": "void fibonacci(int posicion){\n    long int i;\n    unsigned long int actual = 0, siguiente = 1, temporal;\n    for(i =0; i < posicion; i++){\n        printf(\"%ld, \", actual);\n        temporal = siguiente;\n        siguiente = siguiente + actual;\n        actual = temporal;\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__DemoFOTAUpdateSelfTest.2.c", "original_string": "void validateFirmwareUpdateActivation(void)\n{\n  printf(\"Validating firmware update\\n\");\n  if (runRandomSelfTest(SIMULATED_ACTIVATION_SUCCESS_RATE)) \n  {\n    printf(\"Firmware update successfully activated\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED);\n  }\n  else\n  {\n    printf(\"Firmware update activation failed\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_ACTIVATION_FAILED);\n  }\n}"}
{"author": "sdukesameer", "file": "c__mult_mat.0.c", "original_string": "int isValidRC(int r,int c)\n{\n    if(r>NROWS||r<=0)\n    {\n        printf(\"ERROR: Number of rows must be 1-10\");\n        return 0;\n    }\n    else if(c>NCOLS||c<=0)\n    {\n        printf(\"ERROR: Number of columns must be 1-10\");\n        return 0;\n    }\n    else\n    return 1;\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.27.c", "original_string": "ASMBLK* translatepoptemp(VMTRANSLATOR* t) {\n    tpoptemp.items[tpoptemp.count-2] = mktempind(t);\n    tpoptemp.items[tpoptemp.count-1] = mkstr(t, \"M=D\");\n    return copytemplate(&tpoptemp);\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Triangular_Matrix.1.c", "original_string": "void display_upper_triangular(int matrix[R][C])\n{\n    int i, j = 0;\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            if(i < j)\n            {\n                printf(\"%d\\t\", matrix[i][j]);\n            }\n            else\n                continue;\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e91.0.c", "original_string": "void main(){\n    char nome [60];\n    int capacidadeMax, operacao, disponivelMeia, confirmacao, vendidoMeia, vendidoInteira;\n    float valorInteira, meiaEntrada, valorTotal, troco;\n    vendidoMeia = 0;\n    vendidoInteira = 0;\n    printf(\"Ingressos++_Meu sistema de gestao de vendas de ingressos. \\n\");\n    printf(\"\\n\\n Cadastre o seu evento. \\n\");\n    printf(\"Nome do evento: \\n\");\n    gets(nome);\n    printf(\"Valor da entrada: \\n\");\n    scanf(\"%f\", &valorInteira);\n    meiaEntrada = valorInteira/2;\n    printf(\"Capacidade maxima do local: \\n\");\n    scanf(\"%d\", &capacidadeMax);\n    disponivelMeia = capacidadeMax*0.4;\n    printf(\"\\n\\n Evento: %s \\n\", nome);\n    printf(\"Capacidade maxima de %d lugares \\n\", capacidadeMax);\n    printf(\"Valor da entrada Inteira: %g \\n\",valorInteira);\n    printf(\"Valor da Meia entrada: %g \\n\",meiaEntrada);\n    while(operacao != 3){\n    printf(\"\\n\\n Para comprar o seu ingresso escolha: \\n\");\n    printf(\"[1] - Valor inteiro \\n\");\n    printf(\"[2] - Meia entrada \\n\");\n    printf(\"[3] - Finalizar vendas \\n\");\n    scanf(\"%d\", &operacao);\n    switch(operacao){\n        case 1:\n            if(capacidadeMax > 0){\n                printf(\"Valor da compra: %g\", valorInteira);\n                printf(\"\\n\\n Concluir: \\n\");\n                printf(\"[1] - SIM \\n\");\n                printf(\"[2] - NAO \\n\");\n                scanf(\"%d\", &confirmacao);\n                if(confirmacao == 1)\n                    printf(\"\\n Valor do ingresso: %g\", valorInteira);\n                    printf(\"\\n Digite o valor pago: \\n\");\n                    scanf(\"%g\", &valorTotal);\n                    if(valorTotal >= valorInteira){\n                    troco = valorTotal - valorInteira;\n                    printf(\"\\n troco: %g \\n\", troco);\n                }else{\n                    printf(\"Valor insuficiente para concluir a compra.\");\n                    break;\n                }   \n                    printf(\"\\n Compra efeituada com exito.\");\n                    capacidadeMax = capacidadeMax - 1;\n                    vendidoInteira++;\n                    break;\n                }else{\n                    printf(\"Ingressos esgotados. \\n\");\n                    break;\n                }\n        case 2:\n            if(disponivelMeia > 0){\n                printf(\"\\n Valor do ingresso: %g\", meiaEntrada);\n                printf(\"\\n Confirmar: \\n\");\n                printf(\"[1] - SIM \\n\");\n                printf(\"[2] - NAO \\n\");\n                scanf(\"%d\", &confirmacao);\n                if(confirmacao == 1){\n                    printf(\"\\n Valor do ingresso: %g\",meiaEntrada);\n                    printf(\"\\n Digite o valor pago: \\n\");\n                    scanf(\"\\n %g\", &valorTotal);\n                    if(valorTotal >= meiaEntrada){\n                    troco = valorTotal - meiaEntrada;\n                    printf(\"\\n troco: %g \\n\\n\", troco);\n                    printf(\"Compra comcluida com exito. \\n\");\n                    disponivelMeia = disponivelMeia - 1;\n                    capacidadeMax = capacidadeMax - 1;\n                    vendidoMeia++;\n                    break;\n                    }else{\n                        printf(\"\\n quantia insuficiente\");\n                        break;\n                    }   \n                }else{\n                printf(\"Ingressos de meia entrada esgotados. \\n\");\n                break;\n                }\n            }\n        case 3: \n                printf(\"\\nTotal de ingressos tipo inteira vendido: %d \\n\", vendidoInteira);\n                printf(\"Total de ingressos tipo meia vendido: %d \\n\", vendidoMeia);\n                printf(\"Ingressos disponiveis: %d \\n\", capacidadeMax);\n                break;\n        default: \n                printf(\"Opcao invalida.\");  \n                break;\n    }\n}\n}"}
{"author": "earth429", "file": "mulpre__simpleDivide.0.c", "original_string": "int main(int argc, char **argv)\n{\n    int a = 7;\n    int b = -3;\n    int c, d, return_val;\n    return_val = simpleDivide(a, b, &c, &d);\n    printf(\"c = %d\\n\", c);\n    printf(\"d = %d\\n\", d);\n    printf(\"\u623b\u308a\u5024 = %d\", return_val);\n    return 0;\n}"}
{"author": "tadeograch", "file": "sorting_algorithms__2-selection_sort.0.c", "original_string": "void selection_sort(int *array, size_t size)\n{\n    size_t i, j;\n    int lower = 0, position = 0, first = 0;\n    if (size < 2)\n        return;\n    for (i = 0; i < size; i++)\n    {\n        first = array[i];\n        lower = first;\n        for (j = i; j < size; j++)\n        {\n            if (lower > array[j])\n            {\n                lower = array[j];\n                position = j;\n            }\n        }\n        if (lower < first)\n        {\n            array[i] = lower;\n            array[position] = first;\n            print_array(array, size);\n        }\n    }\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_7_c.0.c", "original_string": "int main()\n{\n    int one[8] = {5, 6, 8, 8, 10, -2, 0, 121};\n    int two[8] = {2, 1, 3, -4, 10, 21, 2, 233};\n    int three[8] = {9, 9, 9, -9, -9, 9, 99, 999};\n    unsigned int naturalNumber = 8;\n    printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n    printf(\"\\nElementy tablicy3: \");\n    for(int i = 0; i < (sizeof(three)/sizeof(three[0])); i++){\n        printf(\"%d \", three[i]);\n    }\n    printf(\"\\n\\nMieszanie tablic!!!\\n\\n\");\n    changeArrays(naturalNumber, one, two, three);\n    printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n    printf(\"\\nElementy tablicy3: \");\n    for(int i = 0; i < (sizeof(three)/sizeof(three[0])); i++){\n        printf(\"%d \", three[i]);\n    }\n    getchar();;\n    return 0;\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Deletion_At_Any_Position_In_a_Single_Linked_List.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"Enter 1 for Creation or Enter 0 for Termination:\");\n    scanf(\"%d\",&choice);\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the Data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->ptr = NULL;\n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->ptr = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want to more?(1/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_nodes(temp);\n    delete_at_N_position(head,temp);\n    getch();\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_DCLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes2.6.c", "original_string": "float promedio(float *c){\n    float prom;\n    float acumulador = 0.0;\n    for (int i = 0; i < MAX_CALIFICACIONES - 1; i++)\n    {\n        acumulador += c[i];\n    }\n    prom = acumulador / MAX_CALIFICACIONES - 1;\n    prom = (prom + c[MAX_CALIFICACIONES - 1]) / 2;\n    return prom;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Indexed.4.c", "original_string": "void main()\n{\n    int ch,id,size,i;\n    for(i=0;i<16;i++)\n    {\n        disk[i]=0;\n    }\n    while(1)\n    {\n        printf(\"\\nEnter choice : \");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1: \n            {\n                printf(\"\\nEnter file id : \");\n                scanf(\"%d\",&id);\n                printf(\"\\nEnter size : \");\n                scanf(\"%d\",&size);\n                add_file(id,size);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter file id : \");\n                scanf(\"%d\",&id);\n                rem_file(id);\n                break;\n            }\n            case 3:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_after_pos_DLL.4.c", "original_string": "void insert_at_after_pos()\n{\n    struct node *newnode,*temp;\n    int pos;\n    int i=1;\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    int leg=count();\n    if(pos>leg)\n    {\n        printf(\"Invalid position \\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=temp;\n        newnode->next=temp->next;\n        temp->next=newnode;\n        newnode->next->pre=newnode;\n    }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__testingbinary.4.c", "original_string": "struct node* delete(struct node *root, int x)\n{\n    if(root==NULL)\n        return NULL;\n    if (x>root->data)\n        root->right_child = delete(root->right_child, x);\n    else if(x<root->data)\n        root->left_child = delete(root->left_child, x);\n    else\n    {\n        if(root->left_child==NULL && root->right_child==NULL)\n        {\n            free(root);\n            return NULL;\n        }\n        else if(root->left_child==NULL || root->right_child==NULL)\n        {\n            struct node *temp;\n            if(root->left_child==NULL)\n                temp = root->right_child;\n            else\n                temp = root->left_child;\n            free(root);\n            return temp;\n        }\n        else\n        {\n            struct node *temp = find_minimum(root->right_child);\n            root->data = temp->data;\n            root->right_child = delete(root->right_child, temp->data);\n        }\n    }\n    return root;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__circularLinkedList.1.c", "original_string": "struct Node *insertAtEnd(struct Node *head, int data)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     ptr->data = data;\n     struct Node *p = head->next;\n     while (p->next != head)\n     {\n          p = p->next;\n     }\n     p->next = ptr;\n     ptr->next = head;\n     return head;\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-statements.7.c", "original_string": "LINEBLOCK* compilestatement(SCOPE* s, STATEMENT* st) {\n    if(st->type == dostatement) return compilesubroutcall(s, st->dostatement);\n    if(st->type == returnstatement) return compileret(s, st);\n    if(st->type == ifstatement) return compileif(s, st);\n    if(st->type == whilestatement) return compilewhile(s, st);\n    return compilelet(s, st);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q10.0.c", "original_string": "void reverse(int arr[], int size)\n{\n    int *start = arr , *end = arr + size - 1;\n    for(int i = 0 ; i < size/2 ; i++)\n    {\n        int temp = *(start + i);\n        *(start + i) = *(end - i);\n        *(end - i) = temp;\n    }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__circularLinkedList.7.c", "original_string": "int main()\n{\n     struct Node *head;\n     struct Node *second;\n     struct Node *third;\n     struct Node *fourth;\n     head = (struct Node *)malloc(sizeof(struct Node));\n     second = (struct Node *)malloc(sizeof(struct Node));\n     third = (struct Node *)malloc(sizeof(struct Node));\n     fourth = (struct Node *)malloc(sizeof(struct Node));\n     head->data = 7;\n     head->next = second;\n     second->data = 11;\n     second->next = third;\n     third->data = 70;\n     third->next = fourth;\n     fourth->data = 22;\n     fourth->next = head;\n     linkedListTraversal(head);\n     head = insertAtEnd(head, 54);\n     printf(\"---List After Insertion---\\n\");\n     linkedListTraversal(head);\n     return 0;\n}"}
{"author": "behergue", "file": "Operating_Systems__fuseLib.3.c", "original_string": "static int my_readdir(const char *path, void *buf, fuse_fill_dir_t filler,  off_t offset, struct fuse_file_info *fi)\n{\n    int i;\n    fprintf(stderr, \"--->>>my_readdir: path %s, offset %jd\\n\", path, (intmax_t)offset);\n    if(strcmp(path, \"/\") != 0)\n        return -ENOENT;\n    filler(buf, \".\", NULL, 0);\n    filler(buf, \"..\", NULL, 0);\n    for(i = 0; i < MAX_FILES_PER_DIRECTORY; i++) {\n        if(!(myFileSystem.directory.files[i].freeFile)) {\n            if(filler(buf, myFileSystem.directory.files[i].fileName, NULL, 0) == 1)\n                return -ENOMEM;\n        }\n    }\n    return 0;\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise2.1.c", "original_string": "int main(void){\n    int result;\n    char str[20];\n    gets(str);                       \n    result = CheckString(str);\n    if(result == TRUE){\n        printf(\"All Characters are distinct\");\n    }\n    else if(result == FALSE){\n        printf(\"Repeated characters exist\");\n    }\n    return 0;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__planetas.4.c", "original_string": "void init(void)\n{\n    glEnable ( GL_COLOR_MATERIAL );\n    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n    glEnable(GL_DEPTH_TEST);\n    glShadeModel(GL_SMOOTH);\n    glEnable(GL_NORMALIZE);\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n    gluLookAt(0.0, 2.0, 6.0,\n              0.0, 0.0, 0.0,\n              0.0, 1.0, 0.0);\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluPerspective(45.0, 1.0, 2.0, 8.0);\n    glViewport(0, 0, 700, 700);\n    lightning();\n}"}
{"author": "mehedi9021", "file": "Data_Structure__insert_a_node_in_circular_linked_list.4.c", "original_string": "void insertAtN(int data, int position)\n{\n    struct node *newNode, *current;\n    int i;\n    if(head == NULL)\n    {\n        printf(\"List is empty.\\n\");\n    }\n    else if(position == 1)\n    {\n    struct node *newNode, *current;\n        newNode = (struct node *)malloc(sizeof(struct node));\n        newNode->data = data;\n        newNode->next = head;\n        current = head;\n        while(current->next != head)\n        {\n            current = current->next;\n        }\n        current->next = newNode;\n        head = newNode;\n}\n    else\n    {\n        newNode = (struct node *)malloc(sizeof(struct node));\n        newNode->data = data;\n        current = head;\n        for(i=2; i<=position-1; i++)\n        {\n            current = current->next;\n        }\n        newNode->next = current->next;\n        current->next = newNode;\n    }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__ft_range.2.c", "original_string": "int main()\n{\n    int a = 0;\n    int b = -3;\n    int     i;\n    i = 0;\n    int *tab =ft_range(a,b);\n    while (tab[i])\n    {\n        printf(\"%d \",tab[i]);\n        i++;\n    }\n    printf(\"%d \",tab[i]);\n    i++;\n    while (tab[i])\n    {\n        printf(\"%d \",tab[i]);\n        i++;\n    }\n    return (0);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__sort_in_descending.1.c", "original_string": "int main(void) {\n    printf(\"printing the array in the descending odder \\n \"); \n    printf(\"elements in the array are \\n\");\n    int a[5]={15,24,36,14,22};\n    int n=5,temp;\n    printarray(a,n);\n    printf(\"\\n array in the descending odder is \\n \");\n    int i,j;\n    for(i=0;i<5;i++)\n    {\n        for(j=i+1;j<5;j++)\n        {\n            if(a[j]>a[i])\n            {\n                temp=a[i];\n                a[i]=a[j];\n                a[j]=temp;\n            }\n        }\n    }\n    printarray(a,n);\n    return EXIT_SUCCESS;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__DemoFOTAUpdateWorkflow.4.c", "original_string": "static void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution)\n{\n  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;\n  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;\n  instance->updateInfo.version = NULL;\n  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;\n  if (!postponeInitialExecution) \n  {\n    instance->__currentState = loadState();\n    switch (instance->__currentState)\n    {\n      case DemoFOTAUpdateWorkflowEngine_connected__state:\n      {\n        DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n        break;\n      }\n      case DemoFOTAUpdateWorkflowEngine_restarting__state:\n      {\n        DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n  }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_auth.1.c", "original_string": "error_t acmeFormatAuthorizationRequest(AcmeClientContext *context,\n   const AcmeAuthorization *authorization)\n{\n   error_t error;\n   size_t n;\n   char_t *protected;\n   const char_t *payload;\n   payload = \"\";\n   protected = context->buffer;\n   error = acmeClientFormatJwsProtectedHeader(&context->accountKey,\n      context->account.url, context->nonce, authorization->url, protected, &n);\n   if(!error)\n   {\n      error = jwsCreate(context->prngAlgo, context->prngContext, protected,\n         payload, context->accountKey.alg, context->accountKey.crv,\n         context->accountKey.privateKey, context->buffer, &context->bufferLen);\n   }\n   return error;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__arreglo_uni_dinamico_calloc.2.c", "original_string": "float promedio_calorias(int a[], int tam){\n    int suma = 0;\n    for (int i = 0; i < tam; i++){\n        suma += a[i];\n    }\n    return (suma/tam);\n}"}
{"author": "flora0110", "file": "hw01git__2-1tqueue.10.c", "original_string": "int main(){\n    move[0].vert=-1;\n    move[0].horiz=0;\n    move[0].hei=0;\n    move[1].vert=0;\n    move[1].horiz=1;\n    move[1].hei=0;\n    move[2].vert=1;\n    move[2].horiz=0;\n    move[2].hei=0;\n    move[3].vert=0;\n    move[3].horiz=-1;\n    move[3].hei=0;\n    move[4].vert=0;\n    move[4].horiz=0;\n    move[4].hei=1;\n    move[5].vert=0;\n    move[5].horiz=0;\n    move[5].hei=-1;\n    char y;\n    int i,j,k;\n    FILE *pfile;\n    char name[50];\n    int control;\n    for(control=2;control<=100;control++){\n        min=100000;\n        rear=-1;front=-1;\n        rear2=-1;front2=-1;\n        sprintf(name,\"test%d.txt\",control);\n        pfile = fopen(name,\"r\");\n        if(NULL==pfile){\n            printf(\"Open failure\");\n            return 1;\n        }\n        else{\n            printf(\"reading %s\\n\",name);\n            char* bottom = make1darr(MAXLEN);\n            n=0;\n            char y;\n            bottom[n]=fgetc(pfile);\n            while(bottom[n]!='\\n'){\n                fgetc(pfile);\n                bottom[++n]=fgetc(pfile);\n            }\n            char ***maze=make3darr(n/2+1,n+2,n+2);\n            char ***road=make3darr(n/2+1,n+2,n+2);\n            char ***mark=make3darr(n/2+1,n+2,n+2);\n            int ***d=make3darrint(n/2+1,n+2,n+2);\n            int len=0;\n            int sr,sc,sh,fr,fc,fh;\n            for(i=0;i<n/2+1;i++){\n                for(j=0;j<n+2;j++){\n                    for(k=0;k<n+2;k++){\n                        if(j==0 || k==0 || j==n+1 || k==n+1){\n                            maze[i][j][k]='X';\n                        }\n                        else if(i==0 && j==1){\n                            maze[i][j][k]=bottom[k-1];\n                        }\n                        else if(j > len && j <= n-len && k > len && k <= n-len){\n                            fscanf(pfile,\"%c \",&maze[i][j][k]);\n                        }\n                        else{\n                            maze[i][j][k]='X';\n                        }\n                        if(maze[i][j][k]=='S'){\n                            sh=i;\n                            sr=j;\n                            sc=k;\n                        }\n                        if(maze[i][j][k]=='F'){\n                            fh=i;\n                            fr=j;\n                            fc=k;\n                        }\n                        road[i][j][k]=maze[i][j][k];\n                        mark[i][j][k]=maze[i][j][k];\n                    }\n                }\n                len++;\n            }\n            FILE *wfile;\n            sprintf(name,\"test%d_ans.txt\",control);\n            wfile = fopen(name,\"w\");\n            if( NULL == wfile ){\n                printf( \"wfile open failure\" );\n                return 1;\n            }\n            else{\n                if(bfs(maze,d,sr,sc,sh)){\n                    path(d,maze,road,fr,fc,fh);\n                    fprintf(wfile,\"Path length: %d\\n\",min);\n                    fprintf(wfile,\"=====outMaze=====\\n\");\n                    for(i=0;i<n/2+1;i++){\n                        for(j=i+1;j<n+2-i-1;j++){\n                            for(k=i+1;k<n+2-i-1;k++){\n                                fprintf(wfile,\"%c \",road[i][j][k] );\n                            }\n                            fprintf(wfile,\"\\n\");\n                        }\n                        fprintf(wfile,\"\\n\");\n                    }\n                }\n                else fprintf(wfile,\"The maze does not have a path\\n\" );\n            }\n            free(bottom);\n            for(i = 0; i < n/2+1; i++) {\n                for(j=0;j<n+2;j++){\n                    free(maze[i][j]);\n                }\n            }\n            for(i=0;i < n/2+1; i++){\n                free(maze[i]);\n            }\n            free(maze);\n            for(i = 0; i < n/2+1; i++) {\n                for(j=0;j<n+2;j++){\n                    free(mark[i][j]);\n                }\n            }\n            for(i=0;i < n/2+1; i++){\n                free(mark[i]);\n            }\n            free(mark);\n            for(i = 0; i < n/2+1; i++) {\n                for(j=0;j<n+2;j++){\n                    free(road[i][j]);\n                }\n            }\n            for(i=0;i < n/2+1; i++){\n                free(road[i]);\n            }\n            free(road);\n            for(i = 0; i < n/2+1; i++) {\n                for(j=0;j<n+2;j++){\n                    free(d[i][j]);\n                }\n            }\n            for(i=0;i < n/2+1; i++){\n                free(d[i]);\n            }\n            free(d);\n        }\n        fclose(pfile);\n    }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_10.3.c", "original_string": "char pop(struct stack* stk){\n    if(StackEmpty(stk))\n    {\n        printf(\"%d\\n\", -1);\n        return('b');\n    }\n    stk->top--;\n    return(stk->A[stk->top+1]);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler2.5.c", "original_string": "void DeleteLast(PPNODE Head, PPNODE Tail)\n{\n    PNODE temp = *Head;\n    if((*Head == NULL) && (*Tail == NULL))\n    {\n        return;\n    }\n    if(*Head == *Tail)\n    {\n        free(*Head);\n        *Head = NULL;\n        *Tail = NULL;\n        return;\n    }\n    else\n    {\n        while(temp->next != *Tail)\n        {\n            temp = temp->next;\n        }\n        free(*Tail);\n        *Tail = temp;\n        (*Tail)->next = *Head;\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q3.5.c", "original_string": "void inorder(node* root)\n{\n    if (root == NULL)\n        return;\n    inorder(root->left);\n    printf(\"%c \", root->data);\n    inorder(root->right);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_CLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d\",temp->data);\n    printf(\"\\n\");\n}"}
{"author": "dle2005", "file": "Algorithm__Knapsack3.4.c", "original_string": "void knapsack3() {\n    node u, v;\n    v.level = 0; v.profit = 0; v.weight = 0; v.bound = bound(v);\n    maxprofit = 0;\n    insert(v);\n    while(!empty()) {\n        rmove(&v);\n        printf(\"%d profit: %3d weight: %3d bound: %3d maxprofit: %3d bound: %3d\\n\",\n                v.level, v.profit, v.weight, (int)bound(v), maxprofit, (int)v.bound);\n        if(v.bound > maxprofit) {\n            u.level = v.level + 1;\n            u.profit = v.profit + p[u.level];\n            u.weight = v.weight + w[u.level];\n            if((u.weight <= W) && (u.profit > maxprofit))\n                maxprofit = u.profit;\n            u.bound = bound(u);\n            if(bound(u) > (float)maxprofit) insert(u);\n            u.weight = v.weight;\n            u.profit = v.profit;\n            u.bound = bound(u);\n            if(u.bound > (float)maxprofit) insert(u);\n        }\n    }\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__NumberSeriesProgram.2.c", "original_string": "int primeSeries(int y)\n{\n    int i,j,flag,count = 0;\n    for(i=2;i<=MAX;i++)\n    {\n        flag = 0;\n        for(j=2;j<i;j++)\n        {\n            if(i%j == 0)\n            {\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 0)\n        {\n            if(++count == y)\n            {\n                printf(\"%d\",i);\n            }\n        }\n    }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__stackTopStackBottom.2.c", "original_string": "void push(struct stack*ptr, int val){\n    if(isFull(ptr)){\n        printf(\"Stack Overflow! Cannot push %d to the stack\\n\", val);\n    }\n    else{\n        ptr->top++;\n        ptr->arr[ptr->top]=val;\n    }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__dequeue1.2.c", "original_string": "void dequeueF()\n{\n    if((front==-1 && rear==-1) || front>rear)\n    printf(\"queue is empty\");\n    else\n    {\n        printf(\"The value popped is %d\",queue[front]);\n        front=front+1;\n    }\n}"}
{"author": "Oryx-Embedded", "file": "Common__resource_manager.0.c", "original_string": "error_t resGetData(const char_t *path, const uint8_t **data, size_t *length)\n{\n   bool_t found;\n   bool_t match;\n   uint_t n;\n   uint_t dirLength;\n   ResEntry *resEntry;\n   ResHeader *resHeader = (ResHeader *) res;\n   if(resHeader->totalSize < sizeof(ResHeader))\n      return ERROR_INVALID_RESOURCE;\n   dirLength = resHeader->rootEntry.dataLength;\n   resEntry = (ResEntry *) (res + resHeader->rootEntry.dataStart);\n   for(found = FALSE; !found && path[0] != '\\0'; path += n + 1)\n   {\n      for(n = 0; path[n] != '\\\\' && path[n] != '/' && path[n] != '\\0'; n++);\n      if(n == 0 && path[n] != '\\0')\n      {\n         path++;\n         for(n = 0; path[n] != '\\\\' && path[n] != '/' && path[n] != '\\0'; n++);\n      }\n      for(match = FALSE; !match && dirLength > 0; )\n      {\n         if(dirLength < sizeof(ResEntry))\n            return ERROR_INVALID_RESOURCE;\n         if(dirLength < (sizeof(ResEntry) + resEntry->nameLength))\n            return ERROR_INVALID_RESOURCE;\n         if(resEntry->nameLength == n && !strncasecmp(resEntry->name, path, n))\n         {\n            if(resEntry->type == RES_TYPE_DIR)\n            {\n               dirLength = resEntry->dataLength;\n               resEntry = (ResEntry *) (res + resEntry->dataStart);\n            }\n            else\n            {\n               if(path[n] != '\\0')\n                  return ERROR_NOT_FOUND;\n               found = TRUE;\n            }\n            match = TRUE;\n         }\n         else\n         {\n            dirLength -= sizeof(ResEntry) + resEntry->nameLength;\n            resEntry = (ResEntry *) ((uint8_t *) resEntry + sizeof(ResEntry) + resEntry->nameLength);\n         }\n      }\n      if(!match)\n         return ERROR_NOT_FOUND;\n   }\n   if(!found)\n      return ERROR_NOT_FOUND;\n   if(resEntry->type != RES_TYPE_FILE)\n      return ERROR_NOT_FOUND;\n   *data = res + resEntry->dataStart;\n   *length = resEntry->dataLength;\n   return NO_ERROR;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__keypad.2.c", "original_string": "void col_1(void)                    \n{\n    int val;\n    IODIR1 = IODIR1 & ~COLS;        \n    IODIR1 = IODIR1 | ROWS;         \n    val = IOPIN1 & COLS;        \n    val = val >> 17;\n    switch(val)\n    {\n        case 0x0E:  lcd_data('7');  delay(200); break;\n        case 0x0D:  lcd_data('8');  delay(200); break;\n        case 0x0B:  lcd_data('9');  delay(200); break;\n        case 0x07:  lcd_data('/');  delay(200); break;\n    }\n}"}
{"author": "fikepaci", "file": "monty__monty_funcs_1.2.c", "original_string": "void monty_pint(stack_t **stack, unsigned int line_number)\n{\n    if ((*stack)->next == NULL)\n    {\n        set_op_tok_error(pint_error(line_number));\n        return;\n    }\n    printf(\"%d\\n\", (*stack)->next->n);\n}"}
{"author": "SugumaranEvil", "file": "Linux_programming__prc7.0.c", "original_string": "int main()\n{\n    int shmid1;\n   int fd;\n   ssize_t ret_write;\n    char data[136];\n    char *data_ptr;\n    shmid1 = shmget(111, 8192, 0);\n    perror(\"shmget: \");\n    data_ptr = shmat(shmid1, NULL,0);\n    perror(\"shmat: \");\n    strcpy(data, data_ptr);\n    printf(\"%s\\n\",data);\n   fd = open(\"./file\", O_CREAT | O_WRONLY ,0644 );\n   ret_write = write(fd, data , 136);\n    shmdt(data_ptr);\n    perror(\"shmdt: \");\n    return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__13.0.c", "original_string": "int main()\n{\n    int matriz[4][4];\n    int soma = 0;\n    system(\"clear\");\n    printf(\"Informe os elementos(int) de uma matriz 4x4:\\n\");\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            scanf(\"%i\", &matriz[i][j]);\n            if (i == j)\n            {\n                soma += matriz[i][j];\n            }\n        }\n    }\n    system(\"clear\");\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            if (j == 0)\n            {\n                printf(\"|\");\n            }\n            printf(\"%3i\", matriz[i][j]);\n            if (j == 3)\n            {\n                printf(\" |\");\n            }\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\nA soma dos elementos da diagonal principal \u00e9: %d\\n\\n\", soma);\n    return 0;\n}"}
{"author": "jdes01", "file": "practicassoo__practica1ej4.0.c", "original_string": "int main(int argc, char * argv[]){\n    int status;\n    printf(\"Soy el proceso %d\\n\", getpid());\n    for (int i = 0; i < argc - 1; i++){\n        switch (fork()){\n            case -1:\n                    printf(\"ERROR\");\n                    exit(EXIT_FAILURE);\n                    break;\n            case 0: \n                    printf(\"soy el hijo numero %d; mi padre es el proceso: %d\\n\", getpid(), getppid); \n                        printf(\" %i \\n\", factorial( atoi(argv[i+1]) ) );\n                    exit(EXIT_SUCCESS);\n                    break;\n            default:\n                    wait(&status); \n        }\n    }\n    return 0;\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__sender0.4.c", "original_string": "int main(){\n    unsigned int length;\n    welcome();\n    length = frame_construction(sta_addr,des_addr,protocol,data,sizeof(data));\n    printf(\"Frame length: %d\\n\",length);\n    frame[length-10] = ~frame[length-10];\n    send_frame(frame,length);\n    return 0;\n}"}
{"author": "dishanp", "file": "DSA__q71.0.c", "original_string": "int main()\n{\n    int *arr;\n    int n, k, temp;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n    printf(\"Enter k : \");\n    scanf(\"%d\", &k);\n    for(int i = 0 ; i < n - 1 ; i++)\n    {\n        for(int j = 0; j < n - 1 - i; j ++)\n        {\n            if(arr[j] > arr[j+1])\n            {\n                temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n    printf(\"The kth smallest element : %d\\n\", arr[k-1]);\n    printf(\"The kth largest element : %d\\n\", arr[n-k]);\n}"}
{"author": "tadeograch", "file": "monty__aux_functions.0.c", "original_string": "unsigned int print_dlistint(const stack_t *h)\n{\n    unsigned int n = 0;\n    while (h)\n    {\n        printf(\"%i\\n\", h->n);\n        n++;\n        h = h->next;\n    }\n    return (n);\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Deletion_At_Any_Position_In_a_Single_Linked_List.2.c", "original_string": "void delete_at_N_position(struct node*head1, struct node*temp1)\n{\n    int pos;\n    printf(\"\\nAt what position you want to delete the data?\\n\");\n    scanf(\"%d\",&pos);\n    int i;\n    if(pos<=0)\n    {\n        printf(\"After Deletion:\");\n        while(temp1!=NULL)\n        {\n            printf(\"%d\\t\",temp1->data);\n            temp1 = temp1->ptr;\n        }\n        printf(\"\\nSORRY!!! NO NODE DELETED :(\");\n        return;\n    }\n    if(pos == 1)\n    {\n        head1 = head1->ptr;\n        free(temp1);\n        printf(\"\\nAfter Deletion:\");\n        while(head1!=NULL)\n        {\n            printf(\"%d\\t\",head1->data);\n            head1 = head1->ptr;\n        }\n        return;\n    }\n    for(i = 1;i < pos-1;i++)\n    {\n        temp1 = temp1->ptr;\n    }\n    struct node*prevnode;\n    prevnode = temp1;\n    temp1 = temp1->ptr;\n    prevnode->ptr = temp1->ptr;\n    free(temp1);\n    prevnode = head1;\n    printf(\"\\nAfter Deletion:\");\n    while(prevnode!=NULL)\n    {\n        printf(\"%d\\t\",prevnode->data);\n        prevnode = prevnode->ptr;\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__getpid-getppid.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    printf(\"before fork-1-\\n\");\n    printf(\"before fork-2-\\n\");\n    printf(\"before fork-3-\\n\");\n    printf(\"before fork-4-\\n\");\n    pid_t pid = fork();\n    if(pid == -1)\n    {\n        perror(\"fork error\");\n        exit(1);\n    }\n    else if(pid == 0)\n    {\n        printf(\"child is created, pid:%d, parent-pid:%d\\n\", getpid(), getppid());\n    }\n    else if(pid > 0)\n    {\n        printf(\"parent process:child pid:%d, my-pid:%d, parent-pid:%d\\n\", pid, getpid(), getppid());\n    }\n    printf(\"end of file\\n\");\n    sleep(2);\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q33.3.c", "original_string": "char dequeueright(queue *q)\n{\n    if (q->front==q->rear)\n    {\n        printf(\"Queue Empty\");\n        return '\\0';\n    }\n    else\n        return q->c[--(q->rear)];\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sum_Rows_Columns_Matrix.1.c", "original_string": "void find_Sum_Of_Rows(int matrix[R][C])\n{\n    int i, j, row_sum = 0;\n    int rows = R;\n    int columns = C;\n    for(i=0; i<rows; i++)\n    {\n        row_sum = 0;\n        for(j=0; j<columns; j++)\n        {\n            row_sum += matrix[i][j];\n        }\n        printf(\"\\nSum of Row %d: %d\", i, row_sum);\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_any_pos_SLL.3.c", "original_string": "int count()\n{\n    struct node *temp;\n    int count=0;\n    temp=head;\n    while(temp!=0)\n    {\n        count++;\n        temp=temp->next;\n    }\n    printf(\"the number of element in linked list is %d\", count);\n    printf(\"\\n\");\n    return count;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes2.12.c", "original_string": "void pase_asistencia(){\n    int dia;\n    printf(\"Pase de asistencia...\\n\");\n    int posicion = posicion_alumno();\n    printf(\"Indicar dia de asistencia [1 - %d]: \", MAX_ASISTENCIA);\n    scanf(\"%d\", &dia);\n    printf(\"[0]=Falta o [1]=Asistencia: \");\n    scanf(\"%d\", &lista_estudiantes[posicion].asistencias[dia - 1]);\n}"}
{"author": "jose120918", "file": "binary_trees__16-binary_tree_is_perfect.2.c", "original_string": "size_t tree_size(const binary_tree_t *tree)\n{\n    int count = 0;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    count = 1 + tree_size((*tree).left) + tree_size((*tree).right);\n    return (count);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_DCLL.4.c", "original_string": "void insert_beg()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    temp=head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    head->pre=newnode;\n    temp->next=newnode;\n    newnode->next=head;\n    newnode->pre=temp;\n    head=newnode;\n}"}
{"author": "MFarid94", "file": "Assignment-2__Exercise17.1.c", "original_string": "int main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);                            \n    setvbuf(stderr , NULL , _IONBF , 0);\n    int number1, number2;\n    int maximum;\n    printf(\"Enter first number: \");\n    scanf(\"%d\",&number1);                                           \n    printf(\"Enter second number: \");\n    scanf(\"%d\",&number2);                                           \n    maximum = MaximumValue(number1,number2);\n    printf(\"The maximum value of %d XOR %d is %d\",number1,number2,maximum);\n    return 0;\n}"}
{"author": "0712023", "file": "Arduino-Mood-Light-DIY-kit__Moodlight.5.c", "original_string": "void temp_set() {\n  if ( celsius < temp_1 ) {  \n    r = 0;  \n    g = 0;  \n    b = 255;  \n  }\n  else if ( temp_1 <= celsius && celsius < temp_2 ) {  \n    r = 0;\n    g = 255;\n    b = 0;\n  }\n  else if ( celsius >= temp_2 ) {  \n    r = 255;\n    g = 0;\n    b = 0;\n  }\n  for ( int i = 0; i < NUMPIXELS; i++ ) { \n    pixels.setPixelColor(i, pixels.Color( r, g, b ) );  \n    pixels.show(); \n  }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__heap_sort.2.c", "original_string": "void heapsort(int a[],int n)\n{\n    int i;\n    for(i=(n/2)-1;i>=0;i--)\n    {\n        sort(a,n,i);\n    }\n    for(i=n-1;i>=0;i--)\n    {\n        elemsw(&a[0],&a[i]);\n        sort(a,i,0);\n    }\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad1.1.c", "original_string": "int numberOfDays(monthName){\n    int error = 1; \n    int result = 0;\n    for (int i = 0; i < 12; i++){\n        result += months[i].days;\n        if(strcmp(monthName, months[i].name) == 0){\n            error = 0;\n            break; \n        }\n    }\n    if(error == 1){\n        result = 0;\n    }\n    return result;\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__goal_server.4.c", "original_string": "void queue_remove(int uid){\n    pthread_mutex_lock(&clients_mutex);\n    for(int i=0; i < MAX_CLIENTS; ++i){\n        if(clients[i]){\n            if(clients[i]->uid == uid){\n                clients[i] = NULL;\n                break;\n            }\n        }\n    }\n    pthread_mutex_unlock(&clients_mutex);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_client_misc.1.c", "original_string": "error_t scpClientOpenConnection(ScpClientContext *context)\n{\n   error_t error;\n   Socket *socket;\n   SshConnection *connection;\n   error = sshInit(&context->sshContext, &context->sshConnection, 1,\n      &context->sshChannel, 1);\n   if(error)\n      return error;\n   error = sshSetOperationMode(&context->sshContext, SSH_OPERATION_MODE_CLIENT);\n   if(error)\n      return error;\n   if(context->sshInitCallback != NULL)\n   {\n      error = context->sshInitCallback(context, &context->sshContext);\n      if(error)\n         return error;\n   }\n   socket = socketOpen(SOCKET_TYPE_STREAM, SOCKET_IP_PROTO_TCP);\n   if(socket != NULL)\n   {\n      socketBindToInterface(socket, context->interface);\n      socketSetTimeout(socket, context->timeout);\n      connection = sshOpenConnection(&context->sshContext, socket);\n      if(connection == NULL)\n      {\n         socketClose(socket);\n         error = ERROR_OPEN_FAILED;\n      }\n   }\n   else\n   {\n      error = ERROR_OPEN_FAILED;\n   }\n   return error;\n}"}
{"author": "sdukesameer", "file": "dsa__stk-by-array.4.c", "original_string": "int main()\n{\n    int ch,x;\n    printf(\"Enter size of the working Stack:\\n\");\n    scanf(\"%d\",&x);\n    stack* stk=createstack(x);\n    while(1)\n    {\n        printf(\"\\n\");\n        printf(\"1. PUSH\\n\");\n        printf(\"2. POP\\n\");\n        printf(\"3. PEEK\\n\");\n        printf(\"4. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            scanf(\"%d\",&n);\n            push(stk,n);\n        }\n        else if(ch==2)\n            pop(stk);\n        else if(ch==3)\n            peek(stk);\n        else if (ch==4)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid, choice try again.\\n\");\n    }\n    return 0;\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_6.5.c", "original_string": "void reverse()\n{\n    struct node* temp = root;\n    if(root == NULL)\n    {\n        printf(\"List is Empty\\n\\n\");\n    }\n    else\n    {\n        while(temp->right != NULL)\n        {\n            temp = temp->right;\n        }\n        while(temp != NULL)\n        {\n            printf(\"%d --> \", temp->data);\n            temp = temp->left;\n        }\n        printf(\"\\n\\n\");\n    }\n}"}
{"author": "ankitraj311", "file": "450_babbar__7_intersection_array_Geek_usorted_array.4.c", "original_string": "int main()\n{\n  int arr1[] = {1,2,3,5,6,6,7,8,9,7,8,9,10}, arr2[] = {100,2,3,60,1,2,3,4,4,6,4,9,80,7,2,30,1} ,no,j=0,temp=0,mid=0,n=0;\n  int size_arr1 = sizeof(arr1)/sizeof(int), size_arr2 = sizeof(arr2)/sizeof(int);\n  array_print(arr1,size_arr1); \n  array_print(arr2,size_arr2); \n  size_arr1 = remove_repeat(arr1,size_arr1); \n  size_arr2 = remove_repeat(arr2,size_arr2); \n  array_print(arr1,size_arr1); \n  array_print(arr2,size_arr2); \n  intersection_array(arr1,arr2,size_arr1,size_arr2);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_DLL.1.c", "original_string": "void creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__orderedLL.1.c", "original_string": "void insert(nptr &head, int ele)\n{\n    if (head == NULL)\n    {\n        head = createNode(ele);\n        return;\n    }\n    else if (ele < head -> data)\n    {\n        nptr temp = createNode(ele);\n        temp -> next = head;\n        head = temp;\n        return;\n    }\n    else\n    {\n        nptr prev = NULL, curr = head;\n        while(curr != NULL && curr -> data <= ele)\n        {\n            prev = curr;\n            curr = curr -> next;\n        }\n        nptr temp = createNode(ele);\n        prev -> next = temp;\n        temp -> next = curr;\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__delete_node_manually.1.c", "original_string": "void create(int value){\nstruct node*temp=(struct node*)malloc(sizeof(struct node));\ntemp->data=value;\ntemp->next=NULL;\nif(head==NULL){\n    head=temp;\n}\nelse{\n    struct node*newnode;\n    newnode=head;\n    while(newnode->next!=NULL)\n    {\n        newnode=newnode->next;\n    }\n    newnode->next=temp;\n}\n}"}
{"author": "Mr-JoE1", "file": "Play-with-C__Check_Armstrong_Number_of_n_digits.0.c", "original_string": "int main() {\nwhile(1){\n   int num, originalNum, remainder, n = 0;\n   float result = 0.0;\n   printf(\"Enter an integer: \");\n   scanf(\"%d\", &num);\n   originalNum = num;\n   for (originalNum = num; originalNum != 0; ++n) {\n       originalNum /= 10;\n   }\n   for (originalNum = num; originalNum != 0; originalNum /= 10) {\n       remainder = originalNum % 10;\n      result += pow(remainder, n);\n   }\n   if ((int)result == num)\n    printf(\"%d is an Armstrong number.\", num);\n   else\n    printf(\"%d is not an Armstrong number.\\n\", num);\n    }\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__single_link_list.2.c", "original_string": "void sort_node()\n{\n    print_ptr=sort= head;\n    int j=0,regno;\n    char *name;\n    while(sort != NULL)\n    {\n        print_ptr = head;\n        for(j=0 ;j<i; j++)\n        {\n            if(sort->regno < print_ptr->regno)\n            {\n                regno = print_ptr->regno;\n                name = print_ptr->name;\n                print_ptr->regno = sort->regno;\n                print_ptr->name = sort->name;\n                sort->regno = regno;\n                sort->name = name;\n            }\n            print_ptr = print_ptr->next;\n        }\n        sort = sort->next;;\n    }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__check_mate.5.c", "original_string": "int     is_checkmate(char **tab, int size)\n{\n    int     r;\n    int     c;\n    r = 0;\n    while (r < size)\n    {\n        c = 0;\n        while (c < size)\n        {\n            if (tab[r][c] == 'P' && check_pawn(tab, r, c, size))\n                return (1);\n            else if (tab[r][c] == 'B' && check_bishop(tab, r, c, size))\n                return (1);\n            else if (tab[r][c] == 'R' && check_rook(tab, r, c, size))\n                return (1);\n            else if (tab[r][c] == 'Q' && (check_bishop(tab, r, c, size)\n                        || check_rook(tab, r, c, size)))\n                return (1);\n            c++;\n        }\n        r++;\n    }\n    return (0);\n}"}
{"author": "sdukesameer", "file": "dsa__bfs-dfs.11.c", "original_string": "int main(){\n    graph g;\n    input(&g);\n    while(1){\n        int f=1,s,ch=1;\n        printf(\"\\n\\n****************\\n\");\n        printf(\"1. BFS Traversal\\n\");\n        printf(\"2. DFS Traversal\\n\");\n        printf(\"3. EXIT\\n\");\n        printf(\"Select the traversal you want to execute: \");\n        scanf(\"%d\",&ch);\n        if(ch==1){\n            printf(\"\\n\\' If\");\n            for(int i=0; i<g.n;i++)\n                printf(\" %c=%d\",'A'+i,i+1);\n            printf(\" \\'\\nEnter the initial vertex: \");\n            while(f){\n                scanf(\"%d\",&s);\n                if(s>0 && s<g.n+1)\n                    f=0;\n                else\n                    printf(\"Invalid input. Try again.\\n\");\n            }\n            bfs(g,s-1);\n        }\n        else if(ch==2){\n            printf(\"\\n\\' If\");\n            for(int i=0; i<g.n;i++)\n                printf(\" %c=%d\",'A'+i,i+1);\n            printf(\" \\'\\nEnter the initial vertex: \");\n            while(f){\n                scanf(\"%d\",&s);\n                if(s>0 && s<g.n+1)\n                    f=0;\n                else\n                    printf(\"Invalid input. Try again.\\n\");\n            }\n            dfs(g,s-1);\n        }\n        else if(ch==3)\n            break;\n        else\n            printf(\"\\nInvalid input. Try again.\\n\");\n    }\n    printf(\"\\nExitting program. Thank You.\\n\");\n    free_graph(&g);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_SLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "sdukesameer", "file": "c__rec_merge_sort.3.c", "original_string": "int main() {\n    int i;\n    scanf(\"%d\",&n);\n    if(n<1||n>50)\n    {\n        printf(\"ERROR\");\n        exit(1);\n    }\n    for (i = 0; i < n; i++)\n        scanf(\"%d\", &arr[i]);\n    printf(\"Original: \");\n    printArray();\n    merge_sort(0, n - 1);\n    printf(\"Sorted: \");\n    printArray();\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.19.c", "original_string": "void addstaticvar(SCOPE* s, CLASSVARDEC* v) {\n    STRINGLIST* currname = v->base->names;\n    pthread_mutex_lock(&(s->compiler->staticmutex));\n    static int i = 0;\n    while(currname != NULL) {\n        addvar(s, &(s->staticvars), mkvar(v->base->type, currname->content, v->base->primitive, v->base->debug, staticseg, i));\n        currname = currname->next;\n        i++;\n    }\n    pthread_mutex_unlock(&(s->compiler->staticmutex));\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__ft_rrange.2.c", "original_string": "int     main ()\n{\n    int a;\n    int *b;\n    b = ft_rrange(0,-3);\n    printf(\"%d %d %d %d %d %d\",b[0],b[1],b[2],b[3],b[4],b[5]);\n    return(0);\n}"}
{"author": "augustogunsch", "file": "jack-compiler__io.12.c", "original_string": "void freefilelist(FILELIST* fs) {\n    free(fs->name);\n    free(fs->fullname);\n    free(fs->outname);\n    FILELIST* next = fs->next;\n    free(fs);\n    if(next != NULL)\n        freefilelist(next);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__digit_addition.1.c", "original_string": "int SumR(int iNo)\n{\n    static int iSum = 0;\n    if(iNo != 0)\n    {\n            iSum = iSum + (iNo % 10);\n        iNo = iNo / 10;\n        SumR(iNo);\n    }\n    return iSum;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-statements.1.c", "original_string": "STATEMENT* parsestatementnullified(PARSER* p) {\n    if(equals(p, \"let\")) return parselet(p);\n    if(equals(p, \"if\")) return parseif(p);\n    if(equals(p, \"while\")) return parsewhile(p);\n    if(equals(p, \"do\")) return parsedo(p);\n    if(equals(p, \"return\")) return parsereturn(p);\n    return NULL;\n}"}
{"author": "augustogunsch", "file": "jackc__util.5.c", "original_string": "char* dotlabel(char* n1, char* n2) {\n    int sz = (strlen(n1) + strlen(n2) + 2) * sizeof(char);\n    char* result = (char*)malloc(sz);\n    sprintf(result, \"%s.%s\", n1, n2);\n    return result;\n}"}
{"author": "zjzj-zz", "file": "1s_programing__pingpong.1.c", "original_string": "int main(void) {\n  float wait_time = 0.01;\n  int barw = 20, barh = 150;\n  int bardy = 50;\n  int bardx = 200;\n  int bar1ix = 70, bar2ix = DL_WIDTH - 70;\n  int bar1x = bar1ix, bar1y = DL_HEIGHT / 2;\n  int bar1kup = 'w', bar1kdown = 's', bar1ka = 'e';\n  int bar2x = bar2ix, bar2y = DL_HEIGHT / 2;\n  int bar2kup = 'i', bar2kdown = 'k', bar2ka = 'u';\n  int br = 15;\n  float bvx = 4.0, bvy = 2.0;\n  int bx = DL_WIDTH / 2, by = DL_HEIGHT / 2;\n  int score1 = 0, score2 = 0;\n  int score1changed = 0;\n  int score2changed = 0;\n  int sx = DL_WIDTH / 2 - 120, sy = 50;\n  char sscore[] = \"   :   \";\n  int t, k, x, y;\n  dl_initialize(1.0);\n  while (1) {\n    while (dl_get_event(&t, &k, &x, &y)) {\n      if (t == DL_EVENT_KEY) {\n        if (k == bar1kup)\n          bar1y -= bardy;\n        else if (k == bar1kdown)\n          bar1y += bardy;\n        else if (k == bar1ka) {\n          if (bar1x > bar1ix) \n            bar1x = bar1ix;\n          else\n            bar1x += bardx;\n        } else if (k == bar2kup)\n          bar2y -= bardy;\n        else if (k == bar2kdown)\n          bar2y += bardy;\n        else if (k == bar2ka) {\n          if (bar2x < bar2ix) \n            bar2x = bar2ix;\n          else\n            bar2x -= bardx;\n        }\n      }\n    }\n    if (bar1y - barh / 2 < 0)\n      bar1y = barh / 2;\n    if (bar1y + barh / 2 > DL_HEIGHT)\n      bar1y = DL_HEIGHT - barh / 2;\n    if (bar2y - barh / 2 < 0)\n      bar2y = barh / 2;\n    if (bar2y + barh / 2 > DL_HEIGHT)\n      bar2y = DL_HEIGHT - barh / 2;\n    bx += bvx;\n    if (bx - br <= 0 || bx + br >= DL_WIDTH) \n      bvx *= -1;\n      by += bvy;\n    if (by - br <= 0) {\n      by = br + 1;\n      bvy *= -1;\n    } else if (by + br >= DL_HEIGHT) {\n      by = DL_HEIGHT - br - 1;\n      bvy *= -1;\n    }\n    if (by > bar1y - barh / 2 && by < bar1y + barh / 2) {\n      if (bvx < 0 && bx - br <= bar1x + barw / 2 && bx - br >= bar1x - barw / 2\n            || bvx > 0 && bx + br >= bar1x - barw / 2 && bx + br <= bar1x + barw / 2) {\n        reflect (&bvx, &bvy, by, bar1y, barh);\n      }\n    }\n    if (by > bar2y - barh / 2 && by < bar2y + barh / 2) {\n      if (bvx < 0 && bx - br <= bar2x + barw / 2 && bx - br >= bar2x - barw / 2\n        || bvx > 0 && bx + br >= bar2x - barw / 2 && bx + br <= bar2x + barw / 2) {\n        reflect (&bvx, &bvy, by, bar2y, barh);\n      }\n    }\n        score1changed = 0;\n        score2changed = 0;\n    if (bx - br <= 0) {\n      score2++;\n      bx = bar1x + barw + 1;\n      by = bar1y;\n      bvx = 4.0;\n      bvy = 2.0;\n      score2changed = 1;\n    }\n    if (bx + br >= DL_WIDTH) {\n      score1++;\n      bx = bar2x - barw - 1;\n      by = bar2y;\n      bvx = -4.0;\n      bvy = 2.0;\n      score1changed = 1;\n    }\n    if(score1 > 999)\n      score1 = 999;\n    if(score2 > 999)\n      score2 = 999;\n    if (score1changed) {\ndl_text(\"+1POINT\",100,50,1.0,DL_C(\"red\"),2);\nsleep(1);\nif (score1>=7){\n dl_text(sscore,sx,sy,2.0,DL_C(\"white\"),2);\n dl_text(\"RED WINNER!\",0,300,2.5,DL_C(\"red\"),2);\n dl_resume();\n sleep(3);\n exit(0);\n}\n    }\n    if (score2changed) {\ndl_text(\"+1POINT\",450,50,1.0,DL_C(\"green\"),2);\nsleep(1);\nif (score2>=7){\n dl_text(sscore,sx,sy,2.0,DL_C(\"white\"),2);\n dl_text(\"GREEN WINNER!\",0,300,2.0,DL_C(\"green\"),2);\n dl_resume();\n sleep(3);\n exit(0);\n}\n        }  \n    dl_stop();\n    dl_clear(DL_C(\"black\"));\n    dl_rectangle(bar1x - barw / 2, bar1y - barh / 2,\n         bar1x + barw / 2, bar1y + barh / 2, DL_C(\"red\"), 1, 1);\n    dl_rectangle(bar2x - barw / 2, bar2y - barh / 2,\n         bar2x + barw / 2, bar2y + barh / 2, DL_C(\"green\"), 1, 1);\n    dl_circle(bx, by, br, DL_C(\"blue\"), 1, 1);\n    sprintf(sscore, \"%3d:%d\", score1, score2);\n    dl_text(sscore, sx, sy, 2.0, DL_C(\"white\"), 2);\n    dl_resume();\n    dl_wait(wait_time);\n  }\n  return 0;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_9.6.c", "original_string": "int main()\n{\n    char sel;\n    int p,q,n,element;\n    FILE *fp1;\n    FILE *fp2;\n    fp1=fopen(\"input.txt\",\"r\");\n    fp2=fopen(\"output.txt\",\"w\");\n    queue Q;\n    Q.rear=-1;\n    Q.front=-1;\n    fscanf(fp1,\"%d\",&(Q.size));\n    Q.arr=(int*)malloc(sizeof(int)*(Q.size));\n    while(1)\n         {\n            fscanf(fp1,\"%c\",&sel);\n              if(sel=='e')\n                {\n                    fscanf(fp1,\"%d\",&element);\n                    p=enqueue(&Q,element);\n                    if(p==-999)\n                      fprintf(fp2,\"%d\\n\",p);\n                }  \n            else if(sel=='p')\n                 {\n                    fscanf(fp1,\"%d\",&n);\n                    print(Q,n,fp2);\n                 }\n            else if(sel=='d')\n                {\n                    q=dequeue(&Q);\n                    fprintf(fp2,\"%d\\n\",q);\n                }\n            else if(sel=='s')\n                break;\n         }\n  fclose(fp1);\n  fclose(fp2);\n  return 0;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e20.7.c", "original_string": "int buscaTipo(char palavra[20]){\n    int tipo, cont;\n    for(cont=0;cont<15;cont++){\n        if (strcmp(palavras[cont].nome,palavra)==0) {\n            return palavras[cont].tipo;\n            break;\n        }\n    }\n    return FALSE;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__io.11.c", "original_string": "FILELIST* getfiles(char* input) {\n    int inplen = strlen(input);\n    bool isitdir = isdir(input, inplen);\n    if(isitdir)\n        return getfilesfromdir(input);\n    else\n        return getsinglefile(input);\n}"}
{"author": "2security", "file": "Array__TraceNormMat.2.c", "original_string": "int traceMat(int **mat,int r,int c)\n    {\n    int i,t=0;\n    for(i=0;i<r;i++)\n        t=t+mat[i][i];\n    return t;\n    }"}
{"author": "fikepaci", "file": "monty__set_op_toks_error.0.c", "original_string": "void set_op_tok_error(int error_code)\n{\n    int toks_len = 0, i = 0;\n    char *exit_str = NULL;\n    char **new_toks = NULL;\n    toks_len = token_arr_len();\n    new_toks = malloc(sizeof(char *) * (toks_len + 2));\n    if (!op_toks)\n    {\n        malloc_error();\n        return;\n    }\n    while (i < toks_len)\n    {\n        new_toks[i] = op_toks[i];\n        i++;\n    }\n    exit_str = get_int(error_code);\n    if (!exit_str)\n    {\n        free(new_toks);\n        malloc_error();\n        return;\n    }\n    new_toks[i++] = exit_str;\n    new_toks[i] = NULL;\n    free(op_toks);\n    op_toks = new_toks;\n}"}
{"author": "augustogunsch", "file": "jackc__compiler.1.c", "original_string": "COMPILER* mkcompiler(CLASS* classes) {\n    COMPILER* c = (COMPILER*)malloc(sizeof(COMPILER));\n    c->globalscope = mkscope(NULL);\n    c->globalscope->compiler = c;\n    c->globalscope->classes = classes;\n    c->classes = classes;\n    pthread_mutex_init(&(c->ifmutex), NULL);\n    pthread_mutex_init(&(c->whilemutex), NULL);\n    pthread_mutex_init(&(c->staticmutex), NULL);\n    return c;\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__HeapSort.2.c", "original_string": "void putdata(int x[100], int n)\n    {\n          int k;\n          for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n         }\n          printf(\"\\n\");\n    }"}
{"author": "ankitraj311", "file": "Socket-thread__sum_with_thread.0.c", "original_string": "void* addall(void * arg)\n{\n  long id = (long)arg;\n  int start = id*250000000;\n  int i = 1;\n  while(i<=250000000)\n  {\n    sum[id] += (i + start);\n    i++;\n  }\n  return NULL;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Paging.0.c", "original_string": "int get_count()\n{\n    int i,ct=0;\n    for(i=0;i<16;i++)\n    {\n        if(Mem[i]==0)\n            ct=ct+1;\n    }\n    return(ct);\n}"}
{"author": "theuwis", "file": "project-euler__main6.0.c", "original_string": "int main(void){\n    long answer = 0, product = 1;\n    char input[1001] =  \"73167176531330624919225119674426574742355349194934\"\n                        \"96983520312774506326239578318016984801869478851843\"\n                        \"85861560789112949495459501737958331952853208805511\"\n                        \"12540698747158523863050715693290963295227443043557\"\n                        \"66896648950445244523161731856403098711121722383113\"\n                        \"62229893423380308135336276614282806444486645238749\"\n                        \"30358907296290491560440772390713810515859307960866\"\n                        \"70172427121883998797908792274921901699720888093776\"\n                        \"65727333001053367881220235421809751254540594752243\"\n                        \"52584907711670556013604839586446706324415722155397\"\n                        \"53697817977846174064955149290862569321978468622482\"\n                        \"83972241375657056057490261407972968652414535100474\"\n                        \"82166370484403199890008895243450658541227588666881\"\n                        \"16427171479924442928230863465674813919123162824586\"\n                        \"17866458359124566529476545682848912883142607690042\"\n                        \"24219022671055626321111109370544217506941658960408\"\n                        \"07198403850962455444362981230987879927244284909188\"\n                        \"84580156166097919133875499200524063689912560717606\"\n                        \"05886116467109405077541002256983155200055935729725\"\n                        \"71636269561882670428252483600823257530420752963450\";\n    char solution[nr_of_adjecent + 1] = \"\";\n    int i, j;\n    for(i = nr_of_adjecent - 1; i < 1000; i++){\n        for(j = nr_of_adjecent - 1; j >= 0; j--){\n            product = (input[i - j] - '0') * product;\n        }\n        if(product > answer){\n            answer = product;\n            for(j = 0; j < nr_of_adjecent; j++){\n                solution[j] = input[i - nr_of_adjecent + 1 + j];\n            }\n        }\n        product = 1;\n    }\n    printf(\"answer=%ld (%s)\\n\", answer, solution);\n    return EXIT_SUCCESS;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__infixToPostfix.5.c", "original_string": "int precedence(char ch){\n     if(ch == '*' || ch=='/'){\n          return 3;\n     }\n     else if(ch=='+' || ch=='-')\n          return 2;\n     else\n          return 0;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ili9341_ext.3.c", "original_string": "static void set_addr_window(uint16_t x_0, uint16_t y_0, uint16_t x_1, uint16_t y_1)\n{\n    ASSERT(x_0 <= x_1);\n    ASSERT(y_0 <= y_1);\n    write_command(ILI9341_CASET);\n    write_data(x_0 >> 8);\n    write_data(x_0);\n    write_data(x_1 >> 8);\n    write_data(x_1);\n    write_command(ILI9341_PASET);\n    write_data(y_0 >> 8);\n    write_data(y_0);\n    write_data(y_1 >> 8);\n    write_data(y_1);\n    write_command(ILI9341_RAMWR);\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_rtx.24.c", "original_string": "void *osAllocMem(size_t size)\n{\n   void *p;\n   osSuspendAllTasks();\n   p = malloc(size);\n   osResumeAllTasks();\n   TRACE_DEBUG(\"Allocating %u bytes at 0x%08X\\r\\n\", size, (uint_t) p);\n   return p;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_DLL.6.c", "original_string": "void insert_at_pos()\n{\n    struct node *newnode,*temp;\n    int i=1,pos;\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    int leg=count();\n    if(pos>leg)\n    {\n        printf(\"invalied position\\n\");\n    }\n    else\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode->pre=temp;\n        newnode->next=temp->next;\n        temp->next=newnode;\n        newnode->next->pre=newnode;\n    }\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__14sorting.1.c", "original_string": "void sorting(int a[],int n)\n{\n    int i,j,t;\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<n-i-1;j++)\n        {\n            if(a[j]>a[j+1])\n            {\n                t=a[j];\n                a[j]=a[j+1];\n                a[j+1]=t;\n            }\n        }\n    }\n    for(i=0;i<n;i++)\n        printf(\"%d\",a[i]);\n}"}
{"author": "254Odeke", "file": "Operating-Systems_Lab__Deadlock_Prevention_with_Known_Required_Resourses_Simulation.3.c", "original_string": "void cal()\n{\n int finish[100],temp,need[100][100],flag=1,k,c1=0;\n int dead[100];\n int safe[100];\n int i,j;\n for(i=0;i<n;i++)\n {\n finish[i]=0;\n }\n for(i=0;i<n;i++)\n {\n for(j=0;j<r;j++)\n {\n need[i][j]=max[i][j]-alloc[i][j];\n }\n }\n while(flag)\n {\n flag=0;\n for(i=0;i<n;i++)\n {\n int c=0;\n for(j=0;j<r;j++)\n47;\n{\nif((finish[i]==0)&&(need[i][j]<=avail[j]))\n{\nc++;\n if(c==r)\n{\n for(k=0;k<r;k++)\n {\n avail[k]+=alloc[i][j];\n finish[i]=1;\n flag=1;\n }\nif(finish[i]==1)\n {\ni=n;\n}}}}}}\n j=0;\n flag=0;\n for(i=0;i<n;i++)\n {\n if(finish[i]==0)\n {\n dead[j]=i;\n j++;\n flag=1;\n }\n }\n if(flag==1)\n {\n printf(\"\\n\\nSystem is in Deadlock and the Deadlock process are\\n\");\n for(i=0;i<n;i++)\n {\n printf(\"P%d\\t\",dead[i]);\n }\n }\n else\n {\n printf(\"\\nNo Deadlock Occur\");\n }\n}"}
{"author": "dishanp", "file": "DSA__q15.0.c", "original_string": "void create(int A[], int n)\n{\n    struct node *t, *last;\n    first = (struct node*)malloc(sizeof(struct node));\n    first->data = A[0];\n    first->next = NULL;\n    last = first;\n    for(int i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__singlyLL.7.c", "original_string": "void display(nptr &head)\n{\n    nptr temp = head;\n    while(temp != NULL)\n    {\n        printf(\"%d --> \", temp -> data);\n        temp = temp -> next;\n    }\n    printf(\"NULL\\n\");\n}"}
{"author": "sdukesameer", "file": "dsa__list-ins-rem_even.0.c", "original_string": "node* createnode(int inp)\n{\n    node* newnode=malloc(sizeof(node));\n    newnode->data=inp;\n    newnode->next=NULL;\n    return newnode;\n}"}
{"author": "behergue", "file": "Operating_Systems__simulator.8.c", "original_string": "void Bajar_Autobus(int id_usuario, int destino){\n    pthread_mutex_lock(&esperaBajar[destino]);\n    esperando_bajar[destino]++;\n    while(parada_actual != destino || estado != EN_PARADA){\n        pthread_cond_wait(&bajan, &esperaBajar[destino]);\n    }\n    esperando_bajar[destino]--;\n    if(esperando_bajar[destino] == 0)\n        pthread_cond_signal(&hanBajado);\n    printf(\"Usuario %d se baja en la parada %d \\n\", id_usuario, destino);\n    pthread_mutex_unlock(&esperaBajar[destino]);\n}"}
{"author": "sdukesameer", "file": "dsa__cll-ins-sor-seq-del.4.c", "original_string": "void deletion(node** head, node* del)\n{\n    if (*head==del)\n    {\n        if((*head)->next==*head)\n            *head=NULL;\n        else\n        {\n            node* last=*head;\n            while(last->next!=(*head))\n                last=last->next;\n            *head=(*head)->next;\n            last->next=*head;\n        }\n    }\n    else\n    {\n        node* temp=*head;\n        while(temp->next!=del)\n            temp=temp->next;\n        temp->next=del->next;\n    }\n    free(del);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__duplicateLL.1.c", "original_string": "void insertRear(nptr &head, int x)\n{\n    if (head == NULL)\n    {\n        head = createNode(x);\n        return;\n    }\n    nptr temp = head;\n    while (temp -> next != NULL)\n        temp = temp -> next;\n    temp -> next = createNode(x);\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_2.0.c", "original_string": "int main()\n{\n    while(1)\n    {\n        int ch, item;\n        printf(\"1. Push \\n\");\n        printf(\"2. Pop\\n\");\n        printf(\"3. Traverse \\n\");\n        printf(\"4. Exit\\n\");\n        printf(\"Enter your choice : \");\n        scanf(\"%d\", &ch);\n        switch (ch)\n        {\n        case 1:\n            printf(\"Enter element to push\\n\");\n            scanf(\"%d\", &item);\n            push(item);\n            break;\n        case 2:\n            item = pop();\n            if(item == 0)\n            {\n                printf(\"Stack is underflow\\n\");\n            }\n            else\n            {\n                printf(\"Popped item is %d \\n\", item);\n            }\n            break;\n        case 3:\n            traverse();\n            break;\n        case 4:\n            exit(0);\n            break;\n        default:\n            printf(\"Invalid Input\\n\");\n        }\n    }\n    return 0;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Triangular_Matrix.0.c", "original_string": "void main()\n{\n    int i, j = 0;\n    int input_matrix[R][C];\n    printf(\"\\nEnter the matrix elements...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &input_matrix[i][j]);\n        }\n    }\n    printf(\"\\nOriginal Matrix is as follows:- \\n\");\n    display(input_matrix);\n    printf(\"\\nUpper Triangular Matrix is as follows:- \\n\");\n    display_upper_triangular(input_matrix);\n    printf(\"\\nLower Triangular Matrix is as follows:- \\n\");\n    display_lower_triangular(input_matrix);\n}"}
{"author": "augustogunsch", "file": "jackc__threads.2.c", "original_string": "char* getclassname(char* filename) {\n    int len = strlen(filename) - 1;\n    for(len = len; len >= 0; len--)\n        if(filename[len] == '.')\n            break;\n    int sz = sizeof(char) * (len + 1);\n    char* classname = (char*)malloc(sz);\n    snprintf(classname, sz, \"%s\", filename); \n    return classname;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_30.3.c", "original_string": "int main() {\n    setlocale(LC_ALL, \"\");\n    for (int i = 0; i < 10; i++) {\n        int valorAlocar = 0;\n        printf(\"Preencha o valor do vetor1 numero %d\\n\", i);\n        scanf(\"%d\", &valorAlocar);\n        int retorno = verificarValorRepetido(vet1, valorAlocar);\n        if (retorno != 0) {\n            printf(\"O valor %d nao pode ser inserido pois esta repetido, por favor informe outro numero.\\n\", retorno);\n            i--;\n            continue;\n        } else {\n            vet1[i] = valorAlocar;\n        }\n    }\n    for (int i = 0; i < 10; i++) {\n        int valorAlocar = 0;\n        printf(\"Preencha o valor do vetor2 numero %d\\n\", i);\n        scanf(\"%d\", &valorAlocar);\n        int retorno = verificarValorRepetido(vet2, valorAlocar);\n        if (retorno != 0) {\n            printf(\"O valor %d nao pode ser inserido pois esta repetido, por favor informe outro numero.\\n\", retorno);\n            i--;\n            continue;\n        } else {\n            vet2[i] = valorAlocar;\n        }\n    }\n    system(\"cls\");\n    printf(\"\\n ------------------------------ \\n\");\n    criarVetorIntersecao();\n    imprimirVetorIntersecao();\n    return 0;\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_print_combn.4.c", "original_string": "void comb3(int *numeros,int a,int b,int c)\n{\n  while(a<=7)\n       {\n        while(b<=8)\n             {\n              while(c<=9)\n                  {\n                    printf(\"%i%i%i, \",numeros[a],numeros[b],numeros[c]);\n                    c=c+1;\n                  }\n              b=b+1;\n              c=b+1;\n             }\n        a=a+1;\n        b=a+1;\n        c=b+1;\n       }\n}"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__1-20.2.c", "original_string": "void detab(void){\n  extern char line[];\n  extern char lineS[];\n  int i, j;\n  i = j = 0;\n  while(line[i] != '\\0'){\n    if(line[i] == '\\t')\n      for(int l = 0; l < SPACES; l++){\n    lineS[j] = ' ';\n    ++j;\n      }\n    else{\n      lineS[j] = line[i];\n      ++j;\n    }\n    ++i;\n  }\n  lineS[j] = '\\0';\n}"}
{"author": "Theemiss", "file": "simple_shell__finding_path.1.c", "original_string": "char *build(char *token, char *value)\n{\n    char *cmd;\n    size_t len;\n    len = _strlen(value) + _strlen(token) + 2;\n    cmd = malloc(sizeof(char) * len);\n    if (cmd == NULL)\n    {\n        return (NULL);\n    }\n    memset(cmd, 0, len);\n    cmd = _strcat(cmd, value);\n    cmd = _strcat(cmd, \"/\");\n    cmd = _strcat(cmd, token);\n    return (cmd);\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_cortex.15.c", "original_string": "void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)\n{\n  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));\n  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)\n  {\n    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;\n  }\n  else\n  {\n    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;\n  }\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_pwr_ex.6.c", "original_string": "HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)\n{\n  uint32_t tickstart = 0U;\n  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));\n  __HAL_RCC_PWR_CLK_ENABLE();\n  if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)\n  {\n    __HAL_RCC_PLL_DISABLE();\n    tickstart = HAL_GetTick();    \n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)\n    {\n      if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\n      {\n        return HAL_TIMEOUT;\n      }\n    }\n    __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);\n    __HAL_RCC_PLL_ENABLE();\n    tickstart = HAL_GetTick();\n    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)\n    {\n      if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)\n      {\n        return HAL_TIMEOUT;\n      } \n    }\n    tickstart = HAL_GetTick();\n    while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))\n    {\n      if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)\n      {\n        return HAL_TIMEOUT;\n      } \n    }\n  }\n  else\n  {\n    return HAL_ERROR;\n  }\n  return HAL_OK;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__3.0.c", "original_string": "int main()\n{\n    int n;\n    do\n    {\n        printf(\"\\nDigite o n\u00famero de lados do pol\u00edgono (>= 3): \");\n        scanf(\"%li\", &n);\n        if (n < 3) system(\"clear\");\n    } while (n < 3);\n    pontos_t *poligono = malloc(n * sizeof(pontos_t));\n    le_poligono(poligono, n);\n    system(\"clear\");\n    printf(\"\\n\\tPer\u00edmetro = %lf\\n\", perimetro(poligono, n));\n    printf(\"\\n\\t\u00c1rea = %lf\\n\", area(poligono, n));\n    printf(\"\\n\\tQuantidade de tri\u00e2ngulos poss\u00edveis = %.0lf\\n\\n\", triangulos(poligono, n, 3));\n    free(poligono);\n    return 0;\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__stack.0.c", "original_string": "int main(){\n    int input;\n    stack.data = -1;\n    while(1){\n    printf(\"Enter the choice\\n1.Push\\n2.Pop\\n3.Display\\n4.Exit\\n\");\n    scanf(\"%d\",&input);\n        switch(input){\n            case 1 :\n                push();\n                break ;\n            case 2 :\n                pop();\n                break ;\n            case 3 :\n                display();\n                break ;\n            case 4 :\n                exit(EXIT_SUCCESS);\n            default :\n                printf(\"Invalid Option\\n\");\n        }\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__parser-structure.14.c", "original_string": "VARDEC* parsevardec(PARSER* p) {\n    if(strcmp(p->current->token, \"var\"))\n        return NULL;\n    next(p);\n    VARDEC* vardec = (VARDEC*)malloc(sizeof(VARDEC));\n    parsevardeccommon(p, vardec);\n    return vardec;\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__map_utils.0.c", "original_string": "void        surrend_by_spaces(char **map)\n{\n    int i;\n    int j;\n    i = 0;\n    j = 0;\n    while (map[i])\n    {\n        while (j < g_map_width + 2)\n            j++;\n        map[i][j] = '\\0';\n        i++;\n        j = 0;\n    }\n    i = -1;\n    while (map[++i])\n        map[i][0] = ' ';\n    i = -1;\n    while (map[0][++i])\n        map[0][i] = ' ';\n    i = -1;\n    while (map[g_map_height][++i])\n        map[g_map_height + 1][i] = ' ';\n    i = -1;\n    while (map[++i])\n        map[i][g_map_width + 1] = ' ';\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zadOsmi.8.c", "original_string": "Position AllocateMemoryForDirectory()\n{\n    Position newDirectory = (Position)malloc(sizeof(Dir));\n    if (!newDirectory)\n    {\n        printf(\"Can not allocate memory!\\n\");\n    }\n    newDirectory->child = NULL;\n    newDirectory->sibling = NULL;\n    return newDirectory;    \n}"}
{"author": "MartinMarinovich", "file": "MarinovichMartinLABIPP1G-__main.0.c", "original_string": "int main()\n{\n    eNotebook listaDeNotebooks[TAM_NOTEBOOKS];\n    eMarca listadoDeMarcas[TAM_MARCAS];\n    eTrabajo listadoDeTrabajos[TAM_TRABAJOS];\n    eTipo listadoDeTipos[TAM_TIPOS];\n    eServicio listadoDeServicios [TAM_SERVICIOS];\n    eCliente listadoDeClientes [TAM_CLIENTES];\n    int proximoIdTrabajo = 100;\n    int proximoIdNotebook = 1;\n    int auxModificacion;\n    int auxBaja;\n    int opcionMenu;\n    if(!inicializarNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !inicializarTrabajo(listadoDeTrabajos,TAM_TRABAJOS))\n    {\n        printf(\"Sistema inicializado con exito!\\n\\n\");\n    }else\n    {\n        printf(\"Problema para inicializar el sistema\\n\");\n    }\n    hardCodearTipos(listadoDeTipos,TAM_TIPOS);\n    hardcodearMarcas(listadoDeMarcas,TAM_MARCAS);\n    hardCodearServicios(listadoDeServicios,TAM_SERVICIOS);\n    hardCodearClientes(listadoDeClientes,TAM_NOTEBOOKS);\n    hardCodearTrabajos(listadoDeTrabajos,TAM_NOTEBOOKS);\n    do\n    {\n        menu(&opcionMenu);\n        switch(opcionMenu)\n        {\n            case 1:\n                if(!altaNotebook(listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,TAM_NOTEBOOKS,TAM_CLIENTES,proximoIdNotebook,TAM_TIPOS,TAM_MARCAS))\n                {\n                    proximoIdNotebook++;\n                    printf(\"ALTA EXITOSA!\\n\");\n                }\n                else\n                {\n                    printf(\"Problema para realizar el alta\\n\");\n                }\n            break;\n            case 2:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    auxModificacion = modificarNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);\n                    if( auxModificacion == 0)\n                    {\n                        printf(\"Modificacion exitosa\\n\");\n                    }\n                    else if(auxModificacion == 2)\n                    {\n                        printf(\"La modificacion ha sido cancelada por usuario\\n\");\n                    }\n                    else\n                    {\n                        printf(\"Se ha producido un error en la modificacion\\n\");\n                    }\n                }else\n                {\n                    printf(\"No hay notebooks en el listado\\n\");\n                }\n            break;\n            case 3 :\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    auxBaja = bajaNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TIPOS,TAM_MARCAS);\n                    if( auxBaja == 0)\n                    {\n                        printf(\"Modificacion exitosa\\n\");\n                    }\n                    else if(auxBaja == 2)\n                    {\n                        printf(\"La baja ha sido cancelada por usuario\\n\");\n                    }\n                    else\n                    {\n                        printf(\"Se ha producido un error en la baja\\n\");\n                    }\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 4:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    ordenarNotebooks(listaDeNotebooks,TAM_NOTEBOOKS);\n                    listarNotebook(listaDeNotebooks, listadoDeMarcas,listadoDeClientes,listadoDeTipos,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 5:\n                system(\"cls\");\n                listarMarcas(listadoDeMarcas,TAM_MARCAS);\n            break;\n            case 6:\n                system(\"cls\");\n                listarTipos(listadoDeTipos,TAM_TIPOS);\n            break;\n            case 7:\n                system(\"cls\");\n                listarServicios(listadoDeServicios,TAM_SERVICIOS);\n            break;\n            case 8:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    if(altaTrabajo(listaDeNotebooks,listadoDeTrabajos,listadoDeServicios,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,\n                            TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_TIPOS,TAM_MARCAS,proximoIdTrabajo)==0)\n                    {\n                        proximoIdTrabajo++;\n                        printf(\"ALTA TRABAJO EXITOSA!\\n\");\n                    }else\n                    {\n                        printf(\"Se produjo un error al ingresa el trabajo\\n\");\n                    }\n                }else\n                {\n                    printf(\"No hay notebooks en la lista, no se puede ingresar trabajo\\n\");\n                }\n            break;\n            case 9:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) &&\n                    !verificarExistenciaTrabajo(listadoDeTrabajos,TAM_TRABAJOS))\n                {\n                    system(\"cls\");\n                    listarTrabajos(listadoDeTrabajos,listaDeNotebooks,listadoDeServicios,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS);\n                }else\n                {\n                    printf(\"No se ingresaron trabajos o notebooks\\n\");\n                }\n            break;\n            case 10:\n                system(\"cls\");\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    listarPorTipo(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeClientes,TAM_CLIENTES,TAM_MARCAS,listadoDeTipos,TAM_TIPOS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 11:\n                system(\"cls\");\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    listarPorMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS,TAM_TIPOS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 12:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    contarNotebooksMarcaYTipo(listaDeNotebooks, TAM_NOTEBOOKS,listadoDeMarcas,TAM_MARCAS,listadoDeClientes, TAM_CLIENTES, listadoDeTipos, TAM_TIPOS);\n                }\n            break;\n            case 13:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    listarNotebookXCadaMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_TIPOS,TAM_MARCAS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 14:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    marcaFavorita(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 15:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    notebookMasBarata(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_TIPOS,TAM_MARCAS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 16:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    listarTrabajosXNotebook(listadoDeTrabajos,listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,listadoDeServicios,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_MARCAS,TAM_TIPOS);\n                }\n            break;\n            case 17:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    mostrarSumaDeImportesXNotebook(listadoDeServicios, TAM_SERVICIOS, listadoDeTrabajos, listaDeNotebooks, TAM_NOTEBOOKS, listadoDeMarcas, listadoDeTipos, listadoDeClientes, TAM_CLIENTES, TAM_TIPOS, TAM_MARCAS, TAM_TRABAJOS);\n                }else\n                {\n                    printf(\"No hay notebooks o trabajos cargados\\n\");\n                }\n            break;\n            case 18:\n                 if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    mostrarFechaYNotebookXServicio(listadoDeClientes,listadoDeTrabajos,TAM_TRABAJOS,listadoDeServicios,TAM_SERVICIOS,listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,TAM_MARCAS,listadoDeTipos,TAM_TIPOS,TAM_CLIENTES);\n                }else\n                {\n                    printf(\"No hay notebooks o trabajos cargados\\n\");\n                }\n            break;\n            case 19:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    mostrarServiciosXFecha(listadoDeTrabajos,TAM_TRABAJOS,listadoDeServicios,TAM_SERVICIOS);\n                }else\n                {\n                    printf(\"No hay notebooks o trabajos cargados\\n\");\n                }\n            break;\n        }\n    }while(opcionMenu != 20);\n    return 0;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e20.1.c", "original_string": "char * gerarCaptchaSimples(){\n    int cont, tipo, min, max;\n    char novoCaptcha[TOTAL], caractere;\n    for(cont=0;cont<TOTAL;cont++){\n        tipo=numeroAleatorio(1,3);\n        switch(tipo){\n            case 1:\n                min=65;\n                max=90;\n            break;\n            case 2:\n                min=97;\n                max=122;\n            break;\n            case 3:\n                min=48;\n                max=57;\n            break;\n        }\n        caractere=numeroAleatorio(min,max);\n        novoCaptcha[cont]=caractere;\n    }\n    novoCaptcha[TOTAL]=0;\n    return novoCaptcha;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.1.c", "original_string": "static char *separator(void)\n{\n  char *os = getenv(\"OS\");\n  if (os != NULL && strcmp(os, \"Windows_NT\") == 0) \n  {\n    return \"\\\\\";\n  }\n  else\n  {\n    return \"/\";\n  }\n}"}
{"author": "SugumaranEvil", "file": "Linux_programming__prc10.0.c", "original_string": "int main()\n{\n   int fd,shmid;\n   ssize_t rd,op;\n   char buffer[30],*data_ptr;\n   fd = open(\"./txt\",O_RDONLY);\n   rd = read(fd,buffer,20);\n   shmid = shmget(100,8192,IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH); \n   perror(\"shmget \");\n   data_ptr = shmat(shmid,NULL,0);\n   perror(\"shmat  \");\n   strcpy(data_ptr,buffer);\n   shmdt(data_ptr);\n   perror(\"shmdt  \");\n   return 0;\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client2.0.c", "original_string": "int main()\n{\n    int sockfd, fdmax, i;\n    struct sockaddr_in server_addr;\n    fd_set master;\n    fd_set read_fds;\n    char name[32];\n    char password[32];\n    char new_entry_message[45];\n    printf(\"Please enter your name: \");\n    fgets(name, 32, stdin);\n    trim_newline(name, strlen(name));\n    if (strlen(name) > 32 || strlen(name) < 2)\n    {\n        printf(\"Name must be less than 30 and more than 2 characters.\\n\");\n        return EXIT_FAILURE;\n    }\n    printf(\"Please enter your password: \");\n    fgets(password, 32, stdin);\n    trim_newline(password, strlen(password));\n    connect_request(&sockfd, &server_addr);\n    struct message new_member_message;\n    new_member_message.type = 1;\n    strcpy(new_member_message.name, name);\n    strcpy(new_member_message.data, password);\n    send(sockfd, &new_member_message, sizeof(struct message), 0);\n    FD_ZERO(&master);\n    FD_ZERO(&read_fds);\n    FD_SET(0, &master);\n    FD_SET(sockfd, &master);\n    printf(\"\\nWelcome to Project COBRA\\n\");\n    fdmax = sockfd;\n    while (1)\n    {\n        read_fds = master;\n        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)\n        {\n            perror(\"select\");\n            exit(4);\n        }\n        for (i = 0; i <= fdmax; i++)\n            if (FD_ISSET(i, &read_fds))\n                send_recv(i, sockfd, name, &master);\n    }\n    close(sockfd);\n    return 0;\n}"}
{"author": "ankitraj311", "file": "Socket-thread__socket_tcp_server.0.c", "original_string": "int main()\n{\n    char server_message[256] = \"You have been reached the Server\";\n    int server_socket;\n    server_socket = socket(AF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in server_address;\n    server_address.sin_family = AF_INET;\n    server_address.sin_port = htons(9000);\n    server_address.sin_addr.s_addr = INADDR_ANY;\n    bind(server_socket, (struct sockaddr*)&server_address, sizeof(server_address));\n    listen(server_socket, 5); \n    int client_socket;\n    client_socket = accept(server_socket, NULL, NULL);\n    send(client_socket, server_message, sizeof(server_message),0);\n    close(server_socket);\n    return 0;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_07.4.c", "original_string": "void count_ones(int n,int q,int a[n][q],int one[])\n{\nint i,j;\n  for(i=0;i<n;i++)\n    for(j=0;j<q;j++)\n        {if(a[i][j]==1)\n         one[i]++;\n        }\n}"}
{"author": "paawankohli", "file": "CN-Lab__q4_client.0.c", "original_string": "void main() {\n    int serverfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (serverfd == -1) {\n        printf(\"Couldn't create socket. Exiting!\\n\");\n        exit(0);\n    } else {\n        printf(\"Socket created \\n\");\n    }\n    struct sockaddr_in server_address;\n    int len = sizeof(server_address);\n    server_address.sin_family = AF_INET;\n    server_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    server_address.sin_port = PORT;\n    int status = connect(serverfd, (struct sockaddr *)&server_address, len);\n    if (status == -1) {\n        printf(\"Couldn't connect. Exiting!\\n\");\n        exit(0);\n    } else {\n        printf(\"Connection established!\\n\\n\");\n    }\n    char time[100];\n    read(serverfd, time, 100);\n    printf(\"Server Time: %s\\n\", time);\n    char processid[100];\n    read(serverfd, processid, 100);\n    printf(\"Server proccess ID: %s\\n\", processid);\n    close(serverfd);\n}"}
{"author": "2security", "file": "String__21RemoveFirstOccurrence.0.c", "original_string": "int main()\n    {\n        int i,pos,j;\n        char str[30],temp[30],ch;\n        printf(\"\\n Enter the string\");\n        gets(str);\n        printf(\"\\n Enter the character\");\n        scanf(\"%c\",&ch);\n        for(i=0;i<str[i]!='\\0';i++)\n            {\n                if(str[i]==ch)\n                    {\n                        pos=i;\n                        break;\n                    }\n            }\n        for(j=0;i<str[j]!='\\0';j++);\n        for(i=pos;i<=j-1;i++)\n            str[i]=str[i+1];\n        str[i]='\\0';\n        printf(\"%s\",str);\n        return 0;\n    }"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_pwr_ex.13.c", "original_string": "HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)\n{\n  uint32_t tickstart = 0U;\n  __HAL_RCC_PWR_CLK_ENABLE();\n  __HAL_PWR_OVERDRIVE_ENABLE();\n  tickstart = HAL_GetTick();\n  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))\n  {\n    if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    }\n  }\n  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();\n  tickstart = HAL_GetTick();\n  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))\n  {\n    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    }\n  } \n  return HAL_OK;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.2.c", "original_string": "void agregar_alumno(){\n    if(siguiente_alumno == MAX_ALUMNOS){\n        printf(\"No se puede agregar nuevo alumno, espacio insuficiente...\");\n        puts(\"Presiona cualquier tecla para continuar...\");\n        fflush(stdin);\n        getchar();\n    } else {\n        estudiante nuevo_alumno;\n        printf(\"Ingresa la matr\u00edcula:\");\n        scanf(\"%d\", &nuevo_alumno.matricula);\n        fflush(stdin);\n        printf(\"Ingresa el nombre del alumno:\");\n        fgets(nuevo_alumno.nombre, 60, stdin);\n        nuevo_alumno.calificaciones[0] = 0.0;\n        nuevo_alumno.calificaciones[1] = 0.0;\n        nuevo_alumno.calificaciones[2] = 0.0;\n        nuevo_alumno.calificaciones[3] = 0.0;\n        puts(\"Datos almacenado correctamente...\");\n        puts(\"Presiona cualquier tecla para continuar...\");\n        fflush(stdin);\n        getchar();\n        lista_estudiantes[siguiente_alumno] = nuevo_alumno;\n        siguiente_alumno++;\n    } \n}"}
{"author": "SugumaranEvil", "file": "Datastructure__single_linked_list.0.c", "original_string": "int main()\n{\n    struct node *ptr1 = (struct node *)malloc(sizeof(struct node));\n    ptr1->data = 'A';\n    ptr1->next = NULL;\n    struct node *ptr2 = (struct node *)malloc (sizeof(struct node));\n    ptr2->data = 'B';\n    ptr2->next = NULL;\n    head = ptr1;\n    ptr1->next = ptr2;\n    printf(\"Before insertion\\n\");\n    print_list();\n    struct node *insert_ptr = (struct node *)malloc(sizeof(struct node));\n    insert_ptr->data = 'C';\n    insert_ptr->next = NULL;\n    ptr2->next = insert_ptr;\n    printf(\"After insertion\\n\");\n    print_list();\n    ptr2->next = NULL;\n    printf(\"After deletion\\n\");\n    print_list();\n    free(ptr1);\n    free(ptr2);\n    free(insert_ptr);\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__MatrixOperations.1.c", "original_string": "void add_matrices(int m1[R][C], int m2[R][C])\n{\n    int i, j = 0;\n    int output[R][C];\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            output[i][j] = m1[i][j] + m2[i][j];\n        }\n    }\n    printf(\"\\nResultant Matrix after ADDITION:- \\n\");\n    display_matrix(output);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q1.4.c", "original_string": "void postorder(nptr root)\n{\n    if (root == NULL)\n        return;\n    postorder(root->lchild);\n    postorder(root->rchild);\n    printf(\"%d \", root->data);\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Insert_At_The_End_Of_A_Single_Linked_List.2.c", "original_string": "void insert_at_end(struct node*temp1, struct node*head1)\n{\n    struct node*tempo;\n    tempo = (struct node*) malloc (sizeof(struct node));\n    printf(\"\\nEnter the Data:\");\n    scanf(\"%d\",&tempo->data);\n    while(temp1->link!=NULL)\n    {\n        temp1 = temp1->link;\n    }\n    temp1->link = tempo;\n    tempo->link = NULL;\n    temp1 = head1;\n    printf(\"The Elements After Insertion are:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->link;\n    } \n}"}
{"author": "theuwis", "file": "AdventOfCode2017__main12.0.c", "original_string": "void print_square(void){\n    for(int i = 0; i < GRID_SIZE; i++){\n        for(int j = 0; j < GRID_SIZE; j++){\n            (grid[i][j] == 0) ? printf(\". \") : printf(\"# \");\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__buzzer.0.c", "original_string": "int main()\n{\n    int flag = 0;\n    IODIR0 = IODIR0 | (1<<11);      \n    IODIR1 = IODIR1 & ~(1<<25);     \n    while(1)\n    {\n        if(IOPIN1 & (1<<25))  \n        {\n            IOSET0 = 1<<11;\n            delay(100);\n            IOCLR0 = 1<<11;\n            delay(100);         \n        }\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_any_pos_CLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d\",temp->data);\n    printf(\"\\n\");\n}"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post.5.c", "original_string": "void rec_postorder(node* root) \n{ \n    if (root != NULL) \n    { \n        rec_postorder(root->left);\n        rec_postorder(root->right);\n        printf(\"\\t%d\\n\", root->data); \n    }\n}"}
{"author": "ankitraj311", "file": "450_babbar__4_0_1_2_array_simple_youtube.0.c", "original_string": "void array_print(int arr[], int no)\n{\n  printf(\"Array is :- \");\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n}"}
{"author": "augustogunsch", "file": "jackc__parser-tree.12.c", "original_string": "void freesubroutdecs(SUBROUTDEC* sr) {\n    free(sr->debug);\n    if(sr->parameters != NULL)\n        freeparameters(sr->parameters);\n    freesubroutbody(sr->body);\n    SUBROUTDEC* next = sr->next;\n    free(sr);\n    if(next != NULL)\n        freesubroutdecs(next);\n}"}
{"author": "ankitraj311", "file": "450_babbar__5_mv_-ive_one_side_Geek.0.c", "original_string": "int main()\n{\n  int arr[100],no,j=0,temp=0,mid=0;\n  printf(\"Enter length of array\");\n  scanf(\"%d\",&no);\n  for(int i = 0; i<no; i++)\n  {\n    scanf(\"%d\",&arr[i]);\n  }\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n  for(int i = 0; i<no; i++)\n  {\n    if(arr[i]<0)\n    {\n      if(i != j)\n      {\n        temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n      j++;\n    }\n  }\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n}"}
{"author": "RafaelFelisbino-hub", "file": "MATRIZ-exercices__Exercicio10MATRIZ.0.c", "original_string": "int main()\n{\n    float matriz[3][3] = { {10,20,30}, {40,50,60}, {70,80,90} }, media, acimaMedia = 0, somaMedia = 0, repeticao = 0;\n    int i, j;\n    for (i = 0; i < 1; i++)\n        for (j = 0; j < 1; j++)\n            printf(\"Os elementos da diagonal sao :  %.0f, %.0f, %.0f\\n\", matriz[0][0], matriz[1][1], matriz[2][2]);\n    for (i = 0; i < 3; i++)\n        for (j = 0; j < 3; j++) \n        {\n            somaMedia += matriz[i][j];\n            repeticao++;\n        }\n    media = somaMedia / repeticao;\n    printf(\"\\nA media dos elementos e:  %.2f\", media);\n    for (i = 0; i < 3; i++)\n        for (j = 0; j < 3; j++) \n        {\n            if (matriz[i][j] > media)\n                acimaMedia++;\n        }\n    printf(\"\\nExistem %.0f valores acima da media\\n\",acimaMedia);\n    system(\"pause\");\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__circularqueue.0.c", "original_string": "void enqueue(int val)\n{\n    if(r==-1)\n    {\n        f=(f+1)%MAX;\n        r=(r+1)%MAX;\n        queue[r]=val;\n    }\n    else if((r==MAX-1 && f==0) || r==f-1)\n    {\n        printf(\"\\nQueue is FULL\");\n    }\n    else\n    {\n        r=(r+1)%MAX;\n        queue[r]=val;\n    }\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_8.0.c", "original_string": "int main()\n{\n    while(1)\n    {\n        int choice, ele;\n        printf(\"<--- Operations on BST --->\\n\");\n        printf(\"1. Insertion\\n\");\n        printf(\"2. In order Traversal\\n\");\n        printf(\"3. Pre-order Traversal\\n\");\n        printf(\"4. Post order Traversal\\n\");\n        printf(\"5. Count Leaves\\n\");\n        printf(\"6. Height\\n\");\n        printf(\"7. Exit\\n\");\n        printf(\"Enter your choice : \");\n        scanf(\"%d\", &choice);\n        switch(choice)\n        {\n        case 1:\n            printf(\"Enter an element to insert : \");\n            scanf(\"%d\", &ele);\n            printf(\"%d successfully inserted.\\n\\n\", ele);\n            insert(ele);\n            break;\n        case 2:\n            traverse_inorder(root);\n            printf(\"\\n\\n\");\n            break;\n        case 3:\n            traverse_preorder(root);\n            printf(\"\\n\\n\");\n            break;\n        case 4:\n            traverse_postorder(root);\n            printf(\"\\n\\n\");\n            break;\n        case 5:\n            printf(\"Total Leaf Count : %d\\n\\n\", count_leaves(root));\n            break;\n        case 6:\n            printf(\"Maximum Height : %d\\n\\n\", height(root));\n            break;\n        case 7:\n            exit(0);\n            break;\n        default:\n            printf(\"Invalid Choice\\n\\n\");\n        }\n    }\n    return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__23.0.c", "original_string": "int main()\n{\n    char matriz[3][5];\n    system(\"clear\");\n    printf(\"informe os elementos(char) de uma matriz 3x5:\\n\");\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 5; j++)\n        {\n            scanf(\"%c\", &matriz[i][j]);\n            getchar();\n        }\n    }\n    system(\"clear\");\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 5; j++)\n        {\n            if (j == 0)\n            {\n                printf(\"|\");\n            }\n            printf(\"%2c\", matriz[i][j]);\n            if (j == 4)\n            {\n                printf(\" |\");\n            }\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < 5; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            if (j == 0)\n            {\n                printf(\"|\");\n            }\n            printf(\"%2c\", matriz[j][i]);\n            if (j == 2)\n            {\n                printf(\" |\");\n            }\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Insertion_Sort.2.c", "original_string": "void insertion_sort(int array[MAX], int length)\n{\n    int i, j, temp = 0;\n    int size = length;\n    for(i=1; i<size; i++)\n    {\n        j = i;\n        while((array[j] < array[j-1]) && j>0)\n        {\n            temp = array[j];\n            array[j] = array[j-1];\n            array[j-1] = temp;\n            j--;\n        }\n    }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__string_reverse.0.c", "original_string": "void StrrevX(char str[])\n{\n    int iStart = 0, iEnd = 0;\n    char temp = '\\0';\n    if(str == NULL)\n    {\n        return;\n    }\n    while(str[iEnd] != '\\0')        \n    {\n        iEnd++;\n    }\n    iEnd --;\n    while(iStart < iEnd)            \n    {\n        temp = str[iStart];\n        str[iStart] = str[iEnd];\n        str[iEnd] = temp;\n        iStart++;\n        iEnd--;\n    }\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_1_3_7.0.c", "original_string": "int main()\n{\n    float a, b, c;\n    float delta;\n    float x1, x2;\n    printf(\"Podaj wartosc wspolczynnika a.\\n\");\n    scanf(\"%f\", &a);\n    printf(\"Podaj wartosc wspolczynnika b.\\n\");\n    scanf(\"%f\", &b);\n    printf(\"Podaj wartosc wspolczynnika c.\\n\");\n    scanf(\"%f\", &c);\n    if (a == 0) {\n        x1 = -c/b;\n        printf(\"Rozwiazanie rownania: %.2f\\n\", x1);\n    } else {\n        delta = b*b-4*a*c;\n        if (delta < 0) {\n           printf(\"Rownanie nie ma rozwiazan w zbiorze liczb rzeczywistych.\\n\");\n        } else {\n            x1 = (-b-delta)/(2*a);\n            x2 = (-b+delta)/(2*a);\n            printf(\"x1 wynosi: %.2f\\n\", x1);\n            printf(\"x2 wynosi: %.2f\\n\", x2);\n        }\n    }\n    getchar();\n    return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__BI.0.c", "original_string": "int main()\n{\n    char str0[1002], str[1002], aux[1002];\n    int qtd = 0, tam, busca, busca1, tam0, tam1, tam2, p2, p1, k1, h1;\n    scanf(\"%1002[^\\n]s\", str);\n    tam = strlen(str);\n    for (int i = (tam / 2); i > 1; i--)\n    {\n        for (int h = 0; str[(2 * i) + h - 1] != '\\0'; h++)\n        {\n            h1 = h;\n        }\n        for (int h = h1; h >= 0; h--)\n        {\n            for (int j = 0; j < i; j++)\n            {\n                aux[j] = str[j + h];\n            }\n            tam0 = strlen(aux);\n            for (int j = 0; j < tam0; j++)\n            {\n                if (((int)aux[j] < 97) || ((int)aux[j] > 122))\n                    aux[j] = '\\0';\n            }\n            tam0 = strlen(aux);\n            printf(\"\\n%s %i\\n\", aux, tam0);\n            for (int k = 0; str[2 * i - 1 + k + h] != '\\0'; k++)\n            {\n                k1 = k;\n            }\n            for (int k = k1; k >= 0; k--)\n            {\n                busca = true;\n                for (int l = 0; ((l < tam0)&&(busca == true)); l++)\n                {\n                    if (aux[l] != str[i + k + l + h])\n                    {\n                        busca = false;\n                    }\n                    p2 = i + k + l + h;\n                    p1 = i + k + h;\n                }\n                if (busca == true)\n                {\n                    if (str[p2 + 1] == '\\0')\n                    {\n                        for (int j = p2; j >= p1; j--)\n                        {\n                            str[j] = '\\0';\n                        }\n                    }\n                    else\n                    {\n                        for (int j = p1; (j <= p2)||(str[j+tam0] != '\\0'); j++)\n                        {                           \n                            str[j] = str[j + tam0];\n                            str[j + tam0] = '\\0';\n                        }\n                    }\n                    qtd ++;\n                    printf(\"\\ntrue %i %i\\n%s\\n\", p1, p2, aux);\n                }\n            }\n            for (int j = tam0 - 1; j >= 0; j--)\n            {\n                aux[j] = '\\0';\n            }\n        }\n    }\n    printf(\"\\n%s %li %i\\n\", str, strlen(str), qtd);\n    printf(\"%li\\n\", strlen(str) + qtd);\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader0.9.c", "original_string": "static bool parseFirmwareUpdateInfo(char *updateInfoString)\n{\n  memset(updateVersion, 0, sizeof(updateVersion));\n  memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n  if (strstr(updateInfoString, UPDATE_INFO_SEPARATOR) == NULL) \n  {\n    printf(\"Firmware update request with missing version and/or verification data entered\\n\");\n    return false;\n  }\n  char *parsedVersion = strtok(updateInfoString, UPDATE_INFO_DELIMITERS);\n  if (parsedVersion == NULL) \n  {\n    printf(\"Firmware update request with missing version and verification data entered\\n\");\n    return false;\n  }\n  if (strlen(parsedVersion) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) \n  {\n    printf(\"Received firmware update version too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH);\n    return false;\n  }\n  strncpy(updateVersion, parsedVersion, sizeof(updateVersion));\n  char *parsedVerificationData = strtok(NULL, UPDATE_INFO_DELIMITERS);\n  if (parsedVerificationData == NULL) \n  {\n    printf(\"Firmware update request with missing version or verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (strlen(parsedVerificationData) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n  {\n    printf(\"Received firmware update verification data too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH << 1);\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (convertHexString8ToBinData(parsedVerificationData, strlen(parsedVerificationData), updateVerificationData, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) == 0) \n  {\n    printf(\"Firmware update request with invalid verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n    return false;\n  }\n  return true;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLL.5.c", "original_string": "void display(nptr head)\n{\n    printf(\"                 \");\n    if(head == NULL)\n        printf(\"EMPTY\");\n    while(head)\n    {\n        printf(\" %d \", head -> data);\n        head = head -> right;\n    }\n    printf(\"\\n\");\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__wdt.0.c", "original_string": "int main()\n{\n    IODIR1 |= 0xFF<<17;\n    WDMOD = (1<<1) | (1<<0);   \n    WDTC = 0xFFFFFF;\n    blink_led(24);\n    WDFEED = 0xAA; \n    WDFEED = 0x55;\n    while(1)\n    {\n        blink_led(17);\n    }\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Linked.2.c", "original_string": "void rem_file(int id)\n{\n    int i;\n    for(i=0;i<16;i++)\n    {\n        if(disk[i].id==id)\n        {\n            disk[i].id=0;\n            disk[i].next_index=-1;\n        }\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__count_the_elem_in_DCLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.42.c", "original_string": "void freegarbage(STRINGLIST* garbage) {\n    if(garbage != NULL) {\n        free(garbage->content);\n        STRINGLIST* next = garbage->next;\n        free(garbage);\n        freegarbage(next);\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__delete_node_from_DLL_any_positn.3.c", "original_string": "void deleteFromN(int position)\n{\n    struct node *current;\n    int i;\n    current = head;\n    for(i=1; i<position && current!=NULL; i++)\n    {\n        current = current->next;\n    }\n    if(position == 1)\n    {\n        struct node * toDelete;\n        toDelete = head;\n        head = head->next; \n        head->prev = NULL; \n        free(toDelete); \n    }\n    else if(current == last)\n    {\n        struct node * toDelete;\n        toDelete = last;\n        last = last->prev; \n        last->next = NULL; \n        free(toDelete);       \n    }\n    else if(current != NULL)\n    {\n        current->prev->next = current->next;\n        current->next->prev = current->prev;\n        free(current); \n        printf(\"SUCCESSFULLY DELETED NODE FROM %d POSITION.\\n\", position);\n    }\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__12_.1.c", "original_string": "void Columna(int contador, int pibote, char letra_A){\n    if(contador <= 13){\n        if(contador >= (1 + pibote) && contador <= (13 - pibote))\n            printf(\"%c\", letra_A);\n        else\n            printf(\" \");\n        Columna(++contador,pibote,letra_A);\n    }\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_pwr.3.c", "original_string": "void HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)\n{\n  assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));\n  assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));\n  MODIFY_REG(PWR->CR, PWR_CR_PLS, sConfigPVD->PVDLevel);\n  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();\n  __HAL_PWR_PVD_EXTI_DISABLE_IT();\n  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();\n  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); \n  if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)\n  {\n    __HAL_PWR_PVD_EXTI_ENABLE_IT();\n  }\n  if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)\n  {\n    __HAL_PWR_PVD_EXTI_ENABLE_EVENT();\n  }\n  if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)\n  {\n    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();\n  }\n  if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)\n  {\n    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();\n  }\n}"}
{"author": "haon1026", "file": "linux-programming__pthread_detach.1.c", "original_string": "int main()\n{\n    pthread_t tid;\n    int ret = pthread_create(&tid, NULL, thread_fun, NULL);\n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_create error: %s\\n\", strerror(ret));   \n        exit(1);\n    }\n    ret = pthread_detach(tid);              \n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_detach error: %s\\n\", strerror(ret));\n        exit(1);\n    }\n    sleep(1);\n    ret = pthread_join(tid, NULL);\n    if(ret != 0)                                    \n    {\n        fprintf(stderr, \"pthread_join error: %s\\n\", strerror(ret));\n        exit(1);\n    }\n    printf(\"main:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n    return 0;    \n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__shell_server.1.c", "original_string": "error_t shellServerInit(ShellServerContext *context,\n   const ShellServerSettings *settings)\n{\n   uint_t i;\n   TRACE_INFO(\"Initializing shell server...\\r\\n\");\n   if(context == NULL || settings == NULL)\n      return ERROR_INVALID_PARAMETER;\n   if(settings->sessions == NULL || settings->numSessions < 1 ||\n      settings->numSessions > SHELL_SERVER_MAX_SESSIONS)\n   {\n      return ERROR_INVALID_PARAMETER;\n   }\n   osMemset(context, 0, sizeof(ShellServerContext));\n   context->sshServerContext = settings->sshServerContext;\n   context->numSessions = settings->numSessions;\n   context->sessions = settings->sessions;\n   context->checkUserCallback = settings->checkUserCallback;\n   context->commandLineCallback = settings->commandLineCallback;\n   for(i = 0; i < context->numSessions; i++)\n   {\n      osMemset(&context->sessions[i], 0, sizeof(ShellServerSession));\n      if(!osCreateEvent(&context->sessions[i].startEvent))\n         return ERROR_OUT_OF_RESOURCES;\n      if(!osCreateEvent(&context->sessions[i].event))\n         return ERROR_OUT_OF_RESOURCES;\n   }\n   if(!osCreateEvent(&context->event))\n      return ERROR_OUT_OF_RESOURCES;\n   return NO_ERROR;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__25_sen.3.c", "original_string": "void Sen(int contador, int iteraciones, double total, double X)\n{\n        if(contador <= iteraciones){\n        if(contador%2 == 0){\n            total = total + (Exp((contador*2)+1, X) / Fac((contador*2)+1));\n            Sen(++contador, iteraciones,total,X);\n        }else{\n            total = total - (Exp((contador*2)+1, X) / Fac((contador*2)+1));\n                        Sen(++contador, iteraciones,total,X);\n        }\n        }else{\n                printf(\"\\n**El Sen(%lf) es igual a: %lf\",X,total+X);\n        }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSL__tls_ticket.3.c", "original_string": "error_t tlsGenerateTicketKeys(TlsTicketContext *ticketContext,\n   const PrngAlgo *prngAlgo, void *prngContext)\n{\n   error_t error;\n   TlsTicketEncryptionState *state;\n   state = &ticketContext->encryptionState;\n   state->valid = FALSE;\n   error = prngAlgo->read(prngContext, state->keyName,\n      TLS_TICKET_KEY_NAME_SIZE);\n   if(error)\n      return error;\n   error = prngAlgo->read(prngContext, state->key, TLS_TICKET_KEY_SIZE);\n   if(error)\n      return error;\n   state->timestamp = osGetSystemTime();\n   state->valid = TRUE;\n   return NO_ERROR;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e40.1.c", "original_string": "int cmpString(char vetorUsuario[6], int vetorCaptcha[6])\n{\n    int contador;\n    for(contador = 0; contador < 6; contador ++)\n    {\n        if(strlen(vetorUsuario) != 6)\n        {\n            if(vetorUsuario[contador] == vetorCaptcha[contador])\n            {\n                printf(\"Digite novamente!!\\n\"); \n                return 0;\n            }\n        }\n        else\n        {   \n            printf(\"Voce digitou corretamente!!\");  \n            return 1;\n        }\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__n-bishop-a.3.c", "original_string": "int main(){\n    int x=1;\n    while(x){\n        printf(\"Enter valid N i.e. for no of rows and columns: \");\n        scanf(\"%d\",&N);\n        if(N>0)\n            x=0;\n    }\n    int arr[N][N];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            arr[i][j]=0;\n    bishops(arr,0);\n    return 0;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__flor.6.c", "original_string": "int main(int argc, char **argv)\n{\n  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n  glutInitWindowPosition(50, 100);\n  glutInitWindowSize(400, 400);\n  glutInit(&argc, argv);\n  glutCreateWindow(\"Transforma\u00e7\u00f5es Geom\u00e9tricas - Transla\u00e7\u00e3o\");\n  init();\n  glutDisplayFunc(display_function);\n  glutSpecialFunc(tecladoEspecial);\n  glutMainLoop();\n  return 0;\n}"}
{"author": "dle2005", "file": "Algorithm__Chained_Matrix_Multiplication_v2.0.c", "original_string": "int **init_matrix(int n) {\n    int **matrix = (int **)malloc(sizeof(int *) * n);\n    for(int i = 0; i < n; i++) {\n        matrix[i] = (int *)malloc(sizeof(int) * n);\n    }\n    return matrix;\n}"}
{"author": "Theemiss", "file": "simple_shell__memory_mangment.0.c", "original_string": "void *_realloc(void *ptr, unsigned int old_size, unsigned int new_size)\n{\n    void *result;\n    if (new_size == old_size)\n        return (ptr);\n    if (new_size == 0 && ptr)\n    {\n        free(ptr);\n        return (NULL);\n    }\n    result = malloc(new_size);\n    if (result == NULL)\n        return (NULL);\n    if (ptr == NULL)\n    {\n        fill_an_array(result, '\\0', new_size);\n        free(ptr);\n    }\n    else\n    {\n        _memcpy(result, ptr, old_size);\n        free(ptr);\n    }\n    return (result);\n}"}
{"author": "dishanp", "file": "DSA__q34.8.c", "original_string": "int main()\n{\n    int n,choice, index, x, key, len;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n        scanf(\"%d\", &A[i]);\n    create(A, n);\n    do\n    {\n        printf(\"\\n\\n1 : Traversal of the list\\n2 : Check if the list is empty\\n\");\n        printf(\"3 : Insert a node at the certain position\\n4 : Delete a node at the certain position\\n\");\n        printf(\"5 : Delete a node for the given key\\n6 : Count the total number of nodes\\n\");\n        printf(\"7 : Search for an element in the linked list\\n8: EXIT\\n\");\n        printf(\"\\nEnter Choice : \");\n        scanf(\"%d\", &choice);\n        switch(choice)\n        {\n            case 1 :\n                display(first);\n                break;\n            case 2 :\n                check_empty(first);\n                break;\n            case 3 :\n                printf(\"\\nEnter position (0 for after zero nodes, 1 for after 1 node and so on..) : \");\n                scanf(\"%d\", &index);\n                printf(\"Enter data : \");\n                scanf(\"%d\", &x);\n                insert(first, index, x);\n                printf(\"New list : \");\n                display(first);\n                break;\n            case 4 :\n                printf(\"\\nEnter position (1 for 1st node, 2 for 2nd node and so on..): \");\n                scanf(\"%d\", &index);\n                x = delete_index(first, index);\n                printf(\"Data deleted at position %d : %d\\n\", index, x);\n                printf(\"New list : \");\n                display(first);\n                break;\n            case 5 :\n                printf(\"\\nEnter key : \");\n                scanf(\"%d\", &key);\n                index = delete_key(first, key);\n                if(index != -1)\n                {\n                    printf(\"% deleted at position : %d\\n\", key, index);\n                    printf(\"New list : \");\n                    display(first);\n                }\n                break;\n            case 6 :\n                len = length(first);\n                printf(\"\\nNumber of nodes : %d\\n\", len);\n                break;\n            case 7 :\n                printf(\"\\nEnter key : \");\n                scanf(\"%d\", &key);\n                index = search(first, key);\n                if(index != -1)\n                {\n                    printf(\"Element is present at position %d\\n\", index);\n                }\n                break;\n        }\n    }while(choice != 8);\n}"}
{"author": "fikepaci", "file": "monty__monty_funcs_2.2.c", "original_string": "void monty_div(stack_t **stack, unsigned int line_number)\n{\n    if ((*stack)->next == NULL || (*stack)->next->next == NULL)\n    {\n        set_op_tok_error(short_stack_error(line_number, \"div\"));\n        return;\n    }\n    if ((*stack)->next->n == 0)\n    {\n        set_op_tok_error(div_error(line_number));\n        return;\n    }\n    (*stack)->next->next->n /= (*stack)->next->n;\n    monty_pop(stack, line_number);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q1_queue.6.c", "original_string": "int main()\n{\n    queue q;\n    int opt ,ele;\n    printf(\"\\n1. Insert \\n2. Delete \\n3. Display \\n4. Exit\");\n    printf(\"\\nEnter option: \");\n    scanf(\"%d\",&opt);\n    init(&q);\n    while(opt!=4)\n    {\n        switch(opt)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter element: \");\n                scanf(\"%d\",&ele);\n                insert(&q,ele);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nYou have deleted %d\",deletee(&q));\n                break;\n            }\n            case 3:\n            {\n                display(&q);\n                break;\n            }\n        }\n        printf(\"\\nEnter option: \");\n        scanf(\"%d\",&opt);\n    }\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__stack_using_linked_list.3.c", "original_string": "void pop()\n{\n    struct node *temp;\n    if(top==0)\n    {\n        printf(\"the stack is under flow\\n\");\n    }\n    else\n    {\n        temp=top;\n        printf(\"the poped element is %d\\n\",top->data);\n        top=top->next;\n        free(temp);\n    }\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Reverse_Of_A_Single_Linked_List.2.c", "original_string": "void reverse_node(struct node*head1, struct node*temp1)\n{\n    struct node*prevnode;\n    if(head1!=NULL)\n    {\n        prevnode = head1;\n        temp1 = head1->ptr;\n        head1 = head1->ptr;\n        prevnode->ptr = NULL;\n    }\n    while(head1!=NULL)\n    {\n        head1 = head1->ptr;\n        temp1->ptr = prevnode;\n        prevnode = temp1;\n        temp1 = head1;\n    }\n    head1 = prevnode;\n    printf(\"\\nAFTER REVERSE OPERATION:\");\n    while(head1!=NULL)\n    {\n        printf(\"%d\\t\",head1->data);\n        head1 = head1->ptr;\n    }\n    return;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica3-1.0.c", "original_string": "int main(int argc, char * argv[]){\n    srand(time(NULL)); \n    int n; \n    printf(\"introduce el numero de clientes:\\n\");\n    scanf(\"%i\", &n);\n    pthread_t clientes[n];\n    int m; \n    m = 5;\n    pthread_t proveedores[m];\n    for (int i = 0; i < n; i++){ pthread_create(&clientes[i], NULL, compra, NULL); } \n    for (int i = 0; i < m; i++){ pthread_create(&proveedores[i], NULL, suministro, NULL); } \n    for (int i = 0; i < n; i++){ pthread_join(clientes[i], NULL); } \n    for (int i = 0; i < m; i++) { pthread_join(proveedores[i], NULL); } \n    printf(\"stock: %i %i %i %i %i \\n\",camisetas[0], camisetas[1], camisetas[2], camisetas[3], camisetas[4]);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_in_SLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n       if(head==0)\n       {\n            head=temp=newnode;\n       }\n       else\n       {\n            temp->next=newnode;\n            temp=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n           scanf(\"%d\",& choice);\n    }\n}"}
{"author": "DanielSalis", "file": "AED1__teste6.4.c", "original_string": "void imprimir(TipoLista* l){\n    if(l->tamanho == 0){\n        printf(\"lista vazia\\n\");\n    }\n    else{\n        TipoElemento* aux = l->primeiro;\n        TipoElemento* auxProx = l->primeiro->prox;\n        printf(\"| \");\n        while(auxProx){\n            printf(\"%d -> \", aux->id);\n            aux = auxProx;\n            if(auxProx==NULL){\n                break;\n            }\n            auxProx = auxProx->prox;\n        }\n        printf(\"%d |\\n\", aux->id);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__BToperations.4.c", "original_string": "void getlevel(node* r, int level)\n{\n    if (level == 0)\n        printf(\"%d\\t\", r -> data);\n    else\n    {\n        getlevel(r->left, level-1);\n        getlevel(r->right, level-1);\n    } \n}"}
{"author": "paawankohli", "file": "DSA-LAB__cNum.1.c", "original_string": "cNum subtract(cNum a, cNum b)\n{\n    cNum temp;\n    temp.real = a.real - b.real;\n    temp.imag = a.imag - b.imag;\n    return temp;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__shell_server.7.c", "original_string": "error_t shellServerReadStream(ShellServerSession *session, void *data,\n   size_t size, size_t *received, uint_t flags)\n{\n   error_t error;\n   if(session != NULL)\n   {\n      error = sshReadChannel(session->channel, data, size, received, flags);\n   }\n   else\n   {\n      error = ERROR_INVALID_PARAMETER;\n   }\n   return error;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__onlyRow.1.c", "original_string": "void row_key(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(ROW);\n        IODIR1 = IODIR1 | (COL);\n        val = (IOPIN1 & ROW); \n        val = val >> 21;\n        switch(val)\n        {\n            case 0x0E: \n                lcd_str(\"R1\");\n                delay(500);\n                break;\n            case 0x0D:\n                lcd_str(\"R2\");\n                delay(500);\n                break;\n            case 0x0B:\n                lcd_str(\"R3\");\n                delay(500);\n                break;\n            case 0x07:\n                lcd_str(\"R4\");\n                delay(500);\n                break;\n            default:\n                delay(1000);\n                lcd_cmd(0x01);\n        }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__1,_2.1.c", "original_string": "int main()\n{\n    long int n, *vet;\n    do\n    {\n        printf(\"\\nDigite o tamanho do vetor: \");\n        scanf(\"%ld\", &n);\n        getchar();\n        system(\"clear\");\n    } while (n <= 0);\n    vet = malloc(n * sizeof(long int));\n    printf(\"\\nDigite os elementos do vetor:\\n\");\n    for (long int i = 0; i < n; i++)\n    {\n        printf(\"\\t-> \");\n        scanf(\"%ld\", vet + i);\n        getchar();\n    }\n    printf(\"\\nOrdem normal:\\n\");\n    printf(\"\\t[ \");\n    imprime_elemento(vet, 0, n, normal);\n    printf(\"]\\n\");\n    printf(\"\\nOrdem inversa:\\n\");\n    printf(\"\\t[ \");\n    imprime_elemento(vet, n-1, NULL, inversa);\n    printf(\"]\\n\\n\");\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_DCLL.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.delete the element at the beginning position in the linked list\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4: printf(\"delete the element at the beginning position in the linked list\\n\");\n            delete_beg();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "dle2005", "file": "Algorithm__Floyd_v2.2.c", "original_string": "int** init_matrix(int size) { \n    int **matrix = (int**)malloc(sizeof(int*) * size); \n    for(int i = 0; i < size; i++) {\n        matrix[i] = (int*)malloc(sizeof(int) * size);\n        memset(matrix[i], 0, sizeof(int)*size); \n    }\n    return matrix;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Paging.4.c", "original_string": "void display_Mem()\n{\n    int i;\n    printf(\"\\nMemory is : \");\n    for(i=0;i<16;i++)\n        printf(\"%d\\t\",Mem[i]);\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__listener.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    int sockid,rval,count=0,tlen;\n    char msg[100];\n    struct sockaddr_in lis,talk;\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(1);\n    }\n    lis.sin_family=AF_INET;\n    lis.sin_port=htons(atoi(argv[2]));\n    lis.sin_addr.s_addr=inet_addr(argv[1]);\n    sockid=socket(AF_INET,SOCK_DGRAM,0);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    rval=bind(sockid,(struct sockaddr*)&lis,sizeof(lis));\n    if(rval==-1)\n    {\n        perror(\"BIND-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\nThe Listener is ready to accept messages\\n\");\n    tlen=sizeof(talk);\n    while(1)\n    {\n        strncpy(msg,\" \",100);\n        rval=recvfrom(sockid,msg,sizeof(msg),0,(struct sockaddr*)&talk,&tlen);\n        if(rval==-1)\n        {\n            perror(\"MSG-RCV-ERR:\");\n            close(sockid);\n            exit(1);\n        }\n        printf(\"\\nMessage %d read is %s\\n\",++count,msg);\n        if(!strcmp(msg,\"EXIT\"))\n        break;\n    }\n    close(sockid);\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__test.5.c", "original_string": "unsigned int crc32cyy(unsigned char *data,int len) {\n    unsigned int crc = 0xFFFFFFFF;\n    int i;\n    for (i=0;i<len;i++) {\n        crc = crc ^ data[i];\n        int j;\n        for (j=7;j>=0;j--) {\n            crc = (crc >> 1) ^ (0xEDB88320 & (-(crc & 1)));\n        }\n    }\n    return ~crc;\n}"}
{"author": "sdukesameer", "file": "dsa__pre-eva.5.c", "original_string": "int isOperator(char ch)\n{\n    if (ch=='+' || ch=='-' || ch=='*' || ch=='/')\n        return 1;\n    else\n        return 0;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__menu.2.c", "original_string": "int main () {\n    srand(time(0));\n    int opcion;\n    while (opcion != 4) {\n        imprimir_menu();\n        scanf(\"%d\", &opcion);\n        switch (opcion) {\n            case 1: agregar_alumno();\n                break;\n            case 2: menu_modificacion_calificaciones(&calificacion1, &calificacion2, &calificacion3, &calificacionf);\n                break;\n            case 3: imprimir_alumno();\n                break;\n            case 4:\n                break;\n            default:\n                break;\n        }\n    }\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc-a.9.c", "original_string": "int leafcount(list* node)\n{\n    if(node==NULL)\n        return 0;\n    if(node->left==NULL && node->right==NULL)\n        return 1;\n    else\n        return leafcount(node->left)+leafcount(node->right);\n}"}
{"author": "augustogunsch", "file": "jack-compiler__tokenizer.9.c", "original_string": "bool isint(char* str) {\n    int i = 0;\n    while(str[i] != '\\0') {\n        if(!isdigit(str[i]))\n            return false;\n        i++;\n    }\n    return true;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_01.0.c", "original_string": "void read(int A[], int n)\n{\n        int i;\n        for(i=0;i<n;i++)\n        {\n                fscanf(F1,\"%d\", &A[i]);\n        }\n}"}
{"author": "seefeesaw", "file": "Recursion__horners_rule.2.c", "original_string": "double ei(int x,int n)\n{\n    double s=1;\n    int i;\n    double num = 1;\n    double den = 1;\n    for(i = 1;i<=n;i++)\n    {\n        num*=x;\n        den*=i;\n        s+=num/den;\n    }\n    return s;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_DLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\");\n    }\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "augustogunsch", "file": "jack-compiler__tokenizer.15.c", "original_string": "bool handlecomment(FILE* input, int* lnscount) {\n    unsigned char nextc = fgetc(input);\n    if(nextc == '/') {\n        skipln(input);\n        (*lnscount)++;\n        return true;\n    }\n    else if(nextc == '*') {\n        unsigned char furtherc = fgetc(input);\n        if(furtherc == '*') {\n            skipmultiln(input, lnscount);\n            return true;\n        }\n        ungetc(furtherc, input);\n    }\n    ungetc(nextc, input);\n    return false;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__shell_server.8.c", "original_string": "void shellServerTask(void *param)\n{\n   error_t error;\n   SshChannel *channel;\n   ShellServerSession *session;\n   session = (ShellServerSession *) param;\n   TRACE_INFO(\"Starting shell task...\\r\\n\");\n   error = NO_ERROR;\n   while(1)\n   {\n      osWaitForEvent(&session->startEvent, INFINITE_DELAY);\n      TRACE_INFO(\"Starting shell session...\\r\\n\");\n      channel = session->channel;\n      if(session->state == SHELL_SERVER_SESSION_STATE_OPEN)\n      {\n         sshSetChannelTimeout(channel, INFINITE_DELAY);\n         if(session->bufferLen > 0)\n         {\n            error = sshWriteChannel(channel, session->buffer,\n               session->bufferLen, NULL, 0);\n         }\n         if(!error)\n         {\n            error = sshWriteChannel(channel, session->prompt,\n               osStrlen(session->prompt), NULL, 0);\n         }\n         session->bufferLen = 0;\n         session->bufferPos = 0;\n         session->escSeqLen = 0;\n         while(!error)\n         {\n            SshChannelEventDesc eventDesc[1];\n            eventDesc[0].channel = channel;\n            eventDesc[0].eventMask = SSH_CHANNEL_EVENT_RX_READY;\n            eventDesc[0].eventFlags = 0;\n            error = sshPollChannels(eventDesc, 1, &session->event,\n               SHELL_SERVER_TICK_INTERVAL);\n            if(error == NO_ERROR || error == ERROR_TIMEOUT)\n            {\n               if(session->windowResize)\n               {\n                  error = shellServerProcessWindowResize(session);\n               }\n               if(eventDesc[0].eventFlags != 0)\n               {\n                  error = shellServerProcessChar(session);\n               }\n               else\n               {\n                  error = NO_ERROR;\n               }\n            }\n            else\n            {\n               break;\n            }\n         }\n      }\n      else if(session->state == SHELL_SERVER_SESSION_STATE_EXEC)\n      {\n         session->buffer[session->bufferLen] = '\\0';\n         error = shellServerProcessCommandLine(session, session->buffer);\n      }\n      else\n      {\n      }\n      sshCloseChannel(channel);\n      session->state = SHELL_SERVER_SESSION_STATE_CLOSED;\n      TRACE_INFO(\"Shell session terminated...\\r\\n\");\n   }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__delete_node_manually.2.c", "original_string": "void deletenode(int position)\n{\n    int i;\n    if(position==1)\n    {\n        struct node*temp;\n        temp=head;\n        head=head->next;\n        free(temp);\n    }\n    else\n    {\n        struct node*temp1;\n        temp1=head;\n        for(i=1;i<=position-2;i++)\n        {\n            temp1=temp1->next;\n        }\n        struct node*temp2;\n        temp2=temp1->next;\n        temp1->next=temp2->next;\n        free(temp2);\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post-a.4.c", "original_string": "void preorder(list *root)\n{\n    if (root != NULL)\n    {\n        printf(\"%d \\n\", root->key); \n        preorder(root->left);\n        preorder(root->right);\n    }\n}"}
{"author": "zjzj-zz", "file": "4s_Numerical__sakusei.0.c", "original_string": "void Create(){\n    FILE *rf;\n    double sum, a, kakuritu[27];\n    int i = 0, n;\n    srand(time(NULL));\n    rf = fopen(\"probability.txt\", \"r\");\n    while( ! feof(rf)){\n        fscanf(rf, \"%lf\\n\", &kakuritu[i]);\n        i++;\n    }\n    for(i = 0; i < 100; i++){\n        a = (rand() % 1000000 + 1);\n        a /= 1000000;\n        for(sum = n = 0; sum < 1; n++){\n            sum += kakuritu[n];\n            if(a < sum){\n                if(n == 26){\n                    printf(\"%c\", 0x20);\n                    break;\n                }else{\n                    printf(\"%c\", n+65);\n                    break;\n                }\n            }\n        }\n    }\n    printf(\"\\n\");\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_windows.14.c", "original_string": "bool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)\n{\n   semaphore->handle = CreateSemaphore(NULL, count, count, NULL);\n   if(semaphore->handle != NULL)\n      return TRUE;\n   else\n      return FALSE;\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_embos.0.c", "original_string": "void osInitKernel(void)\n{\n   osMemset(tcbTable, 0, sizeof(tcbTable));\n   osMemset(stkTable, 0, sizeof(stkTable));\n   OS_IncDI();\n   OS_InitKern();\n   OS_InitHW();\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q2.6.c", "original_string": "void levelorder(node* root) \n{\n    queue q;\n    q.front = MAX/2;\n    q.rear = MAX/2;\n    InsertQ(&q, root);\n    while (!QIsEmpty(&q)) \n    {\n        node* temp = DeleteQ(&q);\n        printf(\"%d\\t\", temp->data);\n        if (temp->left) \n            InsertQ(&q, temp->left);\n        if (temp->right) \n            InsertQ(&q, temp->right);\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__ext3_intr.1.c", "original_string": "void intr_config(void)\n{\n    PINSEL1 |= (1<<29);\n    PINSEL1 &= ~(1<<28);    \n    VICIntSelect &= ~(1<<17);       \n    VICVectCntl1    = (1<<5)| 17;   \n    VICVectAddr1    =   (long)eint1_isr;\n    VICIntEnable = 1<<17;\n    EXTMODE = (1<<3);       \n    EXTPOLAR    = (1<<3);       \n}"}
{"author": "augustogunsch", "file": "jackc__parser-structure.12.c", "original_string": "SUBROUTBODY* parsesubroutbody(PARSER* p) {\n    SUBROUTBODY* subroutbody = (SUBROUTBODY*)malloc(sizeof(SUBROUTBODY));\n    subroutbody->vardecs = parsevardecs(p);\n    subroutbody->statements = parsestatements(p);\n    return subroutbody;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-statements.2.c", "original_string": "STATEMENT* parsestatements(PARSER* p) {\n    STATEMENT* head = parsestatementnullified(p);\n    STATEMENT* curr = head;\n    STATEMENT* next;\n    while(next = parsestatementnullified(p), next != NULL) {\n        curr->next = next;\n        curr = next;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica3-3a.3.c", "original_string": "void producirDato(int numero){    \n    v[indiceProduccion] = numero;    \n    indiceProduccion = (indiceProduccion +1)%n; \n    for(int i=0; i<n; i++){ printf(\"%d \", v[i]); }\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__sender0.2.c", "original_string": "int frame_construction(unsigned char *sta_addr, unsigned char *des_addr,\n                        unsigned short protocol, unsigned char *payload,\n                        unsigned int payload_len)\n{   \n    if(payload_len < 46){\n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(payload_len >1500){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    memcpy(&frame[0],des_addr,6);\n    memcpy(&frame[6],sta_addr,6);\n    memcpy(&frame[12],&protocol,sizeof(protocol));\n    memcpy(&frame[14],payload,payload_len);\n    init_crc_table();\n    unsigned int crc32_result = crc32(frame,14+payload_len);\n    memcpy(&frame[14+payload_len],&crc32_result,sizeof(crc32_result));\n        unsigned char crc32_result_[4];\n    memcpy(crc32_result_,&crc32_result,sizeof(crc32_result));\n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: %x\\n\",sta_addr);\n    printf(\"Des address  : %x\\n\",des_addr);\n    printf(\"protocol     : %x\\n\",protocol);\n    printf(\"payload      : %x\\n\",payload);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result_,4);\n    printf(\"**************************************\\n\");\n    return payload_len+6+6+sizeof(protocol)+sizeof(crc32_result);\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es2.0.c", "original_string": "void isPrime(int dim, int a[])\n{\n    int contatore = 0, prime;\n    int b[dim];\n    for(int i=0; i<dim; i++)\n    {\n        for(int j=0; j<dim; j++)\n        {\n            prime = 0;\n            if((i != j) && (a[i] % a[j] != 0))\n            {\n                prime = 1;\n                break;                     \n            }\n        }\n        if(prime == 1)\n        {\n            b[i] = a[i];\n        } else {\n            b[i] = 0;\n        }\n        printf(\"b[%d] = %d\\n\",i, b[i]);          \n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__DemoFOTAUpdateSelfTest.3.c", "original_string": "void validateFirmwareUpdateReversion(void)\n{\n  printf(\"Validating previous firmware\\n\");\n  if (runRandomSelfTest(SIMULATED_REVERSION_SUCCESS_RATE)) \n  {\n    printf(\"Firmware update successfully reverted\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_REVERSION_SUCCEEDED);\n  }\n  else\n  {\n    printf(\"Firmware update reversion failed\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_REVERSION_FAILED);\n  }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__nonVIC.1.c", "original_string": "void interrupt_config(void)\n{\n    PINSEL0 |= (1<<29);\n    PINSEL0 &= ~(1<<28);                                                    \n    VICIntSelect &= ~((1<<4)|(1<<5)|(1<<15));           \n    VICDefVectAddr  = (long)nonvic_isr;\n    VICIntEnable    = (1<<4)|(1<<5)|(1<<15) ;               \n    EXTMODE = (1<<1);                                                       \n    EXTPOLAR    = (1<<1);                                                       \n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__shell_server.3.c", "original_string": "error_t shellServerSetBanner(ShellServerSession *session,\n   const char_t *banner)\n{\n   size_t n;\n   if(session == NULL || banner == NULL)\n      return ERROR_INVALID_PARAMETER;\n   n = osStrlen(banner);\n   if(n > SHELL_SERVER_BUFFER_SIZE)\n      return ERROR_INVALID_LENGTH;\n   osStrncpy(session->buffer, banner, n);\n   session->bufferLen = n;\n   session->bufferPos = 0;\n   return NO_ERROR;\n}"}
{"author": "2security", "file": "String__18FindNoOfHighOccurrence.1.c", "original_string": "int main()\n    {\n        int freq[size],i,c=0,t;\n        char str[size],ch;\n        printf(\"\\n Enter the string\");\n        gets(str);\n        for(i=0;i<size;i++)\n                freq[i]=0;\n        for(i=0;i<str[i]!='\\0';i++)\n            {\n                t=(int)str[i];\n                freq[t]=freq[t]+1;\n            }\n        for(i=0;i<size;i++)\n            printf(\"%d \",freq[i]);\n        i=MyMax(freq,size);\n        printf(\"\\n No of occurrence of '%c' is =%d\",i,freq[i]);\n        return 0;\n    }"}
{"author": "ankitraj311", "file": "450_babbar__6_union_array_SELF_unsorted_array.2.c", "original_string": "int main()\n{\n  int arr1[] = {1,2,3,5,6,7,8,9,10}, arr2[] = {10,2,3,6,4,9,8,7,2,3,1} ,no,j=0,temp=0,mid=0,n=0;\n  int size_arr1 = sizeof(arr1)/sizeof(int), size_arr2 = sizeof(arr2)/sizeof(int);\n  array_print(arr1,size_arr1);\n  array_print(arr2,size_arr2);\n  union_array(arr1,arr2,size_arr1,size_arr2);\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Deletion_At_Any_Position_In_a_Single_Linked_List.1.c", "original_string": "void display_nodes(struct node*temp1)\n{\n    printf(\"The Elements are:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__53_count_repeatation_of_Vowel.0.c", "original_string": "int main()\n{\n  int i,j,k, count = 0;\n  char str_arr[100], f;\n  printf(\"Enter Character to find out Vowel/Consonant\");\n  scanf(\"%[^\\n]s\",str_arr);\n  printf(\"Enter Vowel whose count you want to find\\n\");\n  scanf(\" %c\",&f);\n  for(i=0; str_arr[i] != '\\0'; i++)\n  {\n    if(str_arr[i] == f)\n    {\n      count++;\n    }\n  }\n  if(count ==  0)\n  {\n    printf(\"Not even a Single Time Vowel is Found\");\n  }\n  else\n  {\n    printf(\"Vowel is Found %d Times\",count);\n  }\n}"}
{"author": "Theemiss", "file": "simple_shell__more_fun.0.c", "original_string": "char *_strcpy(char *dest, char *src)\n{\nint i;\ni = 0;\n    while (src[i])\n    {\n        dest[i] = src[i];\n        i++;\n    }\ndest[i] = '\\0';\nreturn (dest);\n}"}
{"author": "behergue", "file": "Operating_Systems__myFS.3.c", "original_string": "int findFreeNode(MyFileSystem* myFileSystem)\n{\n    int i;\n    for(i = 0; i < MAX_NODES; i++) {\n        if(myFileSystem->nodes[i] == NULL)\n            return i;\n    }\n    return -1;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__12_While.0.c", "original_string": "int main()\n{\n    char letra;\n    int i = 0;\n    int j;\n    while( i< 7){\n    switch (i){\n            case 0: letra = 'P';break;\n            case 1: letra = 'N';break;\n            case 2: letra = 'L';break;\n            case 3: letra = 'J';break;\n            case 4: letra = 'H';break;\n            case 5: letra = 'F';break;\n            case 6: letra = 'D';break;\n    }\n    j = 0;\n    while(j <= 13){\n        if(j >= (1 + i) && j <= (13-i))\n            printf(\"%c\", letra);\n        else\n        printf(\" \");\n        ++j;\n    }\n        printf(\"\\n\");\n        ++i;\n    }\n    return 0; \n}"}
{"author": "sdukesameer", "file": "dsa__post-eva.5.c", "original_string": "float operation(float f, char x, float s)\n{\n    if (x=='+')\n        return f+s;\n    if (x=='-')\n        return f-s;\n    if (x=='*')\n        return f*s;\n    else\n        return f/s;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__str_capitalizer.1.c", "original_string": "int     tolowerr(char a, char d)\n{\n    if (a >= 'A' && a <= 'Z')\n    {\n        if (d != ' ' && d != '\\t' && d != '\\0')\n        {\n            return (1);\n        }\n    }\n    return (0);\n}"}
{"author": "augustogunsch", "file": "jackc__io.0.c", "original_string": "char* strtail(char* str, int len, int count) {\n    int index = len - count;\n    if (index <= 0) return str;\n    return str + (sizeof(char) * (index));\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__20_Dowhile.1.c", "original_string": "double Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    do{\n    Total *= numero;\n    ++i;\n    }while(i < exponente);\n    return Total;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__io.7.c", "original_string": "char* getoutname(char* fullname, int len) {\n    char* trimmed = trimstr(fullname, len, 4);\n    int sz = sizeof(char) * (len-1);\n    char* outname = (char*)malloc(sz);\n    sprintf(outname, \"%svm\", trimmed);\n    free(trimmed);\n    return outname;\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__unique.5.c", "original_string": "void change(int vector[], int i, int j){\n  int aux;\n  aux = vector[i];\n  vector[i] = vector[j];\n  vector[j] = aux;\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__3-quick_sort.1.c", "original_string": "void quicksort(int *array, int lo, int hi, size_t size)\n{\n    int q;\n    if (lo < hi)\n    {\n        q = partition(array, lo, hi, size);\n        quicksort(array, lo, q - 1, size);\n        quicksort(array, q + 1, hi, size);\n    }\n}"}
{"author": "christiane-millan", "file": "UTM2020B-102A-025011-Structured-Programming__primos.1.c", "original_string": "int es_primo(int numero){\n    for (int i = 2; i <= sqrt(numero); i++){\n        if ( numero % i == 0) {\n            return 0;\n        }\n    }\n    return 1;\n}"}
{"author": "Ana-Morales", "file": "binary_trees__16-binary_tree_is_perfect.2.c", "original_string": "int binary_tree_is_perfect(const binary_tree_t *tree)\n{\n    if (tree == NULL || (binary_tree_balance(tree) != 0))\n        return (0);\n    if (tree->left == NULL && tree->right == NULL)\n        return (1);\n    return (binary_tree_is_perfect(tree->left)\n        * binary_tree_is_perfect(tree->right));\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__reverse_the_DLL.4.c", "original_string": "void reverse()\n{\n    struct node *currentnode,*nextnode,*prenode;\n    prenode=0;\n    currentnode=nextnode=head;\n    while(nextnode!=0)\n    {\n        nextnode=nextnode->next;\n        currentnode->next=prenode;\n        currentnode->pre=nextnode;\n        prenode=currentnode;\n        currentnode=nextnode;\n    }\n    head=prenode;\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__107-quick_sort_hoare.1.c", "original_string": "void quicksort_hoare(int *array, int lo, int hi, size_t size)\n{\n    int p;\n    if (lo < hi)\n    {\n        p = partition(array, lo, hi, size);\n        quicksort_hoare(array, lo, p, size);\n        quicksort_hoare(array, p + 1, hi, size);\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__DemoFOTAUpdateSelfTest.1.c", "original_string": "static bool runRandomSelfTest(uint8_t successRate)\n{\n  if (((uint8_t)((rand() % 100))) >= (successRate)) \n  {\n    printf(\"Firmware self test failed (reason: simulated pseudo-random failure)\\n\");\n    return false;\n  }\n  return true;\n}"}
{"author": "dle2005", "file": "Algorithm__Knapsack3.1.c", "original_string": "void insert(node v) {\n    rear = rear+1;\n    queue[rear].level = v.level;\n    queue[rear].profit = v.profit;\n    queue[rear].weight = v.weight;\n    queue[rear].bound = v.bound;\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__sender.2.c", "original_string": "int frame_construction(unsigned char *sta_addr, unsigned char *des_addr,\n                        unsigned short protocol, unsigned char *payload,\n                        unsigned int payload_len)\n{   \n    if(payload_len < 46){\n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(payload_len >1500){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    memcpy(&frame[0],des_addr,6);\n    memcpy(&frame[6],sta_addr,6);\n    memcpy(&frame[12],&protocol,sizeof(protocol));\n    memcpy(&frame[14],payload,payload_len);\n    init_crc_table();\n    unsigned int crc32_result = crc32(frame,14+payload_len);\n    memcpy(&frame[14+payload_len],&crc32_result,sizeof(crc32_result));\n        unsigned char crc32_result_[4];\n    memcpy(crc32_result_,&crc32_result,sizeof(crc32_result));\n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: %x\\n\",sta_addr);\n    printf(\"Des address  : %x\\n\",des_addr);\n    printf(\"protocol     : %x\\n\",protocol);\n    printf(\"payload      : %x\\n\",payload);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result_,4);\n    printf(\"**************************************\\n\");\n    return payload_len+6+6+sizeof(protocol)+sizeof(crc32_result);\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__25_insert_specific.0.c", "original_string": "int main()\n{\n  int i=0,j=0,k=0,array1[100]={0},array2[100] = {0}, no=0,insert_no=0,insert_index=0,flag=0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n  printf(\"Enter number to insert and position it from Array\\n\");\n  scanf(\"%d%d\",&insert_no,&insert_index);\n  insert_index = insert_index - 1;\n  for(i=0; i<no+1; i++)\n  {\n    if( i < insert_index)\n    {\n      array2[i] = array1[i];\n    }\n    if( i == insert_index)\n    {\n      array2[i] = insert_no;\n    }\n    if( i > insert_index)\n    {\n      array2[i] = array1[i-1];\n    }\n  }\n  printf(\"\\n\");\n  for(i=0; i<no+1; i++)\n  {\n    printf(\"%d \",array2[i]);\n  }\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__tree.5.c", "original_string": "void inorder_1(struct database *node){\n    if(node == NULL){\n        return;\n    } else {\n        inorder_1(node->right);\n        printf(\"%d\\n\",node->roll_no);\n        inorder_1(node->left);\n    }\n}"}
{"author": "0712023", "file": "Arduino-Mood-Light-DIY-kit__Chapter2_Sensor.4.c", "original_string": "void cds_set() {\n  if ( cds_RGB ) {\n    r = random(255);\n    g = random(255);\n    b = random(255);\n    cds_RGB = false;\n  }\n  int cds = analogRead(CDS_PIN);\n  cds_cur = (0.99 * cds_pre) + (0.01 * cds);\n  cds_pre = cds_cur;\n  cds = cds_cur;\n  if ( cds <= cds_1 )\n    cds = cds_1;\n  else if ( cds_2 < cds )\n    cds = cds_2;\n  for (int i = 0; i < NUMPIXELS; i++) {\n    pixels.setPixelColor(i, pixels.Color( map(cds, cds_1, cds_2, 0 , r) , map(cds, cds_1, cds_2, 0 , g) , map(cds, cds_1, cds_2, 0 , b) ) );\n    pixels.show();\n  }\n}"}
{"author": "sdukesameer", "file": "dsa__Md_Sameer_13000119114.2.c", "original_string": "list *newNode(int item){\n    list *temp = (list*)malloc(sizeof(list));\n    temp->key = item;\n    temp->left = temp->right = NULL;\n    return temp; \n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad10.3.c", "original_string": "stackPointer AllocateMemoryForStackElement(stackPointer head, char sign)\n{\n    stackPointer newStackElement = (stackPointer)malloc(sizeof(struct stack));\n    if (!newStackElement)\n    {\n        printf(\"Neuspjesna alokacija memorije!\\n\");\n        return newStackElement;\n    }\n    newStackElement->next = NULL;\n    newStackElement->nextTree = AllocateMemoryForTree(sign);\n    return newStackElement;\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_cmsis_rtos2.12.c", "original_string": "bool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   uint32_t flags;\n   if(timeout == INFINITE_DELAY)\n   {\n      flags = osEventFlagsWait(event->id, 1, osFlagsWaitAny, osWaitForever);\n   }\n   else\n   {\n      flags = osEventFlagsWait(event->id, 1, osFlagsWaitAny,\n         OS_MS_TO_SYSTICKS(timeout));\n   }\n   if(flags == 1)\n      return TRUE;\n   else\n      return FALSE;\n}"}
{"author": "haon1026", "file": "linux-programming__deadlock2.2.c", "original_string": "int main()\n{\n    pthread_mutex_init(&mutex1, NULL);\n    pthread_mutex_init(&mutex2, NULL);\n    pthread_t tid1, tid2;\n    pthread_create(&tid1, NULL, fun1, NULL);\n    pthread_create(&tid2, NULL, fun2, NULL);\n    pthread_join(tid1, NULL);\n    pthread_join(tid2, NULL);\n    pthread_mutex_destroy(&mutex1);\n    pthread_mutex_destroy(&mutex2);\n    return 0;\n}"}
{"author": "Theemiss", "file": "simple_shell__more_charfun.2.c", "original_string": "char *_itoa(unsigned int n)\n{\n    int len = 0, i = 0;\n    char *s;\n    len = intlen(n);\n    s = malloc(len + 1);\n    if (!s)\n        return (NULL);\n    *s = '\\0';\n    while (n / 10)\n    {\n        s[i] = (n % 10) + '0';\n        n /= 10;\n        i++;\n    }\n    s[i] = (n % 10) + '0';\n    array_rev(s, len);\n    s[i + 1] = '\\0';\n    return (s);\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__cub2d.1.c", "original_string": "void        update(void)\n{\n    float   newx;\n    float   newy;\n    float   move_step;\n    g_player.rotation_angle += g_player.turn_direction *\n                                g_player.rotation_speed;\n    move_step = g_player.walk_direction * g_player.move_speed;\n    newx = g_player.x + cos(g_player.rotation_angle) * move_step;\n    newy = g_player.y + sin(g_player.rotation_angle) * move_step;\n    if (!has_wall(newx, newy))\n    {\n        g_player.x = newx;\n        g_player.y = newy;\n    }\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__goal_client.4.c", "original_string": "void recv_msg_handler() {\n    char message[LENGTH] = {};\n  while (1) {\n        int receive = recv(sockfd, message, LENGTH, 0);\n    if (receive > 0) {\n      printf(\"%s\", message);\n      str_overwrite_stdout();\n    } else if (receive == 0) {\n            break;\n    } else {\n        }\n        memset(message, 0, sizeof(message));\n  }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_any_pos_DLL.1.c", "original_string": "void creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es8.1.c", "original_string": "void similitudine(Triangolo t1, Triangolo* t2)\n{\n    if((t1.alfa == t2->alfa) && (t1.beta == t2->beta) && (t1.gamma == t2->gamma))\n    {\n        printf(\"\\n0 - l'equivalenza \u00e8 vera\");\n    } else {\n        printf(\"\\n1 - l'equivalenza \u00e8 falsa\");\n    }\n}"}
{"author": "ria3999", "file": "cbnst__NEWTON_FORWARD_INTERPOLATION.2.c", "original_string": "int main()\n{\n    int n,i,j,u;\n    float x[90],value;\n    float y[90][90],sum=0;\n    printf(\"\\n\\n***INPUT***\\n\\n\");\n    printf(\"Enter n:\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter the values of x\\n\");\n    for(i=0;i<n;i++)\n        scanf(\"%f\",&x[i]);\n    printf(\"Enter the values of y\\n\");\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<1;j++)\n        {\n            scanf(\"%f\",&y[i][j]);\n        }\n    }\n    for (int i = 1; i < n; i++)\n    {\n        for (int j = 0; j < n - i; j++)\n            y[j][i] = y[j + 1][i - 1] - y[j][i - 1];\n    }\n    printf(\"forward difference table is:\\n\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%f \",x[i]);\n        for (int j = 0; j < n - i; j++)\n            printf(\"%f \",y[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"Enter value:\\n\");\n    scanf(\"%f\",&value);\n    sum = y[0][0];\n    u = (value - x[0]) / (x[1] - x[0]);\n    for (int i = 1; i < n; i++) {\n        sum = sum + (cal(u, i) * y[0][i]) /\n                                 fact(i);\n    }\n    printf(\"\\n\\n***OUTPUT***\\n\\n\");\n    printf(\"Value at %f is %f\",value,sum);\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__insertAfter.2.c", "original_string": "void insertAfter(nptr &head, int x, int key)\n{\n    nptr temp = head;\n    while(temp != NULL)\n    {\n        if (temp -> data == key)\n        {\n            nptr newNode = createNode(x);\n            newNode -> next = temp -> next;\n            temp -> next = newNode;\n            return;\n        }\n        temp = temp -> next;\n    }\n    printf(\"Element wasn't found\\n\");\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__70.0.c", "original_string": "void imprime_sem(aluno_t *alunos, int x, int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        if (alunos[i].semestre == x)\n        {\n            printf(\"\\nNome: %s\\n\", alunos[i].nome);\n            printf(\"Semestre: %i\\n\", alunos[i].semestre);\n            printf(\"Rendimento acad\u00eamico: %f\\n\", alunos[i].ra);\n        }\n    }\n}"}
{"author": "2security", "file": "Matrix__33CheckLowerTriangularMatrix.1.c", "original_string": "int main()\n    {\n    int i,j,r,c,mat1[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    if(r!=c)\n        printf(\"For checking Lower triangualr matrix or not matrix should be square\");\n    else\n        {\n        printf(\"\\n Enter the matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        if(checkLowerTri(mat1,r)==1)\n            printf(\"Matrix is Lower triangualr matrix\");\n        else\n            printf(\"Matrix is not Lower triangualr matrix\");\n        }\n    return 0;\n    }"}
{"author": "zjzj-zz", "file": "4s_Numerical__generation.2.c", "original_string": "void Create(){\n    srand(time(NULL));\n    i = 0;\n    rf = fopen(\"probability.txt\", \"r\");\n    while(! feof(rf)){\n        fscanf(rf, \"%lf\\n\", &kakuritu[i]);\n        i++;\n    }\n    for(i = 0; i < 100; i++){\n        r = (rand() % 1000000 + 1);\n        r /= 1000000;\n        for(sum = n = 0; sum < 1; n++){\n            sum += kakuritu[n];\n            if(r < sum){\n                if(n == 26){\n                    printf(\"%c\", 0X20);\n                    break;\n                }else{\n                    printf(\"%c\", n+65);\n                    break;\n                }\n            }\n        }\n    }\n    printf(\"\\n\");\n    fclose(rf);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__sftp_server_directory.1.c", "original_string": "error_t sftpServerRemoveDir(SftpServerSession *session,\n   const SshString *path)\n{\n   error_t error;\n   uint_t perm;\n   SftpServerContext *context;\n   context = session->context;\n   error = sftpServerGetPath(session, path, context->path,\n      SFTP_SERVER_MAX_PATH_LEN);\n   if(error)\n      return error;\n   perm = sftpServerGetFilePermissions(session, context->path);\n   if((perm & SFTP_FILE_PERM_WRITE) == 0)\n      return ERROR_ACCESS_DENIED;\n   error = fsRemoveDir(context->path);\n   return error;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica2-1.0.c", "original_string": "int main(){\n    int n = 2;\n    float total = 0, * subtotal;\n    pthread_t hilos[n];\n    for (int i = 0; i < n; i++){ pthread_create(&hilos[i], NULL, (void *) aleatorio, NULL); } \n    for (int i = 0; i < n; i++){\n       pthread_join(hilos[i], (void **) &subtotal); \n       printf(\"Valor recibido: %f\\n\", *subtotal); \n       total = total + *subtotal; \n    }\n    printf(\"la suma del total es: %f\\n\", total);\n    exit(EXIT_SUCCESS);\n}"}
{"author": "mehedi9021", "file": "Data_Structure__reverse_single_linked_list.2.c", "original_string": "void print(){\nstruct node*temp;\ntemp=head;\nwhile(temp!=NULL)\n{\n    printf(\"%d\\n\", temp->data);\n    temp=temp->next;\n}\n}"}
{"author": "earth429", "file": "mulpre__check1.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a, b, c, d, e;\n    int r;     \n    srandom(time(NULL)); \n    clearByZero(&a); \n    printf(\"a = \"); \n    dispNumberZeroSuppress(&a);\n    printf(\"\\n\");\n    setRnd(&b, 10); \n    printf(\"b = \"); \n    dispNumberZeroSuppress(&b);\n    printf(\"\\n\");\n    copyNumber(&b, &c); \n    printf(\"c = \"); \n    dispNumberZeroSuppress(&c);\n    printf(\"\\n\");\n    r = mulBy10(&b, &d); \n    printf(\"b * 10 = \"); \n    dispNumberZeroSuppress(&d);\n    printf(\", r = %d\\n\", r);\n    r = divBy10(&c, &e); \n    printf(\"c / 10 = \"); \n    dispNumberZeroSuppress(&e);\n    printf(\", r = %d\\n\", r);\n    printf(\"a == 0? --> %d\\n\", isZero(&a)); \n    printf(\"b == 0? --> %d\\n\", isZero(&b));\n    printf(\"c == 0? --> %d\\n\", isZero(&c));\n    printf(\"d == 0? --> %d\\n\", isZero(&d));\n    printf(\"e == 0? --> %d\\n\", isZero(&e));\n    return (0);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q3_reverselq.2.c", "original_string": "char* delf(nptr list)\n{\n    if(!(list->rlink))\n    {\n        printf(\"Underflow!!\\n\"); \n        return NULL;\n    }\n    nptr temp=list->rlink;\n    list->rlink=temp->rlink;\n    if(temp->rlink)\n        (temp->rlink)->llink=list;\n    char* str=(char*)malloc(SIZE*sizeof(char));\n    strcpy(str,temp->ele);\n    free(temp);\n    return str;\n}"}
{"author": "theuwis", "file": "AdventOfCode2017__main22.0.c", "original_string": "int is_anagram(char *first_string, char *second_string){\n    int first_char_counter[256] = {0}, second_char_counter[256] = {0};\n    int counter;\n    if(strlen(first_string) != strlen(second_string)){\n        return 0;\n    }\n    for(counter = 0; first_string[counter] != '\\0'; counter++){\n      first_char_counter[first_string[counter]]++;\n    }\n    for(counter = 0; second_string[counter] != '\\0'; counter++){\n      second_char_counter[second_string[counter]]++;\n    }\n    for(counter = 0; counter < 256; counter++){\n        if(first_char_counter[counter] != second_char_counter[counter])\n            return 0;\n    }\n    return 1;\n}"}
{"author": "0712023", "file": "Arduino-Mood-Light-DIY-kit__Chapter2_Sensor.2.c", "original_string": "void Mode_set() {\n  if ( Mode == 1) {\n    r = 210;\n    g = 100;\n    b = 10;\n  }\n  else if ( Mode == 2 ) {\n    temp_set();\n  }\n  else if ( Mode == 3 ) {\n    cds_set();\n  }\n  else if ( Mode == 4 ) {\n    ultra_set();\n  }\n  else if ( Mode == 5 ) {\n    temp_set();\n    cds_set();\n  }\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__queue_at_the_school.0.c", "original_string": "int main(){\n  int n, t;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &t);\n  char s[n];\n  if(n < 1 || t < 1\n     || n > 50 || t > 50)\n    return 0;\n  scanf(\"%s\", s);\n  for(int j = 1; j <=t; j++)\n    for(int i = 0; i < n; i++)\n      if(i+1 < n)\n    if(s[i] == 'B' && s[i+1] == 'G'){\n      change(s, i, i+1);\n      i = i+1;\n    }\n  printf(\"%s\\n\", s);\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad9.8.c", "original_string": "treePointer FindElement(int element, treePointer root)\n{\n    if (!root)\n        return root;\n    else if (element < root->data)\n        return FindElement(element, root->left);\n    else if (element > root->data)\n        return FindElement(element, root->right);\n    else\n        return root;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__poly.2.c", "original_string": "void display(nptr head)\n{\n    while(head)\n    {\n        printf(\"%dx^%d\", head -> coeff, head -> exp);\n        if(head -> next)\n            printf(\" + \");\n        head = head -> next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "RafaelFelisbino-hub", "file": "FUNCOES-exercices__Exercicio5FUNCAO.2.c", "original_string": "int diasVividos(int idade)\n{\n    int anos, meses = 0, ano1 = 0;\n    printf(\"Digite sua idade em anos:  \");\n    scanf_s(\"%i\", &idade);\n    printf(\"Digite sua data de nascimento separado por barra 00/00/0000:  \");\n    scanf_s(\"%i/%i/%i\", &dia, &mes, &ano);\n    ano1 = (2020 - ano) * 365;\n    meses = (11 - mes) * 30;\n    anos = dia + meses + ano1;\n    return(anos);\n}"}
{"author": "augustogunsch", "file": "jackc__parser-tree.10.c", "original_string": "void freestatements(STATEMENT* s) {\n    if(s->type == letstatement)\n        freelet(s->letstatement);\n    else if(s->type == ifstatement)\n        freeif(s->ifstatement);\n    else if(s->type == whilestatement)\n        freecond(s->whilestatement);\n    else if(s->type == dostatement)\n        freesubroutcall(s->dostatement);\n    else if(s->retstatement != NULL)\n        freeexpression(s->retstatement);\n    free(s->debug);\n    STATEMENT* next = s->next;\n    free(s);\n    if(next != NULL)\n        freestatements(next);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__BJ.1.c", "original_string": "int main()\n{\n    char str[100002], letters[100002];\n    int qtd, tam_s, impar = false, pali = true;\n    fgets(str, 100002, stdin);\n    if (str[strlen(str) - 1] == '\\n')\n    {\n        str[strlen(str) - 1] = '\\0';\n    }\n    fill_letters(str, letters);\n    tam_s = strlen(str);\n    for (int i = 0; (letters[i] != '\\0') && (pali == true); i++)\n    {\n        qtd = 0;\n        for (int j = 0; str[j] != '\\0'; j++)\n        {\n            if (letters[i] == str[j])\n            {\n                qtd++;\n            }\n        }\n        if (tam_s % 2 == 0)\n        {\n            if (qtd % 2 != 0)\n            {\n                pali = false;\n            }\n        }\n        else\n        {\n            if (qtd % 2 != 0)\n            {\n                if (impar == false)\n                {\n                    impar = true;\n                }\n                else if (impar == true)\n                {\n                    pali = false;\n                }\n            }\n        }    \n    }\n    if (pali == true)\n    {\n        printf(\"Sim\\n\");\n    }\n    else\n    {\n        printf(\"Nao\\n\");\n    }\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_pst.1.c", "original_string": "void rstpPstFsm(RstpBridgePort *port)\n{\n   switch(port->pstState)\n   {\n   case RSTP_PST_STATE_DISCARDING:\n      if(port->learn)\n      {\n         rstpPstChangeState(port, RSTP_PST_STATE_LEARNING);\n      }\n      break;\n   case RSTP_PST_STATE_LEARNING:\n      if(port->forward)\n      {\n         rstpPstChangeState(port, RSTP_PST_STATE_FORWARDING);\n      }\n      else if(!port->learn)\n      {\n         rstpPstChangeState(port, RSTP_PST_STATE_DISCARDING);\n      }\n      else\n      {\n      }\n      break;\n   case RSTP_PST_STATE_FORWARDING:\n      if(!port->forward)\n      {\n         rstpPstChangeState(port, RSTP_PST_STATE_DISCARDING);\n      }\n      break;\n   default:\n      rstpFsmError(port->context);\n      break;\n   }\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__41_mul_n_matrix.0.c", "original_string": "int main()\n{\n  int i,j,k,r1,c1,r2,c2,flag = 0;\n  printf(\"Enter Value of r1, c1, r2, c2\\n\");\n  scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n  int m1[r1][c1], m2[r2][c2], sum = 0, mul[r1][c2];\n  printf(\"Enter value of Matrix1\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      scanf(\"%d\",&m1[i][j]);\n    }\n  }\n  do\n  {\n    printf(\"Enter value of Matrix2\\n\");\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        scanf(\"%d\",&m2[i][j]);\n      }\n    }\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        for(k=0; k<r2; k++)\n    {\n          sum = sum + m1[i][k]* m2[k][j];\n    }\n    mul[i][j] = sum;\n    sum = 0;\n      }\n    }\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        printf(\"%d \",mul[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        m1[i][j] = mul[i][j];\n    mul[i][j] = 0;\n      }\n    }\n    printf(\"Enter 1 To Add more Matrix\\n\");\n    scanf(\"%d\",&flag);\n  }while(flag);\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__words_count_server.0.c", "original_string": "int main()\n{\n    const int SIZE=4096;\n    const char* name=\"vowels\";\n     int     shmid;\n     void* shmptr;\n     char s[FILESI];\n     printf(\"enter the file path\\n\");\n     scanf(\"%s\",s);\n     read_count(s);\n     shmid=shm_open(name,O_CREAT|O_RDWR,0666);\n     if(shmid<0){\n         perror(\"shmget\");\n         exit(1);\n     }\n     ftruncate(shmid,SIZE);\n     shmptr=mmap(0,SIZE,PROT_WRITE,MAP_SHARED,shmid,0);\n    printf(\"shared mym attached\\n\");\n    sprintf(shmptr,\"%d\",m);\n    shmptr +=sizeof(int);\n    sprintf(shmptr,\"%d\",n);\n    shmptr +=sizeof(int);\n     printf(\"open client\\n\");\n     sleep(10);\n     munmap(shmptr,SIZE);\n     shm_unlink(name);\n     return 0;\n}"}
{"author": "2security", "file": "Matrix__24SubMatrix.2.c", "original_string": "int main()\n    {\n    int i,j,r,c,mat1[20][20],mat2[20][20];\n    printf(\"\\n Enter the row & col. for two matrix(Both should be same): \");\n    scanf(\"%d%d\",&r,&c);\n    if(r!=c)\n        printf(\"\\n For Addition matrix should be square\");\n    else\n        {       \n        printf(\"\\n Enter the first matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        printf(\"\\n Enter the second matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat2[i][j]);\n        printf(\"\\n The addtion of two matrix is:\\n\");\n        SubMat(mat1,mat2,r,c);\n        }\n    return 0;\n    }"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__drv_ws2812.4.c", "original_string": "uint32_t drv_ws2812_display(void)\n{\n    if(!pwm_sequencue_finished) \n    {\n        return NRF_ERROR_BUSY;\n    }\n    convert_rgb_to_pwm_sequence();\n    pwm_sequencue_finished = false;\n    uint32_t err_code = nrfx_pwm_simple_playback(&m_pwm0, &pwm_sequence, 1, NRFX_PWM_FLAG_STOP);\n    return err_code;\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__31.0.c", "original_string": "int main(void)\n{\n    int a[tamanho], b[tamanho], aux;\n    printf(\"\\nInforme os n\u00fameros do vetor A:\\n\");\n    for (int i = 0; i < tamanho; i++)\n    {\n        scanf(\"%i\", &a[i]);\n    }\n    printf(\"\\nInforme os n\u00fameros do vetor B:\\n\");\n    for (int i = 0; i < tamanho; i++)\n    {\n        scanf(\"%i\", &b[i]);\n    }\n    for (int j = 0; j < tamanho; j++)\n    {\n        aux = a[j];\n        a[j] = b[j];\n        b[j] = aux;\n    }\n    printf(\"\\nVetor A: \");\n    for (int k = 0; k < tamanho; k++)\n    {\n        printf(\"%i \", a[k]);\n    }\n    printf(\"\\nVetor B: \");\n    for (int k = 0; k < tamanho; k++)\n    {\n        printf(\"%i \", b[k]);\n    }\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__row_cols.1.c", "original_string": "void rows(void)\n{\n    int val;\n    IODIR1 = IODIR1 & ~ROWS;        \n    IODIR1 = IODIR1 | COLS;         \n    val = IOPIN1 & ROWS;        \n    val = val >> 21;\n    switch(val)\n    {\n        case 0x0E:  lcd_str(\"r1\"); cols();  delay(200); break;\n        case 0x0D:  lcd_str(\"r2\"); cols();  delay(200); break;\n        case 0x0B:  lcd_str(\"r3\"); cols();  delay(200); break;\n        case 0x07:  lcd_str(\"r4\"); cols();  delay(200); break;\n    }\n}"}
{"author": "sdukesameer", "file": "c__structure.1.c", "original_string": "int enterStudents( studentType students[MAX] )\n{\n    int i;\n    for (i = 0; i < MAX; i++)\n    {\n        scanf(\"%d\",&students[i].rollNo);\n        if(students[i].rollNo==0)\n            break;\n        scanf(\"%[^\\n]s\",students[i].name);\n    }\n    return i;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_extended.0.c", "original_string": "static void on_write(ble_lbs_t * p_lbs, ble_evt_t const * p_ble_evt)\n{\n    ble_gatts_evt_write_t const * p_evt_write = &p_ble_evt->evt.gatts_evt.params.write;\n    if ((p_evt_write->handle == p_lbs->led_char_handles.value_handle)\n        && (p_evt_write->len == 1)\n        && (p_lbs->led_write_handler != NULL))\n    {\n        p_lbs->led_write_handler(p_ble_evt->evt.gap_evt.conn_handle, p_lbs, p_evt_write->data[0]);\n    }\n    else if ((p_evt_write->handle == p_lbs->led_col_char_handles.value_handle)\n        && (p_evt_write->len == 4)\n        && (p_lbs->led_col_write_handler != NULL))\n    {\n        uint32_t color = p_evt_write->data[0] << 16 | p_evt_write->data[1] << 8 | p_evt_write->data[2] << 0;\n        p_lbs->led_col_write_handler(p_ble_evt->evt.gap_evt.conn_handle, p_lbs, color);\n    }\n}"}
{"author": "dishanp", "file": "DSA__q25.0.c", "original_string": "void create(int A[], int n)\n{\n    struct node *t, *last;\n    first = (struct node*)malloc(sizeof(struct node));\n    first->data = A[0];\n    first->next = NULL;\n    last = first;\n    for(int i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__queue_using_linked_list.0.c", "original_string": "void enqueue(int x)\n{\n    struct node *newnode;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    newnode->data=x;\n    newnode->next=0;\n    printf(\"the data inserted is %d\\n\",x);\n    if(front==0 && rear==0)\n    {\n        front=rear=newnode;\n    }\n    else\n    {\n       rear->next=newnode;\n       rear=newnode;\n    }\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example41.1.c", "original_string": "int ekok(int x, int y)\n{\n  static int temp=1;\n    if(temp%y==0 && temp%x==0)  \n      return temp;\n    temp++;\n    ekok(x,y);\n    return(temp);\n}"}
{"author": "theuwis", "file": "project-euler__main11.0.c", "original_string": "int main(void){\n    unsigned long long answer = 0;\n    unsigned long long input[100] = {\n        37107287533902,\n        46376937677490,\n        74324986199524,\n        91942213363574,\n        23067588207539,\n        89261670696623,\n        28112879812849,\n        44274228917432,\n        47451445736001,\n        70386486105843,\n        62176457141856,\n        64906352462741,\n        92575867718337,\n        58203565325359,\n        80181199384826,\n        35398664372827,\n        86515506006295,\n        71693888707715,\n        54370070576826,\n        53282654108756,\n        36123272525000,\n        45876576172410,\n        17423706905851,\n        81142660418086,\n        51934325451728,\n        62467221648435,\n        15732444386908,\n        55037687525678,\n        18336384825330,\n        80386287592878,\n        78182833757993,\n        16726320100436,\n        48403098129077,\n        87086987551392,\n        59959406895756,\n        69793950679652,\n        41052684708299,\n        65378607361501,\n        35829035317434,\n        94953759765105,\n        88902802571733,\n        25267680276078,\n        36270218540497,\n        24074486908231,\n        91430288197103,\n        34413065578016,\n        23053081172816,\n        11487696932154,\n        63783299490636,\n        67720186971698,\n        95548255300263,\n        76085327132285,\n        37774242535411,\n        23701913275725,\n        29798860272258,\n        18495701454879,\n        38298203783031,\n        34829543829199,\n        40957953066405,\n        29746152185502,\n        41698116222072,\n        62467957194401,\n        23189706772547,\n        86188088225875,\n        11306739708304,\n        82959174767140,\n        97623331044818,\n        42846280183517,\n        55121603546981,\n        32238195734329,\n        75506164965184,\n        62177842752192,\n        32924185707147,\n        99518671430235,\n        73267460800591,\n        76841822524674,\n        97142617910342,\n        87783646182799,\n        10848802521674,\n        71329612474782,\n        62184073572399,\n        66627891981488,\n        60661826293682,\n        85786944089552,\n        66024396409905,\n        64913982680032,\n        16730939319872,\n        94809377245048,\n        78639167021187,\n        15368713711936,\n        40789923115535,\n        44889911501440,\n        41503128880339,\n        81234880673210,\n        82616570773948,\n        22918802058777,\n        77158542502016,\n        72107838435069,\n        20849603980134,\n        53503534226472\n    };\n    int i;\n    for(i = 0; i < 100; i++){\n        answer += input[i];\n    }\n    printf(\"answer=%lld\\n\", answer);\n    return EXIT_SUCCESS;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__DAG1.6.c", "original_string": "void main()\n{\n    int status=-1,ch;\n    char dir[10],file[10];\n    while(1)\n    {\n        printf(\"\\nEnter choice : \");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the name of directory : \");\n                scanf(\"%s\",dir);\n                add_dir(dir[0]);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter the name of file to add : \");\n                scanf(\"%s\",file);\n                printf(\"\\nEnter the directory : \");\n                scanf(\"%s\",dir);\n                status=check(dir[0]);\n                if(status==1)\n                    add_file(dir[0],file[0]);\n                else\n                {\n                    add_dir(dir[0]);\n                    add_file(dir[0],file[0]);\n                }\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the directory to delete : \");\n                scanf(\"%s\",dir);\n                del_dir(dir[0]);\n                break;\n            }\n            case 4:\n            {\n                printf(\"\\nEnter the file to delete : \");\n                scanf(\"%s\",file);\n                printf(\"\\nEnter the directory to which it belongs : \");\n                scanf(\"%s\",dir);\n                del_file(dir[0],file[0]);\n                break;\n            }\n            case 5:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__19_While.1.c", "original_string": "int main()\n{\n    int contador1 = 0;\n    int contador2 = 10;\n    while(contador1 < 11)\n    {\n        if(contador1 > 5)\n            Columna(contador2);\n        else\n            Columna(contador1);\n        --contador2;\n        printf(\"\\n\");\n        ++contador1;\n    }\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__queue1.0.c", "original_string": "void enqueue(int queue[],int val)\n{\n    if(rear==MAX-1)\n    printf(\"\\nqueue is full\");\n    if(front==-1 && rear==-1)\n    {\n        front=0;\n        rear=rear+1;\n        queue[rear]=val;\n    }\n    else\n    {\n        rear=rear+1;\n        queue[rear]=val;\n    }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__check_enemy.3.c", "original_string": "void        check_enemy(t_m *m, int x, int y)\n{\n    m->act_x = x;\n    m->act_y = y;\n    if (m->enemy == 'P')\n        p(m, x, y);\n    if (m->enemy == 'B' || m->enemy == 'Q')\n    {\n        special_check(m, -1, -1);\n        special_check(m, 1, -1);\n        special_check(m, 1, 1);\n        special_check(m, -1, 1);\n    }\n    if (m->enemy == 'R' || m->enemy == 'Q')\n    {\n        special_check(m, 0, -1);\n        special_check(m, 1, 0);\n        special_check(m, 0, 1);\n        special_check(m, -1, 0);\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader0.4.c", "original_string": "void firmwareUpdateInfoReader_run(void)\n{\n  char updateInfoString[260 + 1] = \"\";\n  if (!loadFirmwareUpdateInfoFile(updateInfoString, sizeof(updateInfoString))) \n  {\n    memset(lastUpdateInfoString, 0, sizeof(lastUpdateInfoString));\n    return;\n  }\n  if (strncmp(updateInfoString, lastUpdateInfoString, 260) == 0) \n  {\n    return;\n  }\n  strncpy(lastUpdateInfoString, updateInfoString, 260);\n  if (!parseFirmwareUpdateInfo(updateInfoString)) \n  {\n    return;\n  }\n  printf(\"Firmware update request towards version %s received\\n\", updateVersion);\n  fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);\n}"}
{"author": "sdukesameer", "file": "dsa__bfs-dfs.9.c", "original_string": "void dfs(graph g, int x){\n    stack s;\n    initialiseStack(&s,g.n);\n    int visited[g.n],i,f,t;\n    for(i=0;i<g.n;i++)\n        visited[i]=0;\n    printf(\"\\nFollowing is the DFS Traversal (starting from %c): \\n\",'A'+x);\n    visited[x]=1;\n    printf(\"%c\\t\",'A'+x);\n    push(&s,x);\n    while(s.top!=-1){\n        f=peek(&s);\n        t=1;\n        for(i=0; i<g.n; i++)\n            if(g.arr[f][i])\n                if(!visited[i]){\n                    visited[i]=1;\n                    printf(\"%c\\t\",'A'+i);\n                    push(&s,i);\n                    t=0;\n                    break;\n                }\n        if(t)\n            pop(&s);\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__ls-R.2.c", "original_string": "int main(int argc, char *argv[])\n{\n    if(argc == 1)\n    {\n        isFile(\".\");\n    }\n    else\n    {\n        isFile(argv[1]);\n    }\n    return 0;\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_2.3.c", "original_string": "void traverse()\n{\n    if(isEmpty())\n    {\n        printf(\"Stack is Empty\\n\");\n    }\n    else\n    {\n        int i;\n        for(i = 0; i<=top; i++)\n        {\n            printf(\"%d \\n\", stack[i]);\n        }\n    }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e19.2.c", "original_string": "int main(int argc, char *argv[]) {\n    char novamente;\n    char *captcha;\n    logico result;\n    srand(time(NULL));\n    do {\n        novamente = 'N';\n        captcha = gerarCaptcha(captchaGerado);\n        printf(\" --Por Favor, digite o CAPTCHA abaixo, respeitando maiusculas e minusculas:\\n\\n   %s  \\n\\n\", captcha);\n        gets(captchaLido);\n        result = validarCaptcha ( captchaLido , captcha);\n        if(result == TRUE) {\n            printf(\"   --Captcha Correto! Acesso Permitido!\");\n        } else {\n            if (result == FALSE) {\n                printf(\" --Voce nao digitou o Captcha corretamente. Por favor, tente novamente.\\n\\n\");\n                novamente = 'S';\n            }\n        }\n    } while (novamente == 'S');\n    return 0;\n}"}
{"author": "MartinMarinovich", "file": "ParcialLaboratorio1GCompleto__cliente.3.c", "original_string": "int obtenerCliente(eCliente listaDeClientes[], int idCliente, int tamClientes, char nombreCliente [], char* sexoCliente)\n{\n    int error = -1;\n    if(listaDeClientes != NULL && idCliente >0 && tamClientes >0 && nombreCliente != NULL)\n    {\n        for(int i = 0; i<tamClientes; i++)\n        {\n            if(idCliente == listaDeClientes[i].idCliente)\n            {\n                listaDeClientes[i].idCliente = idCliente;\n                strcpy(nombreCliente,listaDeClientes[i].nombre);\n                *sexoCliente = listaDeClientes[i].sexo;\n                error = 0;\n            }\n        }\n    }\n    return error;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__ex1.0.c", "original_string": "int main()\n{\n    int vet[10], num, busca = false, busca2;\n    for (int i=0; i<10; i++)\n    {\n        scanf (\"%i\", &vet[i]);\n    }\n    putchar ('\\n');\n    scanf (\"%i\", &num);\n    for (int i=0; i<10; i++)\n    {\n        for (int j=0; j<10; j++)\n        {\n            if (j != i)\n            {\n                if ((vet[i] * vet[j]) == num)\n                {\n                    printf (\"\\n%i * %i = %i\", vet[i], vet[j], num);\n                    busca = true;\n                }\n            }\n        }\n    }\n    if (busca == false)\n    {\n        printf (\"\\nN\u00e3o existe n\u00fameros\\n\\n\");\n    }\n    if (busca == true)\n    {\n        printf (\"\\n\\n\");\n    }\n    return 0;\n}"}
{"author": "ankitraj311", "file": "Socket-thread__sum_with_thread.1.c", "original_string": "int main()\n{\n  clock_t start, end; \n  double cpu_time_used;\n  start = clock();\n  pthread_t id1, id2, id3, id4;\n  pthread_create(&id1,NULL,addall,(void *)0);\n  pthread_create(&id2,NULL,addall,(void *)1);\n  pthread_create(&id3,NULL,addall,(void *)2);\n  pthread_create(&id4,NULL,addall,(void *)3);\n  pthread_join(id1,NULL);\n  pthread_join(id2,NULL);\n  pthread_join(id3,NULL);\n  pthread_join(id4,NULL);\n  end = clock();\n  cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;\n  printf(\"Sum of the numbers till 100 Crore %lu and Time taken by Program with thread is %f\\n\",sum[0]+sum[1]+sum[2]+sum[3],cpu_time_used);\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_8_b.1.c", "original_string": "void connectArrays(unsigned int n, int * array1, int * array2, double * array3){\n    int counterEven = 0;\n    int counterOdd = 0;\n    int i = 0;\n    for(i; i < 2*n; i++){\n        if(i % 2 == 0){\n            array3[i] = array2[counterEven];\n            counterEven++;\n        } else {\n            array3[i] = array1[counterOdd];\n            counterOdd++;\n        }\n    }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__HeapSort.2.c", "original_string": "void main()\n{\n    int HEAP[MAX],i,j,n,temp;\n    printf(\"\\nEnter the value of n:\");\n    scanf(\"%d\",&n);\n    printf(\"\\nEnter the values:\");\n    for(i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&HEAP[i]);\n        RestoreHeapUp(HEAP,i);\n    }\n    j=n;\n    for(i=1;i<=j;i++)\n    {\n        temp=HEAP[1];\n        HEAP[1]=HEAP[n];\n        HEAP[n]=temp;\n        n=n-1;\n        RestoreHeapDown(HEAP,1,n);\n    }\n    n=j;\n    printf(\"\\nThe sorted array:\\n\");\n    for(i=1;i<=n;i++)\n    {\n        printf(\"\\t%d\",HEAP[i]);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__queueOfInt.2.c", "original_string": "void deleteq(que* pq)\n{\n    if (pq->front ==  -1)\n        printf(\"Queue is empty\");\n    else if (pq->front == pq->rear)\n    {\n        printf(\"\\n%d deleted\", pq->queue[pq->front]);\n        pq->front =  -1;\n        pq->rear =  -1;\n    }\n    else if (pq->front == size-1) \n    {\n        printf(\"\\n%d deleted\", pq->queue[pq->front]);\n        pq->front = 0;\n    }\n    else\n        printf(\"\\n%d deleted\", pq->queue[(pq->front)++]);\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example40.0.c", "original_string": "int main()\n{\n    int i,binaryNum[SIZE],decimal;\n    printf(\"%s\\n\",\"en fazla 5 basamak olmak \u00fczere binary say\u0131y\u0131 giriniz:\");\n    for(i=SIZE;i>0;i--)\n        scanf(\"%d\",&binaryNum[i]);\n    decimal=binaryToDecimal(binaryNum);\n    printf(\"%s\",\"girilen binary de\u011fer:\");\n    for(i=SIZE;i>0;i--)\n        printf(\"%d\",binaryNum[i]);\n    printf(\"\\ndecimal say\u0131:%d\",decimal);\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q3.9.c", "original_string": "int main()\n{\n    char postfix[MAX];\n    scanf(\" %s\", postfix);\n    node* r = constructTree(postfix);\n    printf(\"infix expression is \\n\");\n    inorder(r);\n    printf(\"\\n%.2f\", calcu(r));\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__os.5.c", "original_string": "CLASS* mkoutput(CLASS* os) {\n    CLASS* outclass = mkosclass(os, \"Output\");\n    adddec(outclass, function, \"void\", \"moveCursor\");\n    adddec(outclass, function, \"void\", \"printChar\");\n    adddec(outclass, function, \"void\", \"printString\");\n    adddec(outclass, function, \"void\", \"printInt\");\n    adddec(outclass, function, \"void\", \"println\");\n    adddec(outclass, function, \"void\", \"backSpace\");\n    return outclass;\n}"}
{"author": "2security", "file": "Matrix__34SumUpperTriangularMatrix.1.c", "original_string": "int main()\n    {\n    int i,j,r,c,mat1[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    if(r!=c)\n        printf(\"Upper triangualr matrix or not matrix should be square\");\n    else\n        {\n        printf(\"\\n Enter the matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        printf(\"The sum of the Upper triangular matrix=%d\",SumUpperTri(mat1,r));    \n        }\n    return 0;\n    }"}
{"author": "kbtomic", "file": "StrukturePodataka__zad5.1.c", "original_string": "int unija(pozicija p, pozicija q, pozicija r)\n{\n    while (p->next != NULL && q->next != NULL)\n    {\n        pozicija s = NULL;\n        s = (pozicija)malloc(sizeof(struct lista));\n        if (s == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        s->next = NULL;\n        if (p->next->el == q->next->el) \n        {\n            s->el = p->next->el;\n            p = p->next;\n            q = q->next;\n        }\n        else if(p->next->el < q->next->el) \n        {\n            s->el = p->next->el;\n            p = p->next;\n        }\n        else\n        {\n            s->el = q->next->el;\n            q = q->next;\n        }\n        r->next = s;\n        r = s;\n    }\n    if (p->next == NULL) \n    {\n        while (q->next != NULL)\n        {\n            pozicija s = NULL;\n            s = (pozicija)malloc(sizeof(struct lista));\n            if (s == NULL)\n            {\n                printf(\"Neuspjesna alokacija memorije!\\n\");\n                return 1;\n            }\n            s->next = NULL;\n            s->el = q->next->el;\n            q = q->next;\n            r->next = s;\n            r = s;\n        }\n    }\n    else \n    {\n        while (p->next != NULL)\n        {\n            pozicija s = NULL;\n            s = (pozicija)malloc(sizeof(struct lista));\n            if (s == NULL)\n            {\n                printf(\"Neuspjesna alokacija memorije!\\n\");\n                return 1;\n            }\n            s->next = NULL;\n            s->el = p->next->el;\n            p = p->next;\n            r->next = s;\n            r = s;\n        }\n    }\n    return 0;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es7.0.c", "original_string": "NumeroComplesso somma(NumeroComplesso x, NumeroComplesso y){\n  NumeroComplesso s;\n  s.reale = x.reale + y.reale;\n  s.immaginaria = x.immaginaria + y.immaginaria;\n  return s;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_conditions.2.c", "original_string": "bool_t rstpAllSynced(RstpBridgeContext *context)\n{\n   uint_t i;\n   bool_t res;\n   RstpBridgePort *port;\n   res = TRUE;\n   for(i = 0; i < context->numPorts; i++)\n   {\n      port = &context->ports[i];\n      if(!port->selected)\n      {\n         res = FALSE;\n      }\n      else if(port->role != port->selectedRole)\n      {\n         res = FALSE;\n      }\n      else if(port->updtInfo)\n      {\n         res = FALSE;\n      }\n      else if(!port->synced && port->role != STP_PORT_ROLE_ROOT)\n      {\n         res = FALSE;\n      }\n      else\n      {\n      }\n   }\n   return res;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__dequeue1.0.c", "original_string": "void enqueueF(int val)\n{\n    if(front==-1 && rear==-1)\n    {\n        front=front+1;\n        rear=rear+1;\n        queue[front]=val;\n    }\n    else if(front==0)\n    {\n        printf(\"\\ncannot be inserted\");\n    }\n    else\n    {\n        front=front-1;\n        queue[front]=val;\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__timer0_1_int.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | (0xFF<<17);       \n    timer1_config();\n    timer0_config();\n    T0TCR = (1<<0);\n    T1TCR = (1<<0);\n    interrupt_config();\n    while(1)\n    {\n            blink_LED(24);\n    }\n}"}
{"author": "dle2005", "file": "File_Structure__ftlmgr.1.c", "original_string": "void optionC(char *fileName, int blocks) {\n    int fileMemory = blocks * BLOCK_SIZE;\n    flashfp = fopen(fileName, \"w+t\");\n    truncate(fileName, fileMemory);\n    for(int i = 0; i < blocks; i++)\n        dd_erase(i);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__UARTDrv0.0.c", "original_string": "void uart_init(uart_port_t unit, uart_config_t *config, uint8_t txPin, uint8_t rxPin)\n{\n  uartUnit = unit;\n  uart_param_config(unit, config);\n  uart_set_pin(unit, txPin, rxPin, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);\n  uart_driver_install(unit, UART_BUFFER_SIZE, UART_BUFFER_SIZE, 0, NULL, 0);\n  uart_set_mode(unit, UART_MODE_UART);\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__odd_even_process.2.c", "original_string": "void odd_file_open()\n{\n    FILE *fpo;\nprintf(\"odd file opening-----\\n\");\nfpo=fopen(\"odd.txt\",\"r\");\nwhile (fgets(words,sizeof(words),fpo)!=NULL)\n{\n    printf(\"\\t%s\",words);\n}\nfclose(fpo);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__20_For.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Euler elevado a X mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas\");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n        Suma_total += (Exp(X,i) / Fac(i));\n    }\n    printf(\"e^%i es igual a %lf\", X, (Suma_total + 1.0));\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__BA.0.c", "original_string": "int safety_module()\n{\n    int work[m],finish[n],i,j,flag=0;\n    for(i=0;i<m;i++)\n        work[i]=available[i];\n    for(i=0;i<n;i++)\n        finish[i]=0;\n    while(1)\n    {\n        for(i=0;i<n;i++)\n        {\n            flag=0;\n            for(j=0;j<m;j++)\n            {\n                if(need[i][j]<=work[j])\n                    continue;\n                else\n                {\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0 && finish[i]==0)\n            {\n                finish[i]=1;\n                for(j=0;j<m;j++)\n                    work[j]=work[j]+allocation[i][j];\n                break;\n            }\n        }\n        if(i==5)\n            break;\n        else\n            continue;\n    }\n    for(i=0;i<n;i++)\n    {\n        if(finish[i]!=1)\n            break;\n    }\n    if(i==5)\n        return(1);\n    else\n        return(0);\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__routing2.0.c", "original_string": "int     str_is_digits(char *c)\n{\n    int i;\n    i = 0;\n    if (!c)\n        return (0);\n    while (c[i])\n    {\n        if (!ft_isdigit(c[i]))\n            return (0);\n        i++;\n    }\n    return (1);\n}"}
{"author": "mehedi9021", "file": "Data_Structure__double_linked_list_create.3.c", "original_string": "void insertAtBeginning(int data)\n{\n    struct node * newNode;\n    if(head == NULL)\n    {\n        printf(\"Error, List is Empty!\\n\");\n    }\n    else\n    {\n        newNode = (struct node *)malloc(sizeof(struct node));\n        newNode->data = data;\n        newNode->next = head; \n        newNode->prev = NULL; \n        head->prev = newNode;\n        head = newNode;\n        printf(\"NODE INSERTED SUCCESSFULLY AT THE BEGINNING OF THE LIST\\n\");\n    }\n}"}
{"author": "dle2005", "file": "Algorithm__N_Queens.2.c", "original_string": "void main() {\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"\\n\");\n    col = (int *)malloc(sizeof(int) * (n + 1));\n    queens(0);\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_chibios.3.c", "original_string": "OsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,\n   void *param, size_t stackSize, int_t priority)\n{\n   uint_t i;\n   void *wa;\n   OsTask *task = NULL;\n   stackSize *= sizeof(uint_t);\n   wa = osAllocMem(THD_WORKING_AREA_SIZE(stackSize));\n   if(wa != NULL)\n   {\n      chSysLock();\n      for(i = 0; i < OS_PORT_MAX_TASKS; i++)\n      {\n         if(taskTable[i].tp == NULL)\n            break;\n      }\n      if(i < OS_PORT_MAX_TASKS)\n      {\n         taskTable[i].tp = chThdCreateI(wa, THD_WORKING_AREA_SIZE(stackSize),\n            priority, (tfunc_t) taskCode, param);\n         if(taskTable[i].tp != NULL)\n         {\n            chSchWakeupS(taskTable[i].tp, MSG_OK);\n            task = &taskTable[i];\n            waTable[i] = wa;\n            chSysUnlock();\n         }\n         else\n         {\n            chSysUnlock();\n            osFreeMem(wa);\n         }\n      }\n      else\n      {\n         chSysUnlock();\n         osFreeMem(wa);\n      }\n   }\n   return task;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CLL.9.c", "original_string": "void delete_at_pos()\n{\n    struct node *temp,*nextnode;\n    int i=1;\n    int pos;\n    int leg=count();\n    printf(\"enter the position in between 1 to %d\\n\",leg);\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    temp=head;\n    while(i<pos-1)\n    {\n        temp=temp->next;\n        i++;\n    }\n    nextnode=temp->next;\n    temp->next=nextnode->next;\n    free(nextnode);\n}"}
{"author": "MFarid94", "file": "Assignment4__Exercise8.0.c", "original_string": "void Swap(int *ptrA , int *ptrB){\n    int temp;\n    int i;\n    for(i=0 ; i<SIZE ; i++){\n        temp = *ptrA;\n        *ptrA = *ptrB;\n        *ptrB = temp;\n        ptrA++;\n        ptrB++;\n    }\n}"}
{"author": "flora0110", "file": "hw01git__check_ans_2-2.2.c", "original_string": "int main(){\n    FILE *ans;\n    FILE *myans;\n    char name[50];\n    ans=fopen(\"output_20201011.txt\",\"r\");\n    myans=fopen(\"4108056029output.txt\",\"r\");\n    if(NULL==ans || NULL == myans){\n        printf(\"Open failure\\n\");\n        if(NULL == myans){\n            printf(\"my ans Open failure\\n\");\n        }\n        if(NULL == ans){\n            printf(\"ans Open failure\\n\");\n        }\n        return 1;\n    }\n    else{\n        int nans,nmy,i;\n        int ansmin,ansLimit,anspathnum;\n        int min,Limit,pathnum;\n        for(i=0;i<100;i++){\n            fscanf(ans,\"test %d starts now.\",&nans);\n            char y=fgetc(ans);\n            fscanf(ans,\"Shortest path: %d, Limit: %d, The number of different paths: %d\",&ansmin,&ansLimit,&anspathnum);\n            y=fgetc(ans);\n            y=fgetc(ans);\n            fscanf(myans,\"test %d starts now.\",&nmy);\n            char x =fgetc(myans);\n            fscanf(myans,\"Shortest path: %d, Limit: %d, The number of different paths: %d\",&min,&Limit,&pathnum);\n            x=fgetc(myans);\n            x=fgetc(myans);\n            if(min!=ansmin){\n                printf(\"Shortest path error in test%d\\n\",nmy);\n                printf(\"ans's min : %d   my min : %d\\n\\n\",ansmin,min );\n            }\n            if(pathnum!=anspathnum){\n                printf(\"pathnum error in test%d\\n\",nmy);\n                printf(\"ans's  : %d   my  : %d\\n\\n\",anspathnum,pathnum );\n            }\n        }\n    }\n    fclose(ans);\n    fclose(myans);\n}"}
{"author": "jose120918", "file": "binary_trees__15-binary_tree_is_full.1.c", "original_string": "size_t internal_nodes(const binary_tree_t *tree)\n{\n    int c = 0;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    if ((*tree).right != NULL || (*tree).left != NULL)\n    {\n        c = 1 + internal_nodes((*tree).right) + internal_nodes((*tree).left);\n    }\n    return (c);\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_01.1.c", "original_string": "void display(int a[],int n)\n{\n  int i;\n  for(i=0;i<n;i++)\n  {fprintf(F2,\"%d \",a[i]);\n   if(i==(n-1))\n    fprintf(F2,\"\\n\");}\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__stack1.1.c", "original_string": "void pop(int stack[])\n{\n    if(top==-1)\n    {\n        printf(\"\\nstack is empty\");\n    }\n    else\n    {\n        printf(\"\\nThe value popped is : %d\",stack[top]);\n        top=top-1;\n    }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler2.1.c", "original_string": "void InsertLast(PPNODE Head, PPNODE Tail, int value)\n{\n    PNODE newn = NULL;\n    newn = (PNODE)malloc(sizeof(NODE));\n    newn->data = value;\n    newn->next = NULL;\n    if((*Head == NULL) && (*Tail == NULL))\n    {\n        *Head = newn;\n        *Tail = newn;\n    }\n    else\n    {\n        (*Tail)->next = newn;\n        *Tail = newn;\n    }\n    (*Tail)->next = *Head;\n}"}
{"author": "behergue", "file": "Operating_Systems__mytar_routines.2.c", "original_string": "stHeaderEntry* readHeader(FILE * tarFile, int *nFiles){\n    fread(nFiles, sizeof(int), 1, tarFile);\n    stHeaderEntry* pair = (stHeaderEntry*) malloc(sizeof(stHeaderEntry) * (*nFiles));\n    for(int i = 0; i < *nFiles; i++){\n        pair[i].name = loadstr(tarFile);\n        fread(&(pair[i].size), sizeof(int), 1, tarFile);\n    }\n    return pair;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__bridge_mib_impl_tp.4.c", "original_string": "error_t bridgeMibGetNextDot1dTpFdbEntry(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, uint8_t *nextOid, size_t *nextOidLen)\n{\n   error_t error;\n   uint_t i;\n   size_t n;\n   MacAddr macAddr;\n   SwitchFdbEntry entry;\n   NetInterface *interface;\n   macAddr = MAC_UNSPECIFIED_ADDR;\n   if(bridgeMibBase.interface == NULL)\n      return ERROR_OBJECT_NOT_FOUND;\n   interface = bridgeMibBase.interface;\n   if(*nextOidLen < object->oidLen)\n      return ERROR_BUFFER_OVERFLOW;\n   osMemcpy(nextOid, object->oid, object->oidLen);\n   error = NO_ERROR;\n   for(i = 0; !error; i++)\n   {\n      error = interface->switchDriver->getDynamicFdbEntry(interface, i, &entry);\n      if(error == NO_ERROR)\n      {\n         n = object->oidLen;\n         error = mibEncodeMacAddr(nextOid, *nextOidLen, &n, &entry.macAddr);\n         if(error)\n            return error;\n         if(oidComp(nextOid, n, oid, oidLen) > 0)\n         {\n            if(mibCompMacAddr(&macAddr, &MAC_UNSPECIFIED_ADDR) == 0 ||\n               mibCompMacAddr(&entry.macAddr, &macAddr) < 0)\n            {\n               macAddr = entry.macAddr;\n            }\n         }\n      }\n      else if(error == ERROR_INVALID_ENTRY)\n      {\n         error = NO_ERROR;\n      }\n      else\n      {\n      }\n   }\n   if(mibCompMacAddr(&macAddr, &MAC_UNSPECIFIED_ADDR) == 0)\n      return ERROR_OBJECT_NOT_FOUND;\n   n = object->oidLen;\n   error = mibEncodeMacAddr(nextOid, *nextOidLen, &n, &macAddr);\n   if(error)\n      return error;\n   *nextOidLen = n;\n   return NO_ERROR;\n}"}
{"author": "dishanp", "file": "DSA__q8.0.c", "original_string": "int main()\n{\n    int *arr;\n    int n;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n    int max = arr[0];\n    int c = 0;\n    for(int i = 0 ; i < n ; i++)\n    {\n        if(max == arr[i])\n        {\n            c++;\n        }\n        if(max < arr[i])\n        {\n            max = arr[i];\n        }\n    }\n    printf(\"Largest element is %d and it appears %d times\\n\", max, c);\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-2new.8.c", "original_string": "int main(){\n    move[0].vert=-1;\n    move[0].horiz=0;\n    move[0].hei=0;\n    move[1].vert=0;\n    move[1].horiz=1;\n    move[1].hei=0;\n    move[2].vert=1;\n    move[2].horiz=0;\n    move[2].hei=0;\n    move[3].vert=0;\n    move[3].horiz=-1;\n    move[3].hei=0;\n    move[4].vert=0;\n    move[4].horiz=0;\n    move[4].hei=1;\n    move[5].vert=0;\n    move[5].horiz=0;\n    move[5].hei=-1;\n    char y;\n    int i,j,k;\n    FILE *pfile;\n    char name[50];\n    int control;\n    FILE *wfile;\n    wfile = fopen( \"4108056029output.txt\",\"w\" );\n    if( NULL == wfile ){\n        printf( \"wfile open failure\" );\n        return 1;\n    }\n    else{\n        for(control=1;control<=100;control++){\n            min = 100000;\n            sprintf(name,\"test%d.txt\",control);\n            pfile = fopen(name,\"r\");\n            if(NULL==pfile){\n                printf(\"Open failure\");\n                return 1;\n            }\n            else{\n                printf(\"reading %s\\n\",name);\n                char* bottom = make1darr(MAXLEN);\n                n=0;\n                char y;\n                bottom[n]=fgetc(pfile);\n                while(bottom[n]!='\\n'){\n                    fgetc(pfile);\n                    bottom[++n]=fgetc(pfile);\n                }\n                char ***maze=make3darr(n/2+1,n+2,n+2);\n                char ***road=make3darr(n/2+1,n+2,n+2);\n                char ***mark=make3darr(n/2+1,n+2,n+2);\n                int ***d=make3darrint(n/2+1,n+2,n+2);\n                int len=0;\n                int sr,sc,sh;\n                for(i=0;i<n/2+1;i++){\n                    for(j=0;j<n+2;j++){\n                        for(k=0;k<n+2;k++){\n                            if(j==0 || k==0 || j==n+1 || k==n+1){\n                                maze[i][j][k]='X';\n                            }\n                            else if(i==0 && j==1){\n                                maze[i][j][k]=bottom[k-1];\n                            }\n                            else if(j > len && j <= n-len && k > len && k <= n-len){\n                                fscanf(pfile,\"%c \",&maze[i][j][k]);\n                            }\n                            else{\n                                maze[i][j][k]='X';\n                            }\n                            if(maze[i][j][k]=='S'){\n                                sh=i;\n                                sr=j;\n                                sc=k;\n                            }\n                            road[i][j][k]=maze[i][j][k];\n                            mark[i][j][k]=maze[i][j][k];\n                        }\n                    }\n                    len++;\n                }\n                fprintf(wfile, \"test %d starts now.\\n\",control );\n                if(bfs(maze,d,sr,sc,sh)){\n                    mark[sh][sr][sc]='X';\n                    pathnum=0;\n                    dfs(maze,mark,road,sr,sc,sh,0);\n                    printf(\"Sortest path : %d, Limit: %d, The number of different paths: %d\\n\\n\",min,min+5,pathnum);\n                    fprintf(wfile,\"Shortest path: %d, Limit: %d, The number of different paths: %d\\n\\n\",min,min+5,pathnum);\n                }\n                else fprintf(wfile,\"The maze does not have a path\\n\" );\n                free(bottom);\n                free(maze);\n                free(mark);\n                free(road);\n                free(d);\n            }\n            fclose(pfile);\n        }\n    }\n    fclose(wfile);\n}"}
{"author": "earth429", "file": "mulpre__mulprec.17.c", "original_string": "int increment(struct NUMBER *a, struct NUMBER *b) {\n    struct NUMBER one;\n    int r;\n    setInt(&one, 1);\n    r = add(a, &one, b);\n    return r;\n}"}
{"author": "sahadipanjan6", "file": "Programs-in-C__Prime_Numbers_Within_Range.1.c", "original_string": "int isPrime(int number)\n{\n    int i, count = 0;\n    int flag = 0;\n    for(i=1; i<=number; i++)\n    {\n        if(number%i == 0)\n            count++;\n    }\n    if(count == 2)\n        flag = 1;\n    return flag;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__circularlinkedlist.1.c", "original_string": "void delete(int tar)\n{\n    if(rear==NULL)\n    {\n        printf(\"\\nlist is empty\");\n    }\n    else\n    {\n        temp=front;\n        q=front;\n        while(temp!=rear)\n        {\n            if(temp->val==tar)\n            {\n                if(temp==front)\n                {\n                    front=front->next;\n                    rear->next=front;\n                    free(temp);\n                    temp=front;\n                }\n                else\n                {\n                    q->next=temp->next;\n                    free(temp);\n                    temp=q->next;\n                }\n            }\n            q=temp;\n            temp=temp->next;\n        }\n        if(temp->val==tar)\n        {\n            q->next=front;\n            temp=NULL;\n            free(temp);\n        }\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q33.4.c", "original_string": "void display(queue *q)\n{\n    int i;\n    for (i=q->front;i<q->rear;i++)\n        printf(\"%c \",q->c[i]);\n    printf(\"\\n\");\n}"}
{"author": "paawankohli", "file": "DSA-LAB__ishanTrees1.0.c", "original_string": "void postorder(node *t)     \n{ \n    STACK s;\n    node*curr;\n    curr=t;\n    s.tos=-1;\n    do\n    { \n        while (curr!=NULL) \n        { \n            if (curr->right!=NULL) \n                push(&s, curr->right); \n            push(&s, curr); \n            curr=curr->left; \n        } \n        curr = pop(&s); \n        if (curr->right!=NULL && s.s[s.tos]==curr->right) \n        { \n            pop(&s); \n            push(&s,curr);\n            curr=curr->right;\n        } \n        else \n        { \n            printf(\"%d\\t\",curr->data); \n            curr=NULL; \n        } \n    }while (s.tos!=-1); \n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica2-4.0.c", "original_string": "int main(int argc, char * argv[]){\n    int nHilos = 2; \n    pthread_t hilos[nHilos];\n    for (int i = 0; i < nHilos; i++){ pthread_create(&hilos[i], NULL, aumentaVariableGlobal, NULL );\n                                      pthread_join(hilos[i], NULL); }\n    printf(\"la variable global suma %i \\n\", variableGlobal);\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Knapsack.0.c", "original_string": "void main()\n{\n    int i, j, k = 0;\n    int remaining_weight = MAX_WEIGHT;  \n    double total_profit = 0.0;\n    struct Object obj[MAX_ARR_SIZE];\n    obj[0].name = \"Object1\";\n    obj[1].name = \"Object2\";\n    obj[2].name = \"Object3\";\n    for(i=0; i<MAX_ARR_SIZE; i++)\n    {\n        printf(\"\\nEnter PROFIT%d: \", (i+1));\n        scanf(\"%f\", &obj[i].profit);\n        printf(\"\\nEnter WEIGHT%d: \", (i+1));\n        scanf(\"%f\", &obj[i].weight);\n    }\n    for(j=0; j<MAX_ARR_SIZE; j++)\n        obj[j].pw_ratio = (obj[j].profit / obj[j].weight);\n    printf(\"\\nObject Details:- \\n\");\n    for(k=0; k<MAX_ARR_SIZE; k++)\n    {\n        printf(\"\\n------------------------------\");\n        printf(\"\\nNAME: %s\", obj[k].name);\n        printf(\"\\nPROFIT: %f\", obj[k].profit);\n        printf(\"\\nWEIGHT: %f\", obj[k].weight);\n        printf(\"\\nProfit/Weight Ratio: %f\", obj[k].pw_ratio);\n    }\n    printf(\"\\n\");\n    sort_decreasing(obj);\n    printf(\"\\nObjects after Sorting:- \\n\");\n    for(i=0; i<MAX_ARR_SIZE; i++)\n    {\n        printf(\"\\n------------------------------\");\n        printf(\"\\nNAME: %s\", obj[i].name);\n        printf(\"\\nPROFIT: %f\", obj[i].profit);\n        printf(\"\\nWEIGHT: %f\", obj[i].weight);\n        printf(\"\\nProfit/Weight Ratio: %f\", obj[i].pw_ratio);\n    }\n    printf(\"\\n\");\n    for(i=0; i<MAX_ARR_SIZE; i++)\n    {\n        if((remaining_weight>0) && (obj[i].weight<=remaining_weight))\n        {\n            remaining_weight = remaining_weight - obj[i].weight;\n            total_profit = total_profit + obj[i].profit;\n            printf(\"\\nObject with profit %f and weight %f is selected...\", obj[i].profit, obj[i].weight);\n            printf(\"\\nRemaining Capacity in the KnapSack: %d\", (remaining_weight));\n            printf(\"\\nTotal Profit upto now: %f\", total_profit);\n        }\n        else if(remaining_weight > 0)\n        {\n            total_profit = total_profit + ((obj[i].profit * remaining_weight) / obj[i].weight);\n            printf(\"\\nObject with profit %f and weight %f is selected...\", obj[i].profit, obj[i].weight);\n            printf(\"\\nRemaining Capacity in the KnapSack: %d\", (remaining_weight));\n            printf(\"\\nTotal Profit upto now: %f\", total_profit);\n            break;\n        }   \n    }\n    printf(\"\\n\\nTotal Profit of Knapsack: %f\\n\", total_profit); \n}"}
{"author": "sdukesameer", "file": "dsa__pol-add-sub-mul.1.c", "original_string": "node* poly_add_sub(char task, node* exp1, node* exp2)\n{\n    node* res=NULL;\n    while(exp1 || exp2)\n    {\n        if(!exp2)\n        {\n            createNode(exp1->coeff,exp1->pow,&res);\n            exp1=exp1->next;\n        }\n        else if(!exp1)\n        {\n            if(task=='+')\n                createNode(exp2->coeff,exp2->pow,&res);\n            else\n            createNode(-(exp2->coeff),exp2->pow,&res);\n            exp2=exp2->next;\n        }\n        else if(exp1->pow > exp2->pow)\n        {\n            createNode(exp1->coeff,exp1->pow,&res);\n            exp1=exp1->next;\n        }\n        else if(exp1->pow < exp2->pow)\n        {\n            if(task=='+')\n                createNode(exp2->coeff,exp2->pow,&res);\n            else\n                createNode(-(exp2->coeff),exp2->pow,&res);\n            exp2=exp2->next;\n        }\n        else if(exp1->pow == exp2->pow )\n        {\n            if(task=='+' && (exp1->coeff + exp2->coeff)!=0)\n                createNode(exp1->coeff+exp2->coeff,exp1->pow,&res);\n            else if(task=='-' && (exp1->coeff - exp2->coeff)!=0)\n                createNode(exp1->coeff-exp2->coeff,exp1->pow,&res);\n            exp1=exp1->next;\n            exp2=exp2->next;\n        }\n    }\n    return res;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__AG.0.c", "original_string": "int main()\n{\n    int n, imaior, imenor, tempm;\n    float temp[100000], maior, menor, media = 0;\n    scanf(\"%i\", &n);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%f\", &temp[i]);\n        if (i == 0)\n        {\n            maior = temp[i];\n            imaior = i;\n            menor = temp[i];\n            imenor = i;\n        }\n        else if (temp[i] > maior)\n        {\n            maior = temp[i];\n            imaior = i;\n        }\n        else if (temp[i] < menor)\n        {\n            menor = temp[i];\n            imenor = i;\n        }\n        media += temp[i];\n    }\n    media /= n;\n    printf(\"%i %.1f\\n%i %.1f\\n%.1f\\n\", imenor, menor, imaior, maior, media);\n    for (int i=0; i<n; i++)\n    {\n        if (temp[i] >= media)\n        {\n            printf(\"%i \", i);\n        }\n    }\n    putchar('\\n');\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader.0.c", "original_string": "static bool isWhitespace(char *str)\n{\n  size_t idx = 0;\n  char currentChr = str[idx++];\n  while (currentChr != '\\0')\n  {\n    if (isspace(currentChr) == 0) \n    {\n      return false;\n    }\n    currentChr = str[idx++];\n  }\n  return true;\n}"}
{"author": "haon1026", "file": "linux-programming__nonblock_readtty.0.c", "original_string": "int main()\n{\n    int fd = open(\"/dev/tty\", O_RDONLY|O_NONBLOCK);\n    if(fd < 0)\n    {\n        perror(\"open /dev/tty\");\n        exit(1);\n    }\n    printf(\"open /dev/tty ok, fd = %d\\n\", fd);\n    char buf[10];\n    int n;\n    while(1)\n    {\n        n = read(fd, buf, 10);\n        if(n < 0)\n        {\n            if(errno != EAGAIN)\n            {\n                perror(\"read /dev/tty\");\n                exit(1);\n            }\n            else\n            {\n                write(STDOUT_FILENO, \"try again\\n\", strlen(\"try again\\n\"));\n                sleep(2);\n                continue;\n            }\n        }\n        break;\n    }\n    write(STDOUT_FILENO, buf, n);\n    close(fd);\n    return 0;\n}"}
{"author": "dle2005", "file": "Algorithm__Kruskal.7.c", "original_string": "int main() {\n   printf(\"-----input-----\\n\");\n   printf(\"num of Vertex = \");\n   scanf(\"%d\", &num_of_Vertex);\n   printf(\"num of Edges = \");\n   scanf(\"%d\", &num_of_Edges);\n   U = (universe *)malloc(sizeof(universe) * num_of_Vertex);\n   edge *E = (edge *)malloc(sizeof(edge) * num_of_Edges);\n   edge *F = (edge *)malloc(sizeof(edge) * num_of_Edges);\n   for(int i = 0; i < num_of_Edges; i++) {\n       printf(\"insert edge = \");\n       scanf(\"%d %d %d\", &E[i].ui, &E[i].uj, &E[i].distance);\n   }\n   kruskal(1, 0, E, F);\n   int value = 0; \n   printf(\"\\n-----output-----\\n\");\n   for(int i = 0; i < num_of_Vertex -1; i++) {\n        printf(\"v%d - v%d = %d\\n\", F[i].ui, F[i].uj, F[i].distance);\n        value += F[i].distance;\n   }\n   printf(\"minimum spannig tree value = %d\\n\", value);\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__queue.2.c", "original_string": "void dequeue(void) {\n    if(front == rear)\n        printf(\"Queue is Empty!!\\n\");\n    else {\n        printf(\"Dleted : %d\",queue[front]);\n        front = front+1;\n        if(front == rear)\n            front = rear = -1;\n    }\n}"}
{"author": "fikepaci", "file": "sorting_algorithms__1-insertion_sort_list.0.c", "original_string": "void swap_backward(listint_t *c)\n{\n    listint_t *tmp, *head;\n    while (c->prev != NULL)\n    {\n        if (c->n < c->prev->n)\n        {\n            tmp = c->prev->prev;\n            c->prev->next = c->next;\n            c->next = c->prev;\n            c->prev->prev = c;\n            c->prev = tmp;\n            c->next->next->prev = c->next;\n            if (tmp != NULL)\n                tmp->next = c;\n            head = c;\n            while (head->prev != NULL)\n                head = head->prev;\n            print_list(head);\n        }\n        else\n            c = c->prev;\n    }\n}"}
{"author": "sdukesameer", "file": "c__tower_of_hanoi.1.c", "original_string": "void move(int n,char src, char dest, char inter)\n{\n    if(n<1)\n        printf(\"ERROR\");\n    else\n    {\n        static int c=0;\n        if(n==1)\n        {\n            c++;\n            printf(\"%d: Move top disk from %c to %c\\n\",c,src,dest);\n            return;\n        }\n        move(n-1,src,inter,dest);\n        c++;\n        printf(\"%d: Move top disk from %c to %c\\n\",c,src,dest);\n        move(n-1,inter,dest,src);\n    }\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Paging.2.c", "original_string": "void add_program(int id,int size)\n{\n    int ct=get_count();\n    int temp=size;\n    int i,k,ch=1,id1;\n    if(ct>=size)\n    {\n        k=0;\n        for(i=0;i<16 && size>0;i++)\n        {\n            if(Mem[i]==0)\n            {\n                Mem[i]=id;\n                size=size-1;\n                t[index1].indices[k]=i;\n                k++;\n            }\n        }\n        t[index1].id=id;\n        t[index1].size=temp;\n        t[index1].indices[k]=-1;\n        index1=index1+1;\n    }\n    else\n    {\n        while(ch==1)\n        {\n            printf(\"\\nIs there any possiblity of removing a program : \");\n            scanf(\"%d\",&ch);\n            if(ch==1)\n            {\n                printf(\"\\nEnter program id : \");\n                scanf(\"%d\",&id1);\n                rem_program(id1);\n            }\n            else\n            {\n                break;\n            }\n        }\n        ct=get_count();\n        if(ct>=size)\n        {\n            k=0;\n            for(i=0;i<16 && size>0;i++)\n            {\n                if(Mem[i]==0)\n                {\n                    Mem[i]=id;\n                    size=size-1;\n                    t[index1].indices[k]=i;\n                    k++;\n                }\n            }\n            t[index1].id=id;\n            t[index1].size=temp;\n            t[index1].indices[k]=-1;\n            index1=index1+1;\n        }\n        else\n            printf(\"\\nNot possible\");\n    }\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__RandomizedQuickSort.2.c", "original_string": "void putdata(int x[50], int n)\n       {\n        int k;\n        for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n         }\n          printf(\"\\n\");\n        }"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedList-1.2.c", "original_string": "struct Node * deleteByGivenKey(struct Node * head, int value){\n     struct Node *p = head;\n     struct Node *q = head->next;\n     while ( q->data != value && q->next != NULL)\n     {\n          p = p->next;\n          q = q->next;\n     }\n     if (q->data == value)\n     {\n          p->next = q->next;\n          free(q);\n     }\n     return head;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e140.0.c", "original_string": "char gerado()\n{\n    int cont=0;\n    int num=0;\n    srand(time(NULL));\n    while(cont<6)\n    {\n        if (cont == 4 || cont == 5)\n        {\n            gerarCaptcha[cont] = 48 + rand() % 9;\n        }\n        else if(cont == 1 || cont == 3)\n        {\n            gerarCaptcha[cont] = 97 + rand() % 26;\n        }\n        else if(cont == 0 || cont == 2)\n        {\n            gerarCaptcha[cont] = 65 + rand() % 26;\n        }\n        cont++;\n    }\n    printf(\"%s\\n\", gerarCaptcha);\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad9.5.c", "original_string": "int PreOrderPrint(treePointer root)\n{\n    if (root)\n    {\n        printf(\"%d\\n\", root->data);\n        PreOrderPrint(root->left);\n        PreOrderPrint(root->right);\n    }\n    return 0;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__arrayADT.0.c", "original_string": "void createArray(struct myArray * a, int tSize, int uSize){\n     a->totalSize = tSize; \n     a->usedSize = uSize; \n     a->ptr = (int *) malloc(tSize*sizeof(int)); \n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__dnsclient.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    struct sockaddr_in dnss;\n    int sockid,rval;\n    char sym[20],IP[20];\n    int slen;\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(1);\n    }\n    sockid=socket(AF_INET,SOCK_DGRAM,0);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    dnss.sin_family=AF_INET;\n    dnss.sin_port=htons(atoi(argv[2]));\n    dnss.sin_addr.s_addr=inet_addr(argv[1]);\n    printf(\"\\nEnter the symbolic name of resource : \");\n    scanf(\"%s\",sym);\n    rval=sendto(sockid,sym,sizeof(sym),0,(struct sockaddr*)&dnss,sizeof(dnss));\n    if(rval==-1)\n    {\n        perror(\"MSG-SND-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\nWaiting to receive from DNS Server\\n\");\n    slen=sizeof(dnss);\n    strncpy(IP,\" \",20);\n    rval=recvfrom(sockid,IP,sizeof(IP),0,(struct sockaddr*)&dnss,&slen);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\nEquivalent IP adrress of %s is %s\\n\",sym,IP);\n    close(sockid);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__16_Dowhile.0.c", "original_string": "void Columna(int pibote)\n{\n    int j = 1;\n    do\n    {\n        if(j >= (10 - pibote) && j <= (10 + pibote))\n            printf(\"Z\");\n        else\n            printf(\" \");\n        ++j;\n    }while(j <= 20);\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__60_Finding_Substring.0.c", "original_string": "int main()\n{\n  int i,j = 0,k, count = 0, count1 = 0, len1 = 0, len2 = 0, flag = 0;\n  char str[100], str_sub[100];\n  printf(\"Enter a Universal string to find Substring\\n\");\n  scanf(\"%[^\\n]s\",str);\n  printf(\"Enter a Substring\\n\");\n  scanf(\" %[^\\n]s\",str_sub);\n  len1 = strlen(str);\n  len2 = strlen(str_sub);\n  for(i=0; i<=(len1 - len2); i++)\n  {\n    for(j=i; j<(i+len2); j++)\n    {\n      flag = 1;\n      if( str[j] != str_sub[j-i])\n      { \n        flag = 0;\n    break;\n      }\n    }\n    if(flag == 1)\n    break;\n  }\n  if(flag == 1)\n  {\n    printf(\"\\nSub_String Found\");\n  }\n  else\n  {\n    printf(\"Sub_String Not FOund\");\n  }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__insert_element.0.c", "original_string": "int main()\n{\n    int n, data;\n    printf(\"Enter the total number of nodes: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    printf(\"\\nData in the list \\n\");\n    displayList();\n    printf(\"\\nEnter data to insert at beginning of the list: \");\n    scanf(\"%d\", &data);\n    inab(data);\n    printf(\"\\nData in the list \\n\");\n    displayList();\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__pre-eva.0.c", "original_string": "stack* createStack(unsigned int x)\n{\n    stack* ret=(stack*) malloc(sizeof(stack));\n    ret->top=-1;\n    ret->size=x;\n    ret->arr=(float*) malloc(x * sizeof(float));\n    return ret;\n}"}
{"author": "deepaliajabsingjadhav", "file": "file__file_student_info.2.c", "original_string": "int main()\n{\n    char name[20];\n    printf(\"Enter file name\\n\");\n    scanf(\"%s\",name);\n   FileWrite(name);\n    FileRead(name);\n    return 0;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Triangular_Matrix.3.c", "original_string": "void display(int matrix[R][C])\n{\n    int i, j = 0;\n    int rows = R;\n    int columns = C;\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "zjzj-zz", "file": "4s_Numerical__Gauss_Seidel_General.2.c", "original_string": "int Convergence_test( double x[N], double y[N] ){ \n    for( j = 0; j < N; j++ ){\n        if( error < fabs( x[j] - y[j] ))return (1);\n    }\n    return (0);\n}"}
{"author": "augustogunsch", "file": "jackc__io.7.c", "original_string": "char* getoutname(char* fullname, int len) {\n    char* trimmed = trimstr(fullname, len, 4);\n    int sz = sizeof(char) * (len-1);\n    char* outname = (char*)malloc(sz);\n    snprintf(outname, sz, \"%svm\", trimmed);\n    free(trimmed);\n    return outname;\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example3_1.2.c", "original_string": "int oku (int arr[SIZE])\n{\n    int i;\n    for(i=0;i<SIZE;i++)\n        scanf(\"%d\",&arr[i]);\n    return arr;    \n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__shell_server.5.c", "original_string": "error_t shellServerSetTimeout(ShellServerSession *session, systime_t timeout)\n{\n   error_t error;\n   if(session != NULL)\n   {\n      error = sshSetChannelTimeout(session->channel, timeout);\n   }\n   else\n   {\n      error = ERROR_INVALID_PARAMETER;\n   }\n   return error;\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_8.5.c", "original_string": "int count_leaves(struct node* root)\n{\n    if (root == NULL)\n    {\n        return 0;\n    }\n    else if (root->left == NULL && root->right == NULL)\n    {\n        return 1;\n    }\n    else\n    {\n        return count_leaves(root->left)+count_leaves(root->right);\n    }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e20.6.c", "original_string": "char ** gerarCaptchaLogico(char verificador[7][20]){\n    int tipo, cont, randPalavra, min, max, baseTipo;\n    char novoCaptcha[7][20];\n    for(cont=1;cont<6;cont++){\n        tipo=numeroAleatorio(1,3);\n        switch(tipo){\n            case 1:\n                min=0;\n                max=4;\n                break;\n            case 2:\n                min=5;\n                max=9;\n                break;\n            case 3:\n                min=10;\n                max=14;\n                break;\n        }\n        randPalavra=numeroAleatorio(min,max);\n        strcpy(verificador[cont],palavras[randPalavra].nome);\n    }\n    baseTipo=buscaTipo(verificador[numeroAleatorio(1,5)]);\n    switch(baseTipo){\n        case 1:\n            strcpy(verificador[0],\"cor\");\n            strcpy(verificador[6],\"1\");\n            break;\n        case 2:\n            strcpy(verificador[0],\"animal\");\n            strcpy(verificador[6],\"2\");\n            break;\n        case 3:\n            strcpy(verificador[0],\"objeto\");\n            strcpy(verificador[6],\"3\");\n            break;\n    }\n    return novoCaptcha;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader0.7.c", "original_string": "static void openFirmwareUpdateInfoFile(void)\n{\n  char command[260 + 1] = \"\";\n  snprintf(command, sizeof(command), \"code %s\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n  system(command);\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_04.2.c", "original_string": "void sort(int a[], int n)\n{\n    int i = 1;\n    int shift, cmp;\n    for(i = 1; i<n; i++)\n    {\n        int key = a[i];\n        int j = i-1;\n        cmp = 0;shift = 0;\n        while(j>=0 && a[j]<key)\n        {\n            a[j+1]= a[j];\n            j = j-1;\n            cmp++;\n            shift++;\n        }\n            a[j+1] = key;\n            if(j != -1)\n            {\n                cmp++;\n            }\n            if( j != i-1)\n            {\n                shift++;\n            }\n            fprintf(F2, \"%d %d\\n\", cmp, shift);\n            display(a, n);\n            fprintf(F2, \"\\n\");\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__4.5.c", "original_string": "double intersecao_area(rect_t retangulo_1, rect_t retangulo_2)\n{\n    rect_t retangulo;\n    if (retangulo_2.sup_esq.x >= retangulo_1.sup_esq.x && retangulo_2.sup_esq.x <= retangulo_1.inf_dir.x)\n    {\n        retangulo.sup_esq.x = retangulo_2.sup_esq.x;\n    }\n    else retangulo.sup_esq.x = retangulo_1.sup_esq.x;\n    if (retangulo_2.sup_esq.y <= retangulo_1.sup_esq.y && retangulo_2.sup_esq.y >= retangulo_1.inf_dir.y)\n    {\n        retangulo.sup_esq.y = retangulo_2.sup_esq.y;\n    }\n    else retangulo.sup_esq.y = retangulo_1.sup_esq.y;\n    if (retangulo_2.inf_dir.x <= retangulo_1.inf_dir.x && retangulo_2.inf_dir.x >= retangulo_1.sup_esq.x)\n    {\n        retangulo.inf_dir.x = retangulo_2.inf_dir.x;\n    }\n    else retangulo.inf_dir.x = retangulo_1.inf_dir.x;\n    if (retangulo_2.inf_dir.y >= retangulo_1.inf_dir.y && retangulo_2.inf_dir.y <= retangulo_1.sup_esq.y)\n    {\n        retangulo.inf_dir.y = retangulo_2.inf_dir.y;\n    }\n    else retangulo.inf_dir.y = retangulo_1.inf_dir.y;\n    printf(\"\\nsup_esq (%lf,%lf)\\ninf_dir(%lf,%lf)\\n\", retangulo.sup_esq.x, retangulo.sup_esq.y, retangulo.inf_dir.x, retangulo.inf_dir.y);\n    return area(retangulo);\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__utils.4.c", "original_string": "char    *ft_strjoi(char *s1, char *s2)\n{\n    char    *str;\n    int     i;\n    int     j;\n    if (!s2)\n        return (s1);\n    if (!s1)\n        return (s2);\n    str = (char*)malloc(ft_strlen(s1) + ft_strlen(s2) + 2);\n    i = -1;\n    while (s1[++i])\n    {\n        str[i] = s1[i];\n    }\n    j = -1;\n    while (s2[++j])\n    {\n        str[i] = s2[j];\n        i++;\n    }\n    str[i] = '\\n';\n    str[i + 1] = '\\0';\n    free(s1);\n    return (str);\n}"}
{"author": "sdukesameer", "file": "dsa__cll-ins-sor-seq-del.1.c", "original_string": "void sort_insertion(node** head, int n)\n{\n    node* cll=createNode(n);\n    if (*head==NULL)\n    {\n        *head=cll;\n        cll->next=cll;\n    }\n    else if((*head)->data >= cll->data)\n    {\n        node* last=*head;\n        while(last->next!=(*head))\n            last=last->next;\n        cll->next=*head;\n        last->next=cll;\n        *head=cll;\n    }\n    else if((*head)->data < cll->data)\n    {\n        node* temp=*head;\n        while(temp->next!=*head && temp->next->data<cll->data)\n            temp=temp->next;\n        cll->next=temp->next;\n        temp->next=cll;\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__1epoll.0.c", "original_string": "int main()\n{\n    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);\n    int opt = 1;\n    setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n    struct sockaddr_in serv_adr;\n    bzero(&serv_adr, sizeof(serv_adr));\n    serv_adr.sin_family = AF_INET;\n    serv_adr.sin_port = htons(9999);\n    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);\n    Bind(serv_sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr));\n    Listen(serv_sock, 128);\n    int epfd = epoll_create(OPEN_MAX);                          \n    if(epfd == -1)\n        sys_err(\"epoll_create() error\");\n    struct epoll_event temp;                                    \n    struct epoll_event ep[OPEN_MAX];                            \n    temp.events = EPOLLIN;                                      \n    temp.data.fd = serv_sock;\n    int res = epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, &temp); \n    if(res == -1)\n        sys_err(\"epoll_ctl() error\");\n    char buf[MAXLINE], str[INET_ADDRSTRLEN];\n    struct sockaddr_in clnt_adr;\n    socklen_t clnt_adr_len;\n    int ret, conn_sock, clnt_sock, i, n, num = 0;\n    while(1)\n    {\n        ret = epoll_wait(epfd, ep, OPEN_MAX, -1);               \n        if(ret == -1)\n            sys_err(\"epoll_wait() error\");\n        for(i = 0; i < ret; i++)\n        {\n            if(!ep[i].events & EPOLLIN)                         \n                continue;\n            if(ep[i].data.fd == serv_sock)\n            {\n                clnt_adr_len = sizeof(clnt_adr);\n                conn_sock = Accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_len);\n                printf(\"receive from %s at PORT %d\\n\", inet_ntop(AF_INET, &clnt_adr.sin_addr, str, sizeof(str)), ntohs(clnt_adr.sin_port));\n                printf(\"cfd %d --- client %d\\n\", conn_sock, ++num);\n                temp.events = EPOLLIN;\n                temp.data.fd = conn_sock;\n                res = epoll_ctl(epfd, EPOLL_CTL_ADD, conn_sock, &temp);     \n                if(res == -1)\n                    sys_err(\"epoll_ctl() error\");\n            }\n            else\n            {\n                clnt_sock = ep[i].data.fd;\n                n = Read(clnt_sock, buf, MAXLINE);\n                if(n == 0)\n                {\n                    res = epoll_ctl(epfd, EPOLL_CTL_DEL, clnt_sock, NULL);  \n                    if(res == -1)\n                        sys_err(\"epoll_ctl() error\");\n                    Close(clnt_sock);\n                    printf(\"client[%d] closed connection\\n\", clnt_sock);\n                }\n                else\n                {\n                    for(i = 0; i < n; i++)\n                        buf[i] = toupper(buf[i]);\n                    Write(STDOUT_FILENO, buf, n);\n                    Write(clnt_sock, buf, n);\n                }\n            }\n        }\n    }\n    Close(serv_sock);\n    Close(epfd);\n    return 0;\n}"}
{"author": "Mr-JoE1", "file": "C-Tasks-for-newbies__main18.0.c", "original_string": "int main()\n{\n    int num;\n    printf(\"Enter A Number : \");\n    scanf(\"%d\" , &num);\n    if(IsPalindrome( num ))\n        printf(\"\\n%d Is Palindrome!!\\n\" , num );\n    else\n        printf(\"\\n%d Is Not Palindrome!!\\n\" , num );\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__bfs-dfs.10.c", "original_string": "void free_graph(graph* g){\n    for(int i=0; i<g->n; i++)\n        free(g->arr[i]);\n    free(g->arr);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q1_doublylq.6.c", "original_string": "int main()\n{\n    printf(\"1:Insert@start 2:Insert@end 3:Delete@start\\n4:Delete@end 5:Display 6:Exit\\n\");\n    int i=1,ch,ele;\n    nptr start=NULL,end=NULL;\n    while(i)\n    {\n        printf(\"Command: \"); \n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n                    printf(\"Enter element to insert: \");\n                    scanf(\"%d\",&ele);\n                    insertst(&start,&end,ele);\n                    break;\n            case 2:\n                    printf(\"Enter element to insert: \");\n                    scanf(\"%d\",&ele);\n                    inserten(&start,&end,ele);\n                    break;\n            case 3:\n                    ele=delst(&start,&end);\n                    if(ele!=-99) \n                        printf(\"Deleted %d\\n\",ele);\n                    break;\n            case 4:\n                    ele=delen(&start,&end);\n                    if(ele!=-99) \n                        printf(\"Deleted %d\\n\",ele);\n                    break;\n            case 5:\n                    disp(start);\n                    break;\n            case 6:\n                    i=0; break;\n        }\n    }\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__strlen.0.c", "original_string": "int main()\n{\n    char str[SIZE];\n    printf(\"enter the string\\n\");\n    int i,n=0;\n    fgets(str,sizeof(str),stdin);\n    for(i=1;str[i]!='\\0';i++)\n        {\n        n++;\n        }\n    printf(\"the number of character in the string is %d\\n\",n);\n    pthread_t thread;\n    pthread_create(&thread,NULL,count_vowels,&str);\n    pthread_join(thread,NULL);\n    return 0;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__15_For.1.c", "original_string": "int main()\n{\n    int contador1 = 1;\n    int contador2 = 7;\n    for(contador1 = 1; contador1 < 8; ++contador1)\n    {\n    printf(\"\\n\");\n        if(contador1 >= 4)\n        Columna(contador2);\n    else\n        Columna(contador1);\n        --contador2;\n    }\n}"}
{"author": "shengelenge", "file": "wstep-do-programowania__zad14.1.c", "original_string": "int main()\n{\n    double x, y;\n    printf(\"Podaj liczbe, z ktorej chcesz wyznaczyc pierwiastek: \");\n    scanf(\"%2lf\", &x);\n    y = pierwiastek(x, E);\n    printf(\"Pierwiastek = %.3lf\", y);\n    return 0;\n}"}
{"author": "Theemiss", "file": "binary_trees__16-binary_tree_is_perfect.1.c", "original_string": "size_t binary_tree_height(const binary_tree_t *tree)\n{\n    size_t h_left, h_right;\n    if (tree == NULL || binary_tree_is_leaf(tree))\n        return (0);\n    h_left = binary_tree_height(tree->left);\n    h_right = binary_tree_height(tree->right);\n    if (h_right <= h_left)\n        return (h_left + 1);\n    return (h_right + 1);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__WDT2.2.c", "original_string": "void delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "shengelenge", "file": "wp-lab3__zad3.0.c", "original_string": "bool czy_pierwsza(int n)\n{\n    if (n <2)\n        return false;\n    for (int i = 2; i*i <= n ; i++) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}"}
{"author": "Mr-JoE1", "file": "Play-with-C__find_STRONG_num.0.c", "original_string": "int main()\n{\nwhile(1){\n    int i, originalNum, num, lastDigit, sum;\n    long fact;\n    printf(\"Enter any number to check Strong number: \");\n    scanf(\"%d\", &num);\n    originalNum = num;\n    sum = 0;\n    while(num > 0)\n    {\n        lastDigit = num % 10;\n        fact = 1;\n        for(i=1; i<=lastDigit; i++)\n        {\n            fact = fact * i;\n        }\n        sum = sum + fact;\n        num = num / 10;\n    }\n    if(sum == originalNum)\n    {\n        printf(\"%d is STRONG NUMBER\\n\", originalNum);\n    }\n    else\n    {\n        printf(\"%d is NOT STRONG NUMBER\\n\", originalNum);\n    }\n}\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__binarySearchTree.0.c", "original_string": "struct Node*create(int x){\n     struct Node*temp=(struct Node*)malloc(sizeof(struct Node));\n     temp->data=x;\n     temp->left=NULL;\n     temp->right=NULL;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__shell_client_misc.5.c", "original_string": "error_t shellClientProcessEvents(ShellClientContext *context)\n{\n   error_t error;\n   uint_t i;\n   SshContext *sshContext;\n   SshConnection *connection;\n   sshContext = &context->sshContext;\n   osMemset(sshContext->eventDesc, 0, sizeof(sshContext->eventDesc));\n   for(i = 0; i < sshContext->numConnections; i++)\n   {\n      connection = &sshContext->connections[i];\n      if(connection->state != SSH_CONN_STATE_CLOSED)\n      {\n         sshRegisterConnectionEvents(sshContext, connection, &sshContext->eventDesc[i]);\n      }\n   }\n   error = socketPoll(sshContext->eventDesc, sshContext->numConnections,\n      &sshContext->event, context->timeout);\n   if(!error)\n   {\n      for(i = 0; i < sshContext->numConnections && !error; i++)\n      {\n         connection = &sshContext->connections[i];\n         if(connection->state != SSH_CONN_STATE_CLOSED)\n         {\n            if(sshContext->eventDesc[i].eventFlags != 0)\n            {\n               error = sshProcessConnectionEvents(sshContext, connection);\n            }\n         }\n      }\n   }\n   if(error == ERROR_WOULD_BLOCK || error == ERROR_TIMEOUT)\n   {\n      error = shellClientCheckTimeout(context);\n   }\n   return error;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__multiple_isr.7.c", "original_string": "void delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__dll-ins-seq-sor-del-a.0.c", "original_string": "void sort_insertion(list** head, int n)\n{\n    list* node=(list*)malloc(sizeof(list));\n    node->key=n;\n    node->next=NULL;\n    node->prev=NULL;\n    if(*head==NULL)\n        *head=node;\n    else if(node->key <= (*head)->key)\n    {\n        (*head)->prev=node;\n        node->next=*head;\n        *head=node;\n    }\n    else\n    {\n        list* temp=*head;\n        while(temp->next != NULL && temp->next->key < node->key)\n            temp=temp->next;\n        node->prev=temp;\n        node->next=temp->next;\n        temp->next=node;\n        if(node->next!=NULL)\n            node->next->prev=node;\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__sftp_server.2.c", "original_string": "error_t sftpServerStart(SftpServerContext *context)\n{\n   error_t error;\n   OsTask *task;\n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n   TRACE_INFO(\"Starting SFTP server...\\r\\n\");\n   if(context->running)\n      return ERROR_ALREADY_RUNNING;\n   error = sshServerRegisterChannelRequestCallback(context->sshServerContext,\n      sftpServerChannelRequestCallback, context);\n   if(!error)\n   {\n      context->stop = FALSE;\n      context->running = TRUE;\n      task = osCreateTask(\"SFTP Server\", sftpServerTask, context,\n         SFTP_SERVER_STACK_SIZE, SFTP_SERVER_PRIORITY);\n      if(task == OS_INVALID_HANDLE)\n      {\n         error = ERROR_OUT_OF_RESOURCES;\n      }\n   }\n   if(error)\n   {\n      context->running = FALSE;\n      sshServerUnregisterChannelRequestCallback(context->sshServerContext,\n         sftpServerChannelRequestCallback);\n   }\n   return error;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q3_reverselq.0.c", "original_string": "nptr createNode()\n{\n    nptr temp=(nptr)malloc(sizeof(node));\n    temp->ele=(char*)malloc(SIZE*sizeof(char));\n    temp->llink=NULL;\n    temp->rlink=NULL;\n    return temp;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-tree.2.c", "original_string": "void freeparameters(PARAMETER* p) {\n    free(p->debug);\n    PARAMETER* next = p->next;\n    free(p);\n    if(next != NULL)\n        freeparameters(next);\n}"}
{"author": "behergue", "file": "Operating_Systems__mytar_routines.0.c", "original_string": "int copynFile(FILE * origin, FILE * destination, int nBytes){\n    char* c = (char*) malloc(nBytes * sizeof(char));\n    int n = fread(c, sizeof(char), nBytes, origin);\n    fwrite(c, sizeof(char), n, destination);\n    free(c);\n    return n;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__check_mate.2.c", "original_string": "int     check_pawn(char **tab, int r, int c, int size)\n{\n    return (r - 1 >= 0\n            && ((c - 1 >= 0 && tab[r - 1][c - 1] == 'K')\n                || (c + 1 < size && tab[r - 1][c + 1] == 'K')));\n}"}
{"author": "augustogunsch", "file": "jack-compiler__threads.1.c", "original_string": "void* compileunit(void* input) {\n    COMPILEUNIT* unit = (COMPILEUNIT*)input;\n    unit->compiled = compileclass(unit->compiler, unit->parsed);\n    pthread_exit(NULL);\n}"}
{"author": "ankitraj311", "file": "450_babbar__4_0_1_2_array_simple_youtube.3.c", "original_string": "int main()\n{\n  int arr[] = {0,1,1,0,0,2,1,2,0,0,0,1};\n  int no = 12;\n  array_print(arr,no);\n  sort012(arr,no);\n  printf(\"\\n\");\n  array_print(arr,no);\n}"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__3-2.3.c", "original_string": "void inverse_escape(char s[], char t[]){\n  int i, j;\n  j = 0;\n  for(i = 0; s[i] != '\\0'; i++)\n    switch(s[i]){\n    case '\\\\':\n      switch(s[++i]){\n      case 'n':\n    t[j++] = '\\n';\n    break;\n      case 't':\n    t[j++] = '\\t';\n    break;\n      case 'a':\n    t[j++] = '\\a';\n    break;\n      case 'b':\n    t[j++] = '\\b';\n    break;\n      case 'f':\n    t[j++] = '\\f';\n    break;\n      case 'r':\n    t[j++] = '\\r';\n    break;\n      case 'v':\n    t[j++] = '\\v';\n    break;\n      case '\\\\':\n    t[j++] = '\\\\';\n    break;\n      case '?':\n    t[j++] = '\\?';\n    break;\n      case '\\'':\n    t[j++] = '\\'';\n    break;\n      case '\"':\n    t[j++] = '\\\"';\n    break;\n      }\n      break;\n    default:\n      t[j++] = s[i];\n      break;\n    }\n  t[j] = '\\0';\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad1.1.c", "original_string": "int upis(FILE* fp, student* s, int n)\n{\n    int i, max = 100;\n    double r;\n    for (i = 0; i < n; i++)\n    {\n        fscanf(fp, \"%s %s %lf\\n\", (*(s + i)).ime, (*(s + i)).prezime, &(*(s + i)).bodovi);\n        r = s[i].bodovi / max * 100;\n        printf(\"Ime i prezime: %s \\t%s\\t Bodovi: %.2lf\\t  Relativni bodovi: %.2lf\\n\", (*(s + i)).ime, (*(s + i)).prezime, (*(s + i)).bodovi, r);\n    }\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.4.c", "original_string": "void firmwareUpdateInfoReader_run(void)\n{\n  char updateInfoString[260 + 1] = \"\";\n  if (!loadFirmwareUpdateInfoFile(updateInfoString, sizeof(updateInfoString))) \n  {\n    memset(lastUpdateInfoString, 0, sizeof(lastUpdateInfoString));\n    return;\n  }\n  if (strncmp(updateInfoString, lastUpdateInfoString, 260) == 0) \n  {\n    return;\n  }\n  strncpy(lastUpdateInfoString, updateInfoString, 260);\n  if (!parseFirmwareUpdateInfo(updateInfoString)) \n  {\n    return;\n  }\n  printf(\"Firmware update request towards version %s received\\n\", updateVersion);\n  fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client_archive.3.c", "original_string": "void send_msg_handler()\n{\n    char message[LENGTH] = {};\n    char buffer[LENGTH + 32] = {};\n    while (1)\n    {\n        str_overwrite_stdout();\n        fgets(message, LENGTH, stdin);\n        str_trim_lf(message, LENGTH);\n        if (strcmp(message, \"exit\") == 0)\n        {\n            break;\n        }\n        else\n        {\n            sprintf(buffer, \"%s: %s\\n\", name, message);\n            send(sockfd, buffer, strlen(buffer), 0);\n        }\n        bzero(message, LENGTH);\n        bzero(buffer, LENGTH + 32);\n    }\n    catch_ctrl_c_and_exit(2);\n}"}
{"author": "SugumaranEvil", "file": "TLPI__P_msgq_snd.0.c", "original_string": "int main()\n{\n    int mq_op_ret,mq_send_ret;\n    struct mq_attr my_mq_attr;\n    my_mq_attr.mq_flags   = 0;   \n    my_mq_attr.mq_maxmsg  = 10;\n    my_mq_attr.mq_msgsize = 8192;\n    mq_op_ret = mq_open(\"/P_msgq\", O_CREAT | O_RDWR, 0644, &my_mq_attr);\n    perror(\"mq_open\");\n    printf(\"ret value of mq_open = %d\\n\",mq_op_ret);\n    mq_send_ret = mq_send(mq_op_ret, str, strlen(str)+1,10);\n    perror(\"mq_send\");\n    printf(\"ret value of mq_send = %d\\n\",mq_send_ret);\n}"}
{"author": "behergue", "file": "Operating_Systems__myFS.10.c", "original_string": "int readNode(MyFileSystem *myFileSystem, int nodeNum, NodeStruct* node)\n{\n    int posNode;\n    assert(nodeNum < MAX_NODES);\n    posNode = findNodeByPos(nodeNum);\n    if( lseek(myFileSystem->fdVirtualDisk, posNode, SEEK_SET)==-1 ||\n        read(myFileSystem->fdVirtualDisk, node, sizeof(NodeStruct)) != sizeof(NodeStruct) ) {\n        perror(\"Error when reading an inode\");\n        return -1;\n    }\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__BinHexConverter0.5.c", "original_string": "size_t convertHexString8ToBinData(char *inputStr, size_t inputStrLength, uint8_t *pOutputData, size_t outputDataSize)\n{\n  if (outputDataSize < inputStrLength >> 1) \n  {\n    return 0;\n  }\n  if ((inputStrLength & 0x01u) != 0) \n  {\n    return 0;\n  }\n  memset(pOutputData, 0x00u, outputDataSize);\n  for ( size_t i = 0 ; i < inputStrLength; i = i + 2 )\n  {\n    pOutputData[i >> 1] = convertHexString8ToBinValue(inputStr + i, 2);\n  }\n  return inputStrLength >> 1;\n}"}
{"author": "earth429", "file": "mulpre__mulprec1.3.c", "original_string": "void setRnd(struct NUMBER *a, int k){\n    int i;\n    int judge;\n    clearByZero(a);\n    for (i = 0; i < k;i++){\n        a->n[i] = random() % 10; \n    }\n    judge = random() % 2; \n    switch (judge) {\n        case 1:\n            a->sign = 1;\n            break;\n        case 0:\n            a->sign = -1;\n            break;\n    }\n}"}
{"author": "DanielSalis", "file": "AED1__teste5.2.c", "original_string": "int existeNaLista(TipoLista *l, char nome){\n  int contador = l->tamanho;\n  if(contador == 0)\n    return 1;\n  TipoElemento *p = l->primeiro;\n  while(contador != 0)\n  {\n    if(p->nome == nome)\n      return 2;\n    p = p->prox;\n    contador--;\n  }\n  return 1;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__menu.5.c", "original_string": "float maximo(float c1, float c2, float c3, float cf){\n    float max = c1; \n    if (c1 < c2) { \n        max = c2; \n    }\n    if (max < c3){ \n        max = c3; \n    }\n    if (max < cf) { \n        max = cf;\n    }\n    return max;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__bridge_mib_impl_base.4.c", "original_string": "error_t bridgeMibGetNextDot1dBasePortEntry(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, uint8_t *nextOid, size_t *nextOidLen)\n{\n   error_t error;\n   uint_t i;\n   size_t n;\n   uint_t numPorts;\n   uint16_t portNum;\n   uint16_t curPortNum;\n   portNum = 0;\n   if(*nextOidLen < object->oidLen)\n      return ERROR_BUFFER_OVERFLOW;\n   osMemcpy(nextOid, object->oid, object->oidLen);\n   numPorts = bridgeMibGetNumPorts();\n   for(i = 1; i <= numPorts; i++)\n   {\n      curPortNum = bridgeMibGetPortNum(i);\n      n = object->oidLen;\n      error = mibEncodeIndex(nextOid, *nextOidLen, &n, curPortNum);\n      if(error)\n         return error;\n      if(oidComp(nextOid, n, oid, oidLen) > 0)\n      {\n         if(portNum == 0 || curPortNum < portNum)\n         {\n            portNum = curPortNum;\n         }\n      }\n   }\n   if(portNum == 0)\n      return ERROR_OBJECT_NOT_FOUND;\n   n = object->oidLen;\n   error = mibEncodeIndex(nextOid, *nextOidLen, &n, portNum);\n   if(error)\n      return error;\n   *nextOidLen = n;\n   return NO_ERROR;\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.39.c", "original_string": "ASMBLK* translateln(VMTRANSLATOR* t) {\n    if(eq(t, 0, \"push\"))\n        return translatepush(t);\n    if(eq(t, 0, \"pop\"))\n        return translatepop(t);\n    if(eq(t, 0, \"add\"))\n        return translatearith(t, \"M=D+M\");\n    if(eq(t, 0, \"sub\"))\n        return translatearith(t, \"M=M-D\");\n    if(eq(t, 0, \"and\"))\n        return translatearith(t, \"M=D&M\");\n    if(eq(t, 0, \"or\"))\n        return translatearith(t, \"M=D|M\");\n    if(eq(t, 0, \"neg\"))\n        return copytemplate(&tneg);\n    if(eq(t, 0, \"not\"))\n        return copytemplate(&tnot);\n    if(eq(t, 0, \"eq\"))\n        return translatecomp(t, \"EQ\");\n    if(eq(t, 0, \"gt\"))\n        return translatecomp(t, \"LT\");\n    if(eq(t, 0, \"lt\"))\n        return translatecomp(t, \"GT\");\n    if(eq(t, 0, \"label\"))\n        return translatelabel(t);\n    if(eq(t, 0, \"goto\"))\n        return translategoto(t);\n    if(eq(t, 0, \"if-goto\"))\n        return translateifgoto(t);\n    if(eq(t, 0, \"return\"))\n        return translatereturn(t);\n    if(eq(t, 0, \"function\"))\n        return translatefunction(t);\n    return translatecall(t);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__SinglePartitionDemoFirmwareUpdateInfoSerialReader0.2.c", "original_string": "void firmwareUpdateInfoReader_onCharacterReceived(uint8_t character)\n{\n  uint8_t ___FirmwareUpdateInfoParser_characterReceived_character__arg = character;\n  void *___FirmwareUpdateInfoParser_characterReceived__args[1] = { &___FirmwareUpdateInfoParser_characterReceived_character__arg };\n  FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_characterReceived__event, ___FirmwareUpdateInfoParser_characterReceived__args);\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__texture_errors.0.c", "original_string": "void    texture_error(int error)\n{\n    if (error == 0)\n        ft_putstr(\"Error\\ndouble inclusion\\n\");\n    else if (error == 1)\n        ft_putstr(\"Error:\\nWrong number of params/invalid file in NO!\\n\");\n    else if (error == 2)\n        ft_putstr(\"Error:\\nWrong number of params/invalid file in SO!\\n\");\n    else if (error == 3)\n        ft_putstr(\"Error:\\nWrong number of params/invalid file in WE!\\n\");\n    else if (error == 4)\n        ft_putstr(\"Error:\\nWrong number of params/invalid file in EA!\\n\");\n    else if (error == 5)\n        ft_putstr(\"Error:\\nWrong number of params/invalid file in S!\\n\");\n    exit(0);\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es3.0.c", "original_string": "void rimuovi(int a[], int *dim){\n  for(int i=0; i<*dim; i++){\n    for(int j=i+1; j<*dim; j++){\n      if(a[i]==a[j]){\n        for(int k=j; k<*dim-1; k++){\n          a[k] = a[k+1];\n        }\n        *dim -=1;\n        j--;\n      }\n    }\n  }\n}"}
{"author": "254Odeke", "file": "OpeartingSystems__os7c.0.c", "original_string": "void main(){\n    int rs[50], i, j, k, n, f, count[20], m[20], min, pf=0;\n    printf(\"Enter number of page references:\");\n    scanf(\"%d\",&n);\n    printf(\"Enter the reference string:\");\n    for(i=0;i<n;i++)\n        scanf(\"%d\",&rs[i]);\n    printf(\"Enter the available no. of frames:\");\n    scanf(\"%d\",&f);\n    for(i=0;i<f;i++){\n        count[i]=0;\n        m[i]=-1;\n    }\n    printf(\"\\nThe Page Replacement Process is\\n\");\n    for(i=0;i<n;i++){\n        for(k=0;k<f;k++){\n            if(rs[i]==m[k]){\n                count[k]++;\n                break;\n            }\n        }\n        if(k==f){\n            if(i<f){\n                m[i]=rs[i];\n                count[i]++;\n            }\n            else{\n                min = 0;\n                for(j=1;j<f;j++)\n                    if(count[min]>count[j])\n                        min=j;\n                m[min]=rs[i];\n                count[min]=1;\n            }\n            pf++;\n        }\n        for(j=0;j<f;j++)\n            printf(\"%d\\t\",m[j]);\n        if(k==f)\n            printf(\"PF No. %d\",pf);\n        print(\"\\n\");    \n    }\n    printf(\"\\n Total number of page faults: %d\",pf);\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__routing_utils.1.c", "original_string": "char    **freethenipples(char **s)\n{\n    int i;\n    i = 0;\n    while (s[i])\n    {\n        free(s[i]);\n        i++;\n    }\n    free(s);\n    return (NULL);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__SinglePartitionDemoFirmwareUpdateInfoSerialReader.2.c", "original_string": "void firmwareUpdateInfoReader_onCharacterReceived(uint8_t character)\n{\n  uint8_t ___FirmwareUpdateInfoParser_characterReceived_character__arg = character;\n  void *___FirmwareUpdateInfoParser_characterReceived__args[1] = { &___FirmwareUpdateInfoParser_characterReceived_character__arg };\n  FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_characterReceived__event, ___FirmwareUpdateInfoParser_characterReceived__args);\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__MatrixChainMultiplication.2.c", "original_string": "void main()\n{\n int M[11][11],S[11][11],i,j,n,p[11];\n for(i=0;i<=10;i++)\n {\n  for(j=0;j<=10;j++)\n  {\n   M[i][j]=0;\n   S[i][j]=0;\n  }\n   p[i]=0;\n }\n printf(\"Enter the total number of matrices:\");\n scanf(\"%d\",&n);\n printf(\"Enter the chain of matrices:\");\n for(i=0;i<=n;i++)\n  scanf(\"%d\",&p[i]);\n matrix_chain_multiplication(p,n,M,S);\n printf(\"\\nResult\\n\");\n putdata(M,n,n);\n printf(\"\\nResult\\n\");\n putdata(S,n,n);\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad10.1.c", "original_string": "treePointer ReadFromFile(char* nameOfFile, treePointer root, stackPointer head)\n{\n    char sign;\n    treePointer rightChild = NULL;\n    treePointer leftChild = NULL;\n    FILE* fp = NULL;\n    fp = fopen(nameOfFile, \"r\");\n    if (!fp)\n    {\n        printf(\"Greska kod otvaranja datoteke!\\n\");\n        return fp;\n    }\n    while (!feof(fp))\n    {\n        fscanf(fp, \"%c \", &sign);\n        if (sign == '+' || sign == '-' || sign == '*' || sign == '/')\n        {\n            root = AllocateMemoryForTree(sign);\n            rightChild = Pop(head);\n            leftChild = Pop(head);\n            root = EditTree(root, rightChild, leftChild);\n            CreateTree(root, head);\n        }\n        else\n            Push(head, sign);\n    }\n    root = head->next->nextTree;\n    fclose(fp);\n    return root;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLLcircular.0.c", "original_string": "nptr createNode(int x)\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp -> data = x;\n    temp -> left = temp -> right = NULL;\n    return temp;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-structure.14.c", "original_string": "VARDEC* parsevardec(PARSER* p) {\n    if(strcmp(p->current->token, \"var\"))\n        return NULL;\n    next(p);\n    VARDEC* vardec = (VARDEC*)malloc(sizeof(VARDEC));\n    parsevardeccommon(p, vardec);\n    return vardec;\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad1-WskaznikiOpadyDeszczu.0.c", "original_string": "int main()\n{\n    const float deszcz[LATA][MIESIACE] = {\n        {10.2, 8.1, 6.8, 4.2, 2.1, 1.8, 0.2, 0.3, 1.1, 2.3, 6.1, 7.4},\n        {9.2, 9.8, 4.8, 3.2, 2.5, 4.8, 1.2, 0.5, 1.6, 1.3, 7.1, 7.4},\n        {10.6, 5.6, 6.7, 4.4, 3.8, 1.8, 2.2, 7.3, 2.6, 4.3, 4.6, 4.6},\n        {12.5, 3.7, 4.3, 0.2, 2.1, 1.7, 4.6, 0.5, 1.6, 0.3, 9.1, 2.4},\n        {12.2, 9.1, 7.8, 1.2, 8.4, 1.5, 0.2, 3.5, 3.8, 1.3, 7.1, 4.4}\n    };\n    float * rok;        \n    float * miesiac;    \n    float podsuma, suma;\n    int licznik = 0;\n    for(rok = deszcz, suma = 0; rok <= &deszcz[4][11]; rok = rok + MIESIACE){\n        for(miesiac = deszcz[licznik], podsuma = 0; miesiac <= &deszcz[licznik][11]; miesiac++){\n            podsuma += *miesiac;\n        }\n        printf(\"%5d %12.1f\\n\", 1995 + licznik, podsuma);\n        licznik++;\n        suma += podsuma;\n    }\n    printf(\"\\nRoczna srednia wynosi %.1f cm.\\n\\n\", suma/LATA);\n    printf(\"SREDNIE MIESIECZNE:\\n\\n\");\n    printf(\" Sty  Lut  Mar  Kwi  Maj  Cze  Lip  Sie  Wrz  Paz \");\n    printf(\" Lis  Gru\\n\");\n    for (miesiac = deszcz; miesiac <= &deszcz[0][11]; miesiac++){\n        for(rok = miesiac, podsuma = 0; rok <= &deszcz[4][11]; rok = rok + 12){ \n            podsuma += *rok;\n        }\n        printf(\"%4.1f \", podsuma/LATA);\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__2.4.c", "original_string": "void display(QUEUE* pq)\n{\n    for(int i = pq->front ; i < pq->rear ; i++)\n        printf(\"%d \", pq->q[i]);\n    printf(\"\\n\");\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__23_cosh.3.c", "original_string": "void cosh(int contador, int iteraciones, double total, double X)\n{\n        if(contador <= iteraciones){\n                total = total + Exp((contador*2),X) / Fac((contador*2));\n                cosh(++contador,iteraciones,total,X);\n        }else{\n                printf(\"\\n**El cosh(%lf) es igual a: %lf\",X,total+1);\n        }\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica2-2.0.c", "original_string": "int main(int argc, char * argv[]){\n    int nHilos = argc-1; \n    int total = 0; \n    int * nLineas=0;\n    pthread_t hilos[nHilos];\n    for (int i = 0; i < nHilos; i++){ pthread_create(&hilos[i], NULL, cuentaLineas, (void*) argv[i+1]); } \n    for (int i = 0; i < nHilos; i++) {\n        pthread_join(hilos[i], (void**) &nLineas); \n        printf(\"El fichero %s tiene %i lineas\\n\", argv[i+1], *nLineas);\n        total += *nLineas; \n    }\n    printf(\"Entre todos los ficheros suman %i lineas\\n\", total);\n}"}
{"author": "dishanp", "file": "DSA__q55.2.c", "original_string": "void sortinsert(struct node *p, int key)\n{\n    struct node *t, *q;\n    t = (struct node *)malloc(sizeof(struct node));\n    t->data = key;\n    while(p && p->data < key)\n    {\n        q = p;\n        p = p->next;\n    }\n    if(p == first)\n    {\n        t->next = first;\n        first = t;\n    }\n    else\n    {\n        t->next = p;\n        q->next = t;\n    }\n}"}
{"author": "jose120918", "file": "binary_trees__101-binary_tree_levelorder.0.c", "original_string": "int scale(const binary_tree_t *tree)\n{\n    int ll = 1;\n    int lr = 1;\n    if (tree == NULL)\n    {\n        return (-1);\n    }\n    ll += scale((*tree).left);\n    lr += scale((*tree).right);\n    if (lr > ll)\n    {\n        return (lr);\n    }\n    return (ll);\n}"}
{"author": "augustogunsch", "file": "jackc__parser-expressions.12.c", "original_string": "TERM* parseidentifierterm(PARSER* p) {\n    TERM* t = parsecalltermnullified(p);\n    if(t == NULL)\n        if(nextequals(p, \"[\"))\n            return parsearrayterm(p);\n        else\n            return parsevarterm(p);\n    else\n        return t;\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__server4.1.c", "original_string": "void* broadcast(char* buffer, int socketfd) {\n    for(int i = 0; i<50; i++) {\n        if(sockets[i]!=0) {\n            char name[5] = \"Name:\";\n            strcat(name, buffer);\n            send(sockets[i], name, strlen(name) , 0);\n        } else {\n            break;\n        }\n    }\n}"}
{"author": "Theemiss", "file": "simple_shell__more_charfun.3.c", "original_string": "void array_rev(char *arr, int len)\n{\n    int i;\n    char tmp;\n    for (i = 0; i < (len / 2); i++)\n    {\n        tmp = arr[i];\n        arr[i] = arr[(len - 1) - i];\n        arr[(len - 1) - i] = tmp;\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__dll-ins-seq-sor-del.6.c", "original_string": "int main()\n{\n    while (1)\n    {\n        int ch;\n        printf(\"\\n1. SORTED ORDER INSERTION\\n\");\n        printf(\"2. SEQUENTIAL ORDER INSERTION\\n\");\n        printf(\"3. EXIT PROGRAM\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1)\n        {\n            printf(\"\\n\\tSORTED ORDER\\n\");\n            node* head=NULL;\n            int c;\n            while(1)\n            {\n                int c;\n                printf(\"\\n1. ENTER AN INTEGER\\n\");\n                printf(\"2. DELETE AN INTEGER\\n\");\n                printf(\"3. TRAVERSAL IN FORWARD DIRECTION\\n\");\n                printf(\"4. TRAVERSAL IN REVERSE DIRECTION\\n\");\n                printf(\"5. EXIT SORTED ORDER INSERTION\\n\");\n                printf(\"Enter your choice: \");\n                scanf(\"%d\",&c);\n                if(c==1)\n                {\n                    int n;\n                    printf(\"Please enter an element: \");\n                    scanf(\"%d\",&n);\n                    sort_insertion(&head,n);\n                    printf(\"%d inserted using SORTED ORDER INSERTION.\\n\",n);\n                }\n                else if(c==2)\n                {\n                    int n;\n                    printf(\"\\nPlease enter the element to be deleted: \");\n                    scanf(\"%d\",&n);\n                    if (head==NULL)\n                        printf(\"COULDN'T DELETE %d. LIST EMPTY\\n\",n);\n                    else\n                    {\n                        node* del_node=search_node(head,n);\n                        if(del_node==NULL)\n                        printf(\"COULDN'T DELETE %d. NOT FOUND IN LIST.\\n\",n);\n                        else\n                        {\n                            deletion(&head,del_node);\n                            printf(\"%d deleted from LIST.\\n\",n);\n                        }\n                    }\n                }\n                else if (c==3)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nTRAVERSAL IN FORWARD DIRECTION: \\n\");\n                        printforward(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==4)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nTRAVERSAL IN REVERSE DIRECTION: \\n\");\n                        printreversed(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==5)\n                {\n                    printf(\"\\nExitting Sorted Order Insertion, Thank You.\\n\");\n                    break;\n                }\n                else\n                    printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n            }\n        }\n        else if(ch==2)\n        {\n            printf(\"\\n\\tSEQUENTIAL ORDER\\n\");\n            node* head=NULL;\n            int c;\n            while(1)\n            {\n                printf(\"\\n1. ENTER AN INTEGER\\n\");\n                printf(\"2. DELETE AN INTEGER\\n\");\n                printf(\"3. TRAVERSAL IN FORWARD DIRECTION\\n\");\n                printf(\"4. TRAVERSAL IN REVERSE DIRECTION\\n\");\n                printf(\"5. EXIT SEQUENTIAL ORDER INSERTION\\n\");\n                printf(\"Enter your choice: \");\n                scanf(\"%d\",&c);\n                if(c==1)\n                {\n                    int n;\n                    printf(\"Please enter an element: \");\n                    scanf(\"%d\",&n);\n                    seq_insertion(&head,n);\n                    printf(\"%d inserted using SEQUENTIAL ORDER INSERTION.\\n\",n);\n                }\n                else if(c==2)\n                {\n                    int n;\n                    printf(\"\\nPlease enter the element to be deleted: \");\n                    scanf(\"%d\",&n);\n                    if (head==NULL)\n                        printf(\"COULDN'T DELETE %d. LIST EMPTY\\n\",n);\n                    else\n                    {\n                        node* del_node=search_node(head,n);\n                        if(del_node==NULL)\n                            printf(\"COULDN'T DELETE %d. NOT FOUND IN LIST.\\n\",n);\n                        else\n                        {\n                            deletion(&head,del_node);\n                            printf(\"%d deleted from LIST.\\n\",n);\n                        }\n                    }\n                }\n                else if (c==3)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nTRAVERSAL IN FORWARD DIRECTION: \\n\");\n                        printforward(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==4)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nTRAVERSAL IN REVERSE DIRECTION: \\n\");\n                        printreversed(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if(c==5)\n                {\n                    printf(\"\\nExitting Sequential Order Insertion, Thank You.\\n\");\n                    break;\n                }\n                else\n                    printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n            }\n        }\n        else if(ch==3)\n        {\n            printf(\"\\nExitting Program, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n    }\n    return 0;\n}"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__3-2.0.c", "original_string": "int main(){\n  char s[MAXLINE];\n  char t[MAXLINE];\n  char r[MAXLINE];\n  int len = getlinee(s);\n  escape(s, t);\n  inverse_escape(t, r);\n  printf(\"word received:%s\", s);\n  printf(\"after escape:%s\\n\", t);\n  printf(\"inverse_escape:%s\", r);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__power.2.c", "original_string": "int main()\n{\n    int no1 = 0, no2 = 0, iRet = 0;\n    printf(\"Enter first number\\n\");\n    scanf(\"%d\",&no1);\n    printf(\"Enter second number\\n\");\n    scanf(\"%d\",&no2);\n    iRet = PowerR(no1,no2);\n    printf(\"Result is %d\",iRet);\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_chibios.2.c", "original_string": "bool_t osCreateStaticTask(OsTask *task, const char_t *name, OsTaskCode taskCode,\n   void *param, void *stack, size_t stackSize, int_t priority)\n{\n   stackSize *= sizeof(uint_t);\n   task->tp = chThdCreateStatic(stack, stackSize,\n      priority, (tfunc_t) taskCode, param);\n   if(task->tp != NULL)\n      return TRUE;\n   else\n      return FALSE;\n}"}
{"author": "2security", "file": "String__37TrimWhiteSpace.2.c", "original_string": "int main()\n    {\n        int i,n;\n        char str[50];\n        printf(\"\\n Enter the string:\");\n        gets(str);\n        printf(\"\\n Before trimming:\");\n        printf(\"%s\",str);\n        printf(\"\\n After  trimming:\");\n        printf(\"%s\",Trim(str));\n        printf(\"Good bye\");\n        return 0;\n    }"}
{"author": "2security", "file": "String__19FindNoOfMinOccurrence.0.c", "original_string": "int MyMin(int a[],int n)\n    {\n        int i,min=0;\n        for(i=0;i<n;i++)\n            {\n                if(a[i]!=0)\n                    {\n                    if(a[i]<a[min]||a[min]==0)\n                        min=i;\n                    }\n            }\n        return min;\n    }"}
{"author": "Qu-Xiangjun", "file": "network-project-master__sender0.1.c", "original_string": "void output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n    }\n    printf(\"\\n\");\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__BC.0.c", "original_string": "int main()\n{\n    char hex[9];\n    long int soma = 0;\n    int tam, pot;\n    fgets(hex, 9, stdin);\n    for (int i = 0; hex[i] != '\\0'; i++)\n    {\n        if (hex[i] == '\\n')\n        {\n            hex[i] = '\\0';\n        }\n    }\n    tam = strlen(hex);\n    pot = tam - 1;\n    for (int i = 0; hex[i] != '\\0'; i++)\n    {\n        switch (hex[i])\n        {\n        case '1':\n            soma += 1 * pow(16, (pot - i));\n            break;\n        case '2':\n            soma += 2 * pow(16, (pot - i));\n            break;\n        case '3':\n            soma += 3 * pow(16, (pot - i));\n            break;\n        case '4':\n            soma += 4 * pow(16, (pot - i));\n            break;\n        case '5':\n            soma += 5 * pow(16, (pot - i));\n            break;\n        case '6':\n            soma += 6 * pow(16, (pot - i));\n            break;\n        case '7':\n            soma += 7 * pow(16, (pot - i));\n            break;\n        case '8':\n            soma += 8 * pow(16, (pot - i));\n            break;\n        case '9':\n            soma += 9 * pow(16, (pot - i));\n            break;\n        case 'a':\n            soma += 10 * pow(16, (pot - i));\n            break;\n        case 'b':\n            soma += 11 * pow(16, (pot - i));\n            break;\n        case 'c':\n            soma += 12 * pow(16, (pot - i));\n            break;\n        case 'd':\n            soma += 13 * pow(16, (pot - i));\n            break;\n        case 'e':\n            soma += 14 * pow(16, (pot - i));\n            break;\n        case 'f':\n            soma += 15 * pow(16, (pot - i));\n            break;\n        }\n    }\n    printf(\"%li\\n\", soma);\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__shell_server.4.c", "original_string": "error_t shellServerSetPrompt(ShellServerSession *session,\n   const char_t *prompt)\n{\n   if(session == NULL || prompt == NULL)\n      return ERROR_INVALID_PARAMETER;\n   if(osStrlen(prompt) > SHELL_SERVER_MAX_PROMPT_LEN)\n      return ERROR_INVALID_LENGTH;\n   osStrcpy(session->prompt, prompt);\n   session->promptLen = osStrlen(prompt);\n   return NO_ERROR;\n}"}
{"author": "dle2005", "file": "Algorithm__Knapsack3.2.c", "original_string": "void rmove(node *v) {\n    front = front+1;\n    v->level = queue[front].level;\n    v->profit = queue[front].profit;\n    v->weight = queue[front].weight;\n    v->bound = queue[front].bound;\n}"}
{"author": "dishanp", "file": "DSA__q55.0.c", "original_string": "void create(int A[], int n)\n{\n    struct node *t, *last;\n    first = (struct node*)malloc(sizeof(struct node));\n    first->data = A[0];\n    first->next = NULL;\n    last = first;\n    for(int i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc-a.1.c", "original_string": "list* rec_insert(list* node, int key) \n{ \n    if (node == NULL) \n    return newNode(key); \n    if (key < node->key) \n        node->left = rec_insert(node->left, key); \n    else if (key > node->key) \n        node->right = rec_insert(node->right, key); \n    return node; \n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__tcpdaytimeserver.0.c", "original_string": "void main(int argc,char*argv[])\n{\n    int sid,sid1,rval;\n    time_t t=time(0);\n    struct sockaddr_in s,c;\n    char buffer[20],smsg[30];\n    strcpy(smsg,ctime(&t));\n    int clen; \n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    sid=socket(AF_INET,SOCK_STREAM,6);\n    if(sid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=bind(sid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)\n    {\n        perror(\"BIND-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    rval=listen(sid,5);\n    if(rval==-1)\n    {\n        perror(\"LISTEN-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    clen=sizeof(c);\n    sid1=accept(sid,(struct sockaddr*)&c,&clen);\n    rval=recv(sid1,buffer,sizeof(buffer),0);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nClient request is %s\\n\",buffer);\n    }\n    strcpy(smsg,ctime(&t));\n    rval=send(sid1,smsg,sizeof(smsg),0);\n    if(rval==-1)\n    {\n        perror(\"MSG-SND-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nResponse sent\\n\");\n    }\n    close(sid);\n    close(sid1);\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_nus_c.6.c", "original_string": "static uint32_t cccd_configure(uint16_t conn_handle, uint16_t cccd_handle, bool enable)\n{\n        NRF_LOG_DEBUG(\"Configuring CCCD. CCCD Handle = %d, Connection Handle = %d\",\n                      cccd_handle,conn_handle);\n        tx_message_t * p_msg;\n        uint16_t cccd_val = enable ? BLE_GATT_HVX_NOTIFICATION : 0;\n        p_msg              = &m_tx_buffer[m_tx_insert_index++];\n        m_tx_insert_index &= TX_BUFFER_MASK;\n        p_msg->req.write_req.gattc_params.handle   = cccd_handle;\n        p_msg->req.write_req.gattc_params.len      = WRITE_MESSAGE_LENGTH;\n        p_msg->req.write_req.gattc_params.p_value  = p_msg->req.write_req.gattc_value;\n        p_msg->req.write_req.gattc_params.offset   = 0;\n        p_msg->req.write_req.gattc_params.write_op = BLE_GATT_OP_WRITE_REQ;\n        p_msg->req.write_req.gattc_value[0]        = LSB_16(cccd_val);\n        p_msg->req.write_req.gattc_value[1]        = MSB_16(cccd_val);\n        p_msg->conn_handle                         = conn_handle;\n        p_msg->type                                = WRITE_REQ;\n        tx_buffer_process();\n        return NRF_SUCCESS;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedList-1.1.c", "original_string": "int find(node *ptr, int key)\n{\n        node *start = ptr;\n        ptr =  ptr -> next; \n        while(ptr!=start)\n        {\n                if(ptr->data == key) \n                {\n                        return 1;\n                }\n                ptr = ptr -> next;  \n        }\n        return 0;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "1lista_de_C__main13.0.c", "original_string": "int main()\n{\n    int a;\n    int b;\n    int c;\n    printf(\"Digite o primeiro numero: \");\n    scanf(\"%d\",&a);\n    printf(\"Digite o segundo numero: \");\n    scanf(\"%d\",&b);\n    printf(\"Digite o terceiro numero: \");\n    scanf(\"%d\",&c);\n    if\n    ((a>b) && (b>c)){\n    printf (\"%d,%d,%d\", c,b,a);\n    }\n    if\n    ((a>b) && (c>b)){\n    printf (\"%d,%d,%d\", b,c,a);\n    }\n    if\n    ((b>a) && (a>c)){\n    printf (\"%d,%d,%d\", c,a,b);\n    }\n    if\n    ((b>c) && (c>a)){\n    printf (\"%d,%d,%d\", a,c,b);\n    }\n    if\n    ((c>b) && (b>a)){\n    printf (\"%d,%d,%d\", a,b,c);\n    }\n    if\n    ((c>a) && (a>b)){\n    printf (\"%d,%d,%d\", b,a,c);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__mergeSortedLL.0.c", "original_string": "Node* mergeTwoLLs(Node *head1, Node *head2) \n{\n    Node* t1 = head1;\n    Node* t2 = head2;\n    Node* head;\n    Node* tail;\n    if(head1->data <= head2->data)\n    {\n        head = head1;\n        tail = head1;\n        t1 = t1->next;\n    }   \n    else \n    {\n        head = head2;  \n        tail = head2;\n        t2 = t2->next;\n    }\n    while(t1 != NULL && t2 != NULL)    \n        if(t1->data <= t2->data)\n        {\n            tail->next = t1;\n            tail = t1;\n            t1 = t1->next;\n        }\n        else\n        {\n            tail->next = t2;\n            tail = t2;\n            t2 = t2->next;\n        }\n    if(t1 == NULL)\n        tail->next = t2;\n    else\n        tail->next = t1;\n    return head;\n}"}
{"author": "haon1026", "file": "linux-programming__cond_produce_multconsumer.2.c", "original_string": "void *comsumer(void *arg)\n{\n    while(1)\n    {\n        pthread_mutex_lock(&mutex);                     \n        while(head == NULL)                             \n        {\n            pthread_cond_wait(&has_data, &mutex);       \n        }                                               \n        struct msg *mp = head;\n        head = head->next;\n        pthread_mutex_unlock(&mutex);                   \n        printf(\"----------comsumer id: %lu : %d\\n\", pthread_self(), mp->num);\n        free(mp);\n        sleep(rand()%3);\n    }\n    return NULL;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_last_DLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__Main0.0.c", "original_string": "int32_t main(int32_t argc, char *argv[])\n{\n  char *programDir = dirname(strdup(argv[0]));\n  chdir(programDir);\n  firmwareUpdateInfoReader_init();\n  fotaUpdateWorkflow_init();\n  fotahub_init(argv[0], DEMO_PRODUCT_ID, DEMO_PRODUCT_NAME, &FOTA_UPDATE_CLIENT_CONFIG);\n  printf(\"\\n--------------------------------------------------------------------------\\n\");\n  printf(\"Running %s %s firmware\\n\", DEMO_PRODUCT_NAME, DEMO_PRODUCT_FIRMWARE_VERSION);\n  printf(\"--------------------------------------------------------------------------\\n\\n\");\n  fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);\n  char *separator = (strlen(programDir) > 0) ? (\"/\") : (\"\");\n  printf(\"Waiting for firmware update info (<new-version>:<checksum-or-signature>) to be entered and saved in '%s%s%s' file\\n\", programDir, separator, DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n  while (true)\n  {\n    firmwareUpdateInfoReader_run();\n    fotahub_run();\n  }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insertion.0.c", "original_string": "int main(void) {\n    printf(\"insertion \\n\"); \n    printf(\"insert an element in the array \\n\");\n    int a[100]={0};\n    int n=10;\n    int i;\n    printf(\"the elements in the array are : \\n\");\n    for(i=0;i<n;i++)\n    {\n        a[i]=i+4;\n        printf(\"%d\\t\",a[i]);\n    }\n    int b=25,pos=3;\n    printf(\"\\n the element is going to insert is : %d \\n\",b);\n    printf(\" the element is going to insert at position is : %d \\n\",pos);\n    n++;\n    for(i=n-1;i>=pos;i--)\n    {\n        a[i]=a[i-1];\n    }\n    a[pos-1]=b;\n    printf(\"\\n after the insertion the elements in the array are \\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\",a[i]);\n    }\n    return EXIT_SUCCESS;\n}"}
{"author": "paawankohli", "file": "CN-Lab__tcpc.0.c", "original_string": "void main () {\n    struct sockaddr_in seradd;\n    int sockaddr_len = sizeof(seradd);\n    seradd.sin_family = AF_INET;\n    seradd.sin_port = 1326;\n    seradd.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    int fd = socket(AF_INET, SOCK_STREAM, 0);\n    connect(fd, (struct sockaddr*)&seradd, sockaddr_len);\n    while (1) {\n        printf(\"enter n and elements: \");\n        int n; scanf(\"%d\", &n);\n        int arr[n + 1];\n        arr[0] = n;\n        for (int i = 1; i <= n; ++i)\n            scanf(\"%d\", &arr[i]);\n        write(fd, arr, (n + 1) * 4);\n        if (n == 0) {\n            break;\n        }\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__pol-add-sub-mul.2.c", "original_string": "node* poly_mul(node* exp1, node* exp2)\n{\n    node* res=NULL;\n    node* t=exp2;\n    while(exp1)\n    {\n        while(t)\n        {\n            createNode(exp1->coeff * t->coeff,exp1->pow + t->pow,&res);\n            t=t->next;\n        }\n        t=exp2;\n        exp1=exp1->next;\n    }\n    return res;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "2lista_de_C__main6.0.c", "original_string": "int main()\n{\nint c; \nint l; \nint a;\nint b;\n    printf(\"Digite um numero: \");\n    scanf(\"%d\",&a);\n    for (l=1; l<a; l++)\n    {\n        for (c=1; c<=a; c++)\n        {\n            if(c<=l){\n                    b = c;\n                printf(\"%d \",b);\n            }\n        }\n        printf(\"\\n\");\n    }\n        printf(\"\\n\\n\\n\");\n}"}
{"author": "ankitraj311", "file": "450_babbar__2_max_min_in_array_GEEk_2.0.c", "original_string": "struct pair max_min_array(int arr[], int low, int high)\n{\n  struct pair minmax,mml,mmr;\n  int mid;\n  if( low == high)\n  {\n    minmax.max = arr[low];\n    minmax.min = arr[low];\n    return minmax;\n  }\n  if(high == low+1)\n  {\n    if(arr[low]>arr[high])\n    {\n      minmax.max = arr[low];\n      minmax.min = arr[high];\n    }\n    else\n    {\n      minmax.min = arr[low];\n      minmax.max = arr[high];\n    }\n    return minmax;\n  }\n  mid = (low+high)/2;\n  mml = max_min_array(arr, low, mid);\n  mmr = max_min_array(arr, mid+1, high);\n  if(mml.min < mmr.min)\n    minmax.min = mml.min;\n  else\n    minmax.min = mmr.min;\n  if(mml.max > mmr.max)\n    minmax.max = mml.max;\n  else\n    minmax.max = mmr.max;\n  return minmax;\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise9.0.c", "original_string": "int ForFibonacci(int arr[],int index){\n    int i;\n    arr[0] = 1;\n    arr[1] = 1;\n    for( i=2 ; i<(SIZE-1) ; i++ ){\n        arr[i] = arr[i-1] + arr[i-2];\n    }\n    return arr[index];\n}"}
{"author": "haon1026", "file": "linux-programming__cond_produce_multconsumer.3.c", "original_string": "int main()\n{\n    srand(time(NULL));\n    pthread_t pid, cid1, cid2, cid3;\n    int ret = pthread_create(&pid, NULL, producer, NULL);   \n    if(ret != 0)\n        err_thread(ret, \"pthread_create producer error\");\n    ret = pthread_create(&cid1, NULL, comsumer, NULL);       \n    if(ret != 0)\n        err_thread(ret, \"pthread_create comsumer error\");\n    ret = pthread_create(&cid2, NULL, comsumer, NULL);       \n    if(ret != 0)\n        err_thread(ret, \"pthread_create comsumer error\");\n    ret = pthread_create(&cid3, NULL, comsumer, NULL);       \n    if(ret != 0)\n        err_thread(ret, \"pthread_create comsumer error\");\n    pthread_join(pid, NULL);\n    pthread_join(cid1, NULL);\n    pthread_join(cid2, NULL);\n    pthread_join(cid3, NULL);\n    return 0;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__employee.2.c", "original_string": "int main()\n{\n    PNODE First = NULL;\n    InsertFirst(&First);\n        InsertFirst(&First);\n        InsertFirst(&First);\n    printf(\"Information of Employess\\n\");\n    Display(First);\n    return 0;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__a.0.c", "original_string": "int     ft_to_lower(char c, char d)\n{\n    if (c >= 'A' && c <= 'Z')\n    {\n        if (d != ' ' && d != '\\t' && d != '\\0')\n            return (1);\n    }\n    return (0);\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Search_In_A_Single_Linked_List.2.c", "original_string": "void search_node(struct node*head1, struct node*temp1)\n{\n    int val;\n    printf(\"\\nWHICH ELEMENT YOU ARE LOOKING FROM THE ABOVE LIST?\\n\");\n    scanf(\"%d\",&val);\n    int count = 1;\n    while(temp1->data!=val)\n    {\n        count++;\n        temp1 = temp1->link;\n    }\n    printf(\"THE ELEMENT %d IS PRESENT AT POSITION %d\",temp1->data,count);\n    return;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-central-scanner-with-whitelist__nrf_ble_whitelist.1.c", "original_string": "ret_code_t nrf_ble_whitelist_enable(void)\n{\n        ret_code_t ret;\n        m_whitelist_is_running = true;\n        if (m_addr_cnt == 0)\n        {\n                return NRF_ERROR_DATA_SIZE;\n        }\n        for (uint32_t i = 0; i < BLE_GAP_WHITELIST_ADDR_MAX_COUNT; i++)\n        {\n                m_whitelist_addr_ptrs[i] = &m_whitelist_addrs[i];\n        }\n        ret = sd_ble_gap_whitelist_set(m_whitelist_addr_ptrs, m_addr_cnt);\n        APP_ERROR_CHECK(ret);\n        return NRF_SUCCESS;\n}"}
{"author": "revathy16296", "file": "rtos_lab_asssignment_1__1_sum.0.c", "original_string": "int main()\n{\n    int array[SI];\n    float product,average,sum;\n    printf(\"enter the array elements\\n\");\n    for(i=0;i<SI;i++)\n    {\n        scanf(\"%d\",&array[i]);\n    }\n    sum=sum_of_num(array);\n    printf(\"the sum of number is %f\\n\",sum);\n    average=average_of_num(sum);\n    printf(\"the average is %f\\n\",average);\n    product=product_of_num(array);\n    printf(\"product of number is %f\",product);\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__DemoFOTAUpdateWorkflow0.1.c", "original_string": "void fotahub_onConnectionStatusChanged(ConnectionStatus_t status)\n{\n  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);\n}"}
{"author": "dle2005", "file": "Algorithm__Chained_Matrix_Multiplication_v2.3.c", "original_string": "void order(index i, index j, int **P) {\n    int k;\n    if(i == j) printf(\"A%d \", i);\n    else {\n        k = P[i][j];\n        printf(\"( \");\n        order(i, k, P);\n        order(k+1, j, P);\n        printf(\") \");\n    }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BST.1.c", "original_string": "struct tree* insert(struct tree* root,int tar)\n{\n    struct tree* p=(struct tree*)malloc(sizeof(struct tree));\n    p->val=tar;\n    p->left=NULL;\n    p->right=NULL;\n    if(root!=NULL)\n    {\n        if(tar<root->val)\n        root->left=insert(root->left,tar);\n        else if(tar>root->val)\n        root->right=insert(root->right,tar);\n        else if(tar==root->val)\n        return(root);\n    }\n    else\n    {\n        root=p;\n        return(root);\n    }\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_8_a.0.c", "original_string": "int main()\n{\n    int one[8] = {5, 6, 8, 8, 10, -2, 0, 121};\n    int two[8] = {2, 1, 3, -4, 10, 21, 2, 233};\n    double three[16];\n    unsigned int naturalNumber = 8;\n    printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n    connectArrays(naturalNumber, one, two, three);\n    printf(\"\\nElementy tablicy3: \");\n    for(int i = 0; i < (sizeof(three)/sizeof(three[0])); i++){\n        printf(\"%.f \", three[i]);\n    }\n    getchar();;\n    return 0;\n}"}
{"author": "dishanp", "file": "DSA__q7.0.c", "original_string": "int main()\n{\n    int a[1000],i,n,min,max;\n    printf(\"Enter size of the array : \");\n    scanf(\"%d\",&n);\n    printf(\"Enter elements in array : \");\n    for(i=0; i<n; i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    min=max=a[0];\n    for(i=1; i<n; i++)\n    {\n         if(min>a[i])\n          min=a[i];\n           if(max<a[i])\n            max=a[i];\n    }\n    printf(\"minimum of array is : %d\",min);\n    printf(\"\\nmaximum of array is : %d\",max);\n    return 0;\n}"}
{"author": "revathy16296", "file": "rtos_lab_asssignment_1__8_filecount.0.c", "original_string": "int main()\n{\n    FILE *f;\n    char s[FILE_SIZE];\n    printf(\"enter the source file path\\n\");\n    scanf(\"%s\",s);\n    read_lines(s);\n    return 0;\n}"}
{"author": "MartinMarinovich", "file": "ParcialLaboratorio1GCompleto__servicio.0.c", "original_string": "int hardCodearServicios(eServicio listadoServicios[], int tamanioServicio)\n{\n    int error = -1;\n    int idServicio [4]= {2000,2001,2002,2003};\n    char servicio [4][25] = {\"Bateria\",\"Antivirus\",\"Actualizacion\",\"Fuente\"};\n    int precios[4] = {250,300,400,600};\n    if(listadoServicios != NULL && tamanioServicio>0)\n    {\n        for(int i = 0; i<tamanioServicio; i++)\n        {\n            strcpy(listadoServicios[i].descripcion,servicio[i]);\n            listadoServicios[i].precio = precios[i];\n            listadoServicios[i].idServicio = idServicio[i];\n        }\n        error = 0;\n    }\n    return error;\n}"}
{"author": "earth429", "file": "mulpre__mulprec.19.c", "original_string": "int multiple(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    int i, j, h, e, aj, bi;\n    struct NUMBER tmp, d;\n    int flag_a = 0; \n    int flag_b = 0; \n    clearByZero(c);\n    for (i = 0; i < KETA;i++){\n        bi = b->n[i];\n        h = 0;\n        clearByZero(&d);\n        for (j = 0; j <= KETA;j++){\n            aj = a->n[j];\n            e = aj * bi + h; \n            d.n[j] = (e % 10); \n            e /= 10;\n            h = (e % 10); \n            e /= 10;\n            if(i == KETA && h != 0){ \n                return -1;\n            }\n        }\n        add(c, &d, c);\n    }\n    return 0; \n}"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLLcircular.4.c", "original_string": "nptr deleteRight(nptr head)\n{\n    if(head == NULL)\n        return head;\n    if(head -> left == head && head -> right == head)\n    {\n        printf(\"%d deleted\\n\", head -> data);\n        free(head);\n        return NULL;\n    }\n    nptr curr = head;\n    while(curr -> right != head)\n        curr = curr -> right;\n    (curr -> left) -> right = head;\n    head -> left = curr -> left;\n    printf(\"%d deleted\\n\", curr -> data);\n    free(curr);\n    return head;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__stack_using_array.4.c", "original_string": "void display()\n{\n    int i;\n    if(top>-1)\n    {\n        for(i=top;i>=0;i--)\n        {\n            printf(\"%d\\t\",stack[i]);\n        }\n        printf(\"\\n\");\n    }\n    else\n    {\n        printf(\"the stack is empty\\n\");\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__extr_intr.1.c", "original_string": "void intr_config(void)\n{\n    VICIntSelect &= ~(1<<15);   \n    VICVectCntl2 = (1<<5)|15;\n    VICVectAddr2 = (long)ext_isr;\n    VICIntEnable = (1<<15);\n    EXTMODE = 1<<1;  \n    EXTPOLAR = (1<<1); \n}"}
{"author": "haon1026", "file": "linux-programming__signalset-op.2.c", "original_string": "int main()\n{\n    sigset_t set;\n    sigemptyset(&set);\n    sigaddset(&set, SIGINT);\n    sigaddset(&set, SIGQUIT);\n    sigaddset(&set, SIGKILL);   \n    sigaddset(&set, SIGBUS);\n    sigset_t oldset;\n    int ret = sigprocmask(SIG_BLOCK, &set, &oldset);\n    if(ret == -1)\n        sys_err(\"sigprocmask error\");\n    sigset_t pendset;\n    while(1)\n    {\n        ret = sigpending(&pendset);\n        if(ret == -1)\n            sys_err(\"sigpending error\");\n        print_set(&pendset);\n        sleep(1);\n    }\n    return 0;\n}"}
{"author": "2security", "file": "Pointer__17ArraySorting.1.c", "original_string": "int main()\n    {\n        int *a,m,i;\n        printf(\"\\n Enter size of array1:: \");\n        scanf(\"%d\",&m);\n        a=(int *)malloc(m*sizeof(int *));\n        printf(\"\\n Enter %d elements of array::\",m);\n        for(i=0;i<m;i++)\n            scanf(\"%d\",&*(a+i));\n        Mysort(a,m);\n        printf(\"\\n After sorting:: \");\n        for(i=0;i<m;i++)\n            printf(\"%d \",*(a+i));\n        return 0;\n    }"}
{"author": "dle2005", "file": "Algorithm__n_Coloring_v2.2.c", "original_string": "void main() {\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"m = \");\n    scanf(\"%d\", &m);\n    printf(\"\\n\");\n    W = (int **)malloc(sizeof(int *) * (n+1));\n    for(int i = 0; i <= n; i++)\n        W[i] = (int *)malloc(sizeof(int) * (n+1));\n    vcolor = (int *)malloc(sizeof(int) * (n+1));\n    memset(vcolor, 0, sizeof(int) * (n+1));\n    printf(\"W = \\n\");\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++)\n            scanf(\"%d\", &W[i][j]);\n    printf(\"\\n\");\n    m_coloring(0);\n}"}
{"author": "sdukesameer", "file": "dsa__bst-del_int-iter_in-pre.4.c", "original_string": "void display(node* root,int n)\n{\n    if (root==NULL)\n    {\n        for (int i = 0; i < n-2; i++)\n            printf(\" \");\n        printf(\"NULL\\n\");\n    }\n    else\n    {\n        display(root->right,n+5);\n        for (int i = 0; i < n+2; i++)\n            printf(\" \");\n        printf(\"/\\n\");\n        for (int i = 0; i < n; i++)\n            printf(\" \");\n        printf(\"%d\\n\",root->data);\n        for (int i = 0; i < n+2; i++)\n            printf(\" \");\n        printf(\"\\\\\\n\");\n        display(root->left,n+5);\n    }\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example7.0.c", "original_string": "int main()\n{\n    int dizi[10]={1,23,4,534,123,564,89,34,76,0};\n    int i,j,temp;\n   for(j=0;j<10;j++)\n   {\n        for(i=0;i<10;i++)\n        {   \n            if(dizi[i]>dizi[i+1])\n            {\n            temp=dizi[i];\n            dizi[i]=dizi[i+1];\n            dizi[i+1]=temp;\n            }\n        }\n   }   \n    printf(\"s\u0131ralanm\u0131\u015f dizi:\\n\");\n    for(i=0;i<10;i++)\n    printf(\"%d\\n\",dizi[i]);\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad9.0.c", "original_string": "int main()\n{\n    treePointer root = NULL;\n    root = InsertElement(2, root);\n    root = InsertElement(4, root);\n    root = InsertElement(9, root);\n    root = InsertElement(1, root);\n    root = InsertElement(11, root);\n    root = InsertElement(7, root);\n    root = DeleteElement(2, root);\n    int choice = 0, element;\n    treePointer temp = NULL;\n    do\n    {\n        printf(\"Odaberi:\\n\");\n        printf(\"1 - unos novog elementa u stablo\\n\");\n        printf(\"2 - ispis inorder stabla\\n\");\n        printf(\"3 - ispis postorder stabla\\n\");\n        printf(\"4 - ispis preorder stabla\\n\");\n        printf(\"5 - trazenje elementa stabla\\n\");\n        printf(\"6 - brisanje elementa iz stabla\\n\");\n        printf(\"7 - izlaz\\n\");\n        scanf(\"%d\", &choice);\n        system(\"cls\");\n        switch (choice)\n        {\n        case 1:\n            printf(\"Unesi element koji zelis unijeti u stablo:\\n\");\n            scanf(\"%d\", &element);\n            root = InsertElement(element, root);\n            break;\n        case 2:\n            InOrderPrint(root);\n            break;\n        case 3:\n            PostOrderPrint(root);\n            break;\n        case 4:\n            PreOrderPrint(root);\n            break;\n        case 5:\n            printf(\"Unesi element koji trazis u stablu:\\n\");\n            scanf(\"%d\", &element);\n            temp = FindElement(element, root);\n            if (temp)\n                printf(\"Element %d se nalazi na adresi %d\\n\", temp->data, temp);\n            break;\n        case 6:\n            printf(\"Unesi element koji brises iz stabla:\\n\");\n            scanf(\"%d\", &element);\n            root = DeleteElement(element, root);\n        case 7:\n            break;\n        default:\n            printf(\"Pogresan unos!\\n\");\n        }\n    } while (choice != '7');\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__DFS1.4.c", "original_string": "void main()\n{\n    int n,i,vertices[10],ct=0,v,visited[10]={1,1,1,1,1,1,1,1,1,1};\n    printf(\"\\nEnter the number of vertices of graph:\");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    G[i]=NULL;\n    create(G,n);\n    display(G,n);\n    printf(\"\\nEnter the starting vertex:\");\n    scanf(\"%d\",&v);\n    push(v);\n    ct=0;\n    while(top>=0)\n    {\n        vertices[ct]=pop(); \n        visited[v]=3;\n        v=vertices[ct];\n        ct++;\n        last=G[v];\n        while(last!=NULL)\n        {\n            if(visited[last->val]==1)\n            {   push(last->val);\n                visited[last->val]=2;\n            }\n            last=last->next;\n        }\n    }       \n    printf(\"\\nThe graph is:\\n\");\n    for(i=0;i<ct;i++)\n    {\n        printf(\"\\t%d\",vertices[i]);\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_any_pos_CLL.3.c", "original_string": "int  count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the list is %d\\n\",c);\n    return c;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__SinglePartitionDemoFirmwareUpdateInfoSerialReader0.1.c", "original_string": "void firmwareUpdateInfoReader_run(void)\n{\n  if ((updateInfoParser.__currentState == FirmwareUpdateInfoParser_yielding__state)) \n  {\n    printf(\"Firmware update request towards version %s received\\n\", updateVersion);\n    fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);\n    FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_updateInfoPickedUp__event, NULL);\n  }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q1_queue.3.c", "original_string": "void insert(queue* q,int x)\n{\n    node* temp;\n    if(q->front==NULL)\n    {\n        temp=(nodePointer)malloc(sizeof(node));\n        temp->data=x;\n        temp->link=NULL;\n        q->front=temp;\n        q->rear=temp;\n    }\n    else\n    {\n        temp=(nodePointer)malloc(sizeof(node));\n        temp->data=x;\n        temp->link=NULL;\n        q->rear->link=temp;\n        q->rear=temp;\n    }\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__hackerrankques1.0.c", "original_string": "int main()\n{\n    int l,n,i;\n    scanf(\"%d\",&l);\n    scanf(\"%d\",&n);\n    for(i=l;i<=n;i++)\n    {\n        if(i==1)\n     {\n        printf(\"One\\n\");\n     }\n    else if(i==2)\n     {\n        printf(\"Two\\n\");\n     }\n    else if(i==3)\n     {\n        printf(\"Three\\n\");\n     }\n    else if(i==4)\n     {\n        printf(\"Four\\n\");\n     }\n    else if(i==5)\n     {\n        printf(\"Five\\n\");\n     }\n    else if(i==6)\n     {\n        printf(\"Six\\n\");\n     }\n    else if(i==7)\n     {\n        printf(\"Seven\\n\");\n     }\n    else if(i==8)\n     {\n        printf(\"Eight\\n\");\n     }\n    else if(i==9)\n     {\n        printf(\"Nine\\n\");\n     }\n     else if(i%2==0)\n     {\n        printf(\"even\\n\");\n     }\n     else\n     printf(\"odd\\n\");\n    }\n    return 0;\n}"}
{"author": "mandarvu", "file": "msc__problem6.1.c", "original_string": "int search(int *array, int num) {\n  for (int j = 0; j < MAX; j++)\n  {\n    if (*(array + j) == num)\n    {\n      return (j + 1);\n    }\n  }\n  return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post-a.1.c", "original_string": "list* rec_insert(list* node, int key) \n{ \n    if (node == NULL) \n    return newNode(key); \n    if (key < node->key) \n        node->left = rec_insert(node->left, key); \n    else if (key > node->key) \n        node->right = rec_insert(node->right, key); \n    return node; \n}"}
{"author": "behergue", "file": "Operating_Systems__myFS.22.c", "original_string": "int writeBlock(MyFileSystem *myFileSystem, DISK_LBA blockNumber, void *buffer)\n{\n    if(blockNumber < 0 || blockNumber >= myFileSystem->superBlock.diskSizeInBlocks) {\n        fprintf(stderr,\"Firts bocks to be read must be between 0 and %d\\n\", myFileSystem->superBlock.diskSizeInBlocks-1);\n        return -1;\n    }\n    if( lseek(myFileSystem->fdVirtualDisk, blockNumber*BLOCK_SIZE_BYTES, SEEK_SET) == (off_t)-1 ) {\n        perror(\"Lseek failed in writeBlock()\");\n        return -1;\n    }\n    if( write(myFileSystem->fdVirtualDisk, buffer, BLOCK_SIZE_BYTES) != BLOCK_SIZE_BYTES ) {\n        perror(\"Write failed in writeBlock()\");\n    }\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__longadd.5.c", "original_string": "int main()\n{\n    char num1[50],num2[50];\n    printf(\"Enter the first number: \");\n    scanf(\"%s\",num1);\n    printf(\"Enter the second number: \");\n    scanf(\"%s\",num2);\n    nptr n1 = getnum(num1);\n    nptr n2 = getnum(num2);\n    nptr sum = add(n1,n2);\n    printf(\"The sum of the given numbers is \");\n    disp(sum);\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.15.c", "original_string": "char* mkgotolab(VMTRANSLATOR* t) {\n    int sz = sizeof(char) * (t->classnamelen + strlen(t->currln->tokens[1]) + 3);\n    char* lab = (char*)malloc(sz);\n    sprintf(lab, \"@%s$%s\", t->classname, t->currln->tokens[1]);\n    togarbage(t, lab);\n    return lab;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_auth.0.c", "original_string": "error_t acmeClientSendAuthorizationRequest(AcmeClientContext *context,\n   AcmeAuthorization *authorization)\n{\n   error_t error;\n   error = NO_ERROR;\n   while(!error)\n   {\n      if(context->requestState == ACME_REQ_STATE_INIT)\n      {\n         TRACE_DEBUG(\"\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"## GET AUTHORIZATION ##########################################################\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"\\r\\n\");\n         context->requestState = ACME_REQ_STATE_FORMAT_BODY;\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_BODY)\n      {\n         error = acmeFormatAuthorizationRequest(context, authorization);\n         if(!error)\n         {\n            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)\n      {\n         error = acmeClientFormatRequestHeader(context, \"POST\",\n            authorization->url);\n         if(!error)\n         {\n            context->requestState = ACME_REQ_STATE_SEND_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||\n         context->requestState == ACME_REQ_STATE_SEND_BODY ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||\n         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||\n         context->requestState == ACME_REQ_STATE_CLOSE_BODY)\n      {\n         error = acmeClientSendRequest(context);\n      }\n      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)\n      {\n         error = acmeClientParseAuthorizationResponse(context, authorization);\n         context->requestState = ACME_REQ_STATE_INIT;\n         break;\n      }\n      else\n      {\n         error = ERROR_WRONG_STATE;\n      }\n   }\n   return error;\n}"}
{"author": "Theemiss", "file": "binary_trees__16-binary_tree_is_perfect.2.c", "original_string": "int binary_tree_is_perfect(const binary_tree_t *tree)\n{\n    binary_tree_t *left, *right;\n    size_t l_r, l_l;\n    if (tree == NULL)\n        return (0);\n    left = tree->left;\n    right = tree->right;\n    if (binary_tree_is_leaf(tree))\n        return (1);\n    if (left == NULL || right == NULL)\n        return (0);\n    l_r = binary_tree_height(right);\n    l_l = binary_tree_height(left);\n    if (l_r == l_l)\n    {\n        if (binary_tree_is_perfect(left) && binary_tree_is_perfect(right))\n            return (1);\n    }\n    return (0);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q2_set1.3.c", "original_string": "void display(nodeptr a)\n{\n    printf(\"\\n\");\n    for(;a;a=a->link)\n        printf(\"%d --> \",a->data);\n    printf(\"NULL\\n\");\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q2_longadd.3.c", "original_string": "nptr add(nptr num1,nptr num2)\n{\n    nptr sum=createNode();\n    nptr n1=num1->llink,n2=num2->llink;\n    int cin=0;\n    int s=0;\n    while(n1!=num1&&n2!=num2)\n    {\n        s=n1->ele+n2->ele+cin;\n        if(s>=10)\n        { \n            cin=1;\n            insert(sum, s-10);\n        }\n        else\n        {\n            cin=0;\n            insert(sum,s);\n        }\n        n1=n1->llink;\n        n2=n2->llink;\n    }\n    while(n1!=num1)\n    {\n        s=n1->ele+cin;\n        if(s>9)\n        { \n            cin=1; \n            insert(sum,s-10);\n        }\n        else \n        {\n            cin=0; \n            insert(sum,s);\n        }\n        n1=n1->llink;\n    }\n    while(n2!=num2)\n    {\n        s=n2->ele+cin;\n        if(s>9)\n        { \n            cin=1; \n            insert(sum,s-10);\n        }\n        else \n        {\n            cin=0; \n            insert(sum,s);\n        }\n        n2=n2->llink;\n    }\n    return sum;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__ledAssign2.0.c", "original_string": "int main()\n{\n    int val;\n    IODIR1 = IODIR1 | (0xFF<<17);\n    while(1)\n    {\n        for(val =0x01;val <= 0xFF; val++)\n        {\n            IOSET1 = val<<17;\n            delay(100);\n            IOCLR1 = val<<17;\n            delay(100);\n        }\n    }\n}"}
{"author": "dishanp", "file": "DSA__q9.1.c", "original_string": "void segregate (int *arr, int n)\n{\n    int i = 0;\n    int j = n - 1;\n    while(i < j)\n    {\n        while(arr[i] == 0 && i < j)\n        i++;\n        while(arr[j] == 1 && i < j)\n        j--;\n        if(arr[i] != 0 && arr[j] != 1 && i < j)\n        {\n            swap(&arr[i], &arr[j]);\n            i++;\n            j--;\n        }\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__fork-mmap.1.c", "original_string": "int main()\n{\n    int fd = open(\"temp\", O_RDWR|O_CREAT|O_TRUNC, 0644);\n    if(fd == -1)\n        sys_err(\"open error\");\n    ftruncate(fd, 4); \n    int *p = (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);\n    if(p == MAP_FAILED)\n        sys_err(\"mmap error\");\n    close(fd);              \n    pid_t pid = fork();\n    if(pid < 0)\n        sys_err(\"fork error\");\n    else if(pid == 0)\n    {\n        *p = 2000;          \n        val = 1000;\n        printf(\"child, *p = %d, var = %d\\n\", *p, val);\n    }\n    else\n    {\n        sleep(1);\n        printf(\"parent, *p = %d, var = %d\\n\", *p, val);     \n        wait(NULL);\n        int ret = munmap(p, 4);\n        if(ret == -1)\n            perror(\"munmap error\");\n    }\n    return 0;\n}"}
{"author": "deepaliajabsingjadhav", "file": "file__copy_file_append.1.c", "original_string": "int main()\n{\n    char name1[20];\n    char name2[20];\n    printf(\"Enter source file name\\n\");\n    scanf(\"%s\",name1);\n    printf(\"Enter destination file name\\n\");\n    scanf(\"%s\",name2);\n    FileCopyAppend(name1,name2);\n    return 0;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_23.0.c", "original_string": "int main()\n{\n    int i,j,z;\n    int conjunto1[5];\n    int conjunto2[5];\n    for(i = 0; i < 5; i++){\n        printf(\"Digite um valor para a: \", i);\n        scanf(\"%d\",&conjunto1[i]);\n    }\n        printf(\"\\n \\n\");\n    for(j = 0; j < 5; j++){\n        printf(\"Digite um valor para b: \", j);\n        scanf(\"%d\",&conjunto2[j]);\n    }\n        int produto = 0;\n       for (int i = 0; i < 5; i++){\n       produto = produto + conjunto1[i] * conjunto2[i];\n        }\n        printf(\" \\n produto escalar dos dois conjuntos eh: %d \\n\", produto);\n    system(\"PAUSE\");\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__selection_sort.1.c", "original_string": "void printarray(int a[],int n)\n{\n    int i;\n    for(i=0;i<n;i++)\n        printf(\"%d\\t\",a[i]);\n}"}
{"author": "sdukesameer", "file": "c__rec_merge_sort.1.c", "original_string": "void merge_array(int a, int b, int c, int d) {\n    int temp[n];\n    int i = a, j = c, k = 0;\n    while (i <= b && j <= d) {\n        if (arr [i] < arr[j])\n            temp[k++] = arr [i++];\n        else\n            temp[k++] = arr[j++];\n    }\n    while (i <= b)\n        temp[k++] = arr[i++];\n    while (j <= d)\n        temp[k++] = arr[j++];\n    for (i = a, j = 0; i <= d; i++, j++)\n        arr[i] = temp[j];\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad11NumbersInArray.0.c", "original_string": "int main()\n{\n    double userNumber;\n    double numbersArray[3][5];\n    char letterCollection;\n    int licznik1 = 0;\n    int licznik2 = 0;\n    double sum, sumAll, biggestNumber;\n    while(licznik1 < 3) {\n        switch (licznik1){\n            case 0:\n                letterCollection = 'A';\n            break;\n            case 1:\n                letterCollection = 'B';\n            break;\n            case 2:\n                letterCollection = 'C';\n            break;\n        }\n        printf(\"Podaj liczbe nr %d dla zbioru %c: \", licznik2 + 1, letterCollection);\n        scanf(\"%lf\", &userNumber);\n        numbersArray[licznik1][licznik2] = userNumber;\n        licznik2++;\n        if(licznik2 >= 5){\n            licznik1++;\n            licznik2 = 0;\n        }\n    }\n    printf(\"\\n\");\n    licznik1 = 0;\n    licznik2 = 0;\n    for(licznik1; licznik1 < 3; licznik1++){\n            switch (licznik1){\n            case 0:\n                letterCollection = 'A';\n            break;\n            case 1:\n                letterCollection = 'B';\n            break;\n            case 2:\n                letterCollection = 'C';\n            break;\n        }\n        for(licznik2; licznik2 < 5; licznik2++){\n            printf(\"%d liczba w zbiorze %c: %.2f\\n\", licznik2 + 1, letterCollection, numbersArray[licznik1][licznik2]);\n            sum += numbersArray[licznik1][licznik2];\n            if(biggestNumber < numbersArray[licznik1][licznik2]){\n               biggestNumber = numbersArray[licznik1][licznik2];\n            }\n        }\n        licznik2 = 0;\n        printf(\"Srednia zbioru %c: %.2lf\\n\\n\", letterCollection, sum/5);\n        sumAll += sum;\n        sum = 0;\n    }\n    printf(\"Srednia wszystkich zbior\\242w: %.2lf\\n\", sumAll/15);\n    printf(\"Najwi\\251ksza liczba: %.2lf\\n\\n\", biggestNumber);\n    return 0;\n}"}
{"author": "dishanp", "file": "DSA__q100.0.c", "original_string": "int main()\n{\n    int m, n;\n    printf(\"Enter number of rows (m) : \");\n    scanf(\"%d\", &m);\n    printf(\"Enter number of columns (n) : \");\n    scanf(\"%d\", &n);\n    int **mat;\n    mat = (int**)malloc(m*sizeof(int*));\n    for(int i = 0 ; i < n ; i++)\n    {\n        mat[i] = malloc(n*sizeof(int));\n    }\n    for(int i = 0 ; i < m ; i++)\n    {\n        for(int j = 0 ; j < n ; j++)\n        {\n            printf(\"Enter element at row %d, column %d : \", i, j);\n            scanf(\"%d\", &mat[i][j]);\n        }\n    }\n    printf(\"Before swapping : \\n\");\n    for(int i = 0 ; i < m ; i++)\n    {\n        for(int j = 0 ; j < n ; j++)\n        {\n            printf(\"%d \", mat[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    int f = 0;\n    int l = n - 1;\n    int temp;\n    while(f < l)\n    {\n        for(int i = 0; i < m ; i++)\n        {\n            temp = mat[i][f];\n            mat[i][f] = mat[i][l];\n            mat[i][l] = temp;\n        }\n        f++;\n        l--;\n    }\n    printf(\"After Swapping : \\n\");\n    for(int i = 0 ; i < m ; i++)\n    {\n        for(int j = 0 ; j < n ; j++)\n        {\n            printf(\"%d \", mat[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "ankitraj311", "file": "450_babbar__4_0_1_2_array_simple_youtube.2.c", "original_string": "void sort012(int arr[], int size)\n{\n  int low,mid,high;\n  low = mid = 0;\n  high = (size-1);\n  while(mid<=high)\n  {\n    if(arr[mid]==0)\n    {\n      swap(&arr[low], &arr[mid]);\n      low++;\n      mid++;\n      continue;\n    }\n    if(arr[mid]==1)\n    {\n      mid++;\n      continue;\n    }\n    if(arr[mid]==2)\n    {\n      swap(&arr[mid], &arr[high]);\n      high--;\n      continue;\n    }\n  }\n}"}
{"author": "SugumaranEvil", "file": "TLPI__store_shm.0.c", "original_string": "int main()\n{\n   int open_fd, munmap_ret, msync_ret;\n   ssize_t write_fd;\n   char *mmap_ret;\n   char buff[50]=\"Data stored in posix shared memory\\n\";\n   open_fd = shm_open(\"/posix\" , O_CREAT | O_RDWR | O_TRUNC , 0644);\n   if(open_fd == -1){\n       perror(\"shm_open\");\n       printf(\"Return value of shm_open %d\\n\",open_fd);\n   }else {\n       perror(\"shm_open\");\n       printf(\"Return value of shm_open %d\\n\",open_fd);\n   }\n   write_fd = write(open_fd,buff,strlen(buff)+1);\n   if(write_fd == -1){\n    perror(\"write\");\n   }else {\n    perror(\"write\");\n   }\n   mmap_ret = mmap(NULL , 4096 , PROT_READ | PROT_WRITE, MAP_SHARED ,open_fd ,0);\n   perror(\"mmap\");\n   msync_ret = msync(mmap_ret, 4096, MS_SYNC);\n   if(msync_ret == -1){\n       perror(\"msync\");\n   }else {\n       perror(\"msync\");\n   }\n   munmap_ret = munmap(mmap_ret, 4096);\n   if(munmap_ret == -1) {\n       perror(\"munmap\");\n   }else {\n       perror(\"munmap\");\n   }       \n}"}
{"author": "sdukesameer", "file": "dsa__bst-del_int-iter_in-pre.1.c", "original_string": "node* insertion(node* root, int n)\n{\n    if(root==NULL) return createNode(n);\n    else if(n < root->data) root->left=insertion(root->left,n);\n    else if(n > root->data) root->right=insertion(root->right,n);\n    return root; \n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Indexed.2.c", "original_string": "void rem_file(int id)\n{\n    int i,j;\n    for(i=1;i<16;i++)\n    {\n        if(disk[i]==id)\n        {\n            disk[i]=0;\n        }\n    }\n    for(i=0;i<16;i++)\n    {\n        if(d_array[i][0]==id)\n        {\n            d_array[i][0]=0;\n            for(j=1;j<16;j++)\n            {\n                if(d_array[i][j]!=0)\n                    d_array[i][j]=0;\n                else\n                    break;\n            }\n        }\n    }\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__21_cos.2.c", "original_string": "int main()\n{\n        double X;\n    int  I;\n        printf(\"Programa para calcular cos(X) mediante sumas de taylor \\nIngresa X: \");\n    scanf(\"%lf\", &X);\n    cos(1,50,0,X); \n        return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_SLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n       if(head==0)\n       {\n            head=temp=newnode;\n       }\n       else\n       {\n            temp->next=newnode;\n            temp=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n           scanf(\"%d\",& choice);\n    }\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_6.1.c", "original_string": "void addend()\n{\n    struct node* temp;\n    temp = (struct node*)malloc(sizeof(struct node));\n    printf(\"Enter an element to append : \");\n    scanf(\"%d\", &temp->data);\n    printf(\"%d inserted.\\n\\n\", temp->data);\n    temp->left = NULL;\n    temp->right = NULL;\n    if(root == NULL)\n    {\n        root = temp;\n    }\n    else\n    {\n        struct node* p = root;\n        while(p->right != NULL)\n        {\n            p = p->right;\n        }\n        p->right = temp;\n        temp->left = p;\n    }\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es32.2.c", "original_string": "void stampa_vettore(int a[], int dim)\n{\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        printf(\"%d\\n\", a[i]);\n    }\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad7ElementsCopy.0.c", "original_string": "int main()\n{\n   int array1[7] = { 8, 32, -4, 43, 200, 4000, -6432};\n   int array2[3];\n   int array3[3];\n   int arraySize1 = sizeof(array1)/sizeof(*array1);\n   int arraySize2 = sizeof(array2)/sizeof(*array2);\n    int arraySize3 = sizeof(array3)/sizeof(*array3);\n    copyArrayNormal(&array1[2], array2, arraySize2); \n    copyArrayPointer(&array1[2], array3, arraySize3);\n    printf(\"array1: \");\n    for(int i = 0; i < arraySize1; i++){\n            printf(\"%d \", array1[i]);\n    }\n    printf(\"\\n\\narray2: \");\n    for(int i = 0; i < arraySize2; i++){\n            printf(\"%d \", array2[i]);\n    }\n    printf(\"\\n\\narray3: \");\n    for(int i = 0; i < arraySize3; i++){\n            printf(\"%d \", array3[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_any_pos_SLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n       if(head==0)\n       {\n            head=temp=newnode;\n       }\n       else\n       {\n            temp->next=newnode;\n            temp=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n           scanf(\"%d\",& choice);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q4.0.c", "original_string": "node* create()\n{\n    node *p;\n    int x;\n    printf(\"Enter data(-1 for no data):\");\n    scanf(\"%d\", &x);\n    if (x == -1)\n        return NULL;\n    p = (node*)malloc(sizeof(node));\n    p->data = x;\n    printf(\"Enter left child of %d:\\n\", x);\n    p->left = create();\n    printf(\"Enter right child of %d:\\n\", x);\n    p->right = create();\n    return p;\n}"}
{"author": "fikepaci", "file": "sorting_algorithms__1-insertion_sort_list.2.c", "original_string": "void insertion_sort_list(listint_t **list)\n{\n    listint_t *c;\n    if ((list == NULL) || (*list == NULL) || ((*list)->next == NULL))\n        return;\n    c = *list;\n    while (c->next != NULL)\n    {\n        if (c->n > c->next->n)\n        {\n            swap_forward(c);\n        }\n        else\n            c = c->next;\n    }\n    while ((*list)->prev != NULL)\n        *list = (*list)->prev;\n}"}
{"author": "Mr-JoE1", "file": "C-Tasks-for-newbies__main17.1.c", "original_string": "int BinaryToDecimal( int binary )\n{\n    int PowerOfTwo = 1;\n    int decimal = 0;\n    while(binary != 0)\n    {\n        decimal += (binary % 10) * PowerOfTwo;                  \n        binary /= 10;\n        PowerOfTwo = PowerOfTwo << 1;                           \n    }\n    return decimal;\n}"}
{"author": "revathy16296", "file": "rtos_lab_asssignment_1__1_sum.1.c", "original_string": "float sum_of_num(int array[])\n{\n    float sum=0;\n    for(i=0;i<SI;i++)\n    {\n        sum+=array[i];\n    }\n    return sum;\n}"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__readfile.0.c", "original_string": "int     readline(void)\n{\n    int     fd;\n    char    *line;\n    fd = open(\"map.cub\", O_RDONLY);\n    global_init();\n    while (get_next_line(fd, &line))\n    {\n        if (!all_params())\n        {\n            if (*line != '\\0')\n                routing(line);\n        }\n        else\n            routing(line);\n        free(line);\n    }\n    free(line);\n    return (0);\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_02.0.c", "original_string": "int search_shift(int a[],int n)\n{\n    int str = 0;\n    int end = n-1;\n    int mid = (end + str)/2;\n    if(a[n-1] > a[str])\n    {\n        return 0;\n    }\n    while(end>str)\n    {\n        mid = (end+str)/2;\n        if(a[mid-1]> a[mid]){\n            return mid;\n        }\n        else if(a[mid-1]<=a[mid] && a[mid]<=a[end])\n        {\n            end = mid;\n        }\n        else if(a[mid - 1]<= a[mid] && a[mid]>=a[end])\n        {\n            str = mid;\n        }\n    }\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__os.10.c", "original_string": "CLASS* mkos() {\n    CLASS* os = mkmath(NULL);\n    os = mkstringclass(os);\n    os = mkarray(os);\n    os = mkoutput(os);\n    os = mkscreen(os);\n    os = mkkeyboard(os);\n    os = mkmemory(os);\n    os = mksys(os);\n    return os;\n}"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal_pwr.4.c", "original_string": "void HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)\n{\n  assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));\n  assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));\n  MODIFY_REG(PWR->CR, PWR_CR_PLS, sConfigPVD->PVDLevel);\n  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();\n  __HAL_PWR_PVD_EXTI_DISABLE_IT();\n  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); \n  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();\n  if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)\n  {\n    __HAL_PWR_PVD_EXTI_ENABLE_IT();\n  }\n  if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)\n  {\n    __HAL_PWR_PVD_EXTI_ENABLE_EVENT();\n  }\n  if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)\n  {\n    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();\n  }\n  if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)\n  {\n    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();\n  }\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica1-1b.0.c", "original_string": "int main(){\n    int n, status;\n    pid_t pid; \n    printf(\"introduce el numero de procesos:\\n\");\n    scanf(\"%i\", &n);\n    for (int i = 0; i < n; i++){\n        switch ( fork() ){\n        case -1: \n            perror(\"fork error:\\n\");\n            fprintf(stderr, \"errno:  %i\\n\", errno); \n            exit(EXIT_FAILURE);\n            break;\n        case 0: \n            printf(\"soy un proceso hijo con PID: [%i]; el PID de mi proceso padre es: [%i]\\n\", getpid(), getppid());\n            break;\n        default:\n            pid = wait(&status); \n            if (pid > 0){ \n                if      (WIFEXITED(status))   printf(\"1 el hijo %i ha sido finalizado con la se\u00f1al %i\\n\", pid, WEXITSTATUS(status));\n                else if (WIFSIGNALED(status)) printf(\"2 el hijo %i ha sido finalizado con la se\u00f1al %i\\n\", pid, WTERMSIG(status));\n                else if (WIFSTOPPED(status))  printf(\"3 el hijo %i ha sido finalizado con la se\u00f1al %i\\n\", pid, WSTOPSIG(status));\n                exit(EXIT_SUCCESS);\n            }\n            else{ \n                printf(\"fallo en la invocacion\\n\");\n                exit(EXIT_FAILURE);\n            }\n        }\n    }\n    exit(EXIT_SUCCESS);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__13,_14.0.c", "original_string": "void le_mdc(int *a, int *b)\n{\n    do\n    {\n        printf(\"\\nDigite dois inteiros 'a' e 'b', onde 'b' > 0:\\n\");\n        printf(\"\\t-> a: \");\n        scanf(\"%i\", a);\n        getchar();\n        printf(\"\\t-> b: \");\n        scanf(\"%i\", b);\n        getchar();\n        system(\"clear\");\n    } while (b <= 0);\n}"}
{"author": "revathy16296", "file": "rtos_lab_asssignment_1__2_sum999.3.c", "original_string": "float product_of_num(int array[],int n)\n{\n    float product=1;\n    for(i=0;i<n;i++)\n    {\n        product*=array[i];\n    }\n    return product;\n}"}
{"author": "mandarvu", "file": "msc__problem4.0.c", "original_string": "int main() {\n  int nums[MAX] = {5, 4, 7, 9, 2}, target[MAX - 1], pos, input; \n  printf(\"The array is\\n\");\n  for (int i = 0; i < MAX; i++)\n    printf(\"%d\\t\",  *(nums + i));\n  printf(\"\\nEnter the position:\");\n  scanf(\"%d\", &pos );\n  deletion(nums, target, pos);\n  printf(\"The array is\\n\");\n  for (int i = 0; i < MAX - 1; i++)\n    printf(\"%d\\t\",  *(target + i));\n  return 0;\n}"}
{"author": "2security", "file": "Star__HollowRightTriangleStar.0.c", "original_string": "int main()\n    {\n    int n,i,j;\n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<=i;j++)\n            {\n                if(j==1||j==i||i==n)\n                    printf(\"*\");\n                else\n                    printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }"}
{"author": "paawankohli", "file": "DSA-LAB__q21.3.c", "original_string": "int infixToPostfix(char* exp, char* ans) \n{ \n    int i, k = 0; \n    stack s;\n    for (i = 0 ; exp[i] != '\\0' ; i++) \n    { \n        if (isOperand(exp[i]))      \n            ans[k++] = exp[i]; \n        else if (exp[i] == '(')     \n            push(&s, exp[i]); \n        else if (exp[i] == ')')     \n        { \n            while (!isEmpty(&s) && top(&s) != '(') \n                ans[k++] = pop(&s); \n            pop(&s);  \n        } \n        else            \n        { \n            while ( !isEmpty(&s) && prec(exp[i]) <= prec(top(&s)) ) \n                ans[k++] = pop(&s); \n            push(&s, exp[i]); \n        } \n    } \n    while (!isEmpty(&s))            \n        ans[k++] = pop(&s); \n    ans[k- 1] = '\\0';  \n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__keypad.2.c", "original_string": "void col_key(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(COL);  \n        IODIR1 = IODIR1 | (ROW);  \n        val = (IOPIN1 & COL); \n        val = val >> 17;\n        lcd_cmd(0xC0);\n        switch(val)\n        {\n            case 0x0E: \n                lcd_str(\"C1\");\n                delay(200);\n                break;\n            case 0x0D:\n                lcd_str(\"C2\");\n                delay(200);\n                break;\n            case 0x0B:\n                lcd_str(\"C3\");\n                delay(200);\n                break;\n            case 0x07:\n                lcd_str(\"C4\");\n                delay(200);\n                break;\n            default:\n                delay(1000);\n                lcd_cmd(0x01);          \n        }\n}"}
{"author": "2security", "file": "String__35TrimLeadingWhiteSpace.1.c", "original_string": "char* Trimleading(char *str)\n    {\n        int i=0,j,c=0,n;\n        char *temp;\n        n=Mystrlen(str);\n        while(str[c]==' '||str[c]=='\\t'||str[c]=='\\n')\n            {\n                c++;\n            }\n        for(j=c;j<=n-1;j++)\n            {\n                str[i]=str[j];  \n                i++;\n            }\n        str[i]='\\0';\n        return str;\n    }"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__ip.2.c", "original_string": "int main()\n{\n    int iRet=0;\n    int a=0,b=0,c=0,d=0;\n    printf(\"enter ip addres\\n\");\n    printf(\"first value :\");\n    scanf(\"%d\",&a);\n    printf(\"second value :\");\n        scanf(\"%d\",&b);\n    printf(\"third value :\");\n        scanf(\"%d\",&c);\n    printf(\"fourth value :\");\n        scanf(\"%d\",&d);\n    iRet=FormIp(a,b,c,d);\n    printf(\"IP address  in one integer  is : %d\",iRet);\n    split(iRet);\n    return 0;\n}"}
{"author": "bgmanuel99", "file": "PracticasArquitecturaDeComputadores__ejercicio3.0.c", "original_string": "int main(int argc, char **argv){\n  MPI_Init(NULL, NULL);\n double A[10000];\n double B[10000];\n int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n  if (world_rank != 0) {\n    int i = 0;\n    for(i; i < 10000; i++){\n        A[i]=world_rank;\n    }\n    MPI_Recv(&B, 10000, MPI_INT, world_rank - 1, 0, MPI_COMM_WORLD,\n             MPI_STATUS_IGNORE);\n    printf(\"Process %d received B[109] = %d from process %d\\n\", world_rank, B[109],\n           world_rank - 1);\n  } else {\n    int i = 0;\n    for(i; i < 10000; i++){\n        A[i]=world_rank;\n    }\n  }\n    printf(\"%d =>rank to : %d\\n\",world_rank,(world_rank + 1) % world_size);\n  MPI_Send(&A, 10000, MPI_INT, (world_rank + 1) % world_size, 0,\n           MPI_COMM_WORLD);\n  if (world_rank == 0) {\n    MPI_Recv(&B, 10000, MPI_INT, world_size - 1, 0, MPI_COMM_WORLD,\n             MPI_STATUS_IGNORE);\n    printf(\"Process %d received B[109] = %d \\n\", world_rank, 3);\n  }\n  MPI_Finalize();\n}"}
{"author": "sdukesameer", "file": "dsa__Md_Sameer_13000119114.9.c", "original_string": "list* del_Node(list* node, int n){\n    if(node==NULL)\n        return node;\n    if(n<node->key)\n        node->left=del_Node(node->left,n);\n    else if(n>node->key)\n        node->right=del_Node(node->right,n);\n    else{\n        if(node->left==NULL){\n            list*temp=node->right;\n            free(node);\n            return temp;\n        }\n        else if (node->right==NULL){\n            list* temp=node->left;\n            free(node);\n            return temp;\n        }\n        list* temp=minValNode(node->right);\n        node->key=temp->key;\n        node->right=del_Node(node->right,temp->key);\n    }\n    return node;\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_embos.3.c", "original_string": "OsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,\n   void *param, size_t stackSize, int_t priority)\n{\n   uint_t i;\n   OS_TASK *task;\n   void *stack;\n   osSuspendAllTasks();\n   for(i = 0; i < OS_PORT_MAX_TASKS; i++)\n   {\n      if(tcbTable[i] == NULL)\n         break;\n   }\n   if(i < OS_PORT_MAX_TASKS)\n   {\n      task = osAllocMem(sizeof(OS_TASK));\n      if(task != NULL)\n      {\n         stack = osAllocMem(stackSize * sizeof(uint_t));\n         if(stack != NULL)\n         {\n            OS_CreateTaskEx(task, name, priority, taskCode,\n               stack, stackSize * sizeof(uint_t), 1, param);\n            tcbTable[i] = task;\n            stkTable[i] = stack;\n         }\n         else\n         {\n            osFreeMem(task);\n            task = NULL;\n         }\n      }\n   }\n   else\n   {\n      task = NULL;\n   }\n   osResumeAllTasks();\n   return task;\n}"}
{"author": "andi-s0106", "file": "binary_trees__9-binary_tree_height.0.c", "original_string": "size_t binary_tree_height(const binary_tree_t *tree)\n{\n    size_t height;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    height = 0;\n    height =  calc_height(tree, height);\n    return (height - 1);\n}"}
{"author": "dle2005", "file": "Algorithm__Dijkstra_v2.0.c", "original_string": "void dijkstra(int n, number **W, set_of_edges *F) {\n    index i, vnear;\n    edge e;\n    index touch[n];\n    number length[n];\n    for(i = 1; i < n; i++) {\n        touch[i] = 1;\n        length[i] = W[0][i];\n    }\n    for(int j = 0; j < n-1; j++) {\n        int min = INF;\n        for(i = 1; i < n; i++) {\n            if(0 <= length[i] && length[i] <= min) {\n                min = length[i];\n                vnear = i;\n            }\n        }\n        e.j = vnear;\n        e.touch = touch[vnear];\n        e.length = length[vnear];\n        F[vnear].j = e.j;\n        F[vnear].touch = e.touch;\n        F[vnear].length = e.length;\n        for(i = 1; i < n; i++) {\n            if(length[vnear] + W[vnear][i] < length[i]) {\n                length[i] = length[vnear] + W[vnear][i];\n                touch[i] = vnear + 1;\n            }\n        }\n        length[vnear] = -1;\n    }\n}"}
{"author": "augustogunsch", "file": "jack-compiler__os.2.c", "original_string": "CLASS* mkmath(CLASS* os) {\n    CLASS* mathclass = mkosclass(os, \"Math\");\n    adddec(mathclass, function, \"int\", \"multiply\");\n    adddec(mathclass, function, \"int\", \"divide\");\n    adddec(mathclass, function, \"int\", \"abs\");\n    adddec(mathclass, function, \"int\", \"min\");\n    adddec(mathclass, function, \"int\", \"max\");\n    adddec(mathclass, function, \"int\", \"sqrt\");\n    return mathclass;\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad14.0.c", "original_string": "int main()\n{\n    int godziny, minuty, czasWMinutach;\n    bool endProgram = false;\n    while(!endProgram){\n        printf(\"Podaj ilo\\230\\206 minut do przeliczenia.\\n\");\n        scanf(\"%d\", &czasWMinutach);\n        godziny = czasWMinutach / GODZINA;\n        minuty = czasWMinutach % GODZINA;\n        printf(\"%d minut to %d godzin i %d minut\\n\\n\", czasWMinutach, godziny, minuty);\n        fflush(stdin);\n        endProgram = nextCalculation();\n    }\n    return 0;\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__goal_server.3.c", "original_string": "void queue_add(client_t *cl){\n    pthread_mutex_lock(&clients_mutex);\n    for(int i=0; i < MAX_CLIENTS; ++i){\n        if(!clients[i]){\n            clients[i] = cl;\n            break;\n        }\n    }\n    pthread_mutex_unlock(&clients_mutex);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__multiParenthesis.3.c", "original_string": "char pop(struct stack*ptr){\n    if(isEmpty(ptr)){\n        printf(\"Stack Underflow! Cannot pop from the stack\\n\");\n        return -1;\n    }\n    else{\n        int val = ptr->arr[ptr->top];\n        ptr->top--;\n        return val;\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__bfs-dfs.8.c", "original_string": "void bfs(graph g, int s){\n    queue q;\n    initialiseQueue(&q,g.n);\n    int visited[g.n],i,f;\n    for(i=0;i<g.n;i++)\n        visited[i]=0;\n    visited[s]=1;\n    enqueue(&q,s);\n    printf(\"\\nFollowing is the BFS Traversal (starting from %c): \\n\",'A'+s);\n    while(q.end!=-1){\n        f=dequeue(&q);\n        printf(\"%c\\t\",'A'+f);\n        for (i = 0; i < g.n; i++)\n            if(g.arr[f][i])\n                if(!visited[i]){\n                    visited[i]=1;\n                    enqueue(&q,i);\n                }\n    }\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sort_Array_Ascending.2.c", "original_string": "void sorting(int array[MAX], int length)\n{\n    int i, j, temp = 0;\n    int size = length;\n    for(i=0; i<length; i++)\n    {\n        for(j=i+1; j<length; j++)\n        {\n            if(array[i] > array[j])\n            {\n                temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n    display(array, size);\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__SelectionSort.0.c", "original_string": "int main()\n{\n    int z,res;\n    printf(\"enter the no.of elements:\");\n    scanf(\"%d\",&z);\n    int arr[z];\n    int i;\n    printf(\"the elements are:\\n\");\n    for(i=0;i<z;i++)\n    {\n        scanf(\"%d\",&arr[i]);\n    }\n    res = selectionSort(arr,z); \n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_last_CLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__pgcd.3.c", "original_string": "int     main(int ac, char **av)\n{\n    if (ac == 3)\n    {\n        ft_pgcd(atoi(av[1]), atoi(av[2]));\n    }\n    write(1, \"\\n\", 1);\n    return (0);\n}"}
{"author": "ankitraj311", "file": "Socket-thread__first_thread.1.c", "original_string": "int main() \n{ \n    pthread_t thread_id; \n    printf(\"Before Thread\\n\"); \n        printf(\"ThreadId is %ld\\n\",thread_id);  \n    pthread_create(&thread_id, NULL, &myThreadFun, NULL); \n    pthread_join(thread_id, NULL); \n    printf(\"After Thread\\n\"); \n    exit(0); \n}"}
{"author": "254Odeke", "file": "OpeartingSystems__prevention.0.c", "original_string": "void main(){\n    int pro,res,i,j;\n    printf(\"Enter No.of Processes:\");\n    scanf(\"%d\",&pro);\n    printf(\"Enter No.of Resources:\");\n    scanf(\"%d\",&res);\n    int res_vector[res],res_allocated[res],res_avail[res];\n    printf(\"Enter Resource Vector:\");\n    for(i=0;i<res;i++){\n        scanf(\"%d\",&res_vector[i]);\n        res_allocated[i]=0;\n    }\n    int max[pro][res],allocated[pro][res],needed[pro][res];\n    printf(\"Enter the Max Requirement matrix:\\n\");\n    for(i=0;i<pro;i++){\n        for(j=0;j<res;j++){\n            scanf(\"%d\",&max[i][j]);\n        }\n    }\n    printf(\"Enter the Allocated Resource matrix:\\n\");\n    for(i=0;i<pro;i++){\n        for(j=0;j<res;j++){\n            scanf(\"%d\",&allocated[i][j]);\n        }\n    }\n    for(i=0;i<pro;i++){\n        for(j=0;j<res;j++){\n            needed[i][j]=max[i][j]-allocated[i][j];\n        }\n    }\n    for(i=0;i<res;i++){\n        for(j=0;j<pro;j++){\n            res_allocated[i]+=allocated[j][i];\n        }\n        res_avail[i]=res_vector[i]-res_allocated[i];\n    }\n    int completed[pro];\n    for(i=0;i<pro;i++){\n        completed[i]=0;\n    }\n    int flag,count=0;\n    x:\n    for(i=0;i<pro;i++){\n        flag=0;\n        for(j=0;j<res;j++){\n            if(res_avail[j]<needed[i][j]||completed[i]==1){\n                flag=1;\n                count++;\n                break;\n            }\n        }\n        if(flag==0){\n            printf(\"P%d \",i);\n            for(j=0;j<res;j++){\n                res_avail[j]+=allocated[i][j];\n                allocated[i][j]=0;\n                needed[i][j]=0;\n            }\n            completed[i]=1;\n            goto x;\n        }\n    }\n    if(count==pro){\n        printf(\"No Safe Sequence is Possible\");\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__Main0.1.c", "original_string": "static char *dirname(char *path)\n{\n  char *lastSeparator = strrchr(path, '\\\\');\n  if (lastSeparator != NULL) \n  {\n    *lastSeparator = '\\0';\n    return path;\n  }\n  else\n  {\n    *path = '\\0';\n  }\n  return path;\n}"}
{"author": "zjzj-zz", "file": "1s_programing__jishojun.0.c", "original_string": "int main(){\n char *str[] = {\"aoki\", \"aoki\"};\n int x;\n printf(\"%s\u3068%s\u306e\u8f9e\u66f8\u9806\u3092\u8abf\u3079\u308b\u3068\\n\", str[0], str[1]);\n x = strcmp(str[0], str[1]);\n printf(\"%d\\n\", x);\n return 0;\n}"}
{"author": "bgmanuel99", "file": "PracticasArquitecturaDeComputadores__calculo.0.c", "original_string": "void get_media(FILE *fd, char *tipo){\n    char cadena[100];\n    float suma = 0.1;\n    float num[50];\n    if(fd == NULL){\n        fputs(\"File error\", stderr);\n        exit(1);\n    }\n    char *eptr;\n    while(feof(fd) == 0){\n        strcpy(cadena, fgets(cadena,100 ,fd));\n        float result = strtod(cadena, &eptr);\n        suma += result;\n    }\n    fclose(fd);\n    printf(\"%s: La media de los milisegundos es: %f\\n\",tipo, suma/50);\n}"}
{"author": "fikepaci", "file": "monty__run_monty.0.c", "original_string": "void free_tokens(void)\n{\n    size_t i = 0;\n    if (op_toks == NULL)\n        return;\n    for (i = 0; op_toks[i]; i++)\n        free(op_toks[i]);\n    free(op_toks);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__iterative_traversals.0.c", "original_string": "void Levelorder(Nodeptr root) \n{\n    queue q;\n    q.front = MAX/2;\n    q.rear = MAX/2;\n    InsertQ(&q, root);\n    while (!QIsEmpty(&q)) \n    {\n        Nodeptr temp = DeleteQ(&q);\n        printf(\"%d \", temp->data);\n        if (temp->lchild) \n            InsertQ(q, temp->lchild);\n        if (temp->rchild) \n            InsertQ(q, temp->rchild);\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__parser-util.0.c", "original_string": "void unexpected(PARSER* p) {\n    eprintf(\"Unexpected token '%s' (of type %s); line %i, file '%s'\\n\",\n                p->current->token, tokentypes.items[p->current->type],\n                p->current->definedat, p->file);\n    exit(1);\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__OPR.2.c", "original_string": "int isthere(int page)\n{\n    int i,flag=-1;\n    for(i=0;i<3;i++)\n    {\n        if(Queue[i]==page)\n        {\n            flag=1;\n            break;\n        }\n    }\n    return(flag);\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__m_init.0.c", "original_string": "static int  ft_strlen(char *s)\n{\n    int i;\n    i = 0;\n    if (s != 0)\n    {\n        while (s[i])\n        {\n            ++i;\n        }\n    }\n    return (i);\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__MergeSort.1.c", "original_string": "void getdata(int x[50],int n)\n       {\n        int k;\n        printf(\"enter the value  for sorting\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        }     \n       }"}
{"author": "sdukesameer", "file": "dsa__n-rooks_castle.1.c", "original_string": "int safe(int arr[N][N], int row, int col){\n    for (int i = 0; i < row; i++)\n        if(arr[row][i])\n            return 0;\n    for (int i = 0; i < col; i++)\n        if(arr[row][i])\n            return 0;\n    return 1;\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_sys_bios.12.c", "original_string": "bool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   Bool ret;\n   if(timeout == 0)\n   {\n      ret = Event_pend(event->handle, Event_Id_00,\n         Event_Id_NONE, BIOS_NO_WAIT);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      ret = Event_pend(event->handle, Event_Id_00,\n         Event_Id_NONE, BIOS_WAIT_FOREVER);\n   }\n   else\n   {\n      ret = Event_pend(event->handle, Event_Id_00,\n         Event_Id_NONE, OS_MS_TO_SYSTICKS(timeout));\n   }\n   return ret;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post.4.c", "original_string": "void rec_preorder(node* root) \n{ \n    if (root != NULL) \n    {\n        printf(\"\\t%d\\n\", root->data); \n        rec_preorder(root->left);\n        rec_preorder(root->right);\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__10.0.c", "original_string": "void palavra_fibonacci(int n)\n{\n    if (n == 0) putchar('b');\n    else if (n == 1) putchar('a');\n    else\n    {\n        palavra_fibonacci(n-1);\n        palavra_fibonacci(n-2);\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__search_a_node_from_list.1.c", "original_string": "void createList(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int data, i;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter node data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n; i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter node data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=temp->next;\n    }\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__flor.3.c", "original_string": "void display_function()\n{\n  glClearColor(0, 0, 0, 0);\n  glClear(GL_COLOR_BUFFER_BIT);\n  glLoadIdentity();\n  glColor3f(1.0, 1.0, 1.0);\n  circulo();\n  glColor3f(1.0, 1.0, 1.0);\n  retangulo();\n  glTranslatef(tx, ty, 0.0);\n  glColor3f(0.5, 1.0, 0.5);\n  quadrado(0.3, 0.3);\n  glColor3f(1.0, 1.0, 0.0);\n  quadrado(-0.3, 0.3);\n  glColor3f(1.0, 0.0, 1.0);\n  quadrado(0.3, -0.3);\n  glColor3f(1.0, 0.0, 0.0);\n  quadrado(-0.3, -0.3);\n  glFlush();\n}"}
{"author": "2security", "file": "File__6CopyFile.2.c", "original_string": "FILE *openfile(char *path,char *mode)\n    {\n    FILE *fp;\n    fp=fopen(path,mode);\n    if(fp==NULL)\n        {\n        perror(\"File opening error (:\");\n        getch();\n        exit(0);\n        }\n    return fp;\n    }"}
{"author": "flora0110", "file": "hw01git__2-1tqueue.1.c", "original_string": "char*** make3darr(int rows, int cols,int hei){\n    char ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Insert_At_Any_Position_In_Single_Linked_List.1.c", "original_string": "void display_node(struct node*temp1)\n{\n    printf(\"The Elements are:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__DFS1.1.c", "original_string": "int pop()\n{\n    int x;\n    if(top==-1)\n    printf(\"\\nStack is Empty\");\n    else\n    {\n        x=STACK[top];\n        top=top-1;\n        return(x);\n    }\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__raycasting.0.c", "original_string": "void        cast_ray(int l, float angle)\n{\n    float   i;\n    float   j;\n    float   xp;\n    float   yp;\n    i = 0;\n    while (i < l)\n    {\n        xp = cos(angle) * i + g_player.x;\n        yp = sin(angle) * i + g_player.y;\n        i++;\n        my_mlx_pixel_put(&g_image, xp, yp, 0xFF0000);\n    }\n}"}
{"author": "dishanp", "file": "DSA__q20.0.c", "original_string": "void reverse (int * data, int n)\n{\n      int i , j;\n      for (i = 0 , j = n-1; i < j ; i++, j--)\n      {\n            int temp = *(data + i) ;\n            *(data + i) = *(data + j) ;\n            *(data + j) = temp ;\n      }\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-1.2.c", "original_string": "int*** make3darrint(int rows, int cols,int hei){\n    int ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}"}
{"author": "MFarid94", "file": "Assignment4__Exercise5.0.c", "original_string": "void CopyArray(int *ptrA , int *ptrB){\n    int i;\n    for(i=0 ; i<SIZE ; i++){\n        *ptrB = *ptrA;\n        ptrA++;\n        ptrB++;\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_bpdu.0.c", "original_string": "void rstpProcessLlcFrame(NetInterface *interface, EthHeader *ethHeader,\n   const uint8_t *data, size_t length, NetRxAncillary *ancillary, void *param)\n{\n   const LlcHeader *llcHeader;\n   const RstpBpdu *bpdu;\n   RstpBridgeContext *context;\n   RstpBridgePort *port;\n   context = (RstpBridgeContext *) param;\n   if(!macCompAddr(&ethHeader->destAddr, &RSTP_BRIDGE_GROUP_ADDR))\n      return;\n   if(length < sizeof(LlcHeader))\n      return;\n   llcHeader = (LlcHeader *) data;\n   if(llcHeader->dsap != STP_LLC_DSAP || llcHeader->ssap != STP_LLC_SSAP ||\n      llcHeader->control != STP_LLC_CTRL)\n   {\n      return;\n   }\n   if(ancillary->port < 1 || ancillary->port > context->numPorts)\n      return;\n   port = &context->ports[ancillary->port - 1];\n   bpdu = (RstpBpdu *) (data + sizeof(LlcHeader));\n   length -= sizeof(LlcHeader);\n   rstpProcessBpdu(port, bpdu, length);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q42.1.c", "original_string": "int del(QUEUE* q)\n{\n    if(q->top1 == -1 && q->top2 == -1)\n    {\n        printf(\"QUEUE EMPTY\\n\");\n        return -1;\n    }\n    if(q->top2 == -1)\n        while(q->top1 != -1)\n            q->stack2[++(q->top2)] = q->stack1[(q->top1)--];\n    return q->stack2[(q->top2)--];\n}"}
{"author": "ankitraj311", "file": "450_babbar__6_union_array_Geek_usorted_array.4.c", "original_string": "int main()\n{\n  int arr1[] = {1,2,3,5,6,6,7,8,9,7,8,9,10}, arr2[] = {100,2,3,60,1,2,3,4,4,6,4,9,80,7,2,30,1} ,no,j=0,temp=0,mid=0,n=0;\n  int size_arr1 = sizeof(arr1)/sizeof(int), size_arr2 = sizeof(arr2)/sizeof(int);\n  array_print(arr1,size_arr1); \n  array_print(arr2,size_arr2); \n  size_arr1 = remove_repeat(arr1,size_arr1); \n  size_arr2 = remove_repeat(arr2,size_arr2); \n  array_print(arr1,size_arr1); \n  array_print(arr2,size_arr2); \n  union_array(arr1,arr2,size_arr1,size_arr2);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__doublyLinkedList.4.c", "original_string": "struct Node *deleteFirst(struct Node *head)\n{\n     struct Node *ptr = head;\n     head = head->next;\n     head->prev = NULL;\n     free(ptr);\n     return head;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__palhaco.6.c", "original_string": "void display()\n{\n    glMatrixMode(GL_MODELVIEW);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glLoadIdentity();\n    glTranslatef(0.0, 0.0, -9.0);\n    glPopMatrix();\n    glPushMatrix();\n    desenhaCabeca();\n    desenhaChapeu();\n    desenhaNariz();\n    desenhaCabeloEsquerda();\n    desenhaCabeloDireita();\n    glutSwapBuffers();\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__quick_sort.3.c", "original_string": "void printarray(int a[],int n)\n{\n    int i;\n    for(i=0;i<n;i++)\n        printf(\"%d\\t\",a[i]);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__LLunion.1.c", "original_string": "void insertRear(nptr &head, int ele)\n{\n    if (head == NULL)\n    {\n        head = createNode(ele);\n        return;\n    }\n    nptr rear = head;\n    while(rear -> next != NULL)\n        rear = rear -> next;\n    nptr temp = createNode(ele);\n    rear -> next = temp;\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__map_manager.2.c", "original_string": "char        **map_manager(void)\n{\n    char    **map_array;\n    int     i;\n    int     j;\n    j = 0;\n    i = 0;\n    map_array = (char**)malloc((g_map_height + 3) * sizeof(char*));\n    while (i < g_map_height + 2)\n    {\n        map_array[i] = (char*)malloc((g_map_width + 3) * sizeof(char));\n        i++;\n    }\n    map_array[i] = NULL;\n    surrend_by_spaces(map_array);\n    fill_map(map_array);\n    map_errors(map_array);\n    if (g_player.x == -1 || g_player.y == -1)\n    {\n        ft_putstr(\"Error:\\nPlayer or map missing\\n\");\n        exit(0);\n    }\n    return (map_array);\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zadOsmi.0.c", "original_string": "int main()\n{\n    Dir C;\n    C.sibling = NULL;\n    C.child = NULL;\n    strcpy(C.name, \"C:\");\n    Stack stackHead;\n    stackHead.data = NULL;\n    stackHead.next = NULL;\n    PushStack(&C, &stackHead);\n    CommandPrompt(&C, &stackHead);\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_embos.17.c", "original_string": "bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   bool_t ret;\n   if(timeout == 0)\n   {\n      ret = OS_CSemaRequest(semaphore);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      OS_WaitCSema(semaphore);\n      ret = TRUE;\n   }\n   else\n   {\n      ret = OS_WaitCSemaTimed(semaphore, OS_MS_TO_SYSTICKS(timeout));\n   }\n   return ret;\n}"}
{"author": "ankitraj311", "file": "450_babbar__6_union_array_Geek_sorted_array.0.c", "original_string": "void array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-statements.8.c", "original_string": "STATEMENT* parsereturn(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, returnstatement);\n    s->retstatement = parseexpressionnullified(p);\n    checkcontent(p, \";\");\n    return s;\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_cmsis_rtos2.16.c", "original_string": "bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   osStatus_t status;\n   if(timeout == INFINITE_DELAY)\n   {\n      status = osSemaphoreAcquire(semaphore->id, osWaitForever);\n   }\n   else\n   {\n      status = osSemaphoreAcquire(semaphore->id, OS_MS_TO_SYSTICKS(timeout));\n   }\n   if(status == osOK)\n      return TRUE;\n   else\n      return FALSE;\n}"}
{"author": "DanielSalis", "file": "AED1__teste4.5.c", "original_string": "void calculaTrajetoTotal(TipoLista* l){\n    int distanciaTotal = 0;\n    int contCidades=0;\n    TipoElemento* aux = l->primeiro;\n    while(aux!=NULL){\n        distanciaTotal = distanciaTotal + aux->distancia;\n        contCidades++;\n        aux = aux->prox;\n    }\n    printf(\"o trajeto total tem %d kms, passando\\n\", distanciaTotal);\n    printf(\"por %d cidades\\n\", contCidades);\n}"}
{"author": "mehedi9021", "file": "Data_Structure__circular_linked_list.2.c", "original_string": "void displayList()\n{\n    struct node *current;\n    int n = 1;\n    if(head == NULL)\n    {\n        printf(\"List is empty.\\n\");\n    }\n    else\n    {\n        current = head;\n        printf(\"DATA IN THE LIST:\\n\");\n        do {\n            printf(\"Data %d = %d\\n\", n, current->data);\n            current = current->next;\n            n++;\n        }while(current != head);\n    }\n}"}
{"author": "dishanp", "file": "DSA__q33.2.c", "original_string": "int main()\n{\n    int *arr;\n    int n;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n    for(int l = 0 ; l < n ; l++)\n    {\n        printf(\"Enter element no %d :\", l+1);\n        scanf(\"%d\", arr + l);\n    }\n    rearrange(arr, n);\n    printf(\"Rearranged array : \\n\");\n    for(int m = 0 ; m < n ; m++)\n    {\n        printf(\"%d\", *(arr + m));\n    }\n    printf(\"\\n\");\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__20.0.c", "original_string": "void main()\n{\n    int a[90][90],r,c,i,j;\n    printf(\"enter no. of rows and columns\");\n    scanf(\"%d%d\",&r,&c);\n    printf(\"enter array elements\");\n    for(i=0;i<r;i++)\n    {\n        for(j=0;j<c;j++)\n        {\n            scanf(\"%d\",&a[i][j]);\n        }\n    }\n    sum(a,r,c);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__31.0.c", "original_string": "int main(int argc, char **argv)\n{\n    FILE *arq_1, *arq_2, *arq_3;\n    int *vet_1, *vet_2, aux;\n    int aux_1 = {1, 3, 5, 7, 10, 11}, aux_2 = {0, 2, 4, 6, 8, 10};\n    if (argc < 4)\n    {\n        printf(\"\\nErro! N\u00e3o foram informados arquivos o suficiente\\n\\n\");\n        return 0;\n    }\n    arq_1 = fopen(argv[1], \"w+b\");\n    arq_2 = fopen(argv[2], \"w+b\");\n    arq_3 = fopen(argv[3], \"wb\");\n    if (arq_1 == NULL || arq_2 == NULL || arq_3 == NULL)\n    {\n        printf(\"\\nErro ao abrir algum arquivo\\n\\n\");\n        return 0;\n    }\n    fwrite(&aux_1, sizeof(int), 6, arq_1);\n    fwrite(&aux_2, sizeof(int), 6, arq_2);\n    fseek(arq_1, 0, SEEK_SET);\n    fseek(arq_2, 0, SEEK_SET);\n    int i = 0, j = 0;\n    while (fread(&aux, sizeof(int), 1, arq_1) != 0)\n    {\n        i++;\n    }\n    while (fread(&aux, sizeof(int), 1, arq_2) != 0)\n    {\n        j++;\n    }\n    vet_1 = malloc(i * sizeof(int));\n    vet_2 = malloc(j * sizeof(int));\n    fseek(arq_1, 0, SEEK_SET);\n    fseek(arq_2, 0, SEEK_SET);\n    fread(vet_1, sizeof(int), i, arq_1);\n    fread(vet_2, sizeof(int), j, arq_2);\n    for (int i2 = 0, j2 = 0; i2 < i, j2 < j;)\n    {\n        if (vet_1[i2] < vet_2[j2])\n        {\n            fwrite(vet_1 + i2, sizeof(int), 1, arq_3);\n            i2++;\n        }\n        else if (vet_2[j2] < vet_1[i2])\n        {\n            fwrite(vet_2 + j2, sizeof(int), 1, arq_3);\n            j2++;\n        }\n        else if (vet_1[i2] == vet_2[j2])\n        {\n            fwrite(vet_1 + i2, sizeof(int), 1, arq_3);\n            fwrite(vet_2 + j2, sizeof(int), 1, arq_3);\n            i2++;\n            j2++;\n        }\n    }\n    fclose(arq_1);\n    fclose(arq_2);\n    fclose(arq_3);\n    return 0;\n}"}
{"author": "MartinMarinovich", "file": "ParcialLaboratorio1GCompleto__tipo.2.c", "original_string": "int listarTipos(eTipo listaDetipos[], int tamanioTipos)\n{\n    int error = -1;\n    if(listaDetipos !=NULL && tamanioTipos>0)\n    {\n        system(\"cls\");\n        printf(\" ****  LISTADO DE TIPOS  ****\\n\");\n        printf(\"Id        Descripcion\\n\");\n        printf(\"----------------------------------\\n\");\n        for(int i = 0 ; i<tamanioTipos; i++)\n        {\n            mostrarTipo(listaDetipos[i]);\n        }\n        error = 0;\n    }\n    return error;\n}"}
{"author": "2security", "file": "Star__HollowInvertedMirroredRightTriangleStar.0.c", "original_string": "int main()\n    {\n    int n,i,j;\n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<i;j++)\n            printf(\" \");\n        for(j=1;j<=n-i+1;j++)\n            {\n            if(i==1||j==n-i+1||j==1)    \n                printf(\"*\");\n            else \n                printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }"}
{"author": "RaigoXD", "file": "Parcial-2__ft_print_combn.9.c", "original_string": "void comb8(int *numeros,int a,int b,int c, int d,int e,int f,int g,int h)\n{\n  while(a<=2)\n       {\n        while(b<=3)\n            {\n              while(c<=4)\n                  {\n                      while(d<=5)\n                          {\n                              while(e<=6)\n                                  {\n                                    while(f<=7)\n                                        {\n                                          while(g<=8)\n                                               {\n                                                while(h<=9)\n                                                    {\n                                                      printf(\"%i%i%i%i%i%i%i%i, \",numeros[a],numeros[b],numeros[c],numeros[d],numeros[e],numeros[f],numeros[g],numeros[h]);\n                                                      h=h+1;\n                                                    }\n                                                g=g+1;\n                                                h=g+1;\n                                               }\n                                          f=f+1;\n                                          g=f+1;\n                                          h=g+1;\n                                        }\n                                    e=e+1;\n                                    f=e+1;\n                                    g=f+1;\n                                    h=g+1;\n                                  } \n                              d=d+1;\n                              e=d+1;\n                              f=e+1;\n                              g=f+1;\n                              h=g+1;\n                          }\n                      c=c+1;\n                      d=c+1;\n                      e=d+1;\n                      f=e+1;\n                      g=f+1;\n                      h=g+1;\n                  }\n              b=b+1;\n              c=b+1;\n              d=c+1;\n              e=d+1;\n              f=e+1;\n              g=f+1;\n              h=g+1;\n            }\n        a=a+1;\n        b=a+1;\n        c=b+1;\n        d=c+1;\n        e=d+1;\n        f=e+1;\n        g=f+1;\n        h=g+1;\n       }\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__35_Reverse_array_element.0.c", "original_string": "int main()\n{\n  int i=0,j=0,k=0, no=0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n  int array1[no], array2[no];\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n  for(i=no-1; i>=0; i--)\n  {\n    array2[j] = array1[i];\n    j++;\n  }\n  printf(\"\\n\");\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array2[i]);\n  }\n}"}
{"author": "andi-s0106", "file": "sorting_algorithms__101-cocktail_sort_list.1.c", "original_string": "int swap(listint_t **list, listint_t *current, int flag)\n{\n    listint_t *tmp;\n    if (list == NULL || *list == NULL || current == NULL)\n        return (1);\n    if (flag == 1)\n        current = current->prev;\n    tmp = current->next;\n    if (tmp != NULL)\n    {\n        current->next = tmp->next;\n        tmp->next = current;\n        tmp->prev = current->prev;\n    }\n    if (current->next != NULL)\n        current->next->prev = current;\n    if (current->prev != NULL)\n        current->prev->next = tmp;\n    current->prev = tmp;\n    if (tmp->prev == NULL)\n        *list = tmp;\n    print_list(*list);\n    return (0);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__nonVIC.2.c", "original_string": "void intr_config(void)\n{\n        VICIntSelect = VICIntSelect & ~((1<<4)|(1<<5)|(1<<15)); \n        VICDefVectAddr = (long)nonvic_isr;\n        VICIntEnable = (1<<5)|(1<<4)|(1<<15);   \n        EXTMODE = 1<<1; \n        EXTPOLAR = 1<<1;    \n}"}
{"author": "jose120918", "file": "binary_trees__104-binary_tree_rotate_right.0.c", "original_string": "binary_tree_t *binary_tree_rotate_right(binary_tree_t *tree)\n{\n    binary_tree_t *y, *x;\n    if (tree != NULL)\n    {\n        x = tree;\n        if ((*x).left != NULL)\n        {\n            y = (*x).left;\n            (*x).left = (*y).right;\n            if ((*y).right != NULL)\n            {\n                (*(*y).right).parent = x;\n            }\n            (*y).parent = (*x).parent;\n            if ((*x).parent == NULL)\n            {\n                tree = y;\n            }\n            else if (x == (*(*x).parent).right)\n            {\n                (*(*x).parent).right = y;\n            }\n            else\n            {\n                (*(*x).parent).left = y;\n            }\n            (*y).right = x;\n            (*x).parent = y;\n            return (tree);\n        }\n    }\n    return (NULL);\n}"}
{"author": "augustogunsch", "file": "jackc__threads.1.c", "original_string": "void* compileunit(void* input) {\n    COMPILEUNIT* unit = (COMPILEUNIT*)input;\n    unit->compiled = compileclass(unit->compiler, unit->parsed);\n    pthread_exit(NULL);\n}"}
{"author": "dishanp", "file": "DSA__q35.0.c", "original_string": "void create(int A[], int n)\n{\n    struct node *t, *last;\n    first = (struct node*)malloc(sizeof(struct node));\n    first->data = A[0];\n    first->next = NULL;\n    last = first;\n    for(int i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_prs.1.c", "original_string": "void rstpPrsFsm(RstpBridgeContext *context)\n{\n   uint_t i;\n   bool_t reselect;\n   switch(context->prsState)\n   {\n   case RSTP_PRS_STATE_INIT_BRIDGE:\n      rstpPrsChangeState(context, RSTP_PRS_STATE_ROLE_SELECTION);\n      break;\n   case RSTP_PRS_STATE_ROLE_SELECTION:\n      for(reselect = FALSE, i = 0; i < context->numPorts; i++)\n      {\n         reselect |= context->ports[i].reselect;\n      }\n      if(reselect)\n      {\n         rstpPrsChangeState(context, RSTP_PRS_STATE_ROLE_SELECTION);\n      }\n      break;\n   default:\n      rstpFsmError(context);\n      break;\n   }\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__sender0.3.c", "original_string": "int send_frame(unsigned char *frame, unsigned int frame_len){\n    FILE *file = fopen(\"pipe.bin\", \"wb+\");\n    if(file == NULL)\n    {\n        printf(\"[INFO] File open error!\\n\");\n        return 0;\n    }\n    fwrite(&frame_len,sizeof(frame_len),1,file);\n    fwrite(frame, sizeof(char), frame_len, file);\n    fclose(file);\n    printf(\"[INFO] Frame send success!\\n\");\n    return 0;\n}"}
{"author": "tadeograch", "file": "sorting_algorithms__105-radix_sort.2.c", "original_string": "int get_index_lower(int *array, int start, int size)\n{\n    int min = 0, index = 0, i = start;\n    for(i = 0; i < size; i++)\n    {\n        if (array[i] < min)\n            min = array[i];\n            index = i;\n    }\n    return(index);\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Orthogonal_Matrix_Or_Not.1.c", "original_string": "void display(int matrix[R][C])\n{\n    int i, j = 0;\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__AF.2.c", "original_string": "int main()\n{\n    int n, iv[100000], jv[100000], maior = 0;\n    scanf(\"%i\", &n);\n    for (int a = 0; a < n; a++)\n    {\n        scanf(\"%i\", &iv[a]);\n        scanf(\"%i\", &jv[a]);\n        if (jv[a] > maior)\n            maior = jv[a];\n    }\n    fibonacci(maior);\n    for (int a=0; a<n; a++)\n    {\n        printf(\"%li\\n\", supersigma(iv[a], jv[a]));\n    }\n    return 0;\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__map_manager.0.c", "original_string": "void        player_init(char c, int x, int y)\n{\n    if (g_peeinit)\n    {\n        ft_putstr(\"Error:\\nthe map has more than one player\\n\");\n        exit(0);\n    }\n    else\n    {\n        g_tile_size = 16;\n        g_player.x = (x * g_tile_size) + (g_tile_size / 2);\n        g_player.y = (y * g_tile_size) + (g_tile_size / 2);\n        g_peeinit = 1;\n        if (c == 'N')\n            g_player.rotation_angle = 270 * (M_PI / 180);\n        else if (c == 'S')\n            g_player.rotation_angle = 90 * (M_PI / 180);\n        else if (c == 'E')\n            g_player.rotation_angle = 0;\n        else if (c == 'W')\n            g_player.rotation_angle = M_PI;\n        g_player.fov = 60 * (M_PI / 180);\n        g_player.turn_direction = 0;\n        g_player.walk_direction = 0;\n        g_player.move_speed = 6;\n        g_player.rotation_speed = 4 * (M_PI / 180);\n    }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__pushPopInStack.3.c", "original_string": "int pop(struct stack*ptr){\n    if(isEmpty(ptr)){\n        printf(\"Stack Underflow! Cannot pop from the stack\\n\");\n        return -1;\n    }\n    else{\n        int val = ptr->arr[ptr->top];\n        ptr->top--;\n        return val;\n    }\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sort_Array_Descending.1.c", "original_string": "void display(int array[MAX], int length)\n{\n    int i = 0;\n    for(i=0; i<length; i++)\n        printf(\"%d\\t\", array[i]);\n    printf(\"\\n\");\n}"}
{"author": "earth429", "file": "mulpre__numComp.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a, b;\n    int return_val;\n    srandom(time(NULL));\n    clearByZero(&a);\n    clearByZero(&b);\n    return_val = numComp(&a, &b);\n    printf(\"\u623b\u308a\u5024 = %d\", return_val);\n    setInt(&b, -1);\n    return_val = numComp(&a, &b);\n    printf(\"\u623b\u308a\u5024 = %d\", return_val);\n    setInt(&a, -1);\n    return_val = numComp(&a, &b);\n    printf(\"\u623b\u308a\u5024 = %d\", return_val);\n    return 0;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__27_no_happy_no_all.0.c", "original_string": "int main()\n{\n  int no,i,j,k,x,y,sum = 0,a,b;\n  printf(\"Enter the Range with lower and uppar limit to find out the Happy no.  or not\");\n  scanf(\"%d%d\",&a,&b);\n  for(i=a; i<=b; i++)\n  {\n    while( i > 0 )\n    {\n      x = i % 10;\n      sum = sum + (x*x);\n      i = i / 10;\n      if( i == 0)\n      {\n    sleep(1);\n        printf(\"sum is %d\\n\",sum);\n        if( sum == 1)\n        {\n          printf(\"Number is Happy\");\n          break;\n        }\n        i = sum;\n        sum = 0;\n      }\n    }\n }\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__goal_server.6.c", "original_string": "void *handle_client(void *arg){\n    char buff_out[BUFFER_SZ];\n    char name[32];\n    int leave_flag = 0;\n    cli_count++;\n    client_t *cli = (client_t *)arg;\n    if(recv(cli->sockfd, name, 32, 0) <= 0 || strlen(name) <  2 || strlen(name) >= 32-1){\n        printf(\"Didn't enter the name.\\n\");\n        leave_flag = 1;\n    } else{\n        strcpy(cli->name, name);\n        sprintf(buff_out, \"%s has joined\\n\", cli->name);\n        printf(\"%s\", buff_out);\n        send_message(buff_out, cli->uid);\n    }\n    bzero(buff_out, BUFFER_SZ);\n    while(1){\n        if (leave_flag) {\n            break;\n        }\n        int receive = recv(cli->sockfd, buff_out, BUFFER_SZ, 0);\n        if (receive > 0){\n            if(strlen(buff_out) > 0){\n                send_message(buff_out, cli->uid);\n                str_trim_lf(buff_out, strlen(buff_out));\n                printf(\"%s -> %s\\n\", buff_out, cli->name);\n            }\n        } else if (receive == 0 || strcmp(buff_out, \"exit\") == 0){\n            sprintf(buff_out, \"%s has left\\n\", cli->name);\n            printf(\"%s\", buff_out);\n            send_message(buff_out, cli->uid);\n            leave_flag = 1;\n        } else {\n            printf(\"ERROR: -1\\n\");\n            leave_flag = 1;\n        }\n        bzero(buff_out, BUFFER_SZ);\n    }\n    close(cli->sockfd);\n  queue_remove(cli->uid);\n  free(cli);\n  cli_count--;\n  pthread_detach(pthread_self());\n    return NULL;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_last_DLL.1.c", "original_string": "void creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "dishanp", "file": "DSA__q15.1.c", "original_string": "void display(struct node *p)\n{\n    while(p)\n    {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "paawankohli", "file": "DSA-LAB__strCopy.1.c", "original_string": "int main()\n{\n    char a[50] = \"\", b[50] = \"\";\n    printf(\"Enter string:\\n\");\n    scanf(\"%s\", a);\n    printf(\"\\nstring 1: %s string2 2: %s\\n\", a, b);\n    printf(\"\\nCopying strings...\\n\");\n    strCopy(a, b);\n    printf(\"\\nstring 1: %s string2 2: %s\\n\", a, b);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedList-1.3.c", "original_string": "void print(node *start,node *ptr)\n{\n        if(ptr==start)\n        {\n                return;\n        }\n        printf(\"%d \",ptr->data);\n        print(start,ptr->next);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__count_the_elem_in_DLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__queue_using_linked_list.3.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=front;\n    if(front==0 && rear==0)\n    {\n        printf(\"the queue is empty\\n\");\n    }\n    else\n    {\n        printf(\"the element in the array are\\n\");\n       while(temp!=0)\n       {\n           printf(\"%d \",temp->data);\n           temp=temp->next;\n       }printf(\"\\n\");\n    }\n}"}
{"author": "ankitraj311", "file": "Socket-thread__temp.0.c", "original_string": "void *myThreadFun(void *vargp) \n{ \n    int *myid = (int *)vargp; \n    static int s = 0; \n    ++s; ++g; \n    printf(\"Thread ID: %d, Static: %d, Global: %d\\n\", *myid, ++s, ++g); \n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_atoi.2.c", "original_string": "int main(){\n    char palabra[10] = \"23456\";\n    int value = 0;\n    value = atoi(palabra);\n    printf(\"%i\", value );\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q42.2.c", "original_string": "int main()\n{\n    QUEUE q;\n    q.top1 = -1;\n    q.top2 = -1;\n    int ch, n;\n    do\n    {\n        printf(\"\\n\\n1. Insert\\n2. Delete\\n0. Exit\");\n        printf(\"\\nEnter Choice? : \");\n        scanf(\"%d\", &ch);\n        switch (ch)\n        {\n            case 1:\n                printf(\"\\nEnter number: \");\n                scanf(\"%d\", &n);\n                add(&q, n);\n                break;\n            case 2:\n                printf(\"\\n%d deleted \\n\", del(&q));\n                break;\n        }\n    }while (ch != 0);\n    return 0;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__20_Dowhile.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Euler elevado a X mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    do{\n        Suma_total += (Exp(X,i) / Fac(i));\n        ++i;\n    }while(i <= veces);\n    printf(\"e^%i es igual a %lf\", X, (Suma_total + 1.0));\n    return 0;\n}"}
{"author": "2security", "file": "Matrix__23AddMatrix.2.c", "original_string": "int main()\n    {\n    int i,j,r,c,mat1[20][20],mat2[20][20];\n    printf(\"\\n Enter the row & col. for two matrix(Both should be same)\");\n    scanf(\"%d%d\",&r,&c);\n    if(r!=c)\n        printf(\"\\n For Addition matrix should be square\");\n    else\n        {       \n        printf(\"\\n Enter the first matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        printf(\"\\n Enter the second matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat2[i][j]);\n        printf(\"\\n The addtion of two matrix is:\\n\");\n        AddMat(mat1,mat2,r,c);\n        }\n    return 0;\n    }"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client3.0.c", "original_string": "int main()\n{\n    int sockfd, fdmax, i;\n    struct sockaddr_in server_addr;\n    fd_set master;\n    fd_set read_fds;\n    char name[32];\n    char new_entry_message[42];\n    printf(\"Please enter your name: \");\n    fgets(name, 32, stdin);\n    str_trim_lf(name, strlen(name));\n    if (strlen(name) > 32 || strlen(name) < 2)\n    {\n        printf(\"Name must be less than 30 and more than 2 characters.\\n\");\n        return EXIT_FAILURE;\n    }\n    connect_request(&sockfd, &server_addr);\n    strcpy(new_entry_message, name);\n    strcat(new_entry_message, \" joined!\");\n    send(sockfd, new_entry_message, 32, 0);\n    FD_ZERO(&master);\n    FD_ZERO(&read_fds);\n    FD_SET(0, &master);\n    FD_SET(sockfd, &master);\n    printf(\"\\n--------------------- WELCOME TO THE CHATROOM ---------------------\\n\");\n    fdmax = sockfd;\n    while (1)\n    {\n        read_fds = master;\n        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)\n        {\n            perror(\"select\");\n            exit(4);\n        }\n        for (i = 0; i <= fdmax; i++)\n            if (FD_ISSET(i, &read_fds))\n               send_recv(i, sockfd, name, &master);\n    }\n    printf(\"Bye\\n\");\n    close(sockfd);\n    return 0;\n}"}
{"author": "Mr-JoE1", "file": "C-Tasks-for-newbies__main25.1.c", "original_string": "unsigned int My_strlen( char string[] , int size )\n{\n    for(int i = 0;i < size;i++)\n        if(string[ i ] == '\\0')                                 \n            return i;\n}"}
{"author": "dle2005", "file": "File_Structure__heapsort.1.c", "original_string": "void insert_heap(Person *person, Person *p) {\n    int i = ++heapsize;\n    memcpy(&person[i], p, sizeof(Person));\n    while((i != 1) && (strcmp(person[i].sn, person[i/2].sn) == -1)) {\n        swap(&person[i], &person[i/2]);\n        i = i/2;\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__1server.1.c", "original_string": "int main(int argc, char *argv[])\n{\n    int serv_sock = socket(AF_INET, SOCK_STREAM, 0);\n    if(serv_sock == -1)\n    {\n        sys_err(\"socket() error\");\n    }\n    int ret = 0;\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9999);\n    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    ret = bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n    if(ret == -1)\n    {\n        sys_err(\"bind() error\");\n    }\n    ret = listen(serv_sock, 128);\n    if(ret == -1)\n    {\n        sys_err(\"listen() error\");\n    }\n    struct sockaddr_in clnt_addr;\n    socklen_t clnt_addr_len = sizeof(clnt_addr);\n    int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_len);\n    if(clnt_sock == -1)\n    {\n        sys_err(\"accept error\");\n    }\n    char clnt_IP[1024];\n    printf(\"client ip:%s, port:%d\\n\", inet_ntop(AF_INET, &clnt_addr.sin_addr.s_addr, clnt_IP, sizeof(clnt_IP)), ntohs(clnt_addr.sin_port));\n    char buf[BUFSIZ];\n    while(1)\n    {\n        int ret = read(clnt_sock, buf, sizeof(buf));\n        if(ret == 0)\n        {\n            break;\n        }\n        write(STDOUT_FILENO, buf, ret);\n        for(int i = 0; i < ret; i++)\n        {\n            buf[i] = toupper(buf[i]);\n        }\n        write(clnt_sock, buf, ret);\n    }\n    close(serv_sock);\n    close(clnt_sock);\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__pll_36MHz.2.c", "original_string": "void pll_48MHz(void)\n{\n    PLLCON = 1<<0;              \n    PLLFEED = 0xAA;\n    PLLFEED = 0x55;             \n    PLLCFG = (1<<5)| 3; \n    PLLCFG &= ~(1<<5);\n    while(!(PLLSTAT & (1<<10)));            \n    PLLCON = (1<<1)|(1<<0);         \n    PLLFEED = 0xAA;\n    PLLFEED = 0x55;             \n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__RR.0.c", "original_string": "void enqueue(char c)\n{\n    if(f==-1 && r==-1)\n    {\n        f=f+1;\n        r=r+1;\n        Queue[r]=c;\n    }\n    else\n    {\n        r=r+1;\n        Queue[r]=c;\n    }\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__strcmp.0.c", "original_string": "void main()\n{\n    char a[100];\n    char b[100];\n    int i;\n    int s;\n    int ct=0;\n    printf(\"enter string-1:\");\n    gets(a);\n    printf(\"\\nenter string-2\");\n    gets(b);\n    s=(strlen(a)>strlen(b))?(strlen(a)):(strlen(b));\n    for(i=0;i<s;i++)\n    {\n        if(a[i]==b[i])\n        {\n            ct++;\n        }\n        else\n        {\n            ct=-1;\n            break;\n        }\n    }\n    if(ct==-1)\n    printf(\"\\nstrings are not equal\");\n    else\n    printf(\"\\nstrings are same\");\n}"}
{"author": "HakNinja", "file": "C-Basic__29mtt.0.c", "original_string": "void main()\n {int a[10][10],t[10][10],n,m,i,j;\n  printf (\"Enter numbers of rows:\");\n  scanf (\"%d\",&n);\n  printf (\"Enter numbers of columns:\");\n  scanf (\"%d\",&m);\n  printf(\"Enter elements:\");\n  for(i=0;i<n;i++)            \n   {for(j=0;j<m;j++)\n     {  scanf(\"%d\",&a[i][j]);\n      }\n    }\n  printf(\"\\n Array is:\\n\");\n  for(i=0;i<n;i++)          \n   {for(j=0;j<m;j++)\n     {  printf(\"\\t %d\",a[i][j]);\n      }\n      printf(\"\\n\");\n    }\n  printf(\"\\n\");  \n  for(i=0;i<n;i++)         \n   {for(j=0;j<m;j++)\n     {   t[j][i]=a[i][j];\n      }\n    }\n  printf(\"\\n Its transpose:\\n\");\n  for(i=0;i<n;i++)           \n   {for(j=0;j<m;j++)\n     {  printf(\"\\t %d\",t[i][j]);\n      }\n    printf(\"\\n\");\n    }\n  }"}
{"author": "ashlyn2002", "file": "programming-using-c__count_the_elem_in_CLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d\",temp->data);\n    printf(\"\\n\");\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__DemoFOTAUpdateWorkflow0.4.c", "original_string": "static void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance)\n{\n  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;\n  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;\n  instance->updateInfo.version = NULL;\n  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;\n  instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n}"}
{"author": "2security", "file": "If-else__DAYNAME.0.c", "original_string": "int main()\n    {\n    int weekd;\n    printf(\"Enter week day number\");\n    scanf(\"%d\",&weekd);\n    if(weekd==1)\n        printf(\"MONDAY\\n\");\n    else if(weekd==2)\n        printf(\"TUESDAY\\n\");\n    else if(weekd==3)\n        printf(\"WEDNESDAY\\n\");\n    else if(weekd==4)\n        printf(\"THURSDAY\\n\");\n    else if(weekd==5)\n        printf(\"FRIDAY\\n\");\n    else if(weekd==6)\n        printf(\"SATURDAY\\n\");\n    else if(weekd==7)\n        printf(\"SUNDAY\\n\");\n    else \n        printf(\"OOPS!!Enter valid week day number\\n\");\n    return 0;\n    }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__12_Dowhile.0.c", "original_string": "int main()\n{\n    char letra;\n    int i = 0;\n    int j;\n    do{\n    switch (i){\n            case 0: letra = 'P';break;\n            case 1: letra = 'N';break;\n            case 2: letra = 'L';break;\n            case 3: letra = 'J';break;\n            case 4: letra = 'H';break;\n            case 5: letra = 'F';break;\n            case 6: letra = 'D';break;\n    }\n    j = 0;\n    do{\n        if(j >= (1 + i) && j <= (13-i))\n            printf(\"%c\", letra);\n        else\n        printf(\" \");\n        ++j;\n    }while(j <= 13);\n        printf(\"\\n\");\n        ++i;\n    }while( i< 7);\n    return 0; \n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_5.1.c", "original_string": "void addend()\n{\n    struct node* temp;\n    temp = (struct node*)malloc(sizeof(struct node));\n    printf(\"Enter Node Data : \");\n    scanf(\"%d\", &temp->data);\n    printf(\"%d inserted.\\n\\n\", temp->data);\n    temp->link = NULL;\n    if(root == NULL)\n    {\n        root = temp;\n    }\n    else\n    {\n        struct node* p;\n        p = root;\n        while(p->link != NULL)\n        {\n            p = p->link;\n        }\n        p->link = temp;\n    }\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__rounting_utils1.1.c", "original_string": "int     wrong_resolution(int width, int height)\n{\n    int w;\n    int h;\n    w = width;\n    h = height;\n    if (width > 2560)\n        w = 2560;\n    if (height > 1400)\n        h = 1400;\n    if (width <= 100 || height <= 100)\n    {\n        ft_putstr(\"Error:\\nresolution is < 100 px!\\n\");\n        exit(0);\n    }\n    get_resolution(w, h);\n    return (1);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__BinHexConverter0.3.c", "original_string": "uint8_t convertHexString8ToBinValue(char *inputStr, size_t inputStrLength)\n{\n  if (inputStrLength != 2) \n  {\n    return 0;\n  }\n  uint8_t outputValue = convertHexDigitToBinValue(inputStr[0]) << 4;\n  outputValue |= convertHexDigitToBinValue(inputStr[1]);\n  return outputValue;\n}"}
{"author": "seefeesaw", "file": "Recursion__fibonacci.3.c", "original_string": "int main()\n     {\n         int i;\n         for ( i = 0; i < 10; i++)\n         {\n             F[i] =-1;\n         }\n         printf(\"%d \\n\",mfib(5));\n         return 0;\n     }"}
{"author": "254Odeke", "file": "OpeartingSystems__sequentialFileAllocation.0.c", "original_string": "void main(){\n    for(i=0;i<512;i++)\n        disk[i]=0;\n        int x,y,flag=0;\n    printf(\"Enter no.of files:\");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        printf(\"Enter File Name:\");\n        scanf(\"%s\",file[i].name);\n        printf(\"Enter Starting Index:\");\n        scanf(\"%d\",&file[i].starting_block);\n        printf(\"Enter Size of Block:\");\n        scanf(\"%d\",&file[i].no_of_blocks);\n        x=file[i].starting_block;\n        y=file[i].no_of_blocks;\n        for(j=x;j<x+y;j++){\n            if(disk[j]==1){\n                printf(\"Sequencial Allocation is not possible\\n\");\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0){\n            for(j=x;j<x+y;j++){\n                disk[j]=1;\n            }\n            printf(\"Allocation is done sequentially\\n\");\n        }\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.16.c", "original_string": "VAR* mkvar(char* type, char* name, bool primitive, DEBUGINFO* debug, MEMSEGMENT seg, int i) {\n    VAR* v = (VAR*)malloc(sizeof(VAR));\n    v->name = name;\n    v->type = type;\n    v->debug = debug;\n    v->memsegment = memsegnames[seg];\n    v->primitive = primitive;\n    v->index = i;\n    return v;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Linear_Search.1.c", "original_string": "void display(int array[MAX], int length)\n{\n    int i = 0;\n    for(i=0; i<length; i++)\n        printf(\"%d\\t\", array[i]);\n    printf(\"\\n\");\n}"}
{"author": "0712023", "file": "Basis-and-Practice-in-Programming_SKKU__stage5.1.c", "original_string": "void check_stuck(){\n  if(pos<8 && map[pos+1] == 'W' && map[pos-1] == 'W' && map[pos+8] == 'W'){\n    exit(0);\n  } else if(pos>55 && map[pos+1] == 'W' && map[pos-1] == 'W' && map[pos-8] == 'W') {\n    exit(0);\n  } else if(pos%8==7 && map[pos-8] == 'W' && map[pos-1] == 'W' && map[pos+8] == 'W') {\n    exit(0);\n  } else if(pos%8==0 && map[pos-8] == 'W' && map[pos+1] == 'W' && map[pos+8] == 'W') {\n    exit(0);\n  } else if(pos<8 && pos%8==7 && map[pos-1] == 'W' && map[pos+8] == 'W'){\n    exit(0);\n  } else if(pos%8==7 && pos>55 && map[pos-8] == 'W' && map[pos-1] == 'W'){\n    exit(0);\n  } else if(pos>55 && pos%8==0 && map[pos-8] == 'W' && map[pos+1] == 'W'){\n    exit(0);\n  } else if(pos%8==0 && pos<8 && map[pos+1] == 'W' && map[pos+8] == 'W'){\n    exit(0);\n  } else if(map[pos-8] == 'W' && map[pos+8] == 'W' && map[pos+1] == 'W' && map[pos-1] == 'W'){\n    exit(0);\n  }\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__readfile.2.c", "original_string": "int     main(void)\n{\n    char **ugh;\n    int a;\n    readline();\n    manage_map();\n    longuest_line();\n    array_height();\n    ugh = map_manager();\n    g_vars.mlx = mlx_init();\n    g_vars.win = mlx_new_window(g_vars.mlx, g_width, g_height, \"Bismilah!\");\n    freethenipples(ugh);\n    mlx_loop_hook(g_vars.mlx, move, 0);\n    mlx_loop(g_vars.mlx);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__dequeue.1.c", "original_string": "void enqueueleft(queue *q,int n)\n{\n    if (q->front==0)\n        printf(\"Side Full\\n\");\n    else\n        q->c[--(q->front)]=n;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__wdt.1.c", "original_string": "void delay(int ct)\n{\n    for(int i=0;i<ct;i++)\n    {\n        for(int j=0;j<6000;j++)\n        {}\n    }\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sum_Of_All_Diagonals.1.c", "original_string": "int find_sum_principal(int matrix[R][C])\n{\n    int rows = R;\n    int columns = C;\n    int i, j, sum_principal = 0;\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {\n            if(i == j)\n                sum_principal += matrix[i][j];\n            else\n                continue;\n        }\n    }\n    return sum_principal;\n}"}
{"author": "mandarvu", "file": "msc__problem4.1.c", "original_string": "void deletion(int *source, int *target, int position) {\n  int j = 0;\n  for (j = 0; j < MAX + 1; j++) { \n    if (j < position - 1){\n      *(target + j) = *(source + j);\n      continue;\n    }\n    else { \n      *(target + j) = *(source + j + 1);\n    }\n  }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__string_copy.1.c", "original_string": "int main()\n{\n    char arr[30] = {'\\0'};   \n    char brr[30] = {'\\0'};   \n    printf(\"Please enter the string\\n\");\n    scanf(\"%[^'\\n']s\",arr);\n    StrcpyX(arr,brr);\n    printf(\"String after copy : %s\\n\",brr);\n    return 0;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sort_Array_Ascending.1.c", "original_string": "void display(int array[MAX], int length)\n{\n    int i = 0;\n    for(i=0; i<length; i++)\n        printf(\"%d\\t\", array[i]);\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Odd_Even_Sort.1.c", "original_string": "void display(int array[MAX], int length)\n{\n    int i = 0;\n    for(i=0; i<length; i++)\n        printf(\"%d\\t\", array[i]);\n    printf(\"\\n\");\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_6.5.c", "original_string": "int main()\n{\n    FILE* fp1;\n    FILE* fp2;\n    fp1=fopen(\"input.txt\",\"r\");\n    fp2=fopen(\"output.txt\",\"w\");\n    node Q=NULL;\n    char sel;\n    int elem,num,temp=0;\n    while(1)\n    {\n        fscanf(fp1,\"%c\",&sel);\n        if(sel=='e')\n        {\n            fscanf(fp1,\"%d\",&elem);\n            enqueue(&Q, elem);\n        }\n        else if(sel=='p')\n        {\n            fscanf(fp1,\"%d\",&num);\n            print(Q,num,fp2);\n        }\n        else if(sel=='d')\n        {\n            temp=dequeue(&Q);\n            fprintf(fp2,\"%d\\n\",temp);\n        }\n        else if(sel=='s')\n        {\n            break;\n        }\n    }\n    fclose(fp1);\n    fclose(fp2);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__BinHexConverter0.0.c", "original_string": "static inline char convertBinValueToHexDigit(uint8_t value, bool upperCase)\n{\n  char hexA = (upperCase) ? ('A') : ('a');\n  return ((char)((value < 10) ? ('0' + value) : (hexA + value - 10)));\n}"}
{"author": "rgautam320", "file": "Data-Structure__main19.4.c", "original_string": "int main()\n{\n    char infix[CAPACITY], prefix[CAPACITY], tempo[CAPACITY], item, temp;\n    int i = 0, j = 0, k = 0, l = 0;\n    printf(\"Enter an Infix Expression to Convert into Prefix : \");\n    gets(tempo);\n    for(k = strlen(tempo)-1; k>=0; k--)\n    {\n        infix[l] = tempo[k];\n        l++;\n    }\n    while(infix[i]!='\\0')\n    {\n        item = infix[i];\n        if(item == ')')\n        {\n            push(item);\n        }\n        else if((item >= 'A' && item <= 'Z') || (item >= 'a' && item <= 'z'))\n        {\n            prefix[j] = item;\n            j++;\n        }\n        else if(is_operator(item) == 1)\n        {\n            temp = pop();\n            while(is_operator(temp) == 1 && precedence(temp) >= precedence(item))\n            {\n                prefix[j] = temp;\n                j++;\n                temp = pop();\n            }\n            push(temp);\n            push(item);\n        }\n        else if(item == '(')\n        {\n            temp = pop();\n            while(temp != ')')\n            {\n                prefix[j] = temp;\n                j++;\n                temp = pop();\n            }\n        }\n        else\n        {\n            printf(\"Invalid Expression\\n\");\n        }\n        i++;\n    }\n    while(top > -1)\n    {\n        prefix[j] = pop();\n        j++;\n    }\n    printf(\"Arithmetic Expression in Prefix form is : \");\n    for(i = strlen(prefix)-1; i>= 0 ; i--)\n    {\n        printf(\"%c\", prefix[i]);\n    }\n    return 0;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica1-1a.0.c", "original_string": "int main(){\n    int n, status;\n    pid_t pid; \n    printf(\"introduce el numero de procesos:\\n\");\n    scanf(\"%i\", &n);\n    for (int i = 0; i < n; i++){\n        switch ( fork() ){\n        case -1: \n            perror(\"fork error:\\n\");\n            fprintf(stderr, \"errno:  %i\\n\", errno); \n            exit(EXIT_FAILURE);\n            break;\n        case 0: \n            printf(\"soy un proceso hijo con PID: %i; el PID de mi proceso padre es: %i\\n\", getpid(), getppid());\n            exit(EXIT_SUCCESS); \n        }\n    }\n    for (int i = 0; i < n; i++){\n        pid = wait(&status); \n        if (pid > 0){ \n            if      (WIFEXITED(status))   printf(\"1 el hijo %i ha sido finalizado con la se\u00f1al %i\\n\", pid, WEXITSTATUS(status));\n            else if (WIFSIGNALED(status)) printf(\"2 el hijo %i ha sido finalizado con la se\u00f1al %i\\n\", pid, WTERMSIG(status));\n            else if (WIFSTOPPED(status))  printf(\"3 el hijo %i ha sido finalizado con la se\u00f1al %i\\n\", pid, WSTOPSIG(status));\n        }\n        else{ \n            printf(\"fallo en la invocacion\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n    exit(EXIT_SUCCESS);\n}"}
{"author": "augustogunsch", "file": "jack-compiler__util.0.c", "original_string": "char* heapstr(const char* str, int len) {\n    int size = sizeof(char) * (len + 1);\n    char* outstr = (char*)malloc(size);\n    strcpy(outstr, str);\n    return outstr;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_03.2.c", "original_string": "int binary_search(int a[], int str, int end, int k)\n{\n    int mid = (end+str)/2;\n    while(str<=end)\n    {\n        mid = (end+str)/2;\n        if(a[mid] == k)\n            return mid;\n        else if(a[mid]>k)\n        {\n            end = mid-1;\n        }\n        else if(a[mid]<k)\n        {\n            str = mid+1;\n        }\n    }\n    return -1;\n}"}
{"author": "haon1026", "file": "linux-programming__3server_afterwarp.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9999);\n    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    Bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n    Listen(serv_sock, 128);\n    struct sockaddr_in clnt_addr;\n    socklen_t clnt_addr_len = sizeof(clnt_addr);\n    int clnt_sock = Accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_len);\n    char clnt_IP[1024];\n    printf(\"client ip:%s, port:%d\\n\", inet_ntop(AF_INET, &clnt_addr.sin_addr.s_addr, clnt_IP, sizeof(clnt_IP)), ntohs(clnt_addr.sin_port));\n    char buf[BUFSIZ];\n    while(1)\n    {\n        int ret = Read(clnt_sock, buf, sizeof(buf));\n        if(ret == 0)\n        {\n            break;\n        }\n        Write(STDOUT_FILENO, buf, ret);\n        for(int i = 0; i < ret; i++)\n        {\n            buf[i] = toupper(buf[i]);\n        }\n        Write(clnt_sock, buf, ret);\n    }\n    Close(serv_sock);\n    Close(clnt_sock);\n    return 0;\n}"}
{"author": "mandarvu", "file": "msc__problem73.0.c", "original_string": "void reverse_array(int *origin, int *rev) {\n  int j = 0;\n  for (int i = MAX - 1; i >= 0; i--)\n    {\n        *(rev + j) = *(origin + i);\n        j++;\n    }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e16.0.c", "original_string": "int main(void) {\n    int jogadorUm, jogadorDois, nEmpatesUm, nEmpatesDois, nDerrotasUm , nDerrotasDois;\n    int opcao, menu;\n    float nVitoriasUm, nVitoriasDois, pVitoriasUm, pVitoriasDois, nJogadas;\n    opcao = 1;\n    nVitoriasDois = 0;\n    nDerrotasUm = 0;\n    printf(\"------------------------------------\\n-------------bem vindo!-------------\\n------------------------------------\\n\\n\");\n    while(opcao != 3){\n    printf(\"Selecione seu modo de jogo: \\n\\n\");\n    printf(\"1- PvC - Player vs Computer \\n\");\n    printf(\"2- PvP - Player vs Player \\n\");\n    printf(\"3- sair\\n\");\n    fflush(stdin);\n    scanf(\"%d\", &opcao);\n    switch(opcao){\n        case 1: \n         jogadorUm = 0;\n         jogadorDois = 0;\n         nVitoriasUm = 0;\n         nVitoriasDois = 0;\n         nEmpatesUm = 0;\n         nEmpatesDois = 0;\n         nJogadas = 0;\n         nDerrotasUm  = 0;\n         nDerrotasDois = 0;\n         pVitoriasUm = 0;\n         pVitoriasDois = 0;\n        while(menu !=4){\n           printf(\"\\nSelecione sua opcao: \\n\");\n           printf(\"1- Pedra\\n 2- Papel \\n 3- Tesoura. \\n\");\n           scanf(\"%d\", &jogadorUm);\n           srand(time(NULL));\n           jogadorDois = 1 + rand() %3;\n           printf(\"\\nOpcao jogadorDois = %d \", jogadorDois, (jogadorDois % 4));\nif(jogadorUm == 1 && jogadorDois == 1){\n            printf(\"\\nDeu Empate!\\n\");\n            nEmpatesUm = nEmpatesUm + 1;\n            nEmpatesDois = nEmpatesDois + 1; \n            nJogadas = nJogadas + 1;\n      }else{\n          if(jogadorUm == 1 && jogadorDois == 2){  \n                       printf(\"\\nO jogador Dois ganhou\\n\");\n                       nDerrotasUm = nDerrotasUm + 1;\n                       nVitoriasDois = nVitoriasDois + 1;\n                       nJogadas = nJogadas + 1;                   \n         }else{\n              if(jogadorUm == 1 && jogadorDois == 3){\n                           printf(\"\\nO Jogador Um ganhou\\n\");\n                           nDerrotasDois = nDerrotasDois + 1;\n                           nVitoriasUm = nVitoriasUm + 1;\n                           nJogadas = nJogadas + 1;\n              }else{\n                    if(jogadorUm == 2 && jogadorDois == 1){ \n                                 printf(\"\\nO jogador Dois ganhou\\n\");\n                                 nDerrotasUm = nDerrotasUm + 1;\n                                 nVitoriasDois = nVitoriasDois + 1;\n                                 nJogadas = nJogadas + 1;\n                    }else{\n                          if(jogadorUm == 2 && jogadorDois == 2){\n                                       printf(\"\\nDeu empate\\n\");\n                                       nEmpatesUm = nEmpatesUm + 1;\n                                       nEmpatesDois = nEmpatesDois + 1;\n                                       nJogadas = nJogadas + 1;\n                         }else{\n                               if(jogadorUm == 2 && jogadorDois == 3){  \n                                            printf(\"\\nO jogador dois ganhou\\n\");\n                                            nVitoriasDois = nVitoriasDois + 1;\n                                            nDerrotasUm = nDerrotasUm + 1;\n                                            nJogadas = nJogadas + 1;\n                              }else{\n                                    if (jogadorUm == 3 && jogadorDois == 1){\n                                                  printf(\"\\nO jogador Dois ganhou\\n\");\n                                                  nVitoriasDois = nVitoriasDois + 1;\n                                                  nDerrotasUm = nDerrotasUm + 1;\n                                                  nJogadas = nJogadas + 1;\n                                    }else{\n                                          if(jogadorUm == 3 && jogadorDois == 2){\n                                                       printf(\"\\nO jogador Um ganhou\\n\");\n                                                       nDerrotasDois = nDerrotasDois + 1;\n                                                       nVitoriasUm = nVitoriasUm + 1;\n                                                       nJogadas = nJogadas + 1;\n                                            }else{\n                                                  if(jogadorUm == 3 && jogadorDois == 3){\n                                                               printf(\"\\nDeu Empate\\n\");\n                                                               nEmpatesUm = nEmpatesUm + 1;\n                                                               nEmpatesDois = nEmpatesDois + 1;\n                                                               nJogadas = nJogadas + 1;\n                                                  }else{\n                                                       printf(\"\\nJogada Invalida\\n\");\n                                                  } \n}}}}}}}}\n            if(nVitoriasUm == 0)\n            {\n                   pVitoriasUm = 0;\n                   }else \n                   {\n                          pVitoriasUm = ( nVitoriasUm/ nJogadas ) * 100;\n                   }\n                                if(nVitoriasDois == 0)\n                                {\n                                        pVitoriasDois = 0;\n                                        }else\n                                        {\n                                                pVitoriasDois = ( nVitoriasDois / nJogadas ) * 100;\n            }\n            printf(\"\\nJOGADOR 1: \\n\");\n            printf(\"\\nQuantidade de Vitorias: %.0f\", nVitoriasUm);\n            printf(\"\\nQuantidade de Derrotas: %d\", nDerrotasUm);\n            printf(\"\\nQuantidade de Empates: %d\", nEmpatesUm);\n            printf(\"\\nPercentual de Vitorias: %.2f %%\", pVitoriasUm );\n            printf(\"\\n------------------------------------------------------------------\");\n            printf(\"\\nJOGADOR 2: \\n\");\n            printf(\"\\nQuantidade de Vitorias: %.0f\", nVitoriasDois);\n            printf(\"\\nQuantidade de Derrotas: %d\", nDerrotasDois);\n            printf(\"\\nQuantidade de Empates: %d\", nEmpatesDois);\n            printf(\"\\nPercentual de Vitorias: %.2f %%\", pVitoriasDois);\n            printf(\"\\n------------------------------------------------------------------\");\n            printf(\"\\nGERAL: \\n\");\n            printf(\"Quantidade de Jogadas Total: %.0f\", nJogadas);\n            printf(\"\\ndeseja jogar novamente?\\n\");\n            scanf(\"%d\", &menu);\n            system(\"cls\");\n    }\n        break;\n        case 2:  \n         jogadorUm = 0;\n         jogadorDois = 0;\n         nVitoriasUm = 0;\n         nVitoriasDois = 0;\n         nEmpatesUm = 0;\n         nEmpatesDois = 0;\n         nJogadas = 0;\n         nDerrotasUm  = 0;\n         nDerrotasDois = 0;\n         pVitoriasUm = 0;\n         pVitoriasDois = 0;\n        while(opcao != 3){\n           printf(\"\\nSelecione sua opcao: \\n\");\n           printf(\"1- Pedra\\n 2- Papel \\n 3- Tesoura. \\n\");\n           scanf(\"%d\", &jogadorUm);\n           printf(\"\\nSelecione sua opcao: \\n\");\n           printf(\"1- Pedra\\n 2- Papel \\n 3- Tesoura. \\n\");\n           scanf(\"%d\", &jogadorDois);\n           system(\"cls\");\nif(jogadorUm == 1 && jogadorDois == 1){\n            printf(\"\\nDeu Empate!\\n\");\n            nEmpatesUm = nEmpatesUm + 1;\n            nEmpatesDois = nEmpatesDois + 1; \n            nJogadas = nJogadas + 1;\n      }else{\n          if(jogadorUm == 1 && jogadorDois == 2){  \n                       printf(\"\\nO jogador Dois ganhou\\n\");\n                       nDerrotasUm = nDerrotasUm + 1;\n                       nVitoriasDois = nVitoriasDois + 1;\n                       nJogadas = nJogadas + 1;                   \n         }else{\n              if(jogadorUm == 1 && jogadorDois == 3){\n                           printf(\"\\nO Jogador Um ganhou\\n\");\n                           nDerrotasDois = nDerrotasDois + 1;\n                           nVitoriasUm = nVitoriasUm + 1;\n                           nJogadas = nJogadas + 1;\n              }else{\n                    if(jogadorUm == 2 && jogadorDois == 1){ \n                                 printf(\"\\nO jogador Dois ganhou\\n\");\n                                 nDerrotasUm = nDerrotasUm + 1;\n                                 nVitoriasDois = nVitoriasDois + 1;\n                                 nJogadas = nJogadas + 1;\n                    }else{\n                          if(jogadorUm == 2 && jogadorDois == 2){\n                                       printf(\"\\nDeu empate\\n\");\n                                       nEmpatesUm = nEmpatesUm + 1;\n                                       nEmpatesDois = nEmpatesDois + 1;\n                                       nJogadas = nJogadas + 1;\n                         }else{\n                               if(jogadorUm == 2 && jogadorDois == 3){  \n                                            printf(\"\\nO jogador dois ganhou\\n\");\n                                            nVitoriasDois = nVitoriasDois + 1;\n                                            nDerrotasUm = nDerrotasUm + 1;\n                                            nJogadas = nJogadas + 1;\n                              }else{\n                                    if (jogadorUm == 3 && jogadorDois == 1){\n                                                  printf(\"\\nO jogador Dois ganhou\\n\");\n                                                  nVitoriasDois = nVitoriasDois + 1;\n                                                  nDerrotasUm = nDerrotasUm + 1;\n                                                  nJogadas = nJogadas + 1;\n                                    }else{\n                                          if(jogadorUm == 3 && jogadorDois == 2){\n                                                       printf(\"\\nO jogador Um ganhou\\n\");\n                                                       nDerrotasDois = nDerrotasDois + 1;\n                                                       nVitoriasUm = nVitoriasUm + 1;\n                                                       nJogadas = nJogadas + 1;\n                                            }else{\n                                                  if(jogadorUm == 3 && jogadorDois == 3){\n                                                               printf(\"\\nDeu Empate\\n\");\n                                                               nEmpatesUm = nEmpatesUm + 1;\n                                                               nEmpatesDois = nEmpatesDois + 1;\n                                                               nJogadas = nJogadas + 1;\n                                                        }else{\n                                                                 printf(\"\\nJogada Invalida\\n\");\n}}}}}}}}}\n            if(nVitoriasUm == 0)\n            {\n                   pVitoriasUm = 0;\n                 }\n                 else\n                     {\n                        pVitoriasUm = ( nVitoriasUm / nJogadas ) * 100;\n                     }\n                             if(nVitoriasDois == 0){\n                                    pVitoriasDois = 0;\n                                    }\n                                     else\n                                     {\n                                               pVitoriasDois = ( nVitoriasDois / nJogadas ) * 100;\n            }\n            printf(\"\\nJOGADOR 1: \\n\");\n            printf(\"\\nQuantidade de Vitorias: %.0f\", nVitoriasUm);\n            printf(\"\\nQuantidade de Derrotas: %d\", nDerrotasUm);\n            printf(\"\\nQuantidade de Empates: %d\", nEmpatesUm);\n            printf(\"\\nPercentual de Vitorias: %.2f\", pVitoriasUm );\n            printf(\"\\n------------------------------------------------------------------\");\n            printf(\"\\nJOGADOR 2: \\n\");\n            printf(\"\\nQuantidade de Vitorias: %.0f\", nVitoriasDois);\n            printf(\"\\nQuantidade de Derrotas: %d\", nDerrotasDois);\n            printf(\"\\nQuantidade de Empates: %d\", nEmpatesDois);\n            printf(\"\\nPercentual de Vitorias: %.2f %%\", pVitoriasDois);\n            printf(\"\\n------------------------------------------------------------------\");\n            printf(\"\\nGERAL: \\n\");\n            printf(\"Quantidade de Jogadas Total: %.0f\", nJogadas);\n            printf(\"\\ndeseja jogar novamente?\\n\");\n            scanf(\"%d\", &menu);\n            system(\"cls\");      \n        }\n           break;\n        case 3:\n           printf(\"Cansou de jogar? \\n\");\n           system(\"exit\");\n           break;\n        default:           \n            printf(\"opcao invalida\");\n            break;\n        }\n}\n    if(menu == 2){\n        printf(\"Voce saira do jogo!\");\n    }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__digit_addition.2.c", "original_string": "int main()\n{\n    int no = 0, iRet = 0;\n    printf(\"Enter first number\\n\");\n    scanf(\"%d\",&no);\n    iRet = SumR(no);\n    printf(\"Result is %d\",iRet);\n    return 0;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_c_extended.6.c", "original_string": "void ble_lbs_c_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context)\n{\n    if ((p_context == NULL) || (p_ble_evt == NULL))\n    {\n        return;\n    }\n    ble_lbs_c_t * p_ble_lbs_c = (ble_lbs_c_t *)p_context;\n    switch (p_ble_evt->header.evt_id)\n    {\n        case BLE_GATTC_EVT_HVX:\n            on_hvx(p_ble_lbs_c, p_ble_evt);\n            break;\n        case BLE_GATTC_EVT_WRITE_RSP:\n            on_write_rsp(p_ble_lbs_c, p_ble_evt);\n            break;\n        case BLE_GAP_EVT_DISCONNECTED:\n            on_disconnected(p_ble_lbs_c, p_ble_evt);\n            break;\n        default:\n            break;\n    }\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad5-LetterCheck.1.c", "original_string": "int letterCheck(char c){\n    int alphabetNumber;\n    int asciiNumber = c;\n    if(asciiNumber >= 65 && asciiNumber <= 90){\n        alphabetNumber = asciiNumber - 64;\n        return alphabetNumber;\n    } else if(asciiNumber >= 97 && asciiNumber <= 122){\n        alphabetNumber = asciiNumber - 96;\n        return alphabetNumber;\n    }\n    return -1;\n}"}
{"author": "254Odeke", "file": "Operating-Systems_Lab__Virtual_to_Physical_Address_Conversion_Simulation.2.c", "original_string": "void cphyaddr(){\n    int log_add,paddr,disp,phy_add,base_add;\n    printf(\"Enter the Base Address: \");\n    scanf(\"%d\",&base_add);\n    printf(\"Enter the Logical Address: \");\n    scanf(\"%d\",&log_add);\n    paddr = log_add / psize;\n    disp = log_add % psize;\n    if(ptable[paddr].pbit == 1 )\n        phy_add = base_add + (ptable[paddr].fno*psize) + disp;\n    printf(\"\\nThe Physical Address where the instruction present: %d\",phy_add);\n}"}
{"author": "davibernardos", "file": "DB-PJ__e62.3.c", "original_string": "int escolherIngresso()\n{   \n    int tipoIngresso;\n    meiaEntrada = valorIngresso*0.5;\n        printf(\"\\t_______________________________________\\n\");\n        printf(\"\\n\\t| ADQUIRA SEU INGRESSO PARA O EVENTO. |\\n\");\n        printf(\"\\t_______________________________________\\n\");\n        printf(\"\\n\\t\\tO valor do evento eh: R$%.2f \\n\\t\\t(Meia entrada: R$%.2f)\\n\", valorIngresso, meiaEntrada);    \n        printf(\"\\nEscolha o tipo de ingresso:\\n\");\n        printf(\"\\n\\t-Digite 1 para inteira.\\n\");\n        printf(\"\\t-Digite 2 para meia.\\n\\n\\t\\t\");   \n        scanf(\"%d\", &tipoIngresso); \n        return tipoIngresso;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__functions.5.c", "original_string": "int PrintHashTable(pointerHash hashTable)\n{\n    printf(\"Hash table of students:\\n\\n\");\n    for (int i = 0; i < hashTable->size; i++)\n    {\n        int printMeOnce = 1;\n        position current = hashTable->hashList[i];\n        while (current)\n        {\n            if (printMeOnce == 1)\n            {\n                printf(\"Key:%d\\n\", i);\n                printMeOnce++;\n            }\n            printf(\"%s %s\\n\\n\", current->firstName, current->lastName);\n            current = current->next;\n        }\n    }\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__list-push-pop-del-rec_rev-count.6.c", "original_string": "node* print(node* head)\n{\n    if(head==NULL)\n        return NULL;\n    else if(head->next==NULL)\n    {\n        printf(\"      STACK      \\n\");\n        return head;\n    }\n    else\n    {\n        printf(\"\\t%d\\n\",(print(head->next))->data);\n        return head;\n    }\n}"}
{"author": "MFarid94", "file": "Assignment4__Exercise9.1.c", "original_string": "int main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n    char str[256];\n    printf(\"Enter a string: \");\n    gets(str);\n    printf(\"Reversed string: %s\",LastLetters(str));\n    return 0;\n}"}
{"author": "mehedi9021", "file": "C__grading_system.0.c", "original_string": "int main()\n{\n    int n;\n    printf(\"Enter The Number :\");\n    scanf(\"%d\", &n);\n    if (n>=80 && n<=100)\n    {\n        printf(\"\\nEarned Grade is >> A+\");\n    }\n    else if (n>=70 && n<=79)\n    {\n        printf(\"\\nEarned Grade is >> A\");\n    }\n    else if(n>=60 && n<=69)\n    {\n        printf(\"\\nEarned Grade is >> A-\");\n    }\n    else if (n>=50 && n<=59)\n    {\n        printf(\"\\nEarned Grade is >> B\");\n    }\n    else if (n>=40 && n<=49)\n    {\n        printf(\"\\nEarned Grade is >> C\");\n    }\n    else\n    {\n        printf(\"\\nEarned Grade is >> F\");\n    }\n    return 0;\n}"}
{"author": "dle2005", "file": "File_Structure__heapsort.2.c", "original_string": "Person delete_heap(Person *person) {\n    int parent, child;\n    Person item, temp;\n    item = person[1];\n    temp = person[heapsize--];\n    parent = 1;\n    child = 2;\n    while(child <= heapsize) {\n        if((child < heapsize) && (strcmp(person[child].sn, person[child+1].sn) == 1)) {\n            child++;\n        }\n        if(strcmp(temp.sn, person[child].sn) == -1)\n            break;\n        swap(&person[parent], &person[child]);\n        parent = child;\n        child *= 2;\n    }\n    person[parent] = temp;\n    return item;\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client2.3.c", "original_string": "void trim_newline(char *arr, int length)\n{\n    int i;\n    for (i = 0; i < length; i++)\n    {\n        if (arr[i] == '\\n')\n        {\n            arr[i] = '\\0';\n            break;\n        }\n    }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e40.0.c", "original_string": "int srandString(int vetorCaptcha[6])\n{\n    int contador;\n    int recebe;\n    for(contador = 0; contador < 6; contador ++)\n    {\n        recebe = rand() % 3;\n        if(recebe == 0);\n        {\n            vetorCaptcha[contador] = (rand() % 10) + (48);\n        }\n        if(recebe == 1)\n        {\n            vetorCaptcha[contador] = (rand() % 25) + (65);  \n        }\n        if(recebe == 2)\n        {\n            vetorCaptcha[contador] = (rand() % 25) + (97);\n        }\n        printf(\"%c\", vetorCaptcha[contador]);\n    }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_07.6.c", "original_string": "void bucketSort(int A[],int n)\n {  int i,j,k,flag=0;\n    int dig=0;\n    dig=findMax_digits(A,n);\n    int binarr[n][dig];\n    for (i = 0; i < n; i++)\n     for (j = 0; j < dig; j++)\n      binarr[i][j]=0;\n    form_binary(A,n,dig,binarr);\n    int one[n];\n    for (i = 0; i < n; i++)\n     {one[i]=0;\n      }\n    count_ones(n,dig,binarr,one);\n    int max=0;\n    for(i=1;i<n;i++)\n     {\n       if(one[i]>one[max])\n       max=i;\n     }\n    int bucket_nos;\n     bucket_nos=one[max]+1;\n    struct bucket buckets[bucket_nos];\n    for (i = 0; i <= bucket_nos; i++)\n    {\n        buckets[i].count = 0;\n        buckets[i].value = (int*)malloc(sizeof(int) * n);\n    }\n    for (i = 0; i < n; i++)\n      buckets[one[i]].value[buckets[one[i]].count++] = A[i];\n    for (k = 0, i = 0; i <= bucket_nos; i++)\n    {\n        if(buckets[i].count!=0)\n          insertionSort(buckets[i].value,buckets[i].count);\n        for (j = 0; j < buckets[i].count; j++)\n                    A[k + j] = buckets[i].value[j];\n        k+=buckets[i].count;\n    }\n        for(i=0;i<= bucket_nos;i++)\n        {\n                if(buckets[i].count!=0)\n                display(buckets[i].value,buckets[i].count);\n        }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server_file.0.c", "original_string": "error_t scpServerOpenFileForWriting(ScpServerSession *session,\n   const char_t *filename, uint32_t mode, uint64_t size)\n{\n   error_t error;\n   uint_t perm;\n   ScpServerContext *context;\n   context = session->context;\n   if(fsDirExists(session->path) || session->recursive)\n   {\n      pathCopy(context->path, session->path, SCP_SERVER_MAX_PATH_LEN);\n      pathCombine(context->path, filename, SCP_SERVER_MAX_PATH_LEN);\n      pathCanonicalize(context->path);\n   }\n   else\n   {\n      pathCopy(context->path, session->path, SCP_SERVER_MAX_PATH_LEN);\n   }\n   perm = scpServerGetFilePermissions(session, context->path);\n   if((perm & SCP_FILE_PERM_WRITE) != 0)\n   {\n      session->file = fsOpenFile(context->path, FS_FILE_MODE_WRITE |\n         FS_FILE_MODE_CREATE | FS_FILE_MODE_TRUNC);\n      if(session->file != NULL)\n      {\n         session->fileSize = size;\n         session->fileOffset = 0;\n         error = NO_ERROR;\n      }\n      else\n      {\n         error = ERROR_FILE_NOT_FOUND;\n      }\n   }\n   else\n   {\n      error = ERROR_ACCESS_DENIED;\n   }\n   return error;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_in_SLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    int count=0;\n    temp=head;\n    while(temp!=0)\n    {\n        count++;\n        temp=temp->next;\n    }\n    printf(\"the number of element in linked list is %d\", count);\n    printf(\"\\n\");\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_11.8.c", "original_string": "int main(int argc,char *argv[])\n{\n    char ch,temp;\n    char exp[10000];\n    FILE *fp1;\n    FILE *fp2;\n    fp1=fopen(\"input.txt\",\"r\");\n    fp2=fopen(\"output.txt\",\"w\");\n    while(1)\n         {\n            fscanf(fp1,\"%c\",&ch);\n            if(ch=='e')\n            {\n                fgetc(fp1);\n                fscanf(fp1,\"%[^\\n]\",exp);\n                infixToPostfix(exp);\n                fprintf(fp2,\"%s\\n\",exp);\n            }\n            else if(ch=='s')\n                break;\n        }\n    fclose(fp1);\n    fclose(fp2);\n    return 0;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__robo.0.c", "original_string": "void circulo()\n{\n  int i;\n  float angulo = 0.0;\n  glBegin(GL_POLYGON);\n  for (i = 0; i <= 6; i++)\n  {\n    angulo = 2 * M_PI * i / 6;\n    glVertex2f(0.04 * cos(angulo), 0.04 * sin(angulo));\n  }\n  glEnd();\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.10.c", "original_string": "void imprimir_menu_calificaciones(){\n    printf(\"1. Modificar calificaci\u00f3n 1:\\n\");\n    printf(\"2. Modificar calificaci\u00f3n 2:\\n\");\n    printf(\"3. Modificar calificaci\u00f3n 3:\\n\");\n    printf(\"4. Modificar calificaci\u00f3n f:\\n\");\n    printf(\"5. Salir:\\n\");\n    printf(\"Ingresa una opci\u00f3n:\");\n}"}
{"author": "Mr-JoE1", "file": "Play-with-C__check_prime_number.0.c", "original_string": "int main() {\nwhile(1){\n    int n, i, flag = 0;\n    printf(\"Enter a positive integer: \");\n    scanf(\"%d\", &n);\n    for (i = 2; i <= n / 2; ++i) {\n        if (n % i == 0) {\n            flag = 1;\n            break;\n        }\n    }\n    if (n == 1) {\n        printf(\"1 is neither prime nor composite.\");\n    }\n    else {\n        if (flag == 0)\n            printf(\"%d is a prime number.\\n\", n);\n        else\n            printf(\"%d is not a prime number.\\n\", n);\n    }\n    }\n}"}
{"author": "2security", "file": "Star__HalfDiamondStar.0.c", "original_string": "int main()\n    {\n    int n,i,j,k,f;\n    printf(\"Enter how many columns\");\n    scanf(\"%d\",&n);\n    f=1;\n    for(i=1;i<=2*n-1;i++)\n        {\n            for(j=1;j<=f;j++)   \n                printf(\"*\");\n            if(i<n)\n                f++;\n            else\n                f--;\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__ft_itoa_base.1.c", "original_string": "int     ft_len(int nb, int base)\n{\n    int     ctrl;\n    if (nb < 0)\n        nb *= -1;\n    ctrl = 0;\n    while(nb > 0)\n    {\n        nb /= base;\n        ctrl++;\n    }\n    return (ctrl);\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__main.0.c", "original_string": "int decToBin(int dec)\n{\n    float resto;\n    int numeriBinari[100], i = 0;\n    while(dec > 0)\n    {\n        numeriBinari[i] = dec % 2;\n        dec = dec/2;\n        i++;\n    }\n    for(int j = i-1; j>=0; j--)\n    {\n        printf(\"%d\",numeriBinari[j]);\n    }\n    return resto;\n}"}
{"author": "MartinMarinovich", "file": "MarinovichMartinLABIPP1G-__tipo0.2.c", "original_string": "int listarTipos(eTipo listaDetipos[], int tamanioTipos)\n{\n    int error = -1;\n    if(listaDetipos !=NULL && tamanioTipos>0)\n    {\n        system(\"cls\");\n        printf(\" ****  LISTADO DE TIPOS  ****\\n\");\n        printf(\"Id        Descripcion\\n\");\n        printf(\"----------------------------------\\n\");\n        for(int i = 0 ; i<tamanioTipos; i++)\n        {\n            mostrarTipo(listaDetipos[i]);\n        }\n        error = 0;\n    }\n    return error;\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_6.0.c", "original_string": "int main()\n{\n    int choice, value;\n    while(1)\n    {\n        printf(\"Double Linked List Operations : \\n\");\n        printf(\"1. Append\\n\");\n        printf(\"2. Add at Begin\\n\");\n        printf(\"3. Add at After\\n\");\n        printf(\"4. Display\\n\");\n        printf(\"5. Reverse\\n\");\n        printf(\"6. Delete\\n\");\n        printf(\"7. Delete Value\\n\");\n        printf(\"8. Delete List\\n\");\n        printf(\"9. Exit\\n\");\n        printf(\"Enter your choice : \");\n        scanf(\"%d\", &choice);\n        switch(choice)\n        {\n        case 1:\n            addend();\n            break;\n        case 2:\n            addbegin();\n            break;\n        case 3:\n            addafter();\n            break;\n        case 4:\n            display();\n            break;\n        case 5:\n            reverse();\n            break;\n        case 6:\n            del();\n            break;\n        case 7:\n            printf(\"Enter the value to delete : \");\n            scanf(\"%d\", &value);\n            delvalue(value);\n            printf(\"\\n\\n\");\n            break;\n        case 8:\n            dellist();\n            break;\n        case 9:\n            exit(0);\n            break;\n        default:\n            printf(\"Invalid Choice\\n\\n\");\n        }\n    }\n    return 0;\n}"}
{"author": "2security", "file": "Pointer__11MultiplicationTwoMatrix.0.c", "original_string": "void Display(int **mat3)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<n;j++)\n            printf(\"%-3d \",mat3[i][j]);\n        printf(\"\\n\");\n        }\n    }"}
{"author": "ankitraj311", "file": "Socket-thread__previous_program_with_thread3.2.c", "original_string": "int main()\n{\n  pthread_t thread_id, thread_id1;\n  pthread_create(&thread_id,NULL,myturn,NULL);  \n  pthread_create(&thread_id,NULL,yourturn,NULL);\n  pthread_join(thread_id,NULL);\n  pthread_join(thread_id,NULL);\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__logica-fuzzy.0.c", "original_string": "int main(void)\n{\n    float temp;\n    float frio, quente, normal;\n    printf(\"\\nInforme a temperatura do ambiente em graus celsius: \");\n    scanf(\"%f\", &temp);\n    if (temp <= 10)\n    {\n        frio = 1;\n        normal = 0;\n        quente = 0;\n    }\n    else if ((10 < temp) && (temp <= 11))\n    {\n        frio = 0.9;\n        normal = 0.1;\n        quente = 0;\n    }\n    else if ((11 < temp) && (temp <= 12))\n    {\n        frio = 0.8;\n        normal = 0.2;\n        quente = 0;\n    }\n    else if ((12 < temp) && (temp <= 13))\n    {\n        frio = 0.7;\n        normal = 0.3;\n        quente = 0;\n    }\n    else if ((13 < temp) && (temp <= 14))\n    {\n        frio = 0.6;\n        normal = 0.4;\n        quente = 0;\n    }\n    else if ((14 < temp) && (temp <= 15))\n    {\n        frio = 0.5;\n        normal = 0.5;\n        quente = 0;\n    }\n    else if ((15 < temp) && (temp <= 16))\n    {\n        frio = 0.5;\n        normal = 0.5;\n        quente = 0;\n    }\n    else if ((16 < temp) && (temp <= 17))\n    {\n        frio = 0.4;\n        normal = 0.6;\n        quente = 0;\n    }\n    else if ((17 < temp) && (temp <= 18))\n    {\n        frio = 0.3;\n        normal = 0.7;\n        quente = 0;\n    }\n    else if ((18 < temp) && (temp <= 19))\n    {\n        frio = 0.2;\n        normal = 0.8;\n        quente = 0;\n    }\n    else if ((19 < temp) && (temp <= 20))\n    {\n        frio = 0.1;\n        normal = 0.9;\n        quente = 0;\n    }\n    else if ((20 < temp) && (temp <= 25))\n    {\n        frio = 0;\n        normal = 1;\n        quente = 0;\n    }\n    else if ((25 < temp) && (temp <= 26))\n    {\n        frio = 0;\n        normal = 0.9;\n        quente = 0.1;\n    }\n    else if ((26 < temp) && (temp <= 27))\n    {\n        frio = 0;\n        normal = 0.8;\n        quente = 0.2;\n    }\n    else if ((27 < temp) && (temp <= 28))\n    {\n        frio = 0;\n        normal = 0.7;\n        quente = 0.3;\n    }\n    else if ((28 < temp) && (temp <= 29))\n    {\n        frio = 0;\n        normal = 0.6;\n        quente = 0.4;\n    }\n    else if ((29 < temp) && (temp <= 30))\n    {\n        frio = 0;\n        normal = 0.5;\n        quente = 0.5;\n    }\n    else if ((30 < temp) && (temp <= 31))\n    {\n        frio = 0;\n        normal = 0.5;\n        quente = 0.5;\n    }\n    else if ((31 < temp) && (temp <= 32))\n    {\n        frio = 0;\n        normal = 0.4;\n        quente = 0.6;\n    }\n    else if ((32 < temp) && (temp <= 33))\n    {\n        frio = 0;\n        normal = 0.3;\n        quente = 0.7;\n    }\n    else if ((33 < temp) && (temp <= 34))\n    {\n        frio = 0;\n        normal = 0.2;\n        quente = 0.8;\n    }\n    else if ((34 < temp) && (temp <= 35))\n    {\n        frio = 0;\n        normal = 0.1;\n        quente = 0.9;\n    }\n    else if (temp > 35)\n    {\n        frio = 0;\n        normal = 0;\n        quente = 1;\n    }\n    if ((frio > quente) && (normal != 1))\n    {\n        printf(\"\\nO aparelho est\u00e1 aquecendo com %.0f%% de pot\u00eancia\\n\\n\", frio * 100);\n    }\n    else if ((quente > frio) && (normal != 1))\n    {\n        printf(\"\\nO aparelho est\u00e1 resfriando com %.0f%% de pot\u00eancia\\n\\n\", quente * 100);\n    }\n    else if (normal == 1)\n    {\n        printf(\"\\nO aparelho est\u00e1 desligado\\n\\n\");\n    }\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc-a.3.c", "original_string": "void inorder(list *root) \n{ \n    if (root != NULL) \n    { \n        inorder(root->left); \n        printf(\"   %d \\n\", root->key); \n        inorder(root->right); \n    } \n}"}
{"author": "haon1026", "file": "linux-programming__sem_product_multconsumer.1.c", "original_string": "void *comsumer(void *arg)\n{\n    while(1)\n    {\n        sem_wait(&product_number);                 \n        printf(\"Comsume:%lu queue[%d]=%d\\n\", pthread_self(), i, queue[i]);           \n        queue[i] = 0;                                                 \n        sem_post(&blank_number);     \n        i = (i+1) % NUM;                                       \n        sleep(rand()%2);\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__double_insert_at_any_position.0.c", "original_string": "int main()\n{\n    int n, data;\n    head = NULL;\n    last = NULL;\n    printf(\"Enter the number of nodes you want to create: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    displayListFromFirst();\n    printf(\"Enter node position: \");\n    scanf(\"%d\", &n);\n    printf(\"Enter data you want to insert at %d position: \", n);\n    scanf(\"%d\", &data);\n    insertAtN(data, n);\n    displayListFromFirst();\n    return 0;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__21_While.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cos(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    while(i <= veces){\n        if(i%2 == 0)\n            Suma_total += (Exp(X, i*2) / Fac(i*2));\n        else\n            Suma_total -= (Exp(X, i*2) / Fac(i*2));\n        ++i;\n    }\n    printf(\"cos(%i) es igual a %lf\", X, (Suma_total + 1.0));\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CDLL.8.c", "original_string": "void delete_end()\n{\n    struct node *temp,*endnode;\n    temp=head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    endnode=temp;\n    temp->pre->next=head;\n    head->pre=endnode->pre;\n    free(endnode);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__BinHexConverter0.0.c", "original_string": "static inline char convertBinValueToHexDigit(uint8_t value, bool upperCase)\n{\n  char hexA = (upperCase) ? ('A') : ('a');\n  return ((char)((value < 10) ? ('0' + value) : (hexA + value - 10)));\n}"}
{"author": "dishanp", "file": "DSA__q1.0.c", "original_string": "int** readmatrix(int **A, int m, int n)\n{\n    A = (int**)malloc(m * sizeof(int*));\n    num = 0;\n    for(int i = 0 ; i < m ; i++)\n    {\n         A[i] = (int*)malloc(n * sizeof(int));\n    }\n    printf(\"Enter elements : \\n\");\n    for (int i = 0 ; i < m ; i++)\n    {\n        for (int j = 0 ; j < n ; j++)\n        {\n            scanf(\"%d\", &A[i][j]);\n            if(A[i][j] != 0)\n                num++;\n        }\n    }\n    return A;\n}"}
{"author": "2security", "file": "Matrix__33CheckLowerTriangularMatrix.0.c", "original_string": "int checkLowerTri(int mat[][20],int r)\n    {\n    int i,j;\n    for(i=0;i<r-1;i++) \n        {\n        for(j=1;j<r;j++) \n            {\n            if(i<j && mat[i][j]!=0)\n                {\n                return 0;\n                break;  \n                }           \n            }\n        }\n    return 1;\n    }"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client_archive.4.c", "original_string": "void recv_msg_handler()\n{\n    char message[LENGTH] = {};\n    while (1)\n    {\n        int receive = recv(sockfd, message, LENGTH, 0);\n        if (receive > 0)\n        {\n            printf(\"%s\", message);\n            str_overwrite_stdout();\n        }\n        else if (receive == 0)\n        {\n            break;\n        }\n        else\n        {\n        }\n        memset(message, 0, sizeof(message));\n    }\n}"}
{"author": "dishanp", "file": "DSA__q43.1.c", "original_string": "int main()\n{\n    int *arr;\n    int n, x, y, z;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n    for (int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n    ngerearrange(arr, n);\n    printf(\"Rearranged Array : \\n\");\n    for (int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d \", *(arr + i));\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__nonblock_timeout.0.c", "original_string": "int main()\n{\n    int fd = open(\"/dev/tty\", O_RDONLY|O_NONBLOCK);\n    if(fd < 0)\n    {\n        perror(\"open /dev/tty\");\n        exit(1);\n    }\n    printf(\"open /dev/tty ok, fd = %d\\n\", fd);\n    char buf[10];\n    int i, n;\n    for(i = 0; i < 5; i++)\n    {\n        n = read(fd, buf, 10);\n        if(n > 0)\n            break;\n        if(errno != EAGAIN)\n        {\n            perror(\"read /dev/tty\");\n            exit(1);\n        }\n        else\n        {\n            write(STDOUT_FILENO, MSG_TRY, strlen(MSG_TRY));\n            sleep(2);\n        }\n    }\n    if(i == 5)\n        write(STDOUT_FILENO, MSG_TIMEOUT, strlen(MSG_TIMEOUT));\n    else\n        write(STDOUT_FILENO, buf, n);\n    close(fd);\n    return 0;\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__restoring_three_numbers.0.c", "original_string": "int main(){\n  int x[4];\n  int a,b,c;\n  for(int i = 0; i < 4; i++)\n    scanf(\"%d\", &x[i]);\n  quicksort(x, 0, 3);\n  b = (x[2] - x[1] + x[0]) / 2;\n  a = x[2] - b;\n  c = x[0]- b;\n  printf(\"%d %d %d\\n\", a, b, c);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q14.0.c", "original_string": "void enqueue(queue *q,int n)\n{\n    if (q->rear==20)\n        printf(\"Queue Full\\n\");\n    else\n    {\n        int i,j,t;\n        q->c[(q->rear)++]=n;\n        for (i=0 ; i<q->rear-1 ; i++)                          \n            for (j=0 ; j<q->rear-i-1 ; j++)\n                if (q->c[j] < q->c[j+1])\n                {\n                    t=q->c[j];\n                    q->c[j]=q->c[j+1];\n                    q->c[j+1]=t;\n                }\n    }\n}"}
{"author": "ankitraj311", "file": "450_babbar__3_kth_small_SELF_MADE.0.c", "original_string": "void array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__stp_conditions.2.c", "original_string": "bool_t stpRootPort(StpBridgePort *port)\n{\n   bool_t res;\n   if(stpComparePortNum(port->portId, port->context->rootPort) == 0)\n   {\n      res = TRUE;\n   }\n   else\n   {\n      res = FALSE;\n   }\n   return res;\n}"}
{"author": "theuwis", "file": "AdventOfCode2016__main28.0.c", "original_string": "int main(){\n   for(int i = 0; i < NR_DISCS; i++){\n      for(int j = 0; j < i + 1; j++){\n         if(input[i][0] - 1 > input[i][2]){\n            input[i][2]++;\n         }\n         else{\n            input[i][2] = 0;\n         }\n      }\n   }\n   while(1){\n      for(int i = 0; i < NR_DISCS; i++){\n         if(input[i][0] - 1 > input[i][2]){\n            input[i][2]++;\n            not_zero = true;\n         }\n         else{\n            input[i][2] = 0;\n         }\n      }\n      if(!not_zero){\n         printf(\"answer=%d\\n\", time);\n         break;\n      }\n      else{\n         not_zero = false;\n      }\n      time++;\n   }\n   return EXIT_SUCCESS;\n}"}
{"author": "haon1026", "file": "linux-programming__pthread_shared_mutex.0.c", "original_string": "void *fun(void *arg)\n{\n    srand(time(NULL));\n    while (1)\n    {\n        pthread_mutex_lock(&mutex);     \n        printf(\"hello \");\n        sleep(rand()%3);    \n        printf(\"world\\n\");\n        pthread_mutex_unlock(&mutex);   \n        sleep(rand()%3);\n    }\n    return NULL;\n}"}
{"author": "dishanp", "file": "DSA__q41.0.c", "original_string": "int main()\n{\n    int arr[100];\n    int i, j, n, count = 0;\n    printf(\"Enter size of the array : \");\n    scanf(\"%d\", &n);\n    printf(\"Enter elements in array : \");\n    for(i=0; i<n; i++)\n    {\n        scanf(\"%d\", &arr[i]);\n    }\n    for(i=0; i<n; i++)\n    {\n        for(j=i+1; j<n; j++)\n        {\n            if(arr[i] == arr[j])\n            {\n                count++;\n                break;\n            }\n        }\n    }\n    printf(\"\\nTotal number of duplicate elements found in array = %d\", count);\n    return 0;\n}"}
{"author": "revathy16296", "file": "rtos_lab_asssignment_1__2_sum999.1.c", "original_string": "int sum_of_num(int array[],int n)\n{\n    int sum=0;\n    for(i=0;i<n;i++)\n    {\n        sum+=array[i];\n    }\n    return sum;\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__telephone.0.c", "original_string": "int main()\n{\n    FILE *fp;\n    struct tele cust[10];\n    struct tele temp;\n    int choice,limit,beg=0,i,j,c,count=0,pid;\n    while(1)\n    {\n        printf(\"\\ntelephone directory\\n\");\n        printf(\"1.add\\n\");\n        printf(\"2.display\\n\");\n        printf(\"3.exit\\n\");\n        printf(\"enter your choice\\n\");\n        scanf(\"%d\",&choice);\n        switch(choice)\n        {\n            case 1:\n            fp=fopen(\"details.txt\",\"w+\");\n                printf(\"enter the number of customers\\n\");\n                scanf(\"%d\",&limit);\n                for(i=beg;i<limit+beg;i++)\n                {\n                    printf(\"enter the name of customer no %d:\\t\",i+1);\n                    scanf(\"%s\",cust[i].name);\n                    printf(\"enter the sir name:\\t\");\n                    scanf(\"%s\",cust[i].sir_name);\n                    printf(\"enter the phone number\\t\");\n                    scanf(\"%s\",cust[i].number);\n                }\n                beg=limit+beg;\n                for(i=0;i<beg;i++)\n                {\n                    for(j=0;j<beg-1;j++)\n                    {\n                        c=strcmp(cust[j].name,cust[j+1].name);\n                        if(c>0)\n                        {\n                            temp=cust[j];\n                            cust[j]=cust[j+1];\n                            cust[j+1]=temp;\n                    }}\n                }\n                fclose(fp);\n                break;\n            case 2:\n            pid=fork();\n            if(pid==0)\n            {\n                printf(\"entered in to the child  process!\\n\");\n            FILE *fp;\n                printf(\"\\ncustomer details\\n\");\n                fp=fopen(\"details.txt\",\"r\");\n                if(fp==NULL)\n                {\n                    printf(\"error!\");\n                    exit(1);\n                }\n                for (i=0;i<beg;i++)\n                {\n                    fread(&cust,sizeof(struct tele),1,fp);\n                    printf(\"(%d) %s %s\\t :%s\\n\",i+1,cust[i].name,cust[i].sir_name,cust[i].number);\n                }\n                fclose(fp);\n            }\n            else\n            {\n            wait(NULL);\n            exit(0);\n            }\n            break;\n            case 3:\n                exit(0);\n        }\n    }\n    return 0;\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_atoi.0.c", "original_string": "int potencia(int numero, int exponente){\n    int resultado = 1;\n    if(exponente == 0)\n        return 1;\n    else{\n        for(int i = 1; i <= exponente; i++) resultado *= numero;\n        return resultado;\n    }\n }"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedInsertion.3.c", "original_string": "struct Node * insertAtEnd(struct Node *head, int data){\n     struct Node * ptr = (struct Node *) malloc(sizeof(struct Node));\n     ptr->data = data;\n     struct Node * p = head; \n     while (p->next != NULL)\n     {\n         p = p->next;  \n     }\n     p->next =ptr;\n     ptr->next= NULL;\n     return head;\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_print_combn.7.c", "original_string": "void comb6(int *numeros,int a,int b,int c, int d,int e,int f)\n{\n  while(a<=4)\n       {\n          while(b<=5)\n              {\n                  while(c<=6)\n                      {\n                        while(d<=7)\n                            {\n                              while(e<=8)\n                                   {\n                                    while(f<=9)\n                                        {\n                                          printf(\"%i%i%i%i%i%i, \",numeros[a],numeros[b],numeros[c],numeros[d],numeros[e],numeros[f]);\n                                          f=f+1;\n                                        }\n                                    e=e+1;\n                                    f=e+1;\n                                   }\n                              d=d+1;\n                              e=d+1;\n                              f=e+1;\n                            }\n                        c=c+1;\n                        d=c+1;\n                        e=d+1;\n                        f=e+1;\n                      } \n                  b=b+1;\n                  c=b+1;\n                  d=c+1;\n                  e=d+1;\n                  f=e+1;\n              }\n          a=a+1;\n          b=a+1;\n          c=b+1;\n          d=c+1;\n          e=d+1;\n          f=e+1;\n      }\n}"}
{"author": "earth429", "file": "mulpre__mulprec.12.c", "original_string": "int setSign(struct NUMBER *a, int s) {\n    if(s == 1){\n        a->sign = 1;\n    } else if(s == -1){\n        a->sign = -1;\n    } else {\n        return -1;\n    }\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__bfs-a.0.c", "original_string": "void input(gph* g){\n    int i,j,f,x=1;\n    while(x){\n        printf(\"\\nEnter the number of vertices: \");\n        scanf(\"%d\",&g->n);\n        if(g->n>0)\n            x=0;\n        else\n            printf(\"Invalid input.\\n\");\n    }\n    g->mat=(int**) malloc(sizeof(int*)*g->n);\n    for(i=0;i<g->n;i++)\n        g->mat[i]=(int*)malloc(sizeof(int)*g->n);\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++)\n            g->mat[i][j]=-1;\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++){\n            if(g->mat[i][j]==1 || g->mat[i][j]==0)\n                continue;\n            if(i==j){\n                g->mat[i][j]=0;\n                continue;\n            }\n            x=1;\n            while(x){\n                printf(\"Is there an edge between %c and %c (Yes=1 & No=0): \",'A'+i,'A'+j);\n                scanf(\"%d\",&f);\n                if(f==0 || f==1){\n                    g->mat[i][j]=f;\n                    g->mat[j][i]=f;\n                    x=0;\n                }\n                else\n                    printf(\"Invalid input.\\n\");\n            }\n        }\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b1.4.c", "original_string": "int main() {\n    char *filename = \"Trees.txt\";\n    size_t n = num_rows(filename);\n    size_t m = num_cols(filename);\n    bool **trees = get_trees(filename, n, m);\n    size_t count = 1;\n    count *= encountered(trees, n, m, 1, 1);\n    count *= encountered(trees, n, m, 1, 3);\n    count *= encountered(trees, n, m, 1, 5);\n    count *= encountered(trees, n, m, 1, 7);\n    count *= encountered(trees, n, m, 2, 1);\n    printf(\"Answer: %zu\\n\", count);\n    for (size_t i = 0; i < n; i++)\n        free(trees[i]);\n    free(trees);\n    return 0;\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_5.0.c", "original_string": "int main()\n{\n    int choice, value;\n    while(1)\n    {\n        printf(\"Single Linked List Operations : \\n\");\n        printf(\"1. Add at End\\n\");\n        printf(\"2. Add at Begin\\n\");\n        printf(\"3. Add at After\\n\");\n        printf(\"4. Display\\n\");\n        printf(\"5. Delete\\n\");\n        printf(\"6. Delete Value\\n\");\n        printf(\"7. Delete List\\n\");\n        printf(\"8. Quit\\n\");\n        printf(\"Enter your choice : \");\n        scanf(\"%d\", &choice);\n        switch(choice)\n        {\n        case 1:\n            addend();\n            break;\n        case 2:\n            addbegin();\n            break;\n        case 3:\n            addafter();\n            break;\n        case 4:\n            display();\n            break;\n        case 5:\n            del();\n            break;\n        case 6:\n            printf(\"Enter the value to delete : \");\n            scanf(\"%d\", &value);\n            delval(value);\n            break;\n        case 7:\n            dellist();\n            break;\n        case 8:\n            exit(0);\n            break;\n        default:\n            printf(\"Invalid Entry\\n\");\n        }\n    }\n    return 0;\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__103-merge_sort.1.c", "original_string": "void TopDownSplitMerge(int *copy, int begin, int end, int *array)\n{\n    int middle;\n    if (end - begin <= 1)\n        return;\n    middle = (end + begin) / 2;\n    TopDownSplitMerge(array, begin, middle, copy);\n    TopDownSplitMerge(array, middle, end, copy);\n    TopDownMerge(copy, begin, middle, end, array);\n}"}
{"author": "sdukesameer", "file": "dsa__bfs.4.c", "original_string": "void bfs(graph g, int s){\n    queue q;\n    initialiseQueue(&q,g.n);\n    int visited[g.n],i,f;\n    for(i=0;i<g.n;i++)\n        visited[i]=0;\n    visited[s]=1;\n    enqueue(&q,s);\n    printf(\"\\nFollowing is the BFS Traversal (starting from %c): \\n\",'A'+s);\n    while(q.end!=-1){\n        f=dequeue(&q);\n        printf(\"%c\\t\",'A'+f);\n        for (i = 0; i < g.n; i++)\n            if(g.arr[f][i])\n                if(!visited[i]){\n                    visited[i]=1;\n                    enqueue(&q,i);\n                }\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__main.0.c", "original_string": "int main(int argc, char* argv[]) {\n    if(argc < 2) {\n        eprintf(\"Usage: %s {input file(s)}\\n\", argv[0]);\n        return 1;\n    }\n    FILELIST* files = getfiles(argv[1]);\n    FILELIST* curr = files->next;\n    COMPILEUNIT* head = (COMPILEUNIT*)malloc(sizeof(COMPILEUNIT));\n    head->file = files;\n    head->parser = mkparser(tokenize(files->fullname), files->name);\n    COMPILEUNIT* currunit = head;\n    while(curr != NULL) {\n        COMPILEUNIT* newunit = (COMPILEUNIT*)malloc(sizeof(COMPILEUNIT));\n        newunit->file = curr;\n        newunit->parser = mkparser(tokenize(curr->fullname), curr->name);\n        currunit->next = newunit;\n        currunit = newunit;\n        curr = curr->next;\n    }\n    currunit->next = NULL;\n    actonunits(head, parseunit);\n    CLASS* headclass = head->parsed;\n    CLASS* currclass = headclass;\n    currunit = head->next;\n    while(currunit != NULL) {\n        currclass->next = currunit->parsed;\n        currclass = currunit->parsed;\n        currunit = currunit->next;\n    }\n    currclass->next = NULL;\n    COMPILER* compiler = mkcompiler(headclass);\n    currunit = head;\n    while(currunit != NULL) {\n        currunit->compiler = compiler;\n        currunit = currunit->next;\n    }\n    actonunits(head, compileunit);\n    actonunits(head, vmtranslateunit);\n    ASMBLK* asmlns = head->asmlns;\n    currunit = head->next;\n    while(currunit != NULL) {\n        mergeasmblks(asmlns, currunit->asmlns);\n        currunit = currunit->next;\n    }\n    ASSEMBLER* assembler = mkassembler(asmlns->head);\n    preprocess(assembler);\n    assemble(assembler);\n    char* outname = getouthack(argv[1]);\n    FILE* output = fopen(outname, \"w\");\n    if(output == NULL) {\n        eprintf(\"%s\", strerror(errno));\n        exit(1);\n    }\n    printstrlist(asmlns->head, output);\n    free(asmlns);\n    fclose(output);\n    free(outname);\n    currunit = head;\n    while(currunit != NULL) {\n        COMPILEUNIT* next = currunit->next;\n        freeunit(currunit);\n        currunit = next;\n    }\n    freecompiler(compiler);\n    freeassembler(assembler);\n    freetree(headclass);\n    freefilelist(files);\n    return 0;\n}"}
{"author": "0712023", "file": "Basis-and-Practice-in-Programming_SKKU__5_even_out.3.c", "original_string": "int func(int number){\n    if (len(number) >0){\n      a+=number%10*power(10, i);\n      number = number/100;\n      i++;\n      func(number);\n    } else {\n      return 0;\n    }\n  }"}
{"author": "sdukesameer", "file": "dsa__Md_Sameer_13000119114.12.c", "original_string": "void display(stack* stk){\n    if(stk->top==-1)\n        printf(\"STACK EMPTY\\n\");\n    else{\n        printf(\"  STACK\\n\");\n        for(int i=stk->top; i>=0; i--)\n            printf(\"    %d\\n\",stk->arr[i]);\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__util.4.c", "original_string": "char* itoa(int i) {\n    int size = sizeof(char)*(countplaces(i)+1);\n    char* a = (char*)malloc(size);\n    sprintf(a, \"%i\", i);\n    return a;\n}"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__texture_errors.0.c", "original_string": "void    texture_error(int error)\n{\n    if (error == 0)\n        ft_putstr(\"Error\\ndouble inclusion\\n\");\n    else if (error == 1)\n        ft_putstr(\"Error:\\nWrong number of params/invalid file in NO!\\n\");\n    else if (error == 2)\n        ft_putstr(\"Error:\\nWrong number of params/invalid file in SO!\\n\");\n    else if (error == 3)\n        ft_putstr(\"Error:\\nWrong number of params/invalid file in WE!\\n\");\n    else if (error == 4)\n        ft_putstr(\"Error:\\nWrong number of params/invalid file in EA!\\n\");\n    else if (error == 5)\n        ft_putstr(\"Error:\\nWrong number of params/invalid file in S!\\n\");\n    exit(0);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__count_the_elem_in_CLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the list is %d\\n\",c);\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_5.4.c", "original_string": "void display()\n{\n    struct node* temp;\n    temp = root;\n    if(temp == NULL)\n    {\n        printf(\"List is Empty\\n\");\n    }\n    else\n    {\n        while(temp != NULL)\n        {\n            printf(\"%d-->\", temp->data);\n            temp = temp->link;\n        }\n        printf(\"\\n\\n\");\n    }\n}"}
{"author": "2security", "file": "Matrix__26Multiplication.0.c", "original_string": "void displayMat(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%-3d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }"}
{"author": "seefeesaw", "file": "Recursion__horners_rule.1.c", "original_string": "double e1(int x,int n)\n{\n    static double s = 1;\n    if(n == 0)\n    {\n        return s;\n    }\n    s = 1+s*x/n;\n    return e1(x,n-1);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__G.0.c", "original_string": "int main ()\n{\n    long int num, primo = true, i = 3;\n    scanf (\"%li\", &num);\n    if (num == 1)\n    {\n        printf (\"Composto!\\n\");\n    }\n    else if (num == 2)\n    {\n        printf (\"Primo!\\n\");\n    }\n    else if ((num % 2) == 0)\n    {\n        printf (\"Composto!\\n\");\n    }\n    else\n    { \n        while (((i*i) <= num)&&(primo == true))\n        {\n            if ((num % i) == 0)\n            {\n                primo = false;\n            }\n            i += 2;\n        }\n        if (primo == true)\n        {\n            printf (\"Primo!\\n\");\n        }\n        else\n        {\n            printf (\"Composto!\\n\");\n        }\n    }\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__Main.1.c", "original_string": "static char *dirname(char *path)\n{\n  char *lastSeparator = strrchr(path, '\\\\');\n  if (lastSeparator != NULL) \n  {\n    *lastSeparator = '\\0';\n    return path;\n  }\n  else\n  {\n    *path = '\\0';\n  }\n  return path;\n}"}
{"author": "augustogunsch", "file": "jackc__tokenizer.12.c", "original_string": "TOKENTYPE gettokentype(STRING* tk, char* file, int definedat) {\n    if(iskeyword(tk)) return keyword;\n    if(issymbol(tk)) return symbol;\n    if(isintcons(tk)) return integer;\n    if(isidentifier(tk)) return identifier;\n    eprintf(\"Unexpected token '%s'; file '%s', line %i\\n\", tk->str, file, definedat);\n    exit(1);\n}"}
{"author": "mehedi9021", "file": "Data_Structure__insert_value_at_doule_linked_list.0.c", "original_string": "int main()\n{\n    int n, data;\n    head = NULL;\n    printf(\"Enter the total number of nodes in list: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    displayList();\n    printf(\"Enter node position: \");\n    scanf(\"%d\", &n);\n    printf(\"Enter data you want to insert at %d position: \", n);\n    insertAtN(data, n);\n    displayList();\n    return 0;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica2-2.1.c", "original_string": "void * cuentaLineas(void * fichero){\n    printf(\"contando el fichero: %s\\n\", fichero);\n    int * nLineas = malloc(sizeof(int)); \n    FILE * f = fopen(fichero, \"r\"); \n    *nLineas = 0; \n    char s[200]; \n    while(fgets(s, 200, f)){ *nLineas = *nLineas + 1; } \n    pthread_exit((void *) nLineas); \n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__check_enemy.0.c", "original_string": "static void p(t_m *m, int x, int y)\n{\n    int att_x;\n    int att_y;\n    att_x = x - 1;\n    att_y = y - 1;\n    if (is_in_range(m, att_x, att_y) && is_king(m, att_x, att_y))\n        m->mate = 1;\n    att_x = x + 1;\n    att_y = y - 1;\n    if (is_in_range(m, att_x, att_y) && is_king(m, att_x, att_y))\n        m->mate = 1;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post-a.3.c", "original_string": "void inorder(list *root) \n{ \n    if (root != NULL) \n    { \n        inorder(root->left); \n        printf(\"%d \\n\", root->key); \n        inorder(root->right); \n    } \n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_pos_DCLL.4.c", "original_string": "void delete_at_pos()\n{\n    struct node *temp;\n    temp=head;\n    int i=1;\n    int pos;\n    int leg=count();\n    printf(\"enter the position in between the 1 to %d\\n\",leg);\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    while(i<pos)\n    {\n        temp=temp->next;\n        i++;\n    }\n    temp->pre->next=temp->next;\n    temp->next->pre=temp->pre;\n    free(temp);\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Single.0.c", "original_string": "int isthere(char name)\n{\n    int flag=-1;\n    temp=start;\n    while(temp!=NULL)\n    {\n        if(temp->file==name)\n        {\n            flag=1;\n            break;\n        }\n        temp=temp->next;\n    }\n    return(flag);\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__FIFO.1.c", "original_string": "int isthere(int page)\n{\n    int flag=-1;\n    for(j=0;j<3;j++)\n    {\n        if(Queue[j]==page)\n        {\n            flag=1;\n            break;\n        }\n    }\n    return(flag);\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.11.c", "original_string": "SUBROUTDEC* getfunction(SCOPE* s, SUBROUTCALL* call) {\n    CLASS* c = getclass(s, call->parentname);\n    if(c == NULL)\n        notdeclared(call->parentname, call->debug);\n    SUBROUTDEC* d = getsubroutdecfromlist(c->subroutdecs, call->name);\n    if(d == NULL)\n        return NULL;\n    if(d->subroutclass == method) {\n        eprintf(\"Calling a method as if it were a function; file '%s', line %i\\n\", call->debug->file, call->debug->definedat);\n        exit(1);\n    }\n    return d;\n}"}
{"author": "jose120918", "file": "binary_trees__15-binary_tree_is_full.3.c", "original_string": "int binary_tree_is_full(const binary_tree_t *tree)\n{\n    int _inodes = 0, _nodes = 0, _leaves = 0;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    _nodes = tree_size(tree);\n    _leaves = count_leaves(tree);\n    _inodes = internal_nodes(tree);\n    if (_inodes > 0)\n    {\n        if (_leaves != _inodes + 1)\n        {\n            return (0);\n        }\n        if (_nodes != 2 * _inodes + 1)\n        {\n            return (0);\n        }\n    }\n    if (_inodes != (_nodes - 1) / 2)\n    {\n        return (0);\n    }\n    if (_leaves != (_nodes + 1) / 2)\n    {\n        return (0);\n    }\n    if (_nodes != 2 * _leaves - 1)\n    {\n        return (0);\n    }\n    if (_inodes != _leaves - 1)\n    {\n        return (0);\n    }\n    return (1);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLL.3.c", "original_string": "nptr deleteLeft(nptr head)\n{\n    if(head == NULL)\n        return head;\n    if(head -> left == NULL && head -> right == NULL)\n    {\n        printf(\"%d deleted\\n\", head -> data);\n        free(head);\n        return NULL;\n    }\n    nptr temp = head;\n    head = head -> right;\n    head -> left = NULL;\n    printf(\"%d deleted\\n\", temp -> data);\n    free(temp);\n    return head;\n}"}
{"author": "earth429", "file": "mulpre__mulprec.8.c", "original_string": "int divBy10(struct NUMBER *a, struct NUMBER *b){\n    int i;\n    int remainder; \n    clearByZero(b);\n    setSign(b, getSign(a)); \n    remainder = getSign(a) * a->n[0]; \n    for (i = 1; i <= KETA - 2;i++){\n        b->n[i - 1] = a->n[i];\n    }\n    b->n[KETA - 1] = 0;\n    return remainder;\n}"}
{"author": "Oryx-Embedded", "file": "Common__cpu_endian.5.c", "original_string": "uint16_t reverseInt16(uint16_t value)\n{\n   value = ((value & 0xFF00) >> 8) | ((value & 0x00FF) << 8);\n   value = ((value & 0xF0F0) >> 4) | ((value & 0x0F0F) << 4);\n   value = ((value & 0xCCCC) >> 2) | ((value & 0x3333) << 2);\n   value = ((value & 0xAAAA) >> 1) | ((value & 0x5555) << 1);\n   return value;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__26_remove_repeatation_in_array.0.c", "original_string": "int main()\n{\n  int i=0,j=0,k=0, no=0,insert_no=0,insert_index=0,flag=0,count = 0i, count2 = 0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n  int array1[no-1], array2[no-1];\n  count = no;\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    for(j=i+1; j<no;)\n    {\n      if(array1[i] == array1[j])\n      {\n        for(k=j; k<count; k++)\n    {\n          array1[k] = array1[k+1];\n    }\n    no--;\n      }\n      else\n      {\n        j++;\n      }\n    }  \n  }\n  printf(\"Value of count is %d and count2 is %d\",count,count2);\n  printf(\"Array after Removal of Repetation\\n\");\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n}"}
{"author": "ankitraj311", "file": "450_babbar__6_union_array_Geek_usorted_array.1.c", "original_string": "int ispresent(int arr1[], int size_arr1, int arr2[], int index_val) \n{\n  for(int i = 0; i<size_arr1; i++)\n  {\n    if(arr1[i] == arr2[index_val])\n    {\n      return 1;\n    }\n  }\n  return 0;\n}"}
{"author": "MartinMarinovich", "file": "ParcialLaboratorio1GCompleto__menu.0.c", "original_string": "int menu (int *opcionMenu)\n{\n    int error = -1;\n    int opcion;\n    if(opcionMenu != NULL)\n    {\n        printf(\"*** ABM Service de Notebooks ***\\n\\n\");\n        printf(\"1  Alta Notebook\\n\");\n        printf(\"2  Modificar Notebook\\n\");\n        printf(\"3  Baja Notebook\\n\");\n        printf(\"4  Listar Notebook\\n\");\n        printf(\"5  Listar Marcas\\n\");\n        printf(\"6  Listar Tipos\\n\");\n        printf(\"7  Listar Servicios\\n\");\n        printf(\"8  Alta Trabajo\\n\");\n        printf(\"9  Listar Trabajos\\n\");\n        printf(\"10 Listar x Tipo\\n\");\n        printf(\"11 Listar x Marca\\n\");\n        printf(\"12 Contar x Marca y Tipo\\n\");\n        printf(\"13 Listar Notebooks separadas x cada Marca\\n\");\n        printf(\"14 Mostrar Marcas mas elegidas \\n\");\n        printf(\"15 Mostrar Notebooks mas baratas \\n\");\n        printf(\"16 Listar trabajos por ID notebook\\n\");\n        printf(\"17 Listar total a pagar por ID notebook\\n\");\n        printf(\"18 Mostrar Notebooks por Servicio\\n\");\n        printf(\"19 Mostrar servicio por fecha\\n\");\n        printf(\"20 Salir\\n\");\n        if(!utn_getNumeroInt(&opcion,\"\\nIngrese la opcion deseada\\n\",\"Error, opcion invalida\\n\",1,20, 4))\n        {\n            *opcionMenu = opcion;\n        }\n        error = 0;\n    }\n    return error;\n}"}
{"author": "SugumaranEvil", "file": "Linux_programming__flock.0.c", "original_string": "int main()\n{\n    int file_des;\n    ssize_t wt,rd;\n    char arr[]=\"sugukavi\";\n    char buf[10];\n    file_des = open(\"./text\",O_CREAT | O_RDWR,0644);\n    perror(\"open\");              \n    wt = write(file_des,arr,8);  \n    perror(\"write\");\n    flock(file_des,LOCK_EX | LOCK_NB);\n    perror(\"flock\");\n    sleep(10);                   \n    rd = read(file_des,buf,8);   \n    perror(\"read\");\n    close(file_des);             \n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client3.2.c", "original_string": "void send_recv(int i, int sockfd, char name[32], fd_set* master)\n{\n    char in_buf[BUFSIZE];\n    char send_buf[BUFSIZE+32]=\"\";\n    char recv_buf[BUFSIZE];\n    char disconnect_mssge[32];\n    int nbyte_recvd;\n    if (i == 0)\n    {\n        fgets(in_buf, BUFSIZE, stdin);\n        str_trim_lf(in_buf, BUFSIZE);\n        sprintf(send_buf, \"%s > %s\", name, in_buf);\n        if (strncmp(in_buf,\"tata\", 4) == 0)\n        {\n            sprintf(disconnect_mssge,\"%s left the chat.\", name);\n            send(sockfd, disconnect_mssge, strlen(disconnect_mssge), 0);\n            FD_CLR(i, master);\n            close(i);\n            close(sockfd);\n            exit(0);\n        }\n        else\n            send(sockfd, send_buf, strlen(send_buf), 0);\n        bzero(send_buf, BUFSIZE);\n    }\n    else\n    {\n        nbyte_recvd = recv(sockfd, recv_buf, BUFSIZE, 0);\n        recv_buf[nbyte_recvd] = '\\0';\n        printf(\"%s\\n\", recv_buf);\n    }\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client_thread.4.c", "original_string": "void str_trim_lf(char *arr, int length) {\n    int i;\n    for (i = 0; i < length; i++)\n    {\n        if (arr[i] == '\\n')\n        {\n            arr[i] = '\\0';\n            break;\n        }\n    }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__dequeue1.1.c", "original_string": "void enqueueR(int val)\n{\n    if(front==-1 && rear==-1)\n    {\n        front=front+1;\n        rear=rear+1;\n        queue[rear]=val;\n    }\n    if(rear==MAX-1)\n    printf(\"queue is full\");\n    else\n    {\n        rear=rear+1;\n        queue[rear]=val;\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q3.6.c", "original_string": "float calcu(node *root)\n{\n    node* curr;\n    curr = root;\n    STACK s;\n    STACKs expression;\n    s.tos = -1;\n    expression.tos = -1;\n    char m;\n    float p, q;\n    do\n    {\n        while (curr != NULL)\n        {\n            if (curr->right != NULL)\n                push(&s, curr->right);\n            push(&s, curr);\n            curr = curr->left;\n        }\n        curr = pop(&s);\n        if (curr->right != NULL && s.s[s.tos] == curr->right)\n        {\n            pop(&s);\n            push(&s, curr);\n            curr = curr->right;\n        }\n        else\n        {\n            m = curr->data;\n            switch (m)\n            {\n                case '*':   pushs(&expression, pops(&expression)*pops(&expression));\n                            break;\n                case '/':   pushs(&expression, pops(&expression) / pops(&expression));\n                            break;\n                case '-':   pushs(&expression, pops(&expression) - pops(&expression));\n                            break;\n                case '+':   pushs(&expression, pops(&expression) + pops(&expression));\n                            break;\n                case '$':   p = pops(&expression);\n                            q = pops(&expression);\n                            pushs(&expression, pow(p, q));\n                            break;\n                default:    pushs(&expression, (float)(m - '0'));\n                            break;\n            }\n            curr = NULL;\n        }\n    }while (s.tos != -1);\n    return expression.a[0];\n}"}
{"author": "haon1026", "file": "linux-programming__pipe_brother.1.c", "original_string": "int main()\n{\n    int fd[2];\n    int ret = pipe(fd);\n    if(ret == -1)\n        sys_error(\"pipe error\");\n    int i;\n    for(i = 0; i < 2; i++)\n    {\n        pid_t pid = fork();\n        if(pid == -1)\n            sys_error(\"fork error\");\n        else if(pid == 0)\n            break;\n    }\n    if(i == 2)\n    {\n        wait(NULL);\n        wait(NULL);\n    }\n    else if (i == 0)\n    {\n        close(fd[0]);\n        dup2(fd[1], STDOUT_FILENO);\n        execlp(\"ls\", \"ls\", NULL);\n        sys_error(\"execlp ls error\");\n    }\n    else if (i == 1)\n    {\n        close(fd[1]);\n        dup2(fd[0], STDIN_FILENO);\n        execlp(\"wc\", \"wc\", \"-l\", NULL);\n        sys_error(\"execlp wc error\");\n    }\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Indexed.3.c", "original_string": "void display()\n{\n    int i,j;\n    printf(\"\\nDisk is : \"); \n    for(i=1;i<16;i++)\n    {\n        printf(\"\\t%d\",disk[i]);\n    }\n    printf(\"\\nd_array is : \");\n    for(i=0;i<pos;i++)\n    {\n        if(d_array[i][0]!=0)\n        {\n            printf(\"\\n%d\",d_array[i][0]);\n            for(j=1;j<16;j++)   \n            {\n                if(d_array[i][j]!=0)\n                    printf(\"\\t%d\",d_array[i][j]);\n                else\n                    break;\n            }\n        }\n    }\n}"}
{"author": "kalpa96", "file": "Struct__even.0.c", "original_string": "int main() {\n    int i;\n    printf(\"Enter information of students:\\n\");\n    for (i=0;i<11;++i) {\n        s[i].no = i+1;\n        printf(\"\\nStudent 0%d\\n\", s[i].no);\n        printf(\"Enter ID number : \");\n        scanf(\"%d\",&s[i].id);\n        printf(\"Enter name : \");\n        scanf(\"%s\",&s[i].name);\n        printf(\"Enter age : \");\n        scanf(\"%d\",&s[i].age);\n        printf(\"Enter address : \");\n        scanf(\"%s\",&s[i].address);\n        printf(\"Enter marks : \");\n        scanf(\"%f\",&s[i].marks);\n    }\n    printf(\"\\nDisplaying Information:\\n\");\n    for (i=0;i<11;i++){\n        if(s[i].id%2==0){\n            printf(\"Name : \");\n            puts(s[i].name);\n        }\n    }\n    return 0;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__card_dos.0.c", "original_string": "int main(){\n    const char *suit[4] = {\"Hearts\", \"Diamons\", \"Clubs\", \"Spades\"};\n    const char *face[13] = {\"Ace\", \"Deuce\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\n     \"Nine\", \"Ten\", \"Jack\", \"Queen\", \"King\" };\n    int deck[4][13] = {0};\n    srand(time (NULL));\n    suffle(deck);\n    deal(deck, face, suit);\n    return 0;\n}"}
{"author": "dle2005", "file": "Algorithm__N_Queens.1.c", "original_string": "void queens(int i) {\n    for(int j = 1; j <= n; j++)\n        printf(\"%d \", col[j]);\n    printf(\"\\n\");\n    if(promising(i)) {\n        if(i == n) {\n            printf(\"\\nSolution = \");\n            for(int j = 1; j <= n; j++)\n                printf(\"%d \", col[j]);\n            printf(\"\\n\");\n            exit(1);\n        }\n        else {\n            for(int j = 1; j <= n; j++) {\n                col[i+1] = j;\n                queens(i+1);\n            }\n        }\n    }\n}"}
{"author": "behergue", "file": "Operating_Systems__my_system.0.c", "original_string": "int main(int argc, char* argv[])\n{\n    if (argc!=2){\n        fprintf(stderr, \"Usage: %s <command>\\n\", argv[0]);\n        exit(1);\n    }\n    return system(argv[1]);\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b1.1.c", "original_string": "size_t num_cols(char *filename) {\n    size_t m = 0;\n    FILE *f = fopen(filename, \"r\");\n    for (char c = fgetc(f); c != '\\n'; c = fgetc(f))\n        m++;\n    fclose(f);\n    return m;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__nonVIC.6.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}"}
{"author": "ankitraj311", "file": "450_babbar__4_0_1_2_array_GEEk.2.c", "original_string": "int sort(int arr[], int size)\n{\n  int low,mid,high;\n  low = mid = 0;\n  high = (size-1);\n  while(mid<=high)\n  {\n    switch (arr[mid]) \n    { \n      case 0: \n          swap(&arr[low++], &arr[mid++]); \n          break; \n      case 1: \n          mid++; \n          break; \n      case 2: \n          swap(&arr[mid], &arr[high--]); \n          break;\n    }\n  }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__infixToPostfix.4.c", "original_string": "char pop(struct stack*ptr){\n    if(isEmpty(ptr)){\n        printf(\"Stack Underflow! Cannot pop from the stack\\n\");\n        return -1;\n    }\n    else{\n        int val = ptr->arr[ptr->top];\n        ptr->top--;\n        return val;\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__merg_sort.3.c", "original_string": "int main(void) {\n    printf(\"sorting the elements in the array \\n\"); \n    printf(\"merge sort \\n\");\n    int a[10]={45,78,96,12,63,80,69,71,85,11};\n    int n=10;\n    printf(\"the elements in the array are :\\n \");\n    printarray(a,n);\n    printf(\"\\n after sorting elements in the array are :\\n\");\n    mergesort(a,0,n-1);\n    printarray(a,n);\n    return EXIT_SUCCESS;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_02.1.c", "original_string": "int* read(int n)\n{\n        int i;\n        int s = sizeof(int);\n        int* arr1= (int*)malloc(s * n);\n        for(i = 0; i<n; i++)\n        {\n                fscanf(F1, \"%d\", (arr1+i));\n        }\n        return arr1;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BST.3.c", "original_string": "struct tree* search(struct tree* root,int tar)\n{\n    if(root!=NULL)\n    {\n        if(tar<root->val)\n        root->left=search(root->left,tar);\n        else if(tar>root->val)\n        root->right=search(root->right,tar);\n        else if(tar==root->val)\n        {\n            printf(\"\\nElement found\");\n            return(root);\n        }       \n    }\n    else\n    {\n        printf(\"\\neither tree is empty or element not found\");\n        return(root);\n    }\n}"}
{"author": "2security", "file": "Pointer__11MultiplicationTwoMatrix.1.c", "original_string": "int **Product(int **mat1,int **mat2,int **mat3)\n    {\n    int i,j,k;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<n;j++)\n                {\n                mat3[i][j]=0;\n                for(k=0;k<c;k++)\n                    mat3[i][j]+=mat1[i][k]*mat2[k][j];\n                }\n        }\n    return mat3;\n    }"}
{"author": "haon1026", "file": "linux-programming__loop_create_pthread.2.c", "original_string": "int main()\n{\n    int i;\n    int ret;\n    pthread_t tid;\n    for(i = 0; i < 5; i++)\n    {\n        ret = pthread_create(&tid, NULL, thread_fun, (void*)i);     \n        if(ret != 0)\n            sys_err(\"pthread_create error\");\n    }\n    sleep(i);\n    printf(\"I'm main thread:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n    return 0;    \n}"}
{"author": "dle2005", "file": "Algorithm__Sum_of_Subsets_v2.0.c", "original_string": "bool promising(int i, int weight, int total) {\n    if(! ((weight + total >= W) && (weight == W || weight + w[i+1] <= W))) {\n        if(weight + total >= W) printf(\"weight + total >= W\\n\");\n        else if(weight == W || weight + w[i+1] <= W) {\n            if (!(weight + w[i+1] <= W)) printf(\"weight + w[i+1] <= W\\n\");\n            else if(!(weight == W)) printf(\"weight == W\\n\");\n        }\n    }\n    else if(weight == W) printf(\" <- this is the solution\\n\");\n    else printf(\"\\n\");\n    return (weight + total >= W)\n        && (weight == W || weight + w[i+1] <= W);\n}"}
{"author": "sdukesameer", "file": "dsa__dll-ins-seq-sor-del-a.6.c", "original_string": "int main()\n{\n    while (1)\n    {\n        int ch;\n        printf(\"\\n1. SORTED ORDER INSERTION\\n\");\n        printf(\"2. SEQUENTIAL ORDER INSERTION\\n\");\n        printf(\"3. EXIT PROGRAM\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1)\n        {\n            list* head=NULL;\n            int c;\n            while(1)\n            {\n                int c;\n                printf(\"\\n1. ENTER AN INTEGER\\n\");\n                printf(\"2. DELETE AN INTEGER\\n\");\n                printf(\"3. TRAVERSAL IN FORWARD DIRECTION\\n\");\n                printf(\"4. TRAVERSAL IN REVERSE DIRECTION\\n\");\n                printf(\"5. EXIT SORTED ORDER INSERTION\\n\");\n                printf(\"Enter your choice: \");\n                scanf(\"%d\",&c);\n                if(c==1)\n                {\n                    int n;\n                    printf(\"Please enter an element: \");\n                    scanf(\"%d\",&n);\n                    sort_insertion(&head,n);\n                    printf(\"%d inserted using SORTED ORDER INSERTION.\\n\",n);\n                }\n                else if(c==2)\n                {\n                    int n;\n                    printf(\"\\nPlease enter the element to be deleted: \");\n                    scanf(\"%d\",&n);\n                    if (head==NULL)\n                        printf(\"COULDN'T DELETE %d. LIST IS EMPTY\\n\",n);\n                    else\n                    {\n                        list* del_node=search_node(head,n);\n                        if(del_node==NULL)\n                        printf(\"COULDN'T DELETE %d. NOT FOUND IN LIST.\\n\",n);\n                        else\n                        {\n                            deletion(&head,del_node);\n                            printf(\"%d deleted from LIST.\\n\",n);\n                        }\n                    }\n                }\n                else if (c==3)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST IS EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nTRAVERSAL IN FORWARD DIRECTION: \\n\");\n                        printfwd(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==4)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST IS EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nTRAVERSAL IN REVERSE DIRECTION: \\n\");\n                        printrev(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==5)\n                {\n                    printf(\"\\nExitting Sorted Order Insertion, Thank You.\\n\");\n                    break;\n                }\n                else\n                    printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n            }\n        }\n        else if(ch==2)\n        {\n            list* head=NULL;\n            int c;\n            while(1)\n            {\n                printf(\"\\n1. ENTER AN INTEGER\\n\");\n                printf(\"2. DELETE AN INTEGER\\n\");\n                printf(\"3. TRAVERSAL IN FORWARD DIRECTION\\n\");\n                printf(\"4. TRAVERSAL IN REVERSE DIRECTION\\n\");\n                printf(\"5. EXIT SORTED ORDER INSERTION\\n\");\n                printf(\"Enter your choice: \");\n                scanf(\"%d\",&c);\n                if(c==1)\n                {\n                    int n;\n                    printf(\"Please enter an element: \");\n                    scanf(\"%d\",&n);\n                    seq_insertion(&head,n);\n                    printf(\"%d inserted using SEQUENTIAL ORDER INSERTION.\\n\",n);\n                }\n                else if(c==2)\n                {\n                    int n;\n                    printf(\"\\nPlease enter the element to be deleted: \");\n                    scanf(\"%d\",&n);\n                    if (head==NULL)\n                        printf(\"COULDN'T DELETE %d. LIST IS EMPTY\\n\",n);\n                    else\n                    {\n                        list* del_node=search_node(head,n);\n                        if(del_node==NULL)\n                        printf(\"COULDN'T DELETE %d. NOT FOUND IN LIST.\\n\",n);\n                        else\n                        {\n                            deletion(&head,del_node);\n                            printf(\"%d deleted from LIST.\\n\",n);\n                        }\n                    }\n                }\n                else if (c==3)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST IS EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nTRAVERSAL IN FORWARD DIRECTION: \\n\");\n                        printfwd(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==4)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST IS EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nTRAVERSAL IN REVERSE DIRECTION: \\n\");\n                        printrev(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if(c==5)\n                {\n                    printf(\"\\nExitting Sorted Order Insertion, Thank You.\\n\");\n                    break;\n                }\n                else\n                    printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n            }\n        }\n        else if(ch==3)\n        {\n            printf(\"\\nExitting Program, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n    }\n    return 0;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__stack_pallindrom_string.2.c", "original_string": "void push(int num) {\n    if (isFull())\n        printf(\"Stack is Full...\\n\");\n    else {\n        string.array[string.top + 1] = num;\n        string.top++;\n    }\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__103-merge_sort.2.c", "original_string": "void merge_sort(int *array, size_t size)\n{\n    int *copy;\n    size_t i;\n    if (array == NULL || size < 2)\n        return;\n    copy = malloc(sizeof(int) * size);\n    if (!copy)\n        return;\n    i = 0;\n    while (i < size)\n    {\n        copy[i] = array[i];\n        i++;\n    }\n    TopDownSplitMerge(copy, 0, (int)size, array);\n    free(copy);\n}"}
{"author": "earth429", "file": "mulpre__mulprec.2.c", "original_string": "void dispNumberZeroSuppress(struct NUMBER *a){\n    int i;\n    if(getSign(a) == 1) {\n        printf(\"+\");\n    } else {\n        printf(\"-\");\n    }\n    for (i = KETA - 1; i >= 0; i--) {\n        if(a->n[i] != 0){\n            break;\n        }\n        if(i == 0){\n            printf(\"%2d\", a->n[i]);\n        }\n    }\n    for (; i >= 0;i--) {\n        printf(\"%2d\", a->n[i]);\n    } \n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ili9341_ext.5.c", "original_string": "static ret_code_t hardware_init(void)\n{\n    ret_code_t err_code;\n    nrf_gpio_cfg_output(ILI9341_DC_PIN);\n    nrf_drv_spi_config_t spi_config = NRF_DRV_SPI_DEFAULT_CONFIG;\n    spi_config.sck_pin  = ILI9341_SCK_PIN;\n    spi_config.miso_pin = ILI9341_MISO_PIN;\n    spi_config.mosi_pin = ILI9341_MOSI_PIN;\n    spi_config.ss_pin   = ILI9341_SS_PIN;\n    spi_config.frequency = SPI_FREQUENCY_FREQUENCY_M4;\n    err_code = nrf_drv_spi_init(&spi, &spi_config, NULL, NULL);\n    return err_code;\n}"}
{"author": "mandarvu", "file": "msc__problem45.1.c", "original_string": "int main(void) {\n    struct point A, B, target;\n    printf(\"Enter first number real and imaginary part of A = (a1 + ib1): \");\n    scanf(\"%f %f\", &A.re, &A.im);\n    printf(\"Enter first number real and imaginary part of B = (a2 + ib2): \");\n    scanf(\"%f %f\", &B.re, &B.im);   \n    target = complex_add(A, B);\n    printf(\"A + B = %4.3f + i(%4.3f)\\n\", target.re, target.im);\n    return 0;\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise20.0.c", "original_string": "int * PrintReverseInclusive(int LowerNumber,int UpperNumber,int * result_size)\n{\n    int i;\n    *result_size = 0;\n    if((LowerNumber>=UpperNumber) || (UpperNumber-1 == LowerNumber))\n    {\n        OutputArray[0] = 0xFF;\n        OutputArray[1] = 0xFF;\n        *result_size = 2;\n    }\n    else\n    {\n        for(i=UpperNumber-1;i>LowerNumber;i--)\n        {\n            OutputArray[*result_size] = i;\n            (*result_size)++;\n        }\n    }\n    return OutputArray;\n}"}
{"author": "sdukesameer", "file": "dsa__arr-ins-del.0.c", "original_string": "int main()\n{\n    int n, arr[10], c=0, ch;\n    while(1)\n    {\n        printf(\"1. To enter elements in the array\\n\");\n        printf(\"2. To delete elements from the array\\n\");\n        printf(\"3. Print the array\\n\");\n        printf(\"4. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            if (c+1>10)\n                    printf(\"Array full. Try deleting elements.\\n\\n\");\n            else\n                scanf(\"%d\",&arr[c++]);\n        }\n        else if(ch==2)\n        {\n            if(c-1<0)\n                printf(\"Array empty, try adding elements.\\n\\n\");\n            else\n                arr[c--]=0;\n        }\n        else if(ch==3)\n        {\n            for(int j=0;j<c;j++)\n            {\n                printf(\"%d \",arr[j]);\n            }\n            printf(\"\\n\\n\");\n        }\n        else if (ch==4)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n        {\n            printf(\"Invalid, choice try again\\n\\n\");\n        }\n    }\n    return 0;\n}"}
{"author": "ankitraj311", "file": "Socket-thread__previous_program_with_thread_4.2.c", "original_string": "int main()\n{\n  pthread_t thread_id, thread_id1;\n  pthread_create(&thread_id,NULL,myturn,NULL);\n  pthread_create(&thread_id1,NULL,yourturn,NULL);\n  pthread_join(thread_id,NULL);\n  pthread_join(thread_id1,NULL);\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__cub2d.5.c", "original_string": "int         move(void)\n{\n    mlx_hook(g_vars.win, 2, 0, key_press, &g_vars);\n    render();\n    mlx_hook(g_vars.win, 3, 0, key_release, &g_vars);\n    return (0);\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_6.2.c", "original_string": "int find_size(node head)\n{\n    node p;\n    int n=0;\n    p=head;\n    while(p!=NULL)\n    {\n        n++;\n        p=p->next;\n    }\n    return n;\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_1-20.7.c", "original_string": "int main(){\n    move[0].vert=-1;\n    move[0].horiz=0;\n    move[1].vert=0;\n    move[1].horiz=1;\n    move[2].vert=1;\n    move[2].horiz=0;\n    move[3].vert=0;\n    move[3].horiz=-1;\n    int num,i,j,startx,starty,finalx,finaly;\n    FILE *rptr;\n    rptr = fopen(\"test.txt\",\"r\");\n    if(NULL==rptr){\n        printf(\"Open failure\");\n        return 1;\n    }\n    else{\n        fscanf(rptr,\"%d\\n\",&num);\n        char** maze = arr(num+2,num+2);\n        char** mark = arr(num+2,num+2);\n        char** road = arr(num+2,num+2);\n        int** d = arrc(num+2,num+2);\n        for(i=0;i<num+2;i++){\n            for(j=0;j<num+2;j++){\n                if(i==0 || j==0 || i==num+1 || j==num+1){\n                    maze[i][j]='X';\n                }\n                else{\n                    fscanf(rptr,\"%c \",&maze[i][j]);\n                    if(maze[i][j]=='S'){\n                        startx=i;\n                        starty=j;\n                    }\n                    if(maze[i][j]=='F'){\n                        finalx=i;\n                        finaly=j;\n                    }\n                }\n                road[i][j]=maze[i][j];\n                mark[i][j]=maze[i][j];\n            }\n        }\n        if(bfs(maze,d,num,startx,starty)){\n            path(d,maze,road,finalx,finaly,num);\n            for(i=1;i<num+2-1;i++){\n                for(j=1;j<num+2-1;j++){\n                    printf(\"%c \",road[i][j]);\n                }\n                printf(\"\\n\");\n            }\n            printf(\"\u6700\u77ed\u8def\u5f91\u70ba%d\\n\",min);\n        }\n        else printf(\"The maze does not have a path\\n\" );\n        for(i = 0; i < num+2; i++) {\n            free(maze[i]);\n        }\n        free(maze);\n        for(i = 0; i < num+2; i++) {\n            free(mark[i]);\n        }\n        free(mark);\n        for(i = 0; i < num+2; i++) {\n            free(road[i]);\n        }\n        free(road);\n        free(d);\n    }\n    fclose(rptr);\n}"}
{"author": "haon1026", "file": "linux-programming__pthread_exit.2.c", "original_string": "int main()\n{\n    int i;\n    int ret;\n    pthread_t tid;\n    for(i = 0; i < 5; i++)\n    {\n        ret = pthread_create(&tid, NULL, thread_fun, (void*)i);\n        if(ret != 0)\n            sys_err(\"pthread_create error\");\n    }\n    printf(\"I'm main thread:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n    pthread_exit(NULL);     \n}"}
{"author": "augustogunsch", "file": "jackc__parser-statements.8.c", "original_string": "STATEMENT* parsereturn(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, returnstatement);\n    s->retstatement = parseexpressionnullified(p);\n    checkcontent(p, \";\");\n    return s;\n}"}
{"author": "deepaliajabsingjadhav", "file": "file__count_Capital_file.1.c", "original_string": "int main()\n{\n    char name[20];\n    int ret = 0;\n    printf(\"Enter file name\\n\");\n    scanf(\"%s\",name);\n   ret = FileCapitalCount(name);\n    printf(\"Number of capital characters are : %d\\n\",ret);\n    return 0;\n}"}
{"author": "zjzj-zz", "file": "1s_programing__pattern.0.c", "original_string": "void dl_hexagon(int x, int y ,int z){\ndl_line(15+x , 8+y , 25+x , 8+y ,DL_RGB(100-z,125,20+z),3);\ndl_line(25+x , 8+y , 35+x , 16+y ,DL_RGB(100-z,125,20+z),3);\ndl_line(35+x , 16+y , 25+x , 25+y ,DL_RGB(100-z,125,20+z),3);\ndl_line(25+x , 25+y , 15+x, 25+y ,DL_RGB(100-z,125,20+z),3);\ndl_line(15+x , 25+y , 5+x , 16+y ,DL_RGB(100-z,125,20+z),3);\ndl_line(5+x , 16+y , 15+x , 8+y ,DL_RGB(100-z,125,20+z),3);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__stp_operation.0.c", "original_string": "void stpReceivedConfigBpdu(StpBridgePort *port, const StpBpdu *bpdu)\n{\n   bool_t rootBridge;\n   StpBridgeContext *context;\n   context = port->context;\n   if(port->state != STP_PORT_STATE_DISABLED && port->macOperState)\n   {\n      if(stpSupersedesPortInfo(port, bpdu))\n      {\n         rootBridge = stpRootBridge(context);\n         stpRecordConfigInfo(port, bpdu);\n         stpConfigUpdate(context);\n         stpPortStateSelection(context);\n         if(rootBridge && !stpRootBridge(context))\n         {\n            stpStopTimer(&context->helloTimer);\n            if(context->topologyChangeDetected)\n            {\n               stpStopTimer(&context->topologyChangeTimer);\n               stpTransmitTcnBpdu(context);\n               stpStartTimer(&context->tcnTimer, 0);\n            }\n         }\n         if(stpRootPort(port))\n         {\n            stpRecordConfigTimeoutValues(context, bpdu);\n            stpConfigBpduGeneration(context);\n            if((bpdu->flags & STP_BPDU_FLAG_TC_ACK) != 0)\n            {\n               stpTopologyChangeAcked(context);\n            }\n         }\n      }\n      else\n      {\n         if(stpDesignatedPort(port))\n         {\n            stpReplyToConfigBpdu(port);\n         }\n      }\n   }\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.5.c", "original_string": "void imprimir_alumno(){\n    int posicion = posicion_alumno();\n    printf(\"Matr\u00edcula: %d\\n\", lista_estudiantes[posicion].matricula);\n    printf(\"Nombre del alumno: %s\\n\", lista_estudiantes[posicion].nombre);\n    printf(\"Calificaci\u00f3n 1: %.2f\\n\", lista_estudiantes[posicion].calificaciones[0]); \n    printf(\"Calificaci\u00f3n 2: %.2f\\n\", lista_estudiantes[posicion].calificaciones[1]); \n    printf(\"Calificaci\u00f3n 3: %.2f\\n\", lista_estudiantes[posicion].calificaciones[2]); \n    printf(\"Calificaci\u00f3n f: %.2f\\n\", lista_estudiantes[posicion].calificaciones[3]); \n    float prom = promedio(lista_estudiantes[posicion].calificaciones);\n    printf(\"Promedio : %.2f\\n\", prom);\n    float m;\n    m = minimo(lista_estudiantes[posicion].calificaciones);\n    printf(\"Calificaci\u00f3n m\u00ednima: %.2f\\n\", m);\n    m = maximo(lista_estudiantes[posicion].calificaciones);\n    printf(\"Calificaci\u00f3n m\u00e1xima: %.2f\\n\", m);\n    imprimir_asistencias(posicion);\n    fflush(stdin);\n    getchar();\n}"}
{"author": "sdukesameer", "file": "dsa__list-ins-seq-sor_acend_decend.3.c", "original_string": "void sorted_insert_dec(node** head, int inp)\n{\n    node* newnode=createnode(inp);\n    if(*head==NULL||newnode->data > (*head)->data)\n    {\n        newnode->next=*head;\n        *head=newnode;\n        printf(\"%d inserted\\n\",(*head)->data);\n    }\n    else\n    {\n        node* temp=*head;\n        while(temp->next!=NULL&&temp->next->data > newnode->data)\n            temp=temp->next;\n        newnode->next=temp->next;\n        temp->next=newnode;\n        printf(\"%d inserted\\n\",temp->next->data);\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__stack.3.c", "original_string": "int pop() {\n   int data;\n   if(!isempty()) {\n      data = stack[top];\n      top = top - 1;\n      return data;\n   } else {\n      printf(\"Could not retrieve data, Stack is empty.\\n\");\n   }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server_file.1.c", "original_string": "error_t scpServerOpenFileForReading(ScpServerSession *session)\n{\n   error_t error;\n   uint_t perm;\n   FsFileStat fileStat;\n   error = fsGetFileStat(session->path, &fileStat);\n   if(!error)\n   {\n      if((fileStat.attributes & FS_FILE_ATTR_DIRECTORY) == 0)\n      {\n         perm = scpServerGetFilePermissions(session, session->path);\n         if((perm & SCP_FILE_PERM_READ) != 0)\n         {\n            session->file = fsOpenFile(session->path, FS_FILE_MODE_READ);\n            if(session->file != NULL)\n            {\n               session->fileSize = fileStat.size;\n               session->fileOffset = 0;\n               if((fileStat.attributes & FS_FILE_ATTR_READ_ONLY) != 0)\n               {\n                  session->fileMode = SCP_MODE_IRUSR | SCP_MODE_IRGRP |\n                     SCP_MODE_IROTH;\n               }\n               else\n               {\n                  session->fileMode = SCP_MODE_IRUSR | SCP_MODE_IWUSR |\n                     SCP_MODE_IRGRP | SCP_MODE_IWGRP | SCP_MODE_IROTH |\n                     SCP_MODE_IWOTH;\n               }\n               error = NO_ERROR;\n            }\n            else\n            {\n               error = ERROR_FILE_NOT_FOUND;\n            }\n         }\n         else\n         {\n            error = ERROR_ACCESS_DENIED;\n         }\n      }\n      else\n      {\n         error = ERROR_FILE_NOT_FOUND;\n      }\n   }\n   else\n   {\n      error = ERROR_FILE_NOT_FOUND;\n   }\n   return error;\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__Campo_minado.0.c", "original_string": "int main()\n{\n    char entrada[100];\n    int string;\n    int matriz_final[n][m];\n    char matriz_entrada[n][m];\n    int linha, coluna, random_bomb, menu, menu2, menu3, menu12, menu13;\n    int mapa = false, instrucoes = false, creditos = false, sair = false;\n    int qtd_bombas, random;\n    random = (n + m) / 3;\n    while (sair == false)\n    {\n        system(\"clear\");\n        printf(\"\\tBem vindo ao gerador de mapa de campo minado.\\n\\n\\t(1) Iniciar\\n\\t(2) Instru\u00e7\u00f5es\\n\\t(3) Cr\u00e9ditos\\n\\t(4) Sair\\n\\t \");\n        scanf(\"%d\", &menu);\n        getchar();\n        system(\"clear\");\n        switch (menu)\n        {\n        case 1:\n            mapa = true;\n            while (mapa == true)\n            {\n                printf(\"\\t(1) Gerador de mapa manual\\n\\t(2) Gerador de mapa rand\u00f4mico\\n\\t \");\n                scanf(\"%d\", &menu12);\n                getchar();\n                switch (menu12)\n                {\n                case 1:\n                    system(\"clear\");\n                    for (int i = 0; i < n; i++)\n                    {\n                        do\n                        {\n                            printf(\"Informe as %d linhas da matriz com %d elementos v\u00e1lidos,\\nou seja 'X' para bomba e 'L' para n\u00e3o bomba,\\nos elementos dever\u00e3o ser inseridos sem espa\u00e7os entre eles.\\nAo fim de uma linha, pressione 'enter' para escrever a pr\u00f3xima linha.\\n\\n\", n, m);\n                            for (int j = 0; j < i; j++)\n                            {\n                                for (int k = 0; k < m; k++)\n                                {\n                                    printf(\"%c\", matriz_entrada[j][k]);\n                                }\n                                printf(\"\\n\");\n                            }\n                            setbuf(stdin, NULL);\n                            scanf(\"%s\", entrada);\n                            getchar();\n                            string = true;\n                            if (strlen(entrada) != m)\n                            {\n                                string = false;\n                            }\n                            for (int j = 0; j < m; j++)\n                            {\n                                if ((toupper(entrada[j]) != 'X') && (toupper(entrada[j]) != 'L'))\n                                {\n                                    string = false;\n                                }\n                            }\n                            if (string == false)\n                            {\n                                printf(\"\\nstring inv\u00e1lida\\n\");\n                                sleep(1);\n                                system(\"clear\");\n                            }\n                        } while (string == false);\n                        for (int j = 0; j < m; j++)\n                        {\n                            matriz_entrada[i][j] = entrada[j];\n                        }\n                        for (int j = 0; j < m; j++)\n                        {\n                            if (toupper(entrada[j]) == 'X')\n                            {\n                                matriz_final[i][j] = 88;\n                            }\n                            else\n                            {\n                                matriz_final[i][j] = 0;\n                            }\n                        }\n                        system(\"clear\");\n                    }\n                    for (int i = 0; i < n; i++)\n                    {\n                        for (int j = 0; j < m; j++)\n                        {\n                            qtd_bombas = 0;\n                            if (matriz_final[i][j] != 88)\n                            {\n                                if (j != 0)\n                                {\n                                    if (matriz_final[i][j - 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if (j != (m - 1))\n                                {\n                                    if (matriz_final[i][j + 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if (i != 0)\n                                {\n                                    if (matriz_final[i - 1][j] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if (i != (n - 1))\n                                {\n                                    if (matriz_final[i + 1][j] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if ((j != (m - 1)) && (i != (n - 1)))\n                                {\n                                    if (matriz_final[i + 1][j + 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if ((j != 0) && (i != (n - 1)))\n                                {\n                                    if (matriz_final[i + 1][j - 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if ((j != 0) && (i != 0))\n                                {\n                                    if (matriz_final[i - 1][j - 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if ((j != (m - 1)) && (i != 0))\n                                {\n                                    if (matriz_final[i - 1][j + 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                matriz_final[i][j] = qtd_bombas;\n                            }\n                        }\n                    }\n                    while (mapa == true)\n                    {\n                        linha = 0;\n                        coluna = 0;\n                        printf(\"colunas:      \");\n                        for (int j = 0; j < m; j++)\n                        {\n                            printf(\"%-2i\", coluna);\n                            coluna++;\n                            printf(\"  \");\n                        }\n                        printf(\"\\n\\t      \");\n                        for (int j = 0; j < m; j++)\n                        {\n                            printf(\"|   \");\n                        }\n                        printf(\"\\n\\n\");\n                        for (int i = 0; i < n; i++)\n                        {\n                            for (int j = 0; j < m; j++)\n                            {\n                                if (j == 0)\n                                {\n                                    printf(\"linha: %2i --  \", linha);\n                                    linha++;\n                                }\n                                if (matriz_final[i][j] == 88)\n                                {\n                                    printf(\"%c   \", matriz_final[i][j]);\n                                }\n                                else\n                                {\n                                    printf(\"%d   \", matriz_final[i][j]);\n                                }\n                            }\n                            printf(\"\\n\\n\");\n                        }\n                        printf(\"\\tQuando estiver pronto digite '0' para voltar: \");\n                        scanf(\"%d\", &menu13);\n                        getchar();\n                        if (menu13 == 0)\n                        {\n                            mapa = false;\n                        }\n                        else\n                        {\n                            system(\"clear\");\n                        }\n                    }\n                    break;\n                case 2:\n                    system(\"clear\");\n                    srand(time(NULL));\n                    for (int i = 0; i < n; i++)\n                    {\n                        for (int j = 0; j < m; j++)\n                        {\n                            random_bomb = rand() % random;\n                            if (random_bomb == 0)\n                            {\n                                matriz_final[i][j] = 88;\n                            }\n                            else\n                            {\n                                matriz_final[i][j] = 0;\n                            }\n                        }\n                    }\n                    for (int i = 0; i < n; i++)\n                    {\n                        for (int j = 0; j < m; j++)\n                        {\n                            qtd_bombas = 0;\n                            if (matriz_final[i][j] != 88)\n                            {\n                                if (j != 0)\n                                {\n                                    if (matriz_final[i][j - 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if (j != (m - 1))\n                                {\n                                    if (matriz_final[i][j + 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if (i != 0)\n                                {\n                                    if (matriz_final[i - 1][j] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if (i != (n - 1))\n                                {\n                                    if (matriz_final[i + 1][j] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if ((j != (m - 1)) && (i != (n - 1)))\n                                {\n                                    if (matriz_final[i + 1][j + 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if ((j != 0) && (i != (n - 1)))\n                                {\n                                    if (matriz_final[i + 1][j - 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if ((j != 0) && (i != 0))\n                                {\n                                    if (matriz_final[i - 1][j - 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                if ((j != (m - 1)) && (i != 0))\n                                {\n                                    if (matriz_final[i - 1][j + 1] == 88)\n                                    {\n                                        qtd_bombas++;\n                                    }\n                                }\n                                matriz_final[i][j] = qtd_bombas;\n                            }\n                        }\n                    }\n                    while (mapa == true)\n                    {\n                        linha = 0;\n                        coluna = 0;\n                        printf(\"colunas:      \");\n                        for (int j = 0; j < m; j++)\n                        {\n                            printf(\"%-2i\", coluna);\n                            coluna++;\n                            printf(\"  \");\n                        }\n                        printf(\"\\n\\t      \");\n                        for (int j = 0; j < m; j++)\n                        {\n                            printf(\"|   \");\n                        }\n                        printf(\"\\n\\n\");\n                        for (int i = 0; i < n; i++)\n                        {\n                            for (int j = 0; j < m; j++)\n                            {\n                                if (j == 0)\n                                {\n                                    printf(\"linha: %2i --  \", linha);\n                                    linha++;\n                                }\n                                if (matriz_final[i][j] == 88)\n                                {\n                                    printf(\"%c   \", matriz_final[i][j]);\n                                }\n                                else\n                                {\n                                    printf(\"%d   \", matriz_final[i][j]);\n                                }\n                            }\n                            printf(\"\\n\\n\");\n                        }\n                        printf(\"\\tQuando estiver pronto digite '0' para voltar: \");\n                        scanf(\"%d\", &menu13);\n                        getchar();\n                        if (menu13 == 0)\n                        {\n                            mapa = false;\n                        }\n                        else\n                        {\n                            system(\"clear\");\n                        }\n                    }\n                    break;\n                default:\n                    system(\"clear\");\n                    break;\n                }\n            }\n            break;\n        case 2:\n            instrucoes = true;\n            while (instrucoes == true)\n            {\n                printf(\"\\tA matriz por padr\u00e3o tem tamanho 5x5, por\u00e9m \u00e9 poss\u00edvel mudar o tamanho da matriz,\\n\");\n                printf(\"\\talterando no inicio c\u00f3digo os valores de n (linhas) e m (colunas) no #define. Ex: '#define n 7'\\n\\n\");\n                printf(\"\\tGera\u00e7\u00e3o manual:\\n\\n\");\n                printf(\"\\tPara cada linha da matriz dever\u00e1 ser digitado uma string (sem espa\u00e7os) do tamanho do n\u00famero de colunas,\\n\");\n                printf(\"\\tEssa string dever\u00e1 conter apenas 'X' para indicar uma bomba e 'L' para indicar n\u00e3o-bomba.\\n\");\n                printf(\"\\tAp\u00f3s digitada a linha, dever\u00e1 pressionar 'enter', para poder escrever a pr\u00f3xima linha.\\n\\n\");\n                printf(\"\\tGera\u00e7\u00e3o rand\u00f4mica:\\n\\n\");\n                printf(\"\\tCaso deseja alterar a chance de que ocorra uma bomba, basta alterar a vari\u00e1vel: 'random',\\n\");\n                printf(\"\\tComo a ocorr\u00eancia de bomba \u00e9 determinada pela escolha aleat\u00f3ria de um n\u00famero de 0 at\u00e9 o random,\\n\");\n                printf(\"\\tQuanto maior for o random menor a chance de aparecer uma bomba.\\n\\n\");\n                printf(\"\\tQuando estiver pronto digite '0' para voltar: \");\n                scanf(\"%d\", &menu2);\n                getchar();\n                if (menu2 == 0)\n                {\n                    instrucoes = false;\n                }\n                else\n                {\n                    system(\"clear\");\n                }\n            }\n            break;\n        case 3:\n            creditos = true;\n            while (creditos == true)\n            {\n                printf(\"\\tEste trabalho, o gerador de mapa de campo minado, foi feito por:\\n\\n\");\n                printf(\"\\tDarla Ellen Santos Garcez\\n\\tGustavo Cunha Lacerda\\n\\tHenrique Tavares Aguiar\\n\\n\");\n                printf(\"\\tQuando estiver pronto, digite '0' para voltar: \");\n                scanf(\"%d\", &menu3);\n                getchar();\n                if (menu3 == 0)\n                {\n                    creditos = false;\n                }\n                else\n                {\n                    system(\"clear\");\n                }\n            }\n            break;\n        case 4:\n            sair = true;\n            break;\n        }\n    }\n    return 0;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_nus.0.c", "original_string": "static void on_connect(ble_nus_t * p_nus, ble_evt_t const * p_ble_evt)\n{\n    ret_code_t                 err_code;\n    ble_nus_evt_t              evt;\n    ble_gatts_value_t          gatts_val;\n    uint8_t                    cccd_value[2];\n    ble_nus_client_context_t * p_client = NULL;\n    err_code = blcm_link_ctx_get(p_nus->p_link_ctx_storage,\n                                 p_ble_evt->evt.gap_evt.conn_handle,\n                                 (void *) &p_client);\n    if (err_code != NRF_SUCCESS)\n    {\n        NRF_LOG_ERROR(\"Link context for 0x%02X connection handle could not be fetched.\",\n                      p_ble_evt->evt.gap_evt.conn_handle);\n    }\n    memset(&gatts_val, 0, sizeof(ble_gatts_value_t));\n    gatts_val.p_value = cccd_value;\n    gatts_val.len     = sizeof(cccd_value);\n    gatts_val.offset  = 0;\n    err_code = sd_ble_gatts_value_get(p_ble_evt->evt.gap_evt.conn_handle,\n                                      p_nus->rx_handles.cccd_handle,\n                                      &gatts_val);\n    if ((err_code == NRF_SUCCESS)     &&\n        (p_nus->data_handler != NULL) &&\n        ble_srv_is_notification_enabled(gatts_val.p_value))\n    {\n        if (p_client != NULL)\n        {\n            p_client->is_notification_enabled = true;\n        }\n        memset(&evt, 0, sizeof(ble_nus_evt_t));\n        evt.type        = BLE_NUS_EVT_COMM_STARTED;\n        evt.p_nus       = p_nus;\n        evt.conn_handle = p_ble_evt->evt.gap_evt.conn_handle;\n        evt.p_link_ctx  = p_client;\n        p_nus->data_handler(&evt);\n    }\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__unique2.5.c", "original_string": "void change(int vector[], int i, int j){\n  int aux;\n  aux = vector[i];\n  vector[i] = vector[j];\n  vector[j] = aux;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_SLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n       if(head==0)\n       {\n            head=temp=newnode;\n       }\n       else\n       {\n            temp->next=newnode;\n            temp=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n           scanf(\"%d\",& choice);\n    }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e150.2.c", "original_string": "int exibirResultado (int comparacao)\n{\n    if (comparacao == 0)\n    {\n        printf (\"\\n\\nCaracteres digitados corretamente!\");\n    }else\n    {\n        system (\"COLOR C\");\n        printf (\"\\n\\nERRO! Caracteres digitados de forma incorreta. Tente novamente.\\n\\n\");\n        sleep(3);\n        comparacao = 1;\n        system(\"cls\");\n    }\n    return comparacao;\n}"}
{"author": "deepaliajabsingjadhav", "file": "file__lseek_End.0.c", "original_string": "int FileSize(char *name)\n{\n    int fd = 0, ret = 0;\n    fd = open(name,O_RDONLY);\n    if(fd == -1)\n    {\n        printf(\"Unable to open file\\n\");\n        return -1;\n    }\n    ret = lseek(fd,0,SEEK_END); \n    close(fd);\n    return ret;\n}"}
{"author": "augustogunsch", "file": "jackc__vm-lines.8.c", "original_string": "LINEBLOCK* mergelnblks(LINEBLOCK* head, LINEBLOCK* tail) {\n    if(head == NULL)\n        return tail;\n    head->tail->next = tail->head;\n    head->tail = tail->tail;\n    free(tail);\n    return head;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler2.6.c", "original_string": "void InsertAtPos(PPNODE Head, PPNODE Tail, int value, int pos)\n{\n    int iCnt = 0, i = 0;\n    PNODE temp = *Head;\n    PNODE newn = NULL;\n    iCnt = Count(*Head, *Tail);\n    if((pos < 1) || (pos > iCnt+1))\n    {\n        return;\n    }\n    if(pos == 1)\n    {\n        InsertFirst(Head, Tail, value);\n    }\n    else if(pos == iCnt +1)\n    {\n        InsertLast(Head,Tail, value);\n    }\n    else\n    {\n        for(i = 1; i<pos-1;i++)\n        {\n            temp = temp->next;\n        }\n        newn = (PNODE)malloc(sizeof(NODE));\n        newn->data = value;\n        newn->next = NULL;\n        newn->next = temp->next;\n        temp->next = newn;\n    }\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__23.1.c", "original_string": "void largest(int ar[],int n)\n{\n    int max,i;\n    max=ar[0];\n    for(i=0;i<n;i++)\n    {\n        if(max<ar[i])\n            max=ar[i];\n    }\n    printf(\"%d\",max);\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad30.0.c", "original_string": "int main()\n{\n    float first, second, third;\n    printf(\"Podaj 1 bok: \");\n    scanf(\"%f\", &first);\n    printf(\"Podaj 2 bok: \");\n    scanf(\"%f\", &second);\n    printf(\"Podaj 3 bok: \");\n    scanf(\"%f\", &third);\n    if(!czyTrojkat(first, second, third)){\n        printf(\"Podane boki nie moga utworzyc trojkata!\");\n    } else {\n        printf(\"Podane boki tworza piekny trojkat!\");\n    };\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-util.1.c", "original_string": "void checktype(PARSER* p, TOKENTYPE type) {\n    if(p->current->type != type) {\n        eprintf(\"Unexpected %s; file '%s', line %i\\n\", \n                tokentypes.items[p->current->type], p->file,\n                    p->current->definedat);\n        exit(1);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q2.10.c", "original_string": "int main()\n{\n    node *root;\n    root = create();\n    printf(\"\\nThe inorder traversal of tree is:\\n\");\n    inorder(root);\n    printf(\"\\nThe postorder traversal of tree is:\\n\");\n    postorder(root);\n    printf(\"\\nThe levelorder traversal of tree is:\\n\");\n    levelorder(root);\n    printf(\"\\nThe preorder traversal of tree is:\\n\");\n    preorder(root);\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__sftp_server_directory.3.c", "original_string": "error_t sftpServerReadDir(SftpServerSession *session,\n   const SshBinaryString *handle, SftpName *name)\n{\n   error_t error;\n   uint_t perm;\n   FsDirEntry dirEntry;\n   SftpServerContext *context;\n   SftpFileObject *fileObject;\n   error = NO_ERROR;\n   context = session->context;\n   osMemset(name, 0, sizeof(SftpName));\n   fileObject = sftpServerFindDir(session, handle);\n   if(fileObject == NULL)\n      return ERROR_INVALID_HANDLE;\n   while(!error)\n   {\n      error = fsReadDir(fileObject->dir, &dirEntry);\n      if(!error)\n      {\n         pathCopy(context->path, fileObject->path, SFTP_SERVER_MAX_PATH_LEN);\n         pathCombine(context->path, dirEntry.name, SFTP_SERVER_MAX_PATH_LEN);\n         pathCanonicalize(context->path);\n         perm = sftpServerGetFilePermissions(session, context->path);\n         if((perm & SFTP_FILE_PERM_READ) != 0)\n         {\n            osStrcpy(context->path, dirEntry.name);\n            name->filename.value = context->path;\n            name->filename.length = osStrlen(context->path);\n            if((dirEntry.attributes & FS_FILE_ATTR_DIRECTORY) != 0)\n            {\n               name->attributes.type = SSH_FILEXFER_TYPE_DIRECTORY;\n            }\n            else\n            {\n               name->attributes.type = SSH_FILEXFER_TYPE_REGULAR;\n            }\n            name->attributes.size = dirEntry.size;\n            if((dirEntry.attributes & FS_FILE_ATTR_READ_ONLY) != 0)\n            {\n               name->attributes.permissions = SFTP_MODE_IRUSR;\n            }\n            else\n            {\n               name->attributes.permissions = SFTP_MODE_IRUSR | SFTP_MODE_IWUSR;\n            }\n            name->attributes.mtime = dirEntry.modified;\n            name->attributes.atime = dirEntry.modified;\n            if((dirEntry.attributes & FS_FILE_ATTR_READ_ONLY) != 0)\n            {\n               name->attributes.bits |= SSH_FILEXFER_ATTR_FLAGS_READONLY;\n            }\n            if((dirEntry.attributes & FS_FILE_ATTR_SYSTEM) != 0)\n            {\n               name->attributes.bits |= SSH_FILEXFER_ATTR_FLAGS_SYSTEM;\n            }\n            if((dirEntry.attributes & FS_FILE_ATTR_HIDDEN) != 0)\n            {\n               name->attributes.bits |= SSH_FILEXFER_ATTR_FLAGS_HIDDEN;\n            }\n            if((dirEntry.attributes & FS_FILE_ATTR_ARCHIVE) != 0)\n            {\n               name->attributes.bits |= SSH_FILEXFER_ATTR_FLAGS_ARCHIVE;\n            }\n            name->attributes.flags = SSH_FILEXFER_ATTR_SIZE |\n               SSH_FILEXFER_ATTR_PERMISSIONS | SSH_FILEXFER_ATTR_ACMODTIME;\n            break;\n         }\n      }\n   }\n   return error;\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_5.7.c", "original_string": "void dellist()\n{\n    struct node *temp = root, *p;\n    while(temp != NULL)\n    {\n        p = temp->link;\n        free(temp);\n        temp = p;\n    }\n    printf(\"All the elements in the list deleted successfully.\\n\\n\");\n    root = NULL;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q1_doublylq.4.c", "original_string": "int delen(nptr* start,nptr* end)\n{\n    if(!*end)\n    {\n        printf(\"Underflow!!\\n\"); \n        return -99;\n    }\n    nptr temp; int x;\n    temp=*end;\n    x=temp->ele;\n    if(!((*end)->llink))\n    {\n        *end=*start=NULL;\n        free(temp);\n        return x;\n    }\n    *end=(*end)->llink;\n    (*end)->rlink=NULL;\n    free(temp);\n    return x;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__insertion.2.c", "original_string": "int main(){\n     int arr[100] = {7, 8, 12, 27, 88};\n     int size = 5, element = 40, index = 3;\n     display(arr, size);\n     indInsertion(arr, size, element, 100, index);\n     return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.9.c", "original_string": "ASSEMBLER* mkassembler(STRINGLIST* input) {\n    ASSEMBLER* a = (ASSEMBLER*)malloc(sizeof(ASSEMBLER));\n    a->labels = (SYMBOLARRAY*)malloc(sizeof(SYMBOLARRAY));\n    a->vars = (SYMBOLARRAY*)malloc(sizeof(SYMBOLARRAY));\n    a->garbage = NULL;\n    a->lns = input;\n    initsymbols(a->labels);\n    initsymbols(a->vars);\n    populatevars(a);\n    a->varsramind = BOTTOM_VAR;\n    return a;\n}"}
{"author": "Dhruvik-Chevli", "file": "DAALab__bst.0.c", "original_string": "struct Node* BSTInsert(struct Node** root,int data)\n{\n    if(!*root)\n    {\n        struct Node* newNode=(struct Node*)malloc(sizeof(struct Node));\n        newNode->data=data;\n        newNode->left=NULL;\n        newNode->right=NULL;\n        return newNode;\n    }\n    else\n    {\n        if((*root)->data>data)\n        {\n            (*root)->left=BSTInsert(&((*root)->left),data);\n        }\n        else if((*root)->data<data)\n        {\n            (*root)->right=BSTInsert(&((*root)->right),data);\n        }\n        else\n        {\n            printf(\"The element already exists in the BST\\n\");\n        }\n    }\n    return *root;\n}"}
{"author": "Theemiss", "file": "binary_trees__16-binary_tree_is_perfect.0.c", "original_string": "int binary_tree_is_leaf(const binary_tree_t *node)\n{\n    if (node == NULL)\n        return (0);\n    else if (node->left == NULL && node->right == NULL)\n        return (1);\n    return (0);\n}"}
{"author": "dishanp", "file": "DSA__q23.0.c", "original_string": "int main()\n{\n    int *arr;\n    int n;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n    int min1 = *arr;\n    int max1 = *arr;\n    int min2 = *arr;\n    int max2 = *arr;\n    for(int i = 0 ; i < n ; i++)\n    {\n        if(max1 < *(arr + i))\n        {\n            max2 = max1;\n            max1 = *(arr + i);\n        }\n        else if(max2 < *(arr +i) && *(arr +i) != max1)\n        {\n            max2 = *(arr +i);\n        }\n        if(min1 > *(arr +i))\n        {\n            min2 = min1;\n            min1 = *(arr + i);\n        }\n        else if(min2 > *(arr +i) && *(arr +i) != min1)\n        {\n            min2 = *(arr +i);\n        }\n    }\n    printf(\"Second smallest element : %d\\n\", min2);\n    printf(\"Second largest element : %d\\n\", max2);\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica2-1.1.c", "original_string": "void * aleatorio(){\n    float f1 = drand48()*10, f2 = drand48()*10;\n    float * f3 = calloc(1, sizeof(float));\n    *f3 = f1+f2;\n    printf(\"%f + %f = %f\\n\", f1, f2, *f3);\n    pthread_exit((void *) f3); \n}"}
{"author": "flora0110", "file": "hw01git__2-1tqueue.2.c", "original_string": "int*** make3darrint(int rows, int cols,int hei){\n    int ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__planetas.8.c", "original_string": "void desenhaSatelites(){\n    float v1 = 1.2;\n    float v2 = 1.4;\n    glPushMatrix();\n        glBindTexture(GL_TEXTURE_2D, texture_id[2]);\n        glRotatef(angulo*v1,0.0,1.0,0.0);\n        glTranslatef(-0.48,0.0,1.0);\n        desenhaEsferaComTextura();\n    glPopMatrix();\n    glPushMatrix();\n        glBindTexture(GL_TEXTURE_2D, texture_id[4]);\n        glRotatef(-angulo*v2,0.0,1.0,0.0);\n        glTranslatef(-0.8,0.0,2.0);\n        desenhaEsferaComTextura();\n    glPopMatrix();\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__planetas.6.c", "original_string": "void esferaQuadrica(){\n    int i,j;\n    glClear(GL_COLOR_BUFFER_BIT);\n    for(i=0;i<n;i++){\n        glBegin(GL_POINTS);\n            for(j=0;j<n;j++){\n                glVertex3f(r*cos(phi)*cos(theta),r*cos(phi)*sin(theta),r*sin(phi));\n                phi = phi + (2*M_PI)/n;\n            }\n        glEnd();\n        phi = 0.0;\n        theta = theta+(2*M_PI)/n;\n    }\n}"}
{"author": "2security", "file": "Matrix__36Transpose.0.c", "original_string": "int main()\n    {\n    int i,j,r,c,mat1[20][20],mat2[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    printf(\"\\n Enter the matrix \\n\");\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)                \n    scanf(\"%d\",&mat1[i][j]);\n    Transpose(mat1,mat2,r,c);\n    printf(\"Transpose of the matrix is:\\n\");\n    displayMat(mat2,r,c);\n    return 0;\n    }"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__DemoFOTAUpdateWorkflow.1.c", "original_string": "void fotahub_onConnectionStatusChanged(ConnectionStatus_t status)\n{\n  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__90.1.c", "original_string": "void exibe_alunos(FILE *arq)\n{\n    aluno_t aluno;\n    while (fread(&aluno, sizeof(aluno_t), 1, arq) != 0)\n    {\n        printf(\"\\nNome: %s\\n\", aluno.nome);\n        printf(\"\\t-> Prova 1: %i\\n\", aluno.prova[0]);\n        printf(\"\\t-> Prova 2: %i\\n\", aluno.prova[1]);\n        printf(\"\\t-> Prova 3: %i\\n\", aluno.prova[3]);\n        printf(\"\\t-> Trabalho 1: %i\\n\", aluno.trab[0]);\n        printf(\"\\t-> Trabalho 2: %i\\n\", aluno.trab[1]);\n    }\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__4_Dowhile.0.c", "original_string": "int main()\n{\n    int Mayor = 0;\n    int menor = 0;\n    int Mayor_150 = 0;\n    int negativos = 0;\n    float promedio_P = 0.0;\n    int contador = 0;\n    int num_p = 0;\n    do\n    {\n     int numero = 0;\n     printf(\"\\nIngrese por favor el numero:\");\n     scanf(\"%i\", &numero);\n     if(numero != 0){\n         if(numero > 150){\n             ++Mayor_150;    \n         }\n         if(numero > Mayor){\n             Mayor = numero;    \n         }else if(numero < menor){\n             menor = numero;    \n         }\n         if(numero > 0){\n             ++num_p;\n             promedio_P += numero; \n         }else{\n             ++negativos;          \n         }\n         ++contador;\n         }\n     }while(contador < 10);\n     printf(\"\\n***Fin del Ciclo***\\n\");\n     promedio_P = promedio_P / num_p;\n     printf(\"\\nCantidad de numeros mayores a 150: %i\", Mayor_150);\n     printf(\"\\nNumero mayor: %i  Numero menor: %i\", Mayor, menor);   \n     printf(\"\\nCantidad de numeros negativos encontrador: %i\", negativos);\n     printf(\"\\nPromedio positivos encontrados: %f\", promedio_P);\n}"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__readfile.2.c", "original_string": "int     main(void)\n{\n    char **ugh;\n    g_player.x = -1;\n    g_player.y = -1;\n    readline();\n    manage_map();\n    longuest_line();\n    array_height();\n    ugh = map_manager();\n}"}
{"author": "haon1026", "file": "linux-programming__sem_product_multconsumer.0.c", "original_string": "void *product(void *arg)\n{\n    int i = 0;\n    while(1)\n    {\n        sem_wait(&blank_number);                    \n        queue[i] = rand() % 1000 + 1;              \n        printf(\"-----Produce %d\\n\", queue[i]);                     \n        sem_post(&product_number);     \n        i = (i+1) % NUM;                    \n        sleep(rand()%1);\n    }\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_cmsis_rtos2.2.c", "original_string": "OsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,\n   void *param, size_t stackSize, int_t priority)\n{\n   osThreadId_t threadId;\n   osThreadAttr_t threadAttr;\n   threadAttr.name = name;\n   threadAttr.attr_bits = 0;\n   threadAttr.cb_mem = NULL;\n   threadAttr.cb_size = 0;\n   threadAttr.stack_mem = NULL;\n   threadAttr.stack_size = stackSize * sizeof(uint_t);\n   threadAttr.priority = (osPriority_t) priority;\n   threadAttr.tz_module = 0;\n   threadAttr.reserved = 0;\n   threadId = osThreadNew(taskCode, param, &threadAttr);\n   return (OsTask *) threadId;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListAllOperations.6.c", "original_string": "struct Node *deleteInBetween(struct Node *head, int index)\n{\n     struct Node *p = head;\n     struct Node *q = head->next;\n     for (int i = 0; i < index - 1; i++)\n     {\n          p = p->next;\n          q = q->next;\n     }\n     p->next = q->next;\n     free(q);\n     return head;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-tree.6.c", "original_string": "void freeexpressionlist(EXPRESSIONLIST* el) {\n    freeexpression(el->expression);\n    EXPRESSIONLIST* next = el->next;\n    free(el);\n    if(next != NULL)\n        freeexpressionlist(next);\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes2.0.c", "original_string": "int main(){\n    int opcion;\n    while (1) {\n        imprimir_menu();\n        scanf(\"%d\", &opcion);\n        switch (opcion) {\n            case 1: agregar_alumno();\n                break;\n            case 2: modificar_alumno();\n                break;\n             case 3: menu_modificacion_calificaciones();\n                 break;\n            case 4: imprimir_alumno();\n                 break;\n            case 5: imprimir_alumnos_en_tabla();\n                break;\n            case 6: pase_asistencia();\n                 break;\n            case 7:\n                return 0;\n                break;\n            default:\n                break;\n        }\n    }\n    return 0;\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__operationsonsemaphores.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    int shmid,rval,sval,csval;\n    sem_t *sem_phore;\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s labelForSHM ByteSize\\n\",argv[0]);\n        exit(0);\n    }\n    shmid=shmget((key_t)atoi(argv[1]),atoi(argv[2]),IPC_CREAT|0666);\n    if(shmid==-1)\n    {\n        perror(\"SHM-CRE-ERR:\");\n        exit(1);\n    }\n    sem_phore=(sem_t*)shmat(shmid,0,0);\n    if(!sem_phore)\n    {\n        perror(\"SHM-ATT-ERR:\");\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    printf(\"\\nEnter the initial value for the semaphore: \");\n    scanf(\"%d\",&sval);\n    rval=sem_init(sem_phore,1,sval);\n    if(rval==-1)\n    {\n        perror(\"Unable to initialize semaphore:\");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    rval=sem_getvalue(sem_phore,&csval);\n    if(rval==-1)\n    {\n        perror(\"Unable to get value of the semaphore: \");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    printf(\"\\nInitialized value of semaphore is %d\\n\",csval);\n    rval=sem_wait(sem_phore);\n    if(rval==-1)\n    {\n        perror(\"WAIT-FAILURE:\");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    rval=sem_getvalue(sem_phore,&csval);\n    if(rval==-1)\n    {\n        perror(\"Unable to get semaphore value:\");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    printf(\"\\nSemaphore value after wait is %d\\n\",csval);\n    rval=sem_post(sem_phore);\n    if(rval==-1)\n    {\n        perror(\"Unable to get semaphore value:\");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    rval=sem_getvalue(sem_phore,&csval);\n    if(rval==-1)\n    {\n        perror(\"Unable to get semaphore value: \");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    printf(\"\\nSemaphore value after signal operation is %d\\n\",csval);\n    rval=sem_destroy(sem_phore);\n    if(rval==-1)\n    {\n        perror(\"SEM-DESTROY-ERR:\");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    rval=shmdt(sem_phore);\n    if(rval==-1)\n    {\n        perror(\"SHM-DETACH-ERR:\");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    rval=shmctl(shmid,IPC_RMID,0);\n    if(rval==-1)\n    {\n        perror(\"SHM-REM-ERR:\");\n        shmdt(sem_phore);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    system(\"ipcs -m\");\n}"}
{"author": "RafaelFelisbino-hub", "file": "FUNCOES-exercices__TesteLayout.0.c", "original_string": "int main()\n{\n    gotoxy(0,0); printf(\"%c\",218);\n    for(i = 1; i <= 69; i++)\n    {\n        gotoxy(i,0); printf(\"%c\",196);\n    }\n    gotoxy(70,0); printf(\"%c\",191);\n    for(i = 1; i <= 15; i++)\n    {\n        gotoxy(0,i); printf(\"%c\",179);\n    }\n     for(i = 1; i <= 15; i++)\n    {\n        gotoxy(70,i); printf(\"%c\",179);\n    }\n    gotoxy(0,16); printf(\"%c\",192);\n    gotoxy(70,16); printf(\"%c\",217);\n    for(i = 1; i <= 69; i++)\n    {\n        gotoxy(i,16); printf(\"%c\",196);\n    }\n    gotoxy(19,1); printf(\"%c\",218);\n    for(i = 20; i <= 50; i++)\n    {\n        gotoxy(i,1); printf(\"%c\",196);\n    }\n    gotoxy(51,1); printf(\"%c\",191);\n    gotoxy(19,2); printf(\"%c\",179);\n    gotoxy(51,2); printf(\"%c\",179);\n    gotoxy(19,3); printf(\"%c\",192);\n    gotoxy(51,3); printf(\"%c\",217);\n    for(i = 20; i <= 50; i++)\n    {\n        gotoxy(i,3); printf(\"%c\",196);\n    }\n    gotoxy(19,5); printf(\"%c\",218);\n    for(i = 20; i <= 50; i++)\n    {\n        gotoxy(i,5); printf(\"%c\",196);\n    }\n    gotoxy(51,5); printf(\"%c\",191);\n    gotoxy(19,6); printf(\"%c\",179);\n    gotoxy(51,6); printf(\"%c\",179);\n    gotoxy(19,7); printf(\"%c\",192);\n    gotoxy(51,7); printf(\"%c\",217);\n    for(i = 20; i <= 50; i++)\n    {\n        gotoxy(i,7); printf(\"%c\",196);\n    }\n    gotoxy(19,9); printf(\"%c\",218);\n    for(i = 20; i <= 50; i++)\n    {\n        gotoxy(i,9); printf(\"%c\",196);\n    }\n    gotoxy(51,9); printf(\"%c\",191);\n    gotoxy(19,10); printf(\"%c\",179);\n    gotoxy(51,10); printf(\"%c\",179);\n    gotoxy(19,11); printf(\"%c\",192);\n    gotoxy(51,11); printf(\"%c\",217);\n    for(i = 20; i <= 50; i++)\n    {\n        gotoxy(i,11); printf(\"%c\",196);\n    }\n    gotoxy(19,13); printf(\"%c\",218);\n    for(i = 20; i <= 50; i++)\n    {\n        gotoxy(i,13); printf(\"%c\",196);\n    }\n    gotoxy(51,13); printf(\"%c\",191);\n    gotoxy(19,14); printf(\"%c\",179);\n    gotoxy(51,14); printf(\"%c\",179);\n    gotoxy(19,15); printf(\"%c\",192);\n    gotoxy(51,15); printf(\"%c\",217);\n    for(i = 20; i <= 50; i++)\n    {\n        gotoxy(i,15); printf(\"%c\",196);\n    }\n    gotoxy(6,3); printf(\"%c\",218);\n    gotoxy(7,3); printf(\"%c\",196);\n    gotoxy(8,3); printf(\"%c\",191);\n    for (i = 4; i <= 13; i++)\n    {\n        gotoxy(6,i); printf(\"%c\",179);\n    }\n     for (i = 4; i <= 13; i++)\n    {\n        gotoxy(8,i); printf(\"%c\",179);\n    }\n    gotoxy(6,14); printf(\"%c\",192);\n    gotoxy(7,14); printf(\"%c\",196);\n    gotoxy(8,14); printf(\"%c\",217);\n    gotoxy(7,4); printf(\"T\");\n    gotoxy(7,5); printf(\"A\");\n    gotoxy(7,6); printf(\"X\");\n    gotoxy(7,7); printf(\"I\");\n    gotoxy(7,9); printf(\"A\");\n    gotoxy(7,10); printf(\"E\");\n    gotoxy(7,11); printf(\"R\");\n    gotoxy(7,12); printf(\"E\");\n    gotoxy(7,13); printf(\"O\");\n    printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\");\n    system(\"pause\");\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__4_For.0.c", "original_string": "int main()\n{\n    int Mayor = 0;\n    int menor = 0; \n    int Mayor_150 = 0; \n    int negativos = 0;\n    float promedio_P = 0.0; \n    int contador = 1; \n    int num_p = 0;  \n    for(contador = 0; contador < 10;)\n    {\n     int numero = 0;\n     printf(\"\\nIngrese por favor el numero: \");\n     scanf(\"%i\", &numero);\n     if(numero != 0){\n         if(numero > 150){\n             ++Mayor_150;    \n         }\n         if(numero > Mayor){\n             Mayor = numero;    \n         }else if(numero < menor){\n             menor = numero;    \n         }\n         if(numero > 0){\n             ++num_p;\n             promedio_P += numero; \n         }else{\n             ++negativos;          \n         }\n         ++contador;\n         }\n     }\n     printf(\"\\n***Fin del Ciclo***\\n\");\n     promedio_P = promedio_P / num_p;\n     printf(\"\\nCantidad de numeros mayores a 150: %i\", Mayor_150);\n     printf(\"\\nNumero mayor: %i  Numero menor: %i\", Mayor, menor);   \n     printf(\"\\nCantidad de numeros negativos encontrador: %i\", negativos);\n     printf(\"\\nPromedio positivos encontrados: %f\", promedio_P);\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__MergeSort.2.c", "original_string": "void main()\n{\n    int n,i;\n    printf(\"\\nEnter the number of elements in the array:\");\n    scanf(\"%d\",&n);\n    printf(\"\\nEnter the elements of the array:\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&ARR[i]);\n    }\n    MergeSort(ARR,0,n-1);\n    printf(\"\\nThe sorted array is:\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\t%d\",ARR[i]);\n    }\n}"}
{"author": "rgautam320", "file": "Data-Structure__main.0.c", "original_string": "int main()\n{\n    int i, ele, loc, n;\n    printf(\"Enter the length of array\\n\");\n    scanf(\"%d\", &n);\n    printf(\"Enter Array Elements\\n\");\n    int arr[50];\n    for(i = 0; i<n; i++)\n    {\n        scanf(\"%d\", &arr[i]);\n    }\n    for(i = 0; i<n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n Enter element to inset\\n\");\n    scanf(\"%d\", &ele);\n    printf(\"Enter location to insert\\n\");\n    scanf(\"%d\", &loc);\n    for(i = n-1; i>=loc; i-- )\n    {\n        arr[i+1] = arr[i];\n    }\n    arr[loc] = ele;\n    for(i = 0; i<=n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    int m;\n    printf(\"\\nEnter the position of element to delete\\n\");\n    scanf(\"%d\", &m);\n    for(i = m; i<n; i++)\n    {\n        arr[i] = arr[i+1];\n    }\n    for(i = 0; i<n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\nArray in Reverse Order: \\n\");\n    for(i = n-1; i>=0; i--)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__switch.1.c", "original_string": "void delay(int ct)\n{\n    for(int i=0;i<ct;++i)\n    {\n        for(int j=0;j<6000;j++)\n        {}\n    }\n}"}
{"author": "RafaelFelisbino-hub", "file": "FOR-exercices__Exercicio7FOR.0.c", "original_string": "int main() \n{\n    float altura = 0,maioralt = 0,menoralt = 999,mediamulher = 0,mediaalt = 0,maiorhomem = 0,menorhomem = 999,quantF = 0;\n    char sexo;\n    int i;\n    system(\"color 17\");\n    for (i = 0; i < 4; i++) \n    {\n        printf(\"Digite sua altura separado por ponto:Ex: 1.00  \");\n        scanf_s(\"%f\", &altura);\n        (void)getchar();\n        printf(\"Digite seu sexo: M ou F:  \");\n        scanf_s(\"%c\", &sexo,1);\n        sexo = toupper(sexo);\n        if (altura < menoralt) \n        {\n            menoralt = altura;\n        }\n        if (altura > maioralt) \n        {\n            maioralt = altura;\n        }\n        if (sexo == 'F') \n        {\n            quantF++;\n            mediamulher += altura;\n        }\n        if (sexo == 'M' && altura < menorhomem) \n        {\n            menorhomem = altura;\n        }\n        if (sexo == 'M' && altura > maiorhomem)\n        {\n            maiorhomem = altura;\n        }\n        mediaalt += altura;\n    }\n    if (mediamulher != 0)\n    {\n        mediamulher = mediamulher / quantF;\n    }\n    mediaalt = mediaalt / i;\n    printf(\"\\n\\n\");\n    printf(\"A maior altura da turma e:  %.2f\\n\", maioralt);\n    printf(\"A maior altura da turma e:  %.2f\\n\", menoralt);\n    printf(\"A media de altura das mulheres e:  %.2f\\n\", mediamulher);\n    printf(\"A maior altura dos homens e:  %.2f\\n\", maiorhomem);\n    printf(\"A menor altura dos homens e:  %.2f\\n\", menorhomem);\n    printf(\"A media de altura da turma e:  %.2f\\n\", mediaalt);\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__27_Merging_2_array_sorted.0.c", "original_string": "int main()\n{\n  int i=0,j=0,k=0,len_array1=0,len_array2=0,temp=0;\n  printf(\"Enter Length of array1 and array2\");\n  scanf(\"%d%d\",&len_array1,&len_array2);\n  int array1[len_array1],array2[len_array2],array3[len_array1+len_array2];\n  printf(\"Enter Element of Array1\\n\");\n  for(i=0; i<len_array1; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  printf(\"Enter Element of Array2\\n\");\n  for(i=0; i<len_array2; i++)\n  {\n    scanf(\"%d\",&array2[i]);\n  }\n  for(i=0;i<len_array1;i++)\n  {\n    array3[j] = array1[i];\n    j++;\n  }\n  for(i=0;i<len_array2;i++)\n  {\n    array3[j] = array2[i];\n    j++;\n  }\n  for(i=0;i<len_array1+len_array2;i++)\n  {\n    printf(\"%d \",array3[i]);\n  }\n  printf(\"After Sorting\\n\");\n  for(i=0;i<len_array1+len_array2;i++)\n  {\n    for(j=i+1;j<len_array1+len_array2;j++)\n    {\n      if(array3[i] > array3[j])\n      {\n        temp = array3[i];\n    array3[i] = array3[j];\n    array3[j] = temp;\n      }\n    }  \n  }\n  for(i=0;i<len_array1+len_array2;i++)\n  {\n    printf(\"%d \",array3[i]);\n  }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__MergeSort.0.c", "original_string": "void Merge(int ARR[],int BEG,int MID,int END)\n{\n    int k=0,I=BEG,J=MID+1,INDEX=BEG;\n    while(I<=MID && J<=END)\n    {\n        if(ARR[I]<ARR[J])\n        {\n            TEMP[INDEX]=ARR[I];\n            I=I+1;\n        }\n        else\n        {\n            TEMP[INDEX]=ARR[J];\n            J=J+1;\n        }\n        INDEX=INDEX+1;\n    }\n    if(I>MID)\n    {\n        while(J<=END)\n        {\n            TEMP[INDEX]=ARR[J];\n            J=J+1;\n            INDEX=INDEX+1;\n        }\n    }\n    else\n    {\n        while(I<=MID)\n        {\n            TEMP[INDEX]=ARR[I];\n            I=I+1;\n            INDEX=INDEX+1;\n        }\n    }\n    for(k=BEG;k<INDEX;k++)\n    {\n        ARR[k]=TEMP[k];\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSL__tls_cache.4.c", "original_string": "void tlsFreeCache(TlsCache *cache)\n{\n   uint_t i;\n   if(cache != NULL)\n   {\n      for(i = 0; i < cache->size; i++)\n      {\n         tlsFreeSessionState(&cache->sessions[i]);\n      }\n      osDeleteMutex(&cache->mutex);\n      tlsFreeMem(cache);\n   }\n}"}
{"author": "kalpa96", "file": "Struct__prese.0.c", "original_string": "int main() {\n    struct Marks marks[5];\n    int i;\n    for(i=0;i<1;i++){\n        printf(\"Student %d\\n\",i+1);\n        printf(\"Enter ID no. : \");\n        scanf(\"%d\",&marks[i].ID_no);\n        printf(\"Enter name : \");\n        scanf(\"%s\",&marks[i].name);\n        printf(\"Enter Chemistry marks : \");\n        scanf(\"%f\",&marks[i].chem_marks);\n        printf(\"Enter Maths marks : \");\n        scanf(\"%f\",&marks[i].maths_marks);\n        printf(\"Enter Physics marks : \");\n        scanf(\"%f\",&marks[i].phy_marks);\n        printf(\"\\n\");\n    }\n    for(i=0;i<5;i++) {\n        printf(\"Student %d\\n\",i+1);\n        float percentage = (marks[i].chem_marks + marks[i].maths_marks + marks[i].phy_marks)/3.0;\n        printf(\"Percentage : %f\\n\", percentage);\n    }\n  return 0;\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Insert_at_begin_In_the_Single_Linked_LIst.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"Enter 1 for Creation or 0 for Termination:\");\n    scanf(\"%d\",&choice);\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->ptr = NULL;\n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->ptr = newnode;\n            temp = newnode;\n        }\n        printf(\"DO you want to enter more?(1/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_node(temp);\n    insert_at_begin(head,temp);\n    getch();    \n}"}
{"author": "revathy16296", "file": "rtos_lab_asssignment_1__9_string_cmp.0.c", "original_string": "int main(int argc,char *argv [])\n{\n    char s[SIZE],b[SIZE];\n    int a,i;\n    if (argc<2)\n    {printf(\"enter the format ./'name',stringFFF,choice'1 or 0'\");}\n    strcpy(s,argv[1]);\n    n=strlen(s);\n    strcpy(b,s);\n    a=atoi(argv[2]);\n    if (a==0)\n    {choice_zero(b);}\n    else if(a==1)\n    {choice_one(b);}\n    else\n    {printf(\"\\nthe length of the given string is %d\",(n-3));}\n    return 0;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__brackets.1.c", "original_string": "int     brackets(char   *str, char *store)\n{\n    int     ctrl;\n    int     top;\n    ctrl = 0;\n    top = -1;\n    while (str[ctrl])\n    {\n        if (str[ctrl] == '(' || str[ctrl] == '[' || str[ctrl] == '{')\n        {\n            top++;\n            store[top] = str[ctrl];\n        }\n        if (str[ctrl] == ')' || str[ctrl] == ']' || str[ctrl] == '}')\n        {\n            if (!store[top])\n                return(0);\n            if (!matching(store[top],str[ctrl]))\n                return (0);\n            else\n            {\n                store[top] = 0;\n                top--;\n            }\n        }\n        ctrl++;\n    }\n    if (store[top] == 0)\n        return(1);\n    return (0);\n}"}
{"author": "andi-s0106", "file": "sorting_algorithms__100-shell_sort.0.c", "original_string": "void shell_sort(int *array, size_t size)\n{\n    int limit;\n    int idx;\n    int gap;\n    int up;\n    if (size < 2)\n        return;\n    up = (int) size;\n    for (gap = 1; gap < up / 3; gap = gap * 3 + 1)\n    {}\n    for (limit = 0; limit < up;)\n    {\n        idx = limit;\n        while (idx < up)\n        {\n            if (idx + gap < up && array[idx] > array[idx + gap])\n                swap(array, gap, idx);\n            idx = idx + gap;\n        }\n        limit++;\n        if (limit == gap)\n        {\n            gap = gap / 3;\n            limit = 0;\n            print_array(array, size);\n        }\n        if (gap < 1)\n            break;\n    }\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__main.1.c", "original_string": "void SystemClock_Config(void)\n{\n  RCC_OscInitTypeDef RCC_OscInitStruct;\n  RCC_ClkInitTypeDef RCC_ClkInitStruct;\n  __HAL_RCC_PWR_CLK_ENABLE();\n  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);\n  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;\n  RCC_OscInitStruct.HSEState = RCC_HSE_ON;\n  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;\n  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;\n  RCC_OscInitStruct.PLL.PLLM = 4;\n  RCC_OscInitStruct.PLL.PLLN = 168;\n  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;\n  RCC_OscInitStruct.PLL.PLLQ = 4;\n  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)\n  {\n    _Error_Handler(__FILE__, __LINE__);\n  }\n  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK\n                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;\n  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;\n  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;\n  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)\n  {\n    _Error_Handler(__FILE__, __LINE__);\n  }\n  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);\n  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);\n  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__2.5.c", "original_string": "void reverse(QUEUE* q1, QUEUE* q2, int n)                                   \n{\n    if(n == 0)\n        return;\n    int x = dequeue(q1);\n    reverse(q1, q2, n - 1);\n    enqueue(q2, x);\n}"}
{"author": "254Odeke", "file": "Operating-Systems_Lab__Page_Replacement_Alg_FIFO_Simulation.0.c", "original_string": "void main(){\nint a[5],b[20],n,p=0,q=0,m=0,h,k,i,q1=1; char f='F';\nprintf(\"Enter the Number of Pages: \"); \nscanf(\"%d\",&n);\nprintf(\"Enter %d Page Numbers:\",n); for(i=0;i<n;i++)\nscanf(\"%d\",&b[i]);\nfor(i=0;i<n;i++)\n{if(p==0)\n{\nif(q>=3)\nq=0;\na[q]=b[i];\nq++;\nif(q1<3)\n{\nq1=q;\n}\n}\nprintf(\"\\n%d\",b[i]);\nprintf(\"\\t\");\nfor(h=0;h<q1;h++)\nprintf(\"%d\",a[h]);\nif((p==0)&&(q<=3))\n{\nprintf(\"-->%c\",f);m++;\n}\np=0;\nfor(k=0;k<q1;k++)\n{\nif(b[i+1]==a[k])\np=1;\n}\n}\nprintf(\"\\nNo of faults:%d\",m); \ngetch();\n}"}
{"author": "augustogunsch", "file": "jackc__parser-statements.1.c", "original_string": "STATEMENT* parsestatementnullified(PARSER* p) {\n    if(equals(p, \"let\")) return parselet(p);\n    if(equals(p, \"if\")) return parseif(p);\n    if(equals(p, \"while\")) return parsewhile(p);\n    if(equals(p, \"do\")) return parsedo(p);\n    if(equals(p, \"return\")) return parsereturn(p);\n    return NULL;\n}"}
{"author": "2security", "file": "Pointer__16ReverseString.2.c", "original_string": "int main()\n    {\n        char str[30],*t;\n        printf(\"\\n Enter the string\");\n        scanf(\"%s\",str);\n        printf(\"\\n Reverse of the string is:: \");\n        t=Mystrrev(str);\n        puts(t);\n    }"}
{"author": "paawankohli", "file": "DSA-LAB__q21.0.c", "original_string": "void strrev(char *str)\n{\n    int i = strlen(str) - 1, j = 0;\n    char ch;\n    while (i > j)\n    {\n        ch = str[i];\n        str[i] = str[j];\n        str[j] = ch;\n        i--;  j++;\n    }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e31.0.c", "original_string": "int main(int argc, char *argv[]) {\n    char name[80];\n    int lotMax; \n    int contLot;\n    int tipEnt;\n    int contPag;\n    int contEsco;\n    int contIntMax;\n    int contInt;\n    int contMeiaMax;\n    int contMeia;\n    float priceMeia;\n    float pricePag;\n    float troco;\n    float lucro;\n    float price;\n    printf(\"Digite o nome do evento (utilize de ( / ) para espaco):\\n\");\n    scanf(\"%s\", &name);\n    do{\n    printf(\"\\nDigite a capacidade maxima de pessoas(somente multiplos de 5):\\n\");\n    scanf(\"%i\" ,&lotMax);\n    }while (lotMax%5!=0 || lotMax <= 0);\n    do{\n    printf(\"\\nDigite o preco do ingresso:\\n\");\n    scanf(\"%f\" ,&price);\n    }while (price<0);\n    priceMeia=price/2;\n    contLot=lotMax;\n    lucro=0;\n    contIntMax=lotMax*0.6;\n    contInt=contIntMax;\n    contMeiaMax=lotMax*0.4;\n    contMeia=contMeiaMax;\n    printf(\"\\n\\nEvento: %s\\n\" ,name);\n    do{\n        do{\n            printf(\"\\nDigite 1 para comprar um ingresso inteira.\\nDigite 2 para comprar um ingresso meia.\\n\");\n            scanf(\"%i\" ,&tipEnt);\n            switch(tipEnt){\n                case 1:\n                    contEsco=0;\n                    if(contInt>0){\n                        contLot--;\n                        contInt--;\n                        do{\n                            printf(\"\\nVoce deve pagar %f.\\n\" ,price);\n                            printf(\"Digite o preco pago:\\n\");\n                            scanf(\"%f\" ,&pricePag);\n                            if(pricePag<price){\n                                contPag=0;\n                                printf(\"\\nVoce nao pagou o suficiente, pague novamente.\\n\");\n                            }\n                            if(pricePag==price){\n                                contPag=1;\n                                printf(\"\\nVoce efetuou seu pagamento, Obrigado e volte sempre\\n\");\n                                lucro=lucro+price;\n                            }\n                            if(pricePag>price){\n                                contPag=1;\n                                troco=pricePag-price;\n                                printf(\"\\nVoce recebe de troco %f.\\n\\n\" ,troco);\n                                lucro=lucro+price;\n                            }\n                        }while(contPag==0);\n                    }\n                    else{\n                        printf(\"\\nAcabou os ingressos do tipo inteiro.\\n\");\n                    }\n                    break;\n                case 2:\n                    contEsco=0;\n                    if(contMeia>0){\n                        contLot--;\n                        contMeia--;\n                        do{                         \n                            printf(\"\\nVoce deve pagar %f.\\n\" ,priceMeia);\n                            printf(\"Digite o preco pago:\\n\");\n                            scanf(\"%f\" ,&pricePag);\n                            if(pricePag<priceMeia){\n                                contPag=0;\n                                printf(\"\\nVoce nao pagou o suficiente, pague novamente.\\n\\n\");\n                            }\n                            if(pricePag==priceMeia){\n                                contPag=1;\n                                printf(\"\\nVoce efetuou seu pagamento, Obrigado e volte sempre\\n\");\n                                lucro=lucro+priceMeia;\n                            }\n                            if(pricePag>priceMeia){\n                                contPag=1;\n                                troco=pricePag-priceMeia;\n                                printf(\"\\nVoce recebe de troco %f.\\n\\n\" ,troco);\n                                lucro=lucro+priceMeia;\n                            }\n                        }while(contPag==0);\n                    }\n                    else{\n                        printf(\"\\nAcabou os ingressos do tipo meia.\\n\");\n                    }\n                    break;\n                default:\n                    contEsco=1;\n                    printf(\"\\nDigite novamente sua escolha.\\n\\n\");\n                    break;\n            }\n        }while(contEsco==1);\n        printf(\"\\n\\nEvento: %s\\n\" ,name);\n        printf(\"\\nAinda se tem %i ingressos do tipo inteiro.\\n\" ,contInt);\n        printf(\"Ainda se tem %i ingressos do tipo meia.\\n\" ,contMeia);\n        printf(\"Voce tem um lucro de %f.\\n\\n\" ,lucro);\n    }while (contLot>0);\n    printf(\"\\n\\nEvento: %s\\n\" ,name);   \n    printf(\"\\nacabou os ingressos.\\n\");\n    printf(\"voce teve um lucro total de %f.\\n\" ,lucro);\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__raggedArray.0.c", "original_string": "int main()\n{\n    int rowNum;\n    printf(\"Enter no. of rows:\");\n    scanf(\"%d\", &rowNum);\n    int **table = calloc(rowNum, sizeof(int*));\n    for(int i = 0 ; i < rowNum ; i++)\n    {\n        int colSize;\n        printf(\"Enter no. of columns of %dth row: \", i + 1);\n        scanf(\"%d\", &colSize);\n        table[i] = calloc(colSize + 1, sizeof(int));\n        table[i][0] = colSize;  \n        printf(\"Enter %d elements: \", colSize);\n        for(int j = 1 ; j <= table[i][0] ; j++)\n            scanf(\"%d\", &table[i][j]);\n    }\n    for(int i = 0 ; i < rowNum ; i++)\n    {\n        int colSize = table[i][0];\n        for(int j = 1 ; j <= colSize ; j++)\n            printf(\"%d\\t\", table[i][j]);\n        printf(\"\\n\");\n        free(table[i]);\n    }\n    free(table);\n}"}
{"author": "haon1026", "file": "linux-programming__fork.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    printf(\"before fork-1-\\n\");\n    printf(\"before fork-2-\\n\");\n    printf(\"before fork-3-\\n\");\n    printf(\"before fork-4-\\n\");\n    pid_t pid = fork();\n    if(pid == -1)\n    {\n        perror(\"fork error\");\n        exit(1);\n    }\n    else if(pid == 0)\n    {\n        printf(\"child is created\\n\");\n    }\n    else if(pid > 0)\n    {\n        printf(\"parent process:child is %d\\n\", pid);\n    }\n    printf(\"end of file\\n\");\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BST.6.c", "original_string": "void postorder(struct tree* root)\n{\n    if(root!=NULL)\n    {\n        postorder(root->left);\n        postorder(root->right);\n        printf(\"\\t%d\",root->val);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__duplicateLL.3.c", "original_string": "void removeDuplicate(nptr head)\n{\n    if (head == NULL || head -> next == NULL)\n        return;\n    nptr temp1 = head, temp2 = head -> next;\n    if (temp1 -> data == temp2 -> data)\n    {\n        temp1 -> next = temp2 -> next;\n        free(temp2);\n    }\n    else\n        temp1 = temp1 -> next;\n    removeDuplicate(temp1);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListAllOperations.7.c", "original_string": "struct Node *deleteLastNode(struct Node *head)\n{\n     struct Node *p = head;\n     struct Node *q = head->next;\n     while (q->next != NULL)\n     {\n          p = p->next;\n          q = q->next;\n     }\n     p->next = NULL;\n     free(q);\n     return head;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__singlyLL.5.c", "original_string": "int deleteFront(nptr &head)\n{\n    if (head == NULL)\n        return -1;\n    nptr temp = head;\n    head = head -> next;\n    int x = temp -> data;\n    free(temp);\n    return x;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__doublyLinkedList.5.c", "original_string": "struct Node *deleteInBetween(struct Node *head, int index)\n{\n     struct Node *p = head;\n     struct Node *q = head->next;\n     for (int i = 0; i < index - 1; i++)\n     {\n          p = p->next;\n          q = q->next;\n     }\n     p->next = q->next;\n     q->next->prev = p;\n     free(q);\n     return head;\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b4.1.c", "original_string": "int main() {\n    char *filename = \"Answers.txt\";\n    FILE *f = fopen(filename, \"r\");\n    size_t *yes = calloc(sizeof(size_t), 26);\n    char *person = NULL; size_t n = 0;\n    size_t num = 0; size_t count = 0;\n    while (getline(&person, &n, f) != -1) {\n        if (strcmp(person, \"\\n\") == 0) {\n            count += count_yes(yes, num);\n            free(yes); yes = calloc(sizeof(size_t), 26);\n            num = 0;\n        } else {\n            num++;\n            for (size_t i = 0; i < strlen(person) - 1; i++)\n                yes[person[i] - 'a']++;\n        }\n    }\n    printf(\"Answer: %zu\\n\", count);\n    fclose(f);\n    return 0;\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise20.1.c", "original_string": "int main(void) {\n    int count;\n    int n1 = 5,n2=10;\n    int *ptr;\n    int arr_size_used = 0;\n    ptr = PrintReverseInclusive(n1,n2,&arr_size_used);\n    printf(\"Output Array = \");\n    for(count=0;count<arr_size_used;count++)\n    {\n        printf(\"%d \",ptr[count]);\n    }\n    printf(\"\\nOutput Array Size = %d\",arr_size_used);\n    return 0;\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__test.2.c", "original_string": "void make_crc32_table() {\n    unsigned int c;\n    int i = 0;\n    int bit = 0;\n    for(i = 0; i < 256; i++)\n    {\n        c  = (unsigned int)i;\n        for(bit = 0; bit < 8; bit++)\n        {\n            if(c&1)\n            {\n                c = (c >> 1)^(0xEDB88320);\n            }\n            else\n            {\n                c =  c >> 1;\n            }\n        }\n        crc32_table[i] = c;\n    }\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__test.5.c", "original_string": "unsigned int crc32cyy(unsigned char *data,int len) {\n    unsigned int crc = 0xFFFFFFFF;\n    int i;\n    for (i=0;i<len;i++) {\n        crc = crc ^ data[i];\n        int j;\n        for (j=7;j>=0;j--) {\n            crc = (crc >> 1) ^ (0xEDB88320 & (-(crc & 1)));\n        }\n    }\n    return ~crc;\n}"}
{"author": "Dhruvik-Chevli", "file": "DAALab__bfs.3.c", "original_string": "void enqueue(struct Queue* queue,int ele)\n{\n    if (isFull(queue))\n    {\n        return;\n    }\n    if (queue->front==-1)\n    {\n        queue->front=0;\n    }\n    queue->rear=(queue->rear+1)%queue->cap;\n    queue->arr[queue->rear]=ele;\n    queue->size++;\n    return;\n}"}
{"author": "sdukesameer", "file": "c__mult_mat.3.c", "original_string": "void dispMat(int sum[][NCOLS],int r1,int c2)\n{\n    for(int i=0;i<r1;i++)\n    {\n        for(int j=0;j<c2;j++)\n        {\n            printf(\"%d \",sum[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__sum1.1.c", "original_string": "void* sum_array(void *a[SIZE])\n{\n    pthread_mutex_lock(&mutex);\n    float sum=0;\n    int *ar=(int *)a;\n    printf(\"inside the first thread\\n\");\n    for(i=0;i<SIZE;i++)\n    {\n        sum += ar[i];\n        printf(\"%f\\t\",sum);\n    }\n    printf(\"the sum is %f\\n\",sum);\n    float average;\n    average=sum/10;\n    printf(\"the average is %f\\n\",average);\n    pthread_mutex_unlock(&mutex);\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_03.5.c", "original_string": "int search(int a[], int k, int size)\n{\n    int str = 0; \n    int end = size - 1;\n    int b = binary_bitonic(a, str, end);\n    int bs = binary_search(a, 0, b, k);\n    if(bs!=-1)\n    {\n        printf(\"search succesful : normal\\n\");  \n        return bs;\n    }\n    else if (bs == -1)\n    {\n        int rbs = binary_search_rev(a, b, end, k);\n            return rbs;\n    }\n}"}
{"author": "earth429", "file": "mulpre__mulprec1.2.c", "original_string": "void dispNumberZeroSuppress(struct NUMBER *a){\n    int i;\n    if(a->sign == 1) {\n        printf(\"+\");\n    } else {\n        printf(\"-\");\n    }\n    for (i = KETA - 1; i >= 0; i--) {\n        if(a->n[i] != 0){\n            break;\n        }\n        if(i == 0){\n            printf(\"%2d\", a->n[i]);\n        }\n    }\n    for (; i >= 0;i--) {\n        printf(\"%2d\", a->n[i]);\n    } \n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_39.0.c", "original_string": "int main()\n{\n    int lin, col, n, num;\n    printf(\"Digite a quantidade de linhas: \");\n    scanf(\"%d\", &n);\n    printf(\"\\n\");\n    for(lin=0;lin<=n;lin++){\n        for(col=n-lin;col!=0;col--){\n            printf(\"   \");\n        }\n        for(col=0;col<=lin;col++){\n            num = comb(lin, col);\n            printf(\" %4d \", num);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}"}
{"author": "2security", "file": "File__5CompareTwoFile.0.c", "original_string": "int CompareFile(FILE *fptr1,FILE *fptr2)\n    {\n    char ch1,ch2;\n    int n=1;\n    ch1=getc(fptr1);\n    ch2=getc(fptr2);\n    while(ch1!=EOF&&ch2!=EOF)\n        {\n        pos++;\n        if(ch1 =='\\n'&&ch2=='\\n') \n            { \n            line++; \n            pos = 0; \n            }    \n        if(ch1!=ch2)\n            {\n            n=0;\n            error++;\n            }\n        ch1=getc(fptr1);\n        ch2=getc(fptr2);\n        }\n    return n;\n    }"}
{"author": "sdukesameer", "file": "dsa__dll-ins-seq-sor-del-a.1.c", "original_string": "void seq_insertion(list** head, int n)\n{\n    list* dll=(list*)malloc(sizeof(list));\n    dll->key=n;\n    dll->next=*head;\n    dll->prev=NULL;\n    if (*head!=NULL)\n        (*head)->prev=dll;\n    *head=dll;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__rtc.0.c", "original_string": "int main()\n{\n    lcd_config();\n    CCR =1<<0;\n    PREINT = 456;\n    PREFRAC = 25024;\n    HOUR = 7;\n    MIN = 0;\n    SEC = 0;\n    while(1)\n    {\n        lcd_cmd(0x80);\n        lcd_num(HOUR);\n        lcd_data(':');\n        lcd_cmd(0x83);\n        lcd_num(MIN);\n        lcd_data(':');\n        if(SEC < 9)\n        {\n            lcd_cmd(0x86);\n            lcd_data('0');\n            lcd_num(SEC);\n        }else{\n            lcd_cmd(0x86);\n            lcd_num(SEC);\n        }\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__Md_Sameer_13000119114.1.c", "original_string": "stack* initialise_stack(unsigned int x){\n    stack* ret=(stack*) malloc(sizeof(stack));\n    ret->top=-1;\n    ret->size=x;\n    ret->arr=(int*)malloc(x * sizeof(int));\n    return ret;\n}"}
{"author": "sdukesameer", "file": "dsa__dll-ins-seq-sor-del.3.c", "original_string": "void deletion(node** head, node* del)\n{\n    if (*head==del)\n        *head=del->next;\n    else \n    {\n        if (del->next!=NULL)\n            del->next->prev=del->prev;\n        if (del->prev!=NULL)\n            del->prev->next=del->next;\n    }\n    free(del);\n}"}
{"author": "earth429", "file": "mulpre__kakezan.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a, b, c;\n    int x, y;\n    int i;\n    srandom(time(NULL));\n    for (i = 0; i < 10;i++){\n        x = (random() % 1000);\n        y = (random() % 1000);\n        setInt(&a, x);\n        setInt(&b, y);\n        printf(\"x = %d\\ny = %d\\nx * y = %d\\n\", x, y, x * y);\n        dispNumberZeroSuppress(&a);\n        puts(\"\");\n        dispNumberZeroSuppress(&b);\n        puts(\"\");\n        multiple(&a, &b, &c);\n        setText(&c, x * y);\n        checkText();\n    }\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__os.15.c", "original_string": "CLASS* getosclass(CLASS* os, const char* name) {\n    CLASS* curr = os;\n    while(curr != NULL) {\n        if(!strcmp(curr->name, name))\n            return curr;\n        curr = curr->next;\n    }\n    return NULL;\n}"}
{"author": "MFarid94", "file": "Assignment4__Exercise11.1.c", "original_string": "int main(void){\n    setvbuf(stdout, NULL ,_IONBF , 0);\n    setvbuf(stderr, NULL ,_IONBF , 0);\n    unsigned int number;\n    unsigned short *ptr = (unsigned short *)&number;\n    printf(\"Enter number: \");\n    scanf(\"%d\",&number);\n    printf(\"Two 16-bits of 32-bits integer number before swapping are %hi  and  %hi\\n\",*ptr,*(ptr+1));\n    SwapBits(&number);\n    printf(\"Two 16-bits of 32-bits integer number after swapping are %hi  and  %hi\",*ptr,*(ptr+1));\n    return 0;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__count_vowels.1.c", "original_string": "int main()\n{\n    char arr[30];\n    int iRet = 0;\n    printf(\"Please enter the string\\n\");\n    scanf(\"%[^'\\n']s\",arr);\n    iRet = CountVowels(arr);\n    printf(\"Total number vowels are %d\\n\",iRet);\n    return 0;\n}"}
{"author": "earth429", "file": "mulpre__divBy10.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a;\n    struct NUMBER b, c, d;\n    srandom(time(NULL));\n    clearByZero(&a);\n    clearByZero(&b);\n    clearByZero(&c);\n    clearByZero(&d);\n    printf(\"a = \");\n    dispNumber(&a);\n    printf(\"\\n\");\n    printf(\"b = \");\n    dispNumber(&b);\n    printf(\"\\n\");\n    printf(\"c = \");\n    dispNumber(&c);\n    printf(\"\\n\");\n    printf(\"d = \");\n    dispNumber(&d);\n    printf(\"\\n\");\n    setRnd(&a, 3);\n    printf(\"a = \");\n    dispNumber(&a);\n    printf(\"\\n\");\n    printf(\"\u3042\u307e\u308a=%d\\n\", divBy10(&a, &b));\n    printf(\"b = \");\n    dispNumber(&b);\n    printf(\"\\n\");\n    printf(\"\u3042\u307e\u308a=%d\\n\", divBy10(&b, &c));\n    printf(\"c = \");\n    dispNumber(&c);\n    printf(\"\\n\");\n    printf(\"\u3042\u307e\u308a=%d\\n\", divBy10(&c, &d));\n    printf(\"d = \");\n    dispNumber(&d);\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__test.1.c", "original_string": "static void init_crc_table(void)\n{\n    unsigned int c;\n    unsigned int i, j;\n    for (i = 0; i < 256; i++) {\n        c = (unsigned int)i;\n        for (j = 0; j < 8; j++) {\n            if (c & 1)\n                c = 0xedb88320L ^ (c >> 1);\n            else\n                c = c >> 1;\n        }\n        crc_table[i] = c;\n    }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListAllOperations.9.c", "original_string": "int main()\n{\n     struct Node *head;\n     struct Node *second;\n     struct Node *third;\n     struct Node *fourth;\n     head = (struct Node *)malloc(sizeof(struct Node));\n     second = (struct Node *)malloc(sizeof(struct Node));\n     third = (struct Node *)malloc(sizeof(struct Node));\n     fourth = (struct Node *)malloc(sizeof(struct Node));\n     head->data = 7;\n     head->next = second;\n     second->data = 11;\n     second->next = third;\n     third->data = 70;\n     third->next = fourth;\n     fourth->data = 22;\n     fourth->next = NULL;\n     printf(\"\\nLinked list before insertion\\n\");\n     linkedListTraversal(head);\n     head = insertAfterNode(head, second, 45);\n     printf(\"\\nLinked list after insertion\\n\");\n     linkedListTraversal(head);\n     return 0;\n}"}
{"author": "fikepaci", "file": "sorting_algorithms__103-merge_sort.2.c", "original_string": "void merge(int *array, int low, int mid, int high, int *temp)\n{\n    int left;\n    int right;\n    int i;\n    left = low;\n    right = mid + 1;\n    printf(\"Merging...\\n\");\n    printf(\"[left]: \");\n    print_array(&array[low], mid + 1);\n    printf(\"[right]: \");\n    print_array(&array[mid + 1], high - mid);\n    for (i = low; left <= mid && right <= high; i++)\n    {\n        if (array[left] <= array[right])\n            temp[i] = array[left++];\n        else\n            temp[i] = array[right++];\n    }\n    while (left <= mid)\n        temp[i++] = array[left++];\n    while (right <= high)\n        temp[i++] = array[right++];\n    for (i = 0; i <= high; i++)\n        array[i] = temp[i];\n    printf(\"[Done]: \");\n    print_array(temp, i);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q3_merge.0.c", "original_string": "void add(nodeptr head,int x){\n    nodeptr temp=malloc(sizeof(node));\n    nodeptr t;\n    temp->data=x;\n    temp->link=head;\n        for(t=head;t->link!=head;t=t->link);\n        t->link=temp;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad7.1.c", "original_string": "int dat(pozicija head)\n{\n    FILE* fp = NULL;\n    fp = fopen(\"postfix.txt\", \"r\");\n    char operacija[15];\n    if (fp == NULL)\n    {\n        printf(\"Neuspjesno otvaranje datoteke!\\n\");\n        return 1;\n    }\n    while (!feof(fp))\n    {\n        int br = 0;\n        int procitani = sscanf(fp, \"%d\", &br);\n        if (!procitani) {\n            if (!strcmp(procitani, \"+\"))\n                zbroj(head);\n            else if (!strcmp(procitani, \"-\"))\n                razlika(head);\n            else if (!strcmp(procitani, \"*\"))\n                umnozak(head);\n            else if (!strcmp(procitani, \"/\"))\n                kvocijent(head);\n        }\n        else\n            push(head, procitani);\n    }\n    fclose(fp);\n    return 0;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad7.2.c", "original_string": "int push(pozicija head, int element)\n{\n    pozicija novi;\n    novi = (pozicija)malloc(sizeof(struct stog));\n    if (novi == NULL)\n    {\n        printf(\"Neuspjesna alokacija memorije!\\n\");\n        return 1;\n    }\n    novi->el = element;\n    novi->next = head->next;\n    head->next = novi;\n    return 0;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_nus.5.c", "original_string": "uint32_t ble_nus_data_send(ble_nus_t * p_nus,\n                           uint8_t   * p_data,\n                           uint16_t  * p_length,\n                           uint16_t    conn_handle)\n{\n    ret_code_t                 err_code;\n    ble_gatts_hvx_params_t     hvx_params;\n    ble_nus_client_context_t * p_client;\n    VERIFY_PARAM_NOT_NULL(p_nus);\n    err_code = blcm_link_ctx_get(p_nus->p_link_ctx_storage, conn_handle, (void *) &p_client);\n    VERIFY_SUCCESS(err_code);\n    if ((conn_handle == BLE_CONN_HANDLE_INVALID) || (p_client == NULL))\n    {\n        return NRF_ERROR_NOT_FOUND;\n    }\n    if (!p_client->is_notification_enabled)\n    {\n        return NRF_ERROR_INVALID_STATE;\n    }\n    if (*p_length > BLE_NUS_MAX_DATA_LEN)\n    {\n        return NRF_ERROR_INVALID_PARAM;\n    }\n    memset(&hvx_params, 0, sizeof(hvx_params));\n    hvx_params.handle = p_nus->tx_handles.value_handle;\n    hvx_params.p_data = p_data;\n    hvx_params.p_len  = p_length;\n    hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;\n    return sd_ble_gatts_hvx(conn_handle, &hvx_params);\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_rtx.13.c", "original_string": "bool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   uint16_t n;\n   OS_RESULT res;\n   if(timeout == INFINITE_DELAY)\n   {\n      res = os_sem_wait(event, 0xFFFF);\n   }\n   else\n   {\n      timeout = OS_MS_TO_SYSTICKS(timeout);\n      do\n      {\n         n = MIN(timeout, 0xFFFE);\n         res = os_sem_wait(event, n);\n         timeout -= n;\n      } while(res == OS_R_TMO && timeout > 0);\n   }\n   if(res == OS_R_OK || res == OS_R_SEM)\n   {\n      do\n      {\n         res = os_sem_wait(event, 0);\n      } while(res == OS_R_OK);\n      return TRUE;\n   }\n   else\n   {\n      return FALSE;\n   }\n}"}
{"author": "deepaliajabsingjadhav", "file": "file__read_whole_file.1.c", "original_string": "int main()\n{\n    char name[50] = {'\\0'};\n    printf(\"Enter file name\\n\");\n    scanf(\"%s\",name);\n    DisplayWholeFile(name);\n    return 0;\n}"}
{"author": "mandarvu", "file": "msc__problem54.0.c", "original_string": "void merge_string(char *source1, char *source2, char *target) {\n  while (*source1 != '\\0') {\n    *target = *source1;\n    source1++;\n    target++;\n  }\n  while (*source2 != '\\0') {\n    *target = *source2;\n    source2++;\n    target++;\n  }\n  *target = '\\0';\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica1-4a.0.c", "original_string": "int main(int argc, char * argv[]){\n    int status;\n    pid_t pid; \n    int n=0;\n    for (int i = 0; i < argc-1; i++){\n        switch ( fork() ){\n            case -1: \n                perror(\"fork error:\\n\");\n                fprintf(stderr, \"errno:  %i\\n\", errno); \n                exit(EXIT_FAILURE);\n            case 0: \n                printf(\"soy un proceso hijo con PID: %i; el PID de mi proceso padre es: %i\\n\", getpid(), getppid());\n                sleep(1);\n                n = atoi(argv[i+1]);\n                printf(\"el factorial de %i es %i\\n\", n, factorial(n));\n                sleep(1);\n                exit(EXIT_SUCCESS); \n        }\n        pid=wait(&status);\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__DemoFOTAUpdateWorkflow0.3.c", "original_string": "void fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)\n{\n  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;\n  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);\n}"}
{"author": "DanielSalis", "file": "AED1__teste5.6.c", "original_string": "int main(){\n    int op;\n    int agilidade;\n    int existe;\n    char nome;\n    TipoLista lista;\n    iniciarLista(&lista);\n    scanf(\"%d\", &op);\n    while(op==1){\n        scanf(\" %c %d\", &nome, &agilidade);\n        existe = existeNaLista(&lista, nome);\n        if(existe == 1)\n           inserirFim(&lista, nome, agilidade);\n        else\n            printf(\"soldado nao pode ser inserido duas vezes\\n\");\n        scanf(\"%d\", &op);\n    }\n    if(op == 2){\n        scanf(\" %c\", &nome);\n        existe = existeNaListaII(&lista, nome); \n        if(existe == 1){\n            printf(\"|| sorteio iniciado ||\\n\");\n            sortear(&lista, nome);\n        }\n        else{\n            if(existe == 2)\n                printf(\"grupo vazio\");\n            else\n                printf(\"soldado nao pertence ao grupo\");\n        }\n    }\n    return 0;\n}"}
{"author": "ankitraj311", "file": "450_babbar__4_0_1_2_array_GEEk.0.c", "original_string": "void array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__cNum.2.c", "original_string": "cNum multiply(cNum a, cNum b)\n{\n    cNum temp;\n    temp.real = a.real * b.real - a.imag * b.imag;\n    temp.imag = a.imag * b.real + a.real * b.imag;\n    return temp;\n}"}
{"author": "seefeesaw", "file": "Recursion__horners_rule.0.c", "original_string": "double e(int x,int n)\n{\n    static double p = 1, f = 1;\n    double r;\n    if(n == 0)\n    {\n        return 1;\n    }\n    r = e(x,n-1);\n    p = p * x;\n    f = f*n;\n    return r + p/f;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__bridge_mib_impl.0.c", "original_string": "error_t bridgeMibInit(void)\n{\n   TRACE_INFO(\"Initializing Bridge MIB base...\\r\\n\");\n   memset(&bridgeMibBase, 0, sizeof(bridgeMibBase));\n   bridgeMibBase.dot1dBaseType = BRIDGE_MIB_BASE_TYPE_TRANSPARENT_ONLY;\n   bridgeMibBase.dot1dStpProtocolSpecification = BRIDGE_MIB_PROTOCOL_SPEC_IEEE802_1D;\n   return NO_ERROR;\n}"}
{"author": "dle2005", "file": "File_Structure__heapsort.3.c", "original_string": "void readPage(FILE *fp, char *pagebuf, int pagenum) {\n    fseek(fp, PAGE_SIZE * pagenum, SEEK_SET);\n    fread(pagebuf, sizeof(char), PAGE_SIZE, fp);\n}"}
{"author": "ankitraj311", "file": "450_babbar__8_rotate_cyclically_by_1.1.c", "original_string": "void cyclic_rotate(int arr1[], int size_arr1)\n{\n  int last_element,i=0;\n  last_element = arr1[size_arr1-1];\n  for(i = size_arr1-1; i > 0; i--)\n    arr1[i] = arr1[i-1];\n  arr1[0] = last_element;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Two.2.c", "original_string": "void rem_file(int d,char name)\n{\n    if(isthere(d,name)==-1)\n        printf(\"file doesnot exist in the directory\");\n    else\n    {\n        temp=dir[d];\n        q=temp;\n        while(temp->next!=NULL)\n        {\n            if(temp->file==name)\n            {\n                if(temp==dir[d])\n                {\n                    dir[d]=dir[d]->next;\n                    free(temp);\n                    temp=dir[d];\n                }\n                else\n                {\n                    q->next=temp->next;\n                    free(temp);\n                    temp=q->next;\n                }\n            }\n            q=temp;\n            temp=temp->next;\n        }\n        if(temp->file==name)\n        {\n            q->next=NULL;\n            free(temp);\n        }\n    }\n}"}
{"author": "dishanp", "file": "DSA__q30.2.c", "original_string": "int main()\n{\n    int a, b ;\n    printf(\"Enter 2 variables a & b: \");\n    scanf(\"%d%d\", &a, &b);\n    printf(\"Value of a : %d\\nValue of b : %d\", a, b);\n    swapval(a, b);\n    swapref(&a, &b);\n    printf(\"\\n\\nAfter swapping by reference : \\n\");\n    printf(\"Value of a : %d\\nValue of b : %d\", a, b);\n    printf(\"\\n\");\n}"}
{"author": "dle2005", "file": "File_Structure__heapsort.7.c", "original_string": "void setHeadPage(char *pagebuf, int pageNum, int recordNum, int deletePageNum, int deleteRecordNum) {\n    memset(pagebuf, 0xFF, PAGE_SIZE);\n    memcpy(pagebuf, &pageNum, sizeof(int));\n    memcpy(pagebuf+4, &recordNum, sizeof(int));\n    memcpy(pagebuf+8, &deletePageNum, sizeof(int));\n    memcpy(pagebuf+12, &deleteRecordNum, sizeof(int));\n}"}
{"author": "fikepaci", "file": "binary_trees__16-binary_tree_is_perfect.2.c", "original_string": "const binary_tree_t *get_leaf(const binary_tree_t *tree)\n{\n    if (is_leaf(tree) == 1)\n        return (tree);\n    return (tree->left ? get_leaf(tree->left) : get_leaf(tree->right));\n}"}
{"author": "augustogunsch", "file": "jackc__parser-expressions.9.c", "original_string": "TERM* parsecalltermnullified(PARSER* p) {\n    SUBROUTCALL* call = parsesubroutcallnullified(p);\n    if(call == NULL)\n        return NULL;\n    TERM* t = mkterm(subroutcall);\n    t->call = call;\n    return t;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_37.5.c", "original_string": "int main()\n{\n    for (int i = 0; i < 11; i++){\n        printf(\"Preencha o valor do vetor numero %d\\n\", i);\n        scanf(\"%d\", &vetor[i]);\n    }\n    ordenarVetorCrescente();\n    ordenarVetorDecrescente();\n    imprimirVetor();\n    return 0;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_08.3.c", "original_string": "int check_digit_array(int A[], int n)\n{\n    int s;\n    int num = check_digit(A[0]);\n    for(int i = 1; i<n; i++)\n    {\n        s = check_digit(A[i]);\n        if(s != num)\n            return 0;\n    }\n    return 1;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "2lista_de_C__main7.0.c", "original_string": "int main()\n{\n    int c; \n    int l; \nfor (l=1; l<6; l++)\n    {\n        for (c=1; c<6; c++)\n        {\n            if(c<l){\n                printf(\"# \");\n            }else if (c == l)\n                {\n                    printf(\"+ \");\n                }else if(c > 1)\n                {\n                    printf(\"# \");\n                }\n        }\n        printf(\"\\n\");\n    }\n        printf(\"\\n\\n\\n\");\n}"}
{"author": "deepaliajabsingjadhav", "file": "file__lseek_End.1.c", "original_string": "int main()\n{\n    char name[20];\n    int ret = 0;\n    printf(\"Enter file name\\n\");\n    scanf(\"%s\",name);\n   ret = FileSize(name);\n    printf(\"File size is : %d\\n\",ret);\n    return 0;\n}"}
{"author": "RafaelFelisbino-hub", "file": "MATRIZ-exercices__Exercicio19MATRIZ.0.c", "original_string": "int main() \n{\n    float matriz[5][4], somaMes[100], somaSemana = 0, totalVendas = 0;\n    int i, j;\n    for(i = 0; i < 5; i++)\n        for (j = 0; j < 4; j++)\n        {\n            printf(\"Digite as vendas da %d loja e %d semana:  \", i + 1, j+1);\n            scanf_s(\"%f\", &matriz[i][j]);\n        }\n    for (i = 0; i < 5; i++) \n    {\n        somaMes[i] = 0;\n        for (j = 0; j < 4; j++)\n        {\n            somaMes[i] += matriz[i][j];\n        }\n        somaSemana += somaMes[i];\n        totalVendas += somaSemana;\n    }\n    for (i = 0; i < 5; i++)\n        for (j = 0; j < 1; j++)\n            printf(\"O total de vendas do mes do %d vendedor e %.2f:  \\n\", i+1, somaMes[i]);\n    printf(\"O total de vendas de cada semana de todos os vendedores e %.2f:  \\n\", somaSemana);\n    printf(\"O total de vendas do mes e %.2f:  \\n\", totalVendas);\n    system(\"pause\");\n}"}
{"author": "augustogunsch", "file": "jackc__tokenizer.16.c", "original_string": "void readstr(FILE* input, STRING* tmp, int definedat) {\n    unsigned char c;\n    while(c = fgetc(input), c != '\\0') {\n        if(c == '\\n') {\n            eprintf(\"Unexpected end of line; line %i\", definedat);\n            exit(1);\n        }\n        if(c == '\"')\n            break;\n        append(tmp, c);\n    }\n    append(tmp, '\\0');\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_07.0.c", "original_string": "int main()\n{\n     int i, maior, menor,posmaior,x;\n     int vet[10];\n    for (i = 0 ; i < 10 ; i++){\n        printf(\"Digite o valor:\\n\");\n        scanf(\"%d\",&vet[i]);\n    }\n    maior=vet[0];\n    posmaior=0;\n    for (i=1;i<10;i++){\n        if(vet[i]>maior){\n            maior=vet[i];\n            posmaior=i;\n        }\n    }\n    menor=vet[0];\n    for(i=1;i<10;i++){\n    if(vet[i]<menor){\n    menor=vet[i];\n        }\n    }\n         printf(\"vetor: \");\n    for (i = 0 ; i < 10 ; i++){\n        printf(\"%d \",vet[i]);\n    }\n    printf(\"\\nO maior valor eh: %d \\n \",maior);\n    printf(\"Posicao: %d\\n\",posmaior);\n    return 0;\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b2.1.c", "original_string": "char *get_field(size_t *n, FILE *f) { \n    char *field = calloc(sizeof(char), 20);\n    size_t i = 0;\n    for (char cur = fgetc(f); cur != ' ' && cur != '\\n'; cur = fgetc(f)) {\n        field[i] = cur;\n        i++;\n    }\n    *n = i;\n    return field;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc.5.c", "original_string": "void rec_postorder(node* root) \n{ \n    if (root != NULL) \n    { \n        rec_postorder(root->left);\n        rec_postorder(root->right);\n        printf(\"\\t%d\\n\", root->data); \n    }\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__menu.1.c", "original_string": "void imprimir_menu(){\n    printf(\"Menu de opiones\\n\");\n    printf(\"1. Agregar alumno\\n\");\n    printf(\"2. Modificar calificaciones\\n\");\n    printf(\"3. Imprimir datos del alumno\\n\");\n    printf(\"4. Salir\\n\");\n    printf(\"Ingresa una opci\u00f3n: \\n\");\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.12.c", "original_string": "void deletion(int val, struct btreeNode *myNode) {\n        struct btreeNode *tmp;\n        if (!delValFromNode(val, myNode)) {\n                printf(\"Given value is not present in B-Tree\\n\");\n                return;\n        } else {\n                if (myNode->count == 0) {\n                        tmp = myNode;\n                        myNode = myNode->link[0];\n                        free(tmp);\n                }\n        }\n        root = myNode;\n        return;\n  }"}
{"author": "Oryx-Embedded", "file": "Common__os_port_posix.16.c", "original_string": "bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   int_t ret;\n   struct timespec ts;\n   if(timeout == 0)\n   {\n      ret = sem_trywait(semaphore);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      ret = sem_wait(semaphore);\n   }\n   else\n   {\n      clock_gettime(CLOCK_REALTIME, &ts);\n      ts.tv_sec += timeout / 1000;\n      ts.tv_nsec += (timeout % 1000) * 1000000;\n      if(ts.tv_nsec >= 1000000000)\n      {\n         ts.tv_sec += 1;\n         ts.tv_nsec -= 1000000000;\n      }\n      ret = sem_timedwait(semaphore, &ts);\n   }\n   if(ret == 0)\n      return TRUE;\n   else\n      return FALSE;\n}"}
{"author": "sdukesameer", "file": "dsa__Md_Sameer_13000119114.10.c", "original_string": "void pop(stack* stk){\n    if(is_empty(stk))\n        printf(\"STACK EMPTY!\\n\");\n    else\n        printf(\"%d popped from stack.\\n\",stk->arr[stk->top--]);\n}"}
{"author": "earth429", "file": "mulpre__mulprec.3.c", "original_string": "void setRnd(struct NUMBER *a, int k){\n    int i;\n    int judge;\n    clearByZero(a);\n    for (i = 0; i < k;i++){\n        a->n[i] = random() % 10; \n    }\n    judge = random() % 2; \n    switch (judge) {\n        case 1:\n            setSign(a, 1);\n            break;\n        case 0:\n            setSign(a, -1);\n            break;\n    }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_08.1.c", "original_string": "void display(int arr2[], int n)\n{\n        int i;\n        for(i = 0; i<n; i++)\n        {\n                fprintf(F2, \"%d \", arr2[i]);\n        }\n}"}
{"author": "2security", "file": "Array__Orthogonal.3.c", "original_string": "int IsIdentity(int **mat,int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            {\n            if((i!=j)&&(mat[i][j]!=0))\n                return 0;\n            else if((i==j)&&(mat[i][j])!=1)\n                return 0;\n            }\n        }\n    return 1;\n    }"}
{"author": "HakNinja", "file": "C-Basic__30strv.0.c", "original_string": "void main()\n {\n  char st[100],ch;\n  printf(\"Enter string:\");\n  gets(st);\n  for(int i=0;st[i]!='\\o';i++)\n   {\n    if (st[i]>='A' && st[i]<='Z')\n     {\n      st[i]=st[i]+32;\n      }\n    if (st[i]>='a' && st[i]<='z')\n     {\n      st[i]=st[i]-32;\n      }\n    }\n  printf(\"Opposite case of the string:\");\n  puts(st);\n  }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Knapsack.1.c", "original_string": "void sort_decreasing(struct Object arr[])\n{\n    int i, j = 0;\n    float temp = 0;\n    char *temp1;\n    for(i=0; i<MAX_ARR_SIZE; i++)\n    {\n        for(j=i+1; j<MAX_ARR_SIZE; j++)\n        {\n            if(arr[i].pw_ratio < arr[j].pw_ratio)\n            {\n                temp = arr[j].pw_ratio;\n                arr[j].pw_ratio = arr[i].pw_ratio;\n                arr[i].pw_ratio = temp;\n                temp1 = arr[j].name;\n                arr[j].name = arr[i].name;\n                arr[i].name = temp1;\n                temp = arr[j].profit;\n                arr[j].profit = arr[i].profit;\n                arr[i].profit = temp;\n                temp = arr[j].weight;\n                arr[j].weight = arr[i].weight;\n                arr[i].weight = temp;\n            }\n        }\n    }\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__cub2d_utils.4.c", "original_string": "int         has_wall(int x, int y)\n{\n    int ughx;\n    int ughy;\n    ughx = floor(x / g_tile_size);\n    ughy = floor(y / g_tile_size);\n    if (g_map_array[ughy][ughx] == '1')\n        return (1);\n    else\n        return (0);\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__SRTF.0.c", "original_string": "void main()\n{\n    int n,i,j,temp,min,k,k1,init_temp,sum=0;\n    float Waiting_time;\n    char s[10];\n    printf(\"\\nEnter the number of processess : \");\n    scanf(\"%d\",&n);\n    struct process p[n];\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter name : \");\n        scanf(\"%s\",p[i].name);\n        printf(\"\\nEnter AT : \");\n        scanf(\"%d\",&p[i].AT);\n        printf(\"\\nEnter BT : \");\n        scanf(\"%d\",&p[i].BT);\n        p[i].CT=0;\n        p[i].status=0;\n        p[i].BT1=p[i].BT;\n    }\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(p[i].AT>p[j].AT)\n            {\n                temp=p[i].AT;\n                p[i].AT=p[j].AT;\n                p[j].AT=temp;\n                temp=p[i].BT;\n                p[i].BT=p[j].BT;\n                p[j].BT=temp;\n                temp=p[i].BT1;\n                p[i].BT1=p[j].BT1;\n                p[j].BT1=temp;\n                strcpy(s,p[i].name);\n                strcpy(p[i].name,p[j].name);\n                strcpy(p[j].name,s);\n            }\n        }\n    }\n    k=0;\n    temp=0;\n    while(k<n)\n    {\n        init_temp=temp;\n        min=1000;\n        printf(\"\\nq\");\n        for(i=0;i<n;i++)\n        {\n            printf(\"\\nw\");\n            if(p[i].BT1<min && p[i].BT1!=0 && p[i].AT<=temp)\n            {\n                min=p[i].BT1;\n            }\n        }\n        for(i=0;i<n;i++)\n        {\n            printf(\"\\ne\");\n            if(p[i].AT<=temp && p[i].status==0 && p[i].BT1<=min)\n            {\n                p[i].BT1--;\n                temp++;\n                p[i].CT=temp;\n                break;\n            }\n        }\n        for(i=0;i<n;i++)\n        {\n            printf(\"\\nr\");\n            if(p[i].BT1==0 && p[i].status==0)\n            {\n                k=k+1;\n                p[i].status=k;\n            }\n        }\n        if(init_temp==temp)\n            temp++;\n    }\n    printf(\"\\nstatus : \");\n    for(i=0;i<n;i++)\n        printf(\"\\t%d\",p[i].status);\n    printf(\"\\nprocess\\tAT\\tBT\\tCT\\tTAT\\tWT\");\n    k1=1;\n    while(k1<=k)\n    {\n        for(i=0;i<n;i++)\n        {\n            if(p[i].status==k1)\n            {\n                p[i].TAT=p[i].CT-p[i].AT;\n                p[i].WT=p[i].TAT-p[i].BT;\n                sum=sum+p[i].WT;\n                printf(\"\\n%s\\t%d\\t%d\\t%d\\t%d\\t%d\",p[i].name,p[i].AT,p[i].BT,p[i].CT,p[i].TAT,p[i].WT);\n                k1++;\n            }\n        }\n    }\n    Waiting_time=(sum*1.0)/n;\n    printf(\"\\nAverage Waiting_time : %f\",Waiting_time);\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__CountingSort.0.c", "original_string": "void main()\n{\n    int n,k=0,A[30],i;\n    printf(\"Enter the value of n \\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter the values to be sorted\\n\");\n    for (i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&A[i]);\n        if (A[i]>k) \n        {\n            k=A[i];\n        }\n    }\n    counting_sort(A, k, n);\n    printf(\"\\nValue of count=%d\",count);\n}"}
{"author": "ankitraj311", "file": "450_babbar__7_intersection_array_Geek_soted_array.0.c", "original_string": "void array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}"}
{"author": "Dhruvik-Chevli", "file": "DAALab__graphAdjacencyList.3.c", "original_string": "int main()\n{\n    int V;\n    printf(\"Please enter the number of vertices to your graph\\n\");\n    scanf(\"%d\",&V);\n    struct Graph* graph=createGraph(V);\n    int n;\n    printf(\"Please enter the number of Edges you want the graph to have\\n\");\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n    {\n        int src,dst;\n        scanf(\"%d %d\",&src,&dst);\n        addEdge(graph,src,dst);\n    }\n    printGraph(graph);\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__doublylinkedlist.2.c", "original_string": "void search(int tar)\n{\n    int ct=0;\n    if(start==NULL)\n    printf(\"\\nList is empty\");\n    else\n    {\n        temp=start;\n        while(temp->next!=NULL)\n        {\n            if(temp->val==tar)\n            {\n                printf(\"\\nElement found\");\n                ct++;\n                break;\n            }\n            temp=temp->next;\n        }\n        if(temp->val==tar && temp->next==NULL)\n        {\n            printf(\"\\nElement found\");\n            ct++;\n        }\n        if(ct==0)\n        {\n            printf(\"\\nthe element is not found in the list\");\n        }\n    }\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_26.1.c", "original_string": "float calculaDesvioPadrao(float vet[]) {\n        float soma = 0.0, mean, desvio = 0.0;\n        int i;\n        for (i = 0; i < 10; i++) {\n            soma += vet[i];\n        }\n        mean = soma / 10;\n        for (i = 0; i < 10; i++)\n            desvio += pow(vet[i] - mean, 2);\n        return sqrt(desvio / 10);\n}"}
{"author": "ankitraj311", "file": "450_babbar__6_union_array_SELF_with_warning.0.c", "original_string": "void array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_01.2.c", "original_string": "int merge_sort(int A[],int p,int r)\n{\n        static int flips=0;\n    int q = p + (r-p)/2;\n    if((r-p+1)%2 == 0)\n        q = q + 1;\n    if(p<r)\n    {\n        for(int i=p;i<q;i++)\n            for(int j=q;j<=r;j++)\n            {\n                if(A[j]<A[i])\n                {\n                    flips++;\n                }\n            }\n        merge_sort(A,p,q-1);\n        merge_sort(A,q,r);\n    }\n    return flips;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__search_an_element_by_key.0.c", "original_string": "void createList(int n)\n{\n    struct node *newNode, *temp;\n    int data, i;\n    head = (struct node *)malloc(sizeof(struct node));\n        printf(\"Enter the data of node 1: \");\n        scanf(\"%d\", &data);\n        head->data = data;\n        head->next = NULL;\n        temp = head;\n        for(i=2; i<=n; i++)\n        {\n            newNode = (struct node *)malloc(sizeof(struct node));\n                printf(\"Enter the data of node %d: \", i);\n                scanf(\"%d\", &data);\n                newNode->data = data;\n                newNode->next = NULL;\n                temp->next = newNode;\n                temp = temp->next;\n            }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_DLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad7ElementsCopy.2.c", "original_string": "void copyArrayPointer(int sourceArray[], int outputArray[], int size){\n    int * pointerSource = sourceArray;\n    int * pointerOutput = outputArray;\n    for(int i = 0; i < size; i++){\n        *pointerOutput = *pointerSource;\n        pointerSource++;\n        pointerOutput++;\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__1.4.c", "original_string": "bool imprime_idade(aluno_t *turma, int idade, int n)\n{\n    bool id = false;\n    for (int i = 0; i < n; i++)\n    {\n        if (turma[i].idade == idade)\n        {\n            if (id == false) id = true;\n            imprime_aluno(turma[i]);\n        }\n    }\n    if (id == false)\n    {\n        printf(\"\\nNenhum aluno com a idade escolhida foi encontrado.\\n\");\n        return false;\n    }\n    return true;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc-a.0.c", "original_string": "list *newNode(int item) \n{ \n    list *temp = (list *)malloc(sizeof(list)); \n    temp->key = item; \n    temp->left = temp->right = NULL; \n    return temp; \n}"}
{"author": "bgmanuel99", "file": "PracticasArquitecturaDeComputadores__ejercicio20.0.c", "original_string": "int main(int argc, char *argv[]) {\n    int rank, \n    size; \n    MPI_Init(&argc, &argv); \n    MPI_Comm_size(MPI_COMM_WORLD, &size); \n    MPI_Comm_rank(MPI_COMM_WORLD, &rank); \n    int *buffer = NULL;\n    int localData;\n    if (rank == 0) {\n        buffer = malloc(size * sizeof(int));\n        for(int i = 0; i < size; i++){\n            buffer[i] = rank;\n        }\n        printf(\"El proceso %d contiene los datos: \", rank);\n        for(int i = 0; i < size; i++){\n            printf(\"%d, \", buffer[i]);\n        }\n        printf(\"\\n\");\n    }\n    MPI_Scatter(buffer, 1, MPI_INT, &localData, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    printf(\"El proceso %d contiene el dato %d\\n\", rank, localData);\n    localData += rank;\n    printf(\"El proceso %d despues de sumar su indice al dato contiene ahora el dato %d\\n\", rank, localData);\n    MPI_Gather(&localData, 1, MPI_INT, buffer, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    if(rank == 0){\n        printf(\"Despues de los procesos de scatter y gather ahora el proceso %d contiene los datos: \", rank);\n        for(int i = 0; i < size; i++){\n            printf(\"%d, \", buffer[i]);\n        }\n        printf(\"\\n\");\n        free(buffer);\n    }\n    MPI_Finalize();\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_any_pos_DLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\");\n    }\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__count_the_elem_in_DLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler.7.c", "original_string": "void DeleteAtPos(PPNODE Head,PPNODE Tail, int pos)\n{\n    int cnt = 0,i = 0;\n    PNODE temp = *Head;\n    cnt = Count(*Head, *Tail);\n    if((pos < 1) || (pos > cnt))\n    {\n        return;\n    }\n    if(pos == 1)\n    {\n        DeleteFirst(Head, Tail);\n    }\n    else if(pos == cnt)\n    {\n        DeleteLast(Head, Tail);\n    }\n    else\n    {\n        for(i = 1; i<pos-1; i++)\n        {\n            temp =temp->next;\n        }\n        temp->next = temp->next->next;\n        free(temp->next->prev);\n        temp->next->prev = temp;\n    }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__p.0.c", "original_string": "void    ft_print_hex(unsigned char c)\n{\n    char *radix;\n    radix = \"0123456789abcdef\";\n    write(1, &radix[c / 16], 1);\n    write(1, &radix[c % 16], 1);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__timer_interrupt.1.c", "original_string": "void interrupt_config(void)\n{\n    VICIntSelect &= ~(1<<4);            \n    VICVectCntl2    = (1<<5)|4;         \n    VICVectAddr2    = (long)timer0_isr1;        \n    VICIntEnable    = (1<<4);               \n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__str_capitalizer.0.c", "original_string": "int     toupperr(char a, char d)\n{\n    if (a >= 'a' && a <= 'z')\n    {\n        if (d  == ' ' || d == '\\t' || d == '\\0')\n            return (1);\n    }\n    return(0);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__quick_sort.2.c", "original_string": "void quicksort(int a[],int l,int r)\n{\n    int loc;\n    if(l<r)\n    {\n        loc=sort(a,l,r);\n        quicksort(a,l,loc);\n        quicksort(a,loc+1,r);\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__insert_element_at_begining_single_linked_list.3.c", "original_string": "void displayList()\n{\n    struct node*temp;\n    temp=head;\n    while(temp!=NULL)\n    {\n        printf(\"%d\\n\", temp->data);\n        temp=temp->next;\n    }\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_4.2.c", "original_string": "int precedence(char symbol)\n{\n    if(symbol == '^')\n        return 3;\n    else if(symbol == '*' || symbol == '/')\n        return 2;\n    else if(symbol == '+' || symbol == '-')\n        return 1;\n    else\n        return 0;\n}"}
{"author": "ankitraj311", "file": "450_babbar__6_union_array_SELF_with_warning.2.c", "original_string": "int main()\n{\n  int arr1[] = {1,2,3,5,6,7,8,9,10}, arr2[] = {10,2,3,6,4,9,8,7,2,3,1} ,no,j=0,temp=0,mid=0,n=0;\n  array_print(arr1,sizeof(arr1)/sizeof(int));\n  array_print(arr2,sizeof(arr2)/sizeof(int));\n  union_array(arr1,arr2);\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_02.2.c", "original_string": "void display(int arr2[], int n)\n{\n        int i;\n        for(i = 0; i<n; i++)\n        {\n                fprintf(F2, \"%d \", arr2[i]);\n        }\n}"}
{"author": "dishanp", "file": "DSA__q63.0.c", "original_string": "void create(int A[], int n)\n{\n    struct node *t, *last;\n    first = (struct node*)malloc(sizeof(struct node));\n    first->data = A[0];\n    first->next = NULL;\n    last = first;\n    for(int i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n}"}
{"author": "flora0110", "file": "hw04git__4108056029_40.0.c", "original_string": "int main(){\n    FILE* rptr;\n    rptr=fopen(\"test8.txt\",\"r\");\n    if(rptr==NULL){\n        printf(\"error\\n\");\n        return 0;\n    }\n    int n,i,j;\n    fscanf(rptr,\"%d\\n\",&n);\n    char* token;\n    const char* delim = \" \";\n    All* all=(All*)malloc(300*sizeof(All));\n    int alln=0;\n    char **obj=(char**)malloc(18000*sizeof(char*));\n    int objn=0;\n    int flyat,pigat;\n    int* ori;\n    int* chan_to;\n    for(i=0;i<n;i++){\n        char str[300];\n        fgets(str,300,rptr);\n        token = strtok(str,delim);\n        int chan=0;\n        ori=(int*)malloc(18000*sizeof(int));\n        chan_to=(int*)malloc(18000*sizeof(int));\n        int orin=0,chan_ton=0;\n        int isthat=0;\n        while( token != NULL ){\n            if('Z'>=token[0] && token[0]>='A'){\n                if(token[strlen(token)-1]=='\\n') token[strlen(token)-1]='\\0';\n                int at=at_where(obj,token,&objn);\n                if(chan==0){\n                    ori[orin++]=at;\n                }\n                else if(chan==1){\n                    chan_to[chan_ton++]=at;\n                }\n                if (strlen(token)==3 && strncmp(\"FLY\",token,strlen(token))==0) flyat=at;\n                else if (strlen(token)==4 && strncmp(\"PIGS\",token,strlen(token))==0) pigat=at;\n            }\n            if((strlen(token)==3 && strncmp(\"are\",token,strlen(token))==0)||\\\n                (strlen(token)==3 && strncmp(\"can\",token,strlen(token))==0) && isthat==0 ||\\\n                (strlen(token)==4 && strncmp(\"have\",token,strlen(token))==0)){\n                chan=1;\n            }\n            if(strlen(token)==4 && strncmp(\"that\",token,strlen(token))==0){\n                isthat=1;\n            }\n            if(strlen(token)==3 && strncmp(\"can\",token,strlen(token))==0 && isthat==1){\n                isthat=0;\n            }\n            token=strtok(NULL,delim);\n        }\n        ori[orin]=-1;\n        chan_to[chan_ton]=-1;\n        all[alln].ori=ori;\n        all[alln++].chan_to=chan_to;\n    }\n    int *test=(int*)malloc((objn+1)*sizeof(int));\n    memset(test,0,objn+1);\n    test[pigat]=1;\n    int allcheck=pass(all,test,alln,flyat,pigat);\n    while(allcheck!=0 && allcheck!=2){\n        allcheck=pass(all,test,alln,flyat,pigat);\n    }\n    if(allcheck==2){\n        printf(\"All pigs can fly\\n\");\n    }\n    else{\n        for(i=0;i<objn;i++){\n            for(j=0;j<objn;j++){\n                test[j]=0;\n                if(j==i) test[j]=1;\n            }\n            allcheck=pass(all,test,alln,flyat,pigat);\n            while(allcheck!=0 && allcheck!=2){\n                allcheck=pass(all,test,alln,flyat,pigat);\n            }\n            if(allcheck==2) {\n                break;\n            }\n        }\n        if(allcheck==2){\n            printf(\"Some pigs can fly\\n\");\n        }\n        else{\n            printf(\"No pigs can fly\\n\");\n        }\n    }\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__21.0.c", "original_string": "void main()\n{\n    int a[90][90],r,c,i,j;\n    printf(\"enter no of rows and columns\");\n    scanf(\"%d%d\",&r,&c);\n    printf(\"enter ele\");\n    for(i=0;i<r;i++)\n    {\n        for(j=0;j<c;j++)\n        {\n            scanf(\"%d\",&a[i][j]);\n        }\n    }\n    largest(a,r,c);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader.3.c", "original_string": "static bool createFirmwareUpdateInfoFile(void)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"w\");\n  if (updateInfoFile == NULL) \n  {\n    printf(\"Failed to create %s: %s (error code: %i)\\n\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, strerror(errno), errno);\n    return false;\n  }\n  fclose(updateInfoFile);\n  return true;\n}"}
{"author": "sahadipanjan6", "file": "Programs-in-C__P3.0.c", "original_string": "void main()\n{\n    int arr[10][10];\n    int rows=0;\n    int columns=0;\n    int i=0;\n    int j=0;\n    printf(\"Enter number of rows: \\n\");\n    scanf(\"%d\", &rows);\n    printf(\"Enter number of columns: \\n\");\n    scanf(\"%d\", &columns);\n    printf(\"Enter the array elements...\\n\");\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {\n            scanf(\"%d\", &arr[i][j]);\n        }\n    }\n    if(isSparse(arr, rows, columns) == 1)\n        printf(\"Given Matrix is a SPARSE MATRIX...\\n\");\n    else\n        printf(\"Given Matrix is NOT a SPARSE MATRIX...\\n\");\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__circularLinkedList.3.c", "original_string": "struct Node *insertAtTheFirst(struct Node *head, int data)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     ptr->data = data;\n     struct Node *p = head->next;\n     while (p->next != head)\n     {\n          p = p->next;\n     }\n     ptr->next = p->next;\n     p->next = ptr;\n     return ptr;\n}"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__syscalls.5.c", "original_string": "int _write(int32_t file, uint8_t *ptr, int32_t len)\n{\n    int i;\n    for(i = 0; i < len; i++)\n        ITM_SendChar(*ptr++);\n    return len;\n}"}
{"author": "2security", "file": "Star__MirrorRhombusStar.0.c", "original_string": "int main()\n    {\n    int n,i,j;\n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<i;j++)\n            printf(\" \");\n        for(j=1;j<=n;j++)\n            printf(\"*\");\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_SLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__patternmatch.0.c", "original_string": "void Brute_Force(char S[],char P[],int n,int m)\n{\n    int i=0,j=0;\n    int flag=-1;\n    while(i<n && j<m)\n    {\n        if(P[j]==S[i])\n        {\n            i=i+1;\n            j=j+1;\n        }\n        else\n        {\n            i=i+1;\n            j=0;\n        }\n    if(j==m)\n    {\n        flag=1;\n        printf(\"\\npattern found at %d\",(i-j+1));\n        j=0;\n    }\n}\n    if(flag==-1)\n    {\n        printf(\"pattern not found\");\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__longadd.2.c", "original_string": "nptr getnum(char num[50])\n{\n    nptr head = createNode();\n    for(int i = strlen(num) - 1 ; i >= 0 ; i--)\n        insert(head, num[i] - '0');\n    return head;\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__fatores_primos.0.c", "original_string": "int main(void)\n{\n    long int n;\n    int vf = false, qtd = 0, primo = 2;\n    do\n    {\n        printf(\"\\nDigite um numero natural para calcular seus fatores primos: \");\n        scanf(\"%li\", &n);\n        if (n < 0)\n        {\n            printf(\"ERRO! Favor digitar um numero natural\\n\");\n        }\n    } while (n < 0);\n    if (n == 0)\n    {\n        printf(\"\\nNao ha fatores primos de 0\\n\");\n    }\n    else if (n == 1)\n    {\n        printf(\"\\n1 = 1\\n\");\n    }\n    else\n    {\n        printf(\"\\n%.0li = \", n);\n        while (n > 1)\n        {\n            while (vf = false)\n            {\n                for (int i = 2; i < primo; i++)\n                {\n                    if ((primo % i) == 0)\n                    {\n                        vf = true;\n                    }\n                }\n                if (vf = false)\n                {\n                    primo++;\n                }\n            }\n            while ((n % primo) == 0)\n            {\n                n = n / primo;\n                qtd++;\n            }\n            if (qtd != 0)\n            {\n                printf(\"%i(%i) \", primo, qtd);\n            }\n            primo++;\n            vf = false;\n            qtd = 0;\n        }\n        printf(\"\\n\\n\");\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__wdt_1.0.c", "original_string": "int main()\n{\n    IODIR1 |= 0xFF<<17;\n    WDMOD = (1<<1) | (1<<0);   \n    WDTC = 0xFFFFFF;        \n    blink_led(24);\n    WDFEED = 0xAA; \n    WDFEED = 0x55;\n    while(1)\n    {\n        if(WDTV <= 0xF00000)\n        {\n                WDFEED = 0xAA;          \n                WDFEED = 0x55;\n        }\n        blink_led(17);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__singlyLL.8.c", "original_string": "int main()\n{\n    printf(\"1. Insert Front   2. Insert Rear   3. Delete Front   4. Delete Rear   5. Display   6. Reverse 7. Reverse2   0. Exit\\n\");\n    int ch, ele;\n    nptr head = NULL;\n    do\n    {\n        printf(\"Command: \"); scanf(\"%d\", &ch);\n        switch(ch)\n        {\n            case 1:     \n                    printf(\"Element: \"); scanf(\"%d\", &ele);\n                    insertFront(head, ele);\n                    break;\n            case 2:\n                    printf(\"Element: \"); scanf(\"%d\", &ele);\n                    insertRear(head, ele);\n                    break;\n            case 3: ele = deleteFront(head);\n                    if(ele == -1)\n                        printf(\"List empty!\\n\");\n                    else\n                        printf(\"%d removed\\n\", ele);\n                    break;\n            case 4: ele = deleteRear(head);\n                    if(ele == -1)\n                        printf(\"List empty!\\n\");\n                    else\n                        printf(\"%d removed\\n\", ele);\n                    break;\n            case 5: display(head);\n                    break;\n            case 6: head = reverse(head);\n                    break; \n            case 7: head = reverse2(head);\n                    break;\n        }\n    }while(ch != 0);\n}"}
{"author": "jdes01", "file": "practicassoo__practica2ej3.4.c", "original_string": "vInfo * creaHijos(int * vPadre, int numeroHilos){\n    int numeroElementos = 10 / numeroHilos;\n    vInfo * vHijos = (vInfo *) malloc (numeroHilos * sizeof(vInfo));\n    for (int i=0;i<numeroHilos;i++){\n        vHijos[i].vector = reservarMemoria(numeroElementos);\n        vHijos[i].numeroElementos = numeroElementos;\n        int k = 0;\n        for (int j = (i * numeroElementos); j < ( (i * numeroElementos) + numeroElementos ); j++){\n            vHijos[i].vector[k] =vPadre[j];\n            k++;\n        }\n        printf(\"El vector hijo es: \\n\");\n        imprimeVector(vHijos[i].vector, vHijos->numeroElementos);\n    }\n    return vHijos;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_03.0.c", "original_string": "void read(int A[],int n)\n{\n    int i;\n    for(i=0;i<n;i++)\n    fscanf(F1,\"%d\",&A[i]);\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_msp.0.c", "original_string": "void HAL_MspInit(void)\n{\n  __HAL_RCC_SYSCFG_CLK_ENABLE();\n  __HAL_RCC_PWR_CLK_ENABLE();\n  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);\n  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__server.0.c", "original_string": "int main()\n{\n    fd_set master, read_fds;\n    int fdmax, i;\n    int sockfd = 0;\n    struct sockaddr_in server_addr, client_addr;\n    FD_ZERO(&master);\n    FD_ZERO(&read_fds);\n    server_set_up(&sockfd, &server_addr);\n    FD_SET(sockfd, &master);\n    fdmax = sockfd;\n    while (1)\n    {\n        read_fds = master;\n        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)\n        {\n            perror(\"select\");\n            exit(4);\n        }\n        for (i = 0; i <= fdmax; i++)\n        {\n            if (FD_ISSET(i, &read_fds))\n            {\n                if (i == sockfd)\n                    connection_accept(&master, &fdmax, sockfd, &client_addr);\n                else\n                    send_recv(i, &master, sockfd, fdmax);\n            }\n        }\n    }\n    return 0;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__47_dignoal_sum.0.c", "original_string": "int main()\n{\n  int i,j,k,r1,c1,r2,c2,row_sum = 0, col_sum = 0, diagnoal1 = 0, diagnoal2 = 0;\n  printf(\"Enter Value of r1, c1\\n\");\n  scanf(\"%d%d\",&r1,&c1);\n  int m1[r1][c1], sum = 0;\n  printf(\"Enter value of Matrix1\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      scanf(\"%d\",&m1[i][j]);\n    }\n  }\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      printf(\"%d \",m1[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for(i=0; i<r1; i++)\n  {\n    diagnoal1 = diagnoal1 + m1[i][i];\n    diagnoal2 = diagnoal2 + m1[i][c1];\n    c1--;\n  }\n  printf(\"\\n\\nValue of Diagnoal1 is %d & Diagnoal2 is %d\",diagnoal1,diagnoal2);\n }"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__carro.1.c", "original_string": "void quadrado(float x, float y)\n{\n  glBegin(GL_POLYGON);\n  glVertex2f(-0.2 + x, 0.2 + y);\n  glVertex2f(0.2 + x, 0.2 + y);\n  glVertex2f(0.2 + x, -0.2 + y);\n  glVertex2f(-0.2 + x, -0.2 + y);\n  glEnd();\n}"}
{"author": "deepaliajabsingjadhav", "file": "file__lseek_file.1.c", "original_string": "int main()\n{\n    char name[20];\n    int value = 0;\n    printf(\"Enter file name\\n\");\n    scanf(\"%s\",name);\n    printf(\"Enter the position\\n\");\n    scanf(\"%d\",&value);\n    FileRead(name,value);\n    return 0;\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__queue0.6.c", "original_string": "int main()\n{\n    insert(1);\n    insert(2);\n    insert(3);\n    insert(4);\n    insert(5);\n    insert(6);\n    int num = removedata();\n    printf(\"%d \\n\",num);\n    insert(7);\n    while(!empty())\n    {\n        int n = removedata();\n        printf(\"%d \",n);\n    }\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__flor.4.c", "original_string": "void tecladoEspecial(int tecla, int x, int y)\n{\n  switch (tecla)\n  {\n  case GLUT_KEY_RIGHT:\n    tx += 0.05;\n    break;\n  case GLUT_KEY_LEFT:\n    tx -= 0.05;\n    break;\n  case GLUT_KEY_UP:\n    ty += 0.05;\n    break;\n  case GLUT_KEY_DOWN:\n    ty -= 0.05;\n    break;\n  default:\n    break;\n  }\n  glutPostRedisplay();\n}"}
{"author": "sdukesameer", "file": "dsa__list-ins-rem_even.4.c", "original_string": "int main()\n{\n    int n;\n    node* head=NULL;\n    while(1)\n    {\n        printf(\"\\n1. INSERT\\n\");\n        printf(\"2. REMOVE EVEN\\n\");\n        printf(\"3. PRINT\\n\");\n        printf(\"4. EXIT\\n\");\n        printf(\"Enter choice: \");\n        scanf(\"%d\",&n);\n        if(n==1)\n        {\n            int inp;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&inp);\n            insert(&head,inp);\n        }\n        else if(n==2)\n        {\n            removeeven(&head);\n            printf(\"All even integers removed.\\n\");\n        }\n        else if(n==3)\n            print(&head);\n        else if(n==4)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"INVALID CHOICE, TRY AGAIN!\\n\");\n    }\n    return 0;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__channel_survey.4.c", "original_string": "void update_and_sort_channel_survey_handler(void * p_event_data, uint16_t size)\n{\n        NRF_LOG_INFO(\"Channel energy report:\\n--------------\\n\");\n        for (uint8_t i = 0; i < BLE_GAP_CHANNEL_COUNT; i++)\n        {\n                int8_t channel_energy = m_average_ch_energy[i].ch_energy;\n                m_average_ch_energy[i].index = i;\n        }\n        NRF_LOG_DEBUG(\"00-04: %4d %4d %4d %4d %4d\", \\\n                      (int8_t)m_average_ch_energy[0].ch_energy, \\\n                      (int8_t)m_average_ch_energy[1].ch_energy, \\\n                      (int8_t)m_average_ch_energy[2].ch_energy, \\\n                      (int8_t)m_average_ch_energy[3].ch_energy, \\\n                      (int8_t)m_average_ch_energy[4].ch_energy  \\\n                      );\n        NRF_LOG_DEBUG(\"05-09: %4d %4d %4d %4d %4d\", \\\n                      (int8_t)m_average_ch_energy[5].ch_energy, \\\n                      (int8_t)m_average_ch_energy[6].ch_energy, \\\n                      (int8_t)m_average_ch_energy[7].ch_energy, \\\n                      (int8_t)m_average_ch_energy[8].ch_energy, \\\n                      (int8_t)m_average_ch_energy[9].ch_energy  \\\n                      );\n        NRF_LOG_DEBUG(\"10-14: %4d %4d %4d %4d %4d\", \\\n                      (int8_t)m_average_ch_energy[10].ch_energy, \\\n                      (int8_t)m_average_ch_energy[11].ch_energy, \\\n                      (int8_t)m_average_ch_energy[12].ch_energy, \\\n                      (int8_t)m_average_ch_energy[13].ch_energy, \\\n                      (int8_t)m_average_ch_energy[14].ch_energy  \\\n                      );\n        NRF_LOG_DEBUG(\"15-19: %4d %4d %4d %4d %4d\", \\\n                      (int8_t)m_average_ch_energy[15].ch_energy, \\\n                      (int8_t)m_average_ch_energy[16].ch_energy, \\\n                      (int8_t)m_average_ch_energy[17].ch_energy, \\\n                      (int8_t)m_average_ch_energy[18].ch_energy, \\\n                      (int8_t)m_average_ch_energy[19].ch_energy  \\\n                      );\n        NRF_LOG_DEBUG(\"20-24: %4d %4d %4d %4d %4d\", \\\n                      (int8_t)m_average_ch_energy[20].ch_energy, \\\n                      (int8_t)m_average_ch_energy[21].ch_energy, \\\n                      (int8_t)m_average_ch_energy[22].ch_energy, \\\n                      (int8_t)m_average_ch_energy[23].ch_energy, \\\n                      (int8_t)m_average_ch_energy[24].ch_energy  \\\n                      );\n        NRF_LOG_DEBUG(\"25-29: %4d %4d %4d %4d %4d\", \\\n                      (int8_t)m_average_ch_energy[25].ch_energy, \\\n                      (int8_t)m_average_ch_energy[26].ch_energy, \\\n                      (int8_t)m_average_ch_energy[27].ch_energy, \\\n                      (int8_t)m_average_ch_energy[28].ch_energy, \\\n                      (int8_t)m_average_ch_energy[29].ch_energy  \\\n                      );\n        NRF_LOG_DEBUG(\"30-34: %4d %4d %4d %4d %4d\", \\\n                      (int8_t)m_average_ch_energy[30].ch_energy, \\\n                      (int8_t)m_average_ch_energy[31].ch_energy, \\\n                      (int8_t)m_average_ch_energy[32].ch_energy, \\\n                      (int8_t)m_average_ch_energy[33].ch_energy, \\\n                      (int8_t)m_average_ch_energy[34].ch_energy  \\\n                      );\n        NRF_LOG_DEBUG(\"35-39: %4d %4d %4d %4d %4d\", \\\n                      (int8_t)m_average_ch_energy[35].ch_energy, \\\n                      (int8_t)m_average_ch_energy[36].ch_energy, \\\n                      (int8_t)m_average_ch_energy[37].ch_energy, \\\n                      (int8_t)m_average_ch_energy[38].ch_energy, \\\n                      (int8_t)m_average_ch_energy[39].ch_energy  \\\n                      );\n        sort_channel_survey();\n        NRF_LOG_DEBUG(\"Top Best Clean Channel Index:\");\n        NRF_LOG_DEBUG(\"%02d %02d %02d %02d %02d\",  \\\n                      m_average_ch_energy[0].index,  \\\n                      m_average_ch_energy[1].index,  \\\n                      m_average_ch_energy[2].index,  \\\n                      m_average_ch_energy[3].index,  \\\n                      m_average_ch_energy[4].index   \\\n                      );\n        NRF_LOG_DEBUG(\"%02d %02d %02d %02d %02d\",  \\\n                      m_average_ch_energy[5].index,  \\\n                      m_average_ch_energy[6].index,  \\\n                      m_average_ch_energy[7].index,  \\\n                      m_average_ch_energy[8].index,  \\\n                      m_average_ch_energy[9].index   \\\n                      );\n        NRF_LOG_DEBUG(\"%02d %02d %02d %02d %02d\",  \\\n                      m_average_ch_energy[10].index,  \\\n                      m_average_ch_energy[11].index,  \\\n                      m_average_ch_energy[12].index,  \\\n                      m_average_ch_energy[13].index,  \\\n                      m_average_ch_energy[14].index   \\\n                      );\n        NRF_LOG_DEBUG(\"%02d %02d %02d %02d %02d\",  \\\n                      m_average_ch_energy[15].index,  \\\n                      m_average_ch_energy[16].index,  \\\n                      m_average_ch_energy[17].index,  \\\n                      m_average_ch_energy[18].index,  \\\n                      m_average_ch_energy[19].index   \\\n                      );\n        NRF_LOG_DEBUG(\"%02d %02d %02d %02d %02d\",  \\\n                      m_average_ch_energy[20].index,  \\\n                      m_average_ch_energy[21].index,  \\\n                      m_average_ch_energy[22].index,  \\\n                      m_average_ch_energy[23].index,  \\\n                      m_average_ch_energy[24].index   \\\n                      );\n        NRF_LOG_DEBUG(\"%02d %02d %02d %02d %02d\",  \\\n                      m_average_ch_energy[25].index,  \\\n                      m_average_ch_energy[26].index,  \\\n                      m_average_ch_energy[27].index,  \\\n                      m_average_ch_energy[28].index,  \\\n                      m_average_ch_energy[29].index   \\\n                      );\n        NRF_LOG_DEBUG(\"%02d %02d %02d %02d %02d\",  \\\n                      m_average_ch_energy[30].index,  \\\n                      m_average_ch_energy[31].index,  \\\n                      m_average_ch_energy[32].index,  \\\n                      m_average_ch_energy[33].index,  \\\n                      m_average_ch_energy[34].index   \\\n                      );\n        NRF_LOG_DEBUG(\"%02d %02d\",  \\\n                      m_average_ch_energy[35].index,  \\\n                      m_average_ch_energy[36].index\n                      );\n        update_channel_survey_status = true;\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__strcmp.0.c", "original_string": "int main(int argc,char *argv [])\n{\n    char s[SIZE],b[SIZE];\n    int a,p[2],pid;\n    pipe(p);\n    if (argc<2)\n    {printf(\"enter the format ./'name',stringFFF,choice'1 or 0'\");}\n    strcpy(s,argv[1]);\n    strcpy(b,s);\n    a=atoi(argv[2]);\n    if (a==0)\n    {choice_zero(b);}\n    else if(a==1)\n    {choice_one(b);}\n    else\n    {return 1;}\n    printf(\"writing to child\\n\");\n    pid=fork();\n    if(pid==0)\n    {printf(\"inside  child-------\\n\");\n    char c[SIZE];\n    close(p[1]);\n    read(p[0],c,10);\n    n=strlen(c);\n    printf(\"the string count is %d\\n\",(n-3));\n    close(p[0]);\n    }\n    else{\n    close(p[0]);\n    write(p[1],s,10);\n    close(p[1]);\n    printf(\"writed\\n\");\n        wait(NULL);\n    }\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_CLL.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.insert the element at the beginning position \\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"insert the element at the beginning position \\n\");\n            insert_beg();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__LLstack.3.c", "original_string": "void display(nptr &stack)\n{\n    if (stack == NULL)\n    {   \n        printf(\"EMPTY\\n\");\n        return;\n    }\n    nptr curr = stack;\n    while(curr)\n    {\n        printf(\"    %d \\n\", curr -> data);\n        curr = curr -> next;\n    }\n}"}
{"author": "theuwis", "file": "AdventOfCode2016__main23.0.c", "original_string": "int main(){\n   char * msg = \"abbhdwsy\", * dummy = NULL;\n   char code[9] = \"--------\\0\"; int code_counter = 0;\n   bool done[8] = {false};\n   long index = 0;\n   size_t len = 0;\n   uint8_t * md5_result;\n   clock_t start = clock(), diff;\n   while(1){\n      asprintf(&dummy,\"%s%ld\" , msg, index);\n      len = strlen(dummy);\n      md5(dummy, len);\n      md5_result = (uint8_t *) &h0;\n      char str[10];\n      sprintf(str, \"%2.2X%2.2X%2.2X%2.2X\", md5_result[0], md5_result[1], md5_result[2], md5_result[3]);\n      if(strncmp(str, \"00000\", 5) == 0){\n         printf(\"hash found - input=%s - MD5=%s - index=%ld\\n\", dummy, str, index);\n         int index = str[5] - '0';\n         if(code_counter >= 8){\n            printf(\"done! code=%s\\n\", code);\n            diff = clock() - start;\n            int msec = diff * 1000 / CLOCKS_PER_SEC;\n            printf(\"time: %ds %dms\", msec/1000, msec%1000);\n            break;\n         }\n         else{\n            if( (index < 8) && (done[index] == false) ){\n               code[index] = str[6];\n               done[index] = true;\n               code_counter++;\n               printf(\"current code = %s\\n\\n\", code);\n            }\n         }\n      }\n      index++;\n   }\n   return 0;\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad4.1.c", "original_string": "float ciag(int n){\n    float a_n;\n    if(n == 1) return 1;\n    if(n == 2) return 2;\n    if(n == 3) return 3;\n    a_n = (ciag(n-1) + ciag(n-2) + ciag(n-3))/3; \n    return a_n;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_nus_c.9.c", "original_string": "uint32_t ble_nus_c_handles_assign(ble_nus_c_t               * p_ble_nus,\n                                  uint16_t conn_handle,\n                                  ble_nus_c_handles_t const * p_peer_handles)\n{\n        VERIFY_PARAM_NOT_NULL(p_ble_nus);\n        p_ble_nus->conn_handle = conn_handle;\n        if (p_peer_handles != NULL)\n        {\n                p_ble_nus->handles.nus_tx_cccd_handle = p_peer_handles->nus_tx_cccd_handle;\n                p_ble_nus->handles.nus_tx_handle      = p_peer_handles->nus_tx_handle;\n                p_ble_nus->handles.nus_rx_handle      = p_peer_handles->nus_rx_handle;\n        }\n        return NRF_SUCCESS;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_client_misc.6.c", "original_string": "error_t scpClientProcessEvents(ScpClientContext *context)\n{\n   error_t error;\n   uint_t i;\n   SshContext *sshContext;\n   SshConnection *connection;\n   sshContext = &context->sshContext;\n   osMemset(sshContext->eventDesc, 0, sizeof(sshContext->eventDesc));\n   for(i = 0; i < sshContext->numConnections; i++)\n   {\n      connection = &sshContext->connections[i];\n      if(connection->state != SSH_CONN_STATE_CLOSED)\n      {\n         sshRegisterConnectionEvents(sshContext, connection, &sshContext->eventDesc[i]);\n      }\n   }\n   error = socketPoll(sshContext->eventDesc, sshContext->numConnections,\n      &sshContext->event, context->timeout);\n   if(!error)\n   {\n      for(i = 0; i < sshContext->numConnections && !error; i++)\n      {\n         connection = &sshContext->connections[i];\n         if(connection->state != SSH_CONN_STATE_CLOSED)\n         {\n            if(sshContext->eventDesc[i].eventFlags != 0)\n            {\n               error = sshProcessConnectionEvents(sshContext, connection);\n            }\n         }\n      }\n   }\n   if(error == ERROR_WOULD_BLOCK || error == ERROR_TIMEOUT)\n   {\n      error = scpClientCheckTimeout(context);\n   }\n   return error;\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__odd_even_threads.2.c", "original_string": "void *odd_file_open(void *para)\n{\n    FILE *fpo;\nprintf(\"odd file opening-----\\n\");\nfpo=fopen(\"odd.txt\",\"r\");\nwhile (fgets(words,sizeof(words),fpo)!=NULL)\n{\n    printf(\"\\t%s\",words);\n}\nfclose(fpo);\n}"}
{"author": "MFarid94", "file": "Assignment-2__Exercise6.1.c", "original_string": "int main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);                            \n    setvbuf(stderr , NULL , _IONBF , 0);\n    char alphabet;                                                  \n    char uppercase;                                                 \n    printf(\"Please enter a lowercase letter: \");\n    scanf(\"%c\",&alphabet);                                          \n    uppercase = lower_to_upper(alphabet);                           \n    if( test_case == CHECK_LOWER_TRUE ){\n    printf(\"Uppercase letter %c of corresponding Lowercase letter %c \",uppercase,alphabet);\n       }\n    else {\n        printf(\"Invalid input, please enter a lowercase letter \");\n    }\n    return 0;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__channel_survey.3.c", "original_string": "static void sort_channel_survey(void)\n{\n        int n, c, d;\n        float t;\n        uint8_t index = 0;\n        n = BLE_GAP_CHANNEL_COUNT;\n        for (c = 1; c <= n - 1; c++)\n        {\n                d = c;\n                while ( d > 0 && m_average_ch_energy[d-1].ch_energy > m_average_ch_energy[d].ch_energy)\n                {\n                        t          = m_average_ch_energy[d].ch_energy;\n                        index      = m_average_ch_energy[d].index;\n                        m_average_ch_energy[d].ch_energy   = m_average_ch_energy[d-1].ch_energy;\n                        m_average_ch_energy[d].index       = m_average_ch_energy[d-1].index;\n                        m_average_ch_energy[d-1].ch_energy = t;\n                        m_average_ch_energy[d-1].index     = index;\n                        d--;\n                }\n        }\n        return;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__channel_survey.7.c", "original_string": "uint32_t channel_survey_get_report_event(ble_gap_evt_qos_channel_survey_report_t *channel_survey_report)\n{\n        uint32_t err_code;\n        process_channel_survey_report(channel_survey_report);\n        m_num_channel_survey_reports_received++;\n        if (m_num_channel_survey_reports_received > NUM_REPORTS_BEFORE_AVERAGE_PRINTOUT)\n        {\n                err_code = sd_ble_gap_qos_channel_survey_stop();\n                APP_ERROR_CHECK(err_code);\n                err_code = app_sched_event_put(NULL, 0, update_and_sort_channel_survey_handler);\n                APP_ERROR_CHECK(err_code);\n                m_num_channel_survey_reports_received = 0;\n        }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler2.7.c", "original_string": "void DeleteAtPos(PPNODE Head, PPNODE Tail,int pos)\n{\n    PNODE temp1 = *Head;\n    PNODE temp2 = NULL;\n    int iCnt = 0, i = 0;\n    iCnt = Count(*Head,*Tail);\n    if((pos < 1) || (pos > iCnt))\n    {\n        return;\n    }\n    if(pos == 1)\n    {\n        DeleteFirst(Head, Tail);\n    }\n    else if(pos == iCnt)\n    {\n        DeleteLast(Head, Tail);\n    }\n    else\n    {\n        for(i = 1; i< pos-1; i++)\n        {\n            temp1 = temp1->next;\n        }\n        temp2 = temp1->next;\n        temp1->next = temp2->next;\n        free(temp2);\n    }\n}"}
{"author": "behergue", "file": "Computer_Structure__timer.0.c", "original_string": "int tmr_set_prescaler(int p, int  value)\n{\n    int offset = p*8;\n    value &= 0xFF;\n    if (p < 0 || p > 3)\n        return -1;\n    value <<= offset;\n    rTCFG0 |= value;\n    return 0;\n}"}
{"author": "2security", "file": "Matrix__37DeterminantOfMatrix.0.c", "original_string": "int main()\n    {\n    int i,j,r,c;\n    float **mat,temp;\n    printf(\"Enter the row & col. of the matrix \");\n    scanf(\"%d%d\",&r,&c);\n    if(r!=c)\n        printf(\"For determinant matrix should be square\");\n    else\n        {\n        mat=(float **)malloc(r*sizeof(float *));        \n        for(i=0;i<r;i++)\n            mat[i]=(float *)malloc(c*sizeof(float));    \n        printf(\"\\n Enter the matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)\n        scanf(\"%f\",&mat[i][j]);\n        printf(\"The matrix is:\\n\");\n        displayMat(mat,r,c);\n        temp=deterMat(mat,r,c);\n        printf(\"Determinant of the matrix is:= %f\\n\", temp);\n        }\n    return 0;\n    }"}
{"author": "zjzj-zz", "file": "1s_programing__pingpong.0.c", "original_string": "void reflect (float *vx, float *vy, int y, int bary, int barh) {\n  float hity = fabs((float)(y - bary) / (barh / 2));\n  float weight = 0.75 * hity + 0.75;\n  *vx *= -1.0 * weight;\n  *vy *= weight;\n}"}
{"author": "behergue", "file": "Operating_Systems__simulator.7.c", "original_string": "void Subir_Autobus(int id_usuario, int origen){\n    pthread_mutex_lock(&esperaSubir[origen]);\n    esperando_parada[origen]++;\n    while(parada_actual != origen || estado != EN_PARADA){\n        pthread_cond_wait(&suben, &esperaSubir[origen]);\n    }\n    esperando_parada[origen]--;\n    if(esperando_parada[origen] == 0)\n        pthread_cond_signal(&hanSubido);\n    printf(\"Usuario %d se sube en la parada %d \\n\", id_usuario, origen);\n    pthread_mutex_unlock(&esperaSubir[origen]);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CLL.4.c", "original_string": "void insert_beg()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node *)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    if(head==0)\n    {\n        head=newnode;\n        newnode->next=newnode;\n    }\n    else\n    {\n        temp=head;\n        while(temp->next!=head)\n        {\n            temp=temp->next;\n        }\n        temp->next=newnode;\n        newnode->next=head;\n        head=newnode;\n    }\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica1-2.0.c", "original_string": "int main(){\n        switch ( fork() ){\n        case -1: \n            perror(\"fork error:\\n\");\n            fprintf(stderr, \"errno:  %i\\n\", errno); \n            exit(EXIT_FAILURE);\n            break;\n        case 0: \n            printf(\"soy un proceso hijo con PID: %i; el PID de mi proceso padre es: %i\\n\", getpid(), getppid());\n            break;\n        default:\n            sleep(10);\n            exit(EXIT_FAILURE);\n        }\n}"}
{"author": "jose120918", "file": "sorting_algorithms__102-counting_sort.0.c", "original_string": "void counting_sort(int *array, size_t size)\n{\n    int max, position, *count = NULL, *order = NULL;\n    size_t i;\n    if (size < 2 || array == NULL)\n        return;\n    max = array[0];\n    for (i = 0; i < size; i++)\n        if (array[i] > max)\n            max = array[i];\n    count = malloc(sizeof(int) * (max + 1));\n    for (i = 0; i <= (size_t)max; i++)\n        count[i] = 0;\n    for (i = 0; i < size; i++)\n        count[array[i]] = count[array[i]] + 1;\n    for (i = 1; i <= (size_t)max; i++)\n        count[i] = count[i] + count[i - 1];\n    print_array(count, (size_t)max + 1);\n    order = malloc(sizeof(int) * size);\n    for (i = 0; i < size; i++)\n    {\n        count[array[i]] = count[array[i]] - 1;\n        position = count[array[i]];\n        order[position] = array[i];\n    }\n    for (i = 0; i < size; i++)\n        array[i] = order[i];\n    free(count);\n    free(order);\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_8_b.0.c", "original_string": "int main()\n{\n    int one[8] = {5, 6, 8, 8, 10, -2, 0, 121};\n    int two[8] = {2, 1, 3, -4, 10, 21, 2, 233};\n    double three[16];\n    unsigned int naturalNumber = 8;\n    printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n    connectArrays(naturalNumber, one, two, three);\n    printf(\"\\nElementy tablicy3: \");\n    for(int i = 0; i < (sizeof(three)/sizeof(three[0])); i++){\n        printf(\"%.f \", three[i]);\n    }\n    getchar();;\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_directory.1.c", "original_string": "error_t acmeClientParseDirectoryResponse(AcmeClientContext *context)\n{\n   error_t error;\n   const char_t *newNonce;\n   const char_t *newAccount;\n   const char_t *newOrder;\n   const char_t *revokeCert;\n   const char_t *keyChange;\n   json_t *rootObj;\n   json_t *newNonceObj;\n   json_t *newAccountObj;\n   json_t *newOrderObj;\n   json_t *revokeCertObj;\n   json_t *keyChangeObj;\n   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))\n      return ERROR_UNEXPECTED_STATUS;\n   if(osStrcasecmp(context->contentType, \"application/json\"))\n      return ERROR_INVALID_RESPONSE;\n   if(context->bufferLen >= ACME_CLIENT_BUFFER_SIZE)\n      return ERROR_RESPONSE_TOO_LARGE;\n   error = ERROR_INVALID_RESPONSE;\n   osMemset(&context->directory, 0, sizeof(AcmeDirectory));\n   rootObj = json_loads(context->buffer, 0, NULL);\n   if(json_is_object(rootObj))\n   {\n      newNonceObj = json_object_get(rootObj, \"newNonce\");\n      newAccountObj = json_object_get(rootObj, \"newAccount\");\n      newOrderObj = json_object_get(rootObj, \"newOrder\");\n      revokeCertObj = json_object_get(rootObj, \"revokeCert\");\n      keyChangeObj = json_object_get(rootObj, \"keyChange\");\n      if(json_is_string(newNonceObj) &&\n         json_is_string(newAccountObj) &&\n         json_is_string(newOrderObj) &&\n         json_is_string(revokeCertObj) &&\n         json_is_string(keyChangeObj))\n      {\n         newNonce = json_string_value(newNonceObj);\n         newAccount = json_string_value(newAccountObj);\n         newOrder = json_string_value(newOrderObj);\n         revokeCert = json_string_value(revokeCertObj);\n         keyChange = json_string_value(keyChangeObj);\n         if(osStrlen(newNonce) <= ACME_CLIENT_MAX_URL_LEN &&\n            osStrlen(newAccount) <= ACME_CLIENT_MAX_URL_LEN &&\n            osStrlen(newOrder) <= ACME_CLIENT_MAX_URL_LEN &&\n            osStrlen(revokeCert) <= ACME_CLIENT_MAX_URL_LEN &&\n            osStrlen(keyChange) <= ACME_CLIENT_MAX_URL_LEN)\n         {\n            osStrcpy(context->directory.newNonce, newNonce);\n            osStrcpy(context->directory.newAccount, newAccount);\n            osStrcpy(context->directory.newOrder, newOrder);\n            osStrcpy(context->directory.revokeCert, revokeCert);\n            osStrcpy(context->directory.keyChange, keyChange);\n            error = NO_ERROR;\n         }\n      }\n   }\n   json_decref(rootObj);\n   return error;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__36_nearest_to_zero.0.c", "original_string": "int main()\n{\n  int i=0,j=0,k=0, no=0, min_sum = 0, sum = 0, min_i = 0, min_j = 0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n  int array1[no];\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  min_sum = array1[0] + array1[1];\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    for(j=i+1; j<no; j++)\n    {\n      sum = array1[i] + array1[j];\n      if( abs(min_sum) > abs(sum) )\n      {\n        min_sum = sum;\n    min_i = i;\n    min_j = j;\n      }  \n    }\n  }\n printf(\"Sum of %d %d Gives Nearest\\n\",array1[min_i],array1[min_j]); \n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__bridge_mib_impl_tp.3.c", "original_string": "error_t bridgeMibGetDot1dTpFdbEntry(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, MibVariant *value, size_t *valueLen)\n{\n   error_t error;\n   uint_t i;\n   size_t n;\n   SwitchFdbEntry entry;\n   MacAddr dot1dTpFdbAddress;\n   NetInterface *interface;\n   if(bridgeMibBase.interface == NULL)\n      return ERROR_READ_FAILED;\n   interface = bridgeMibBase.interface;\n   n = object->oidLen;\n   error = mibDecodeMacAddr(oid, oidLen, &n, &dot1dTpFdbAddress);\n   if(error)\n      return error;\n   if(n != oidLen)\n      return ERROR_INSTANCE_NOT_FOUND;\n   for(i = 0; !error; i++)\n   {\n      error = interface->switchDriver->getDynamicFdbEntry(interface, i, &entry);\n      if(error == NO_ERROR)\n      {\n         if(macCompAddr(&entry.macAddr, &dot1dTpFdbAddress))\n            break;\n      }\n      else if(error == ERROR_INVALID_ENTRY)\n      {\n         error = NO_ERROR;\n      }\n      else\n      {\n      }\n   }\n   if(error)\n      return ERROR_INSTANCE_NOT_FOUND;\n   if(!strcmp(object->name, \"dot1dTpFdbAddress\"))\n   {\n      if(*valueLen >= sizeof(MacAddr))\n      {\n         macCopyAddr(value->octetString, &entry.macAddr);\n         *valueLen = sizeof(MacAddr);\n      }\n      else\n      {\n         error = ERROR_BUFFER_OVERFLOW;\n      }\n   }\n   else if(!strcmp(object->name, \"dot1dTpFdbPort\"))\n   {\n      value->integer = entry.srcPort;\n   }\n   else if(!strcmp(object->name, \"dot1dTpFdbStatus\"))\n   {\n      value->integer = BRIDGE_MIB_FDB_STATUS_LEARNED;\n   }\n   else\n   {\n      error = ERROR_OBJECT_NOT_FOUND;\n   }\n   return error;\n}"}
{"author": "shengelenge", "file": "wp-lab3__zad4.0.c", "original_string": "int main()\n{\n    int sum1 = 0;\n    int sum2 = 0;\n    int sum3 = 0;\n    int i = 1;\n    int j = 1;\n    printf(\"Petla for:\\n\");\n    for (int i = 1; i <=100; i +=2)\n    {\n        sum1 += i;\n        printf (\"%d\\n\", sum1 );\n    }\n    printf(\"\\nPetla while:\\n\");\n    while (i <= 100)\n    {\n        sum2 += i;\n        printf(\"%d\\n\", sum2);\n        i += 2;\n    }\n    printf(\"\\nPetla do while:\\n\");\n    do {\n        sum3 += j;\n        printf(\"%d\\n\", sum3);\n        j += 2;\n    } while (j <= 100);\n    return 0;\n}"}
{"author": "kbtomic", "file": "Seminarski-StrukturePodataka__Stack.1.c", "original_string": "int PushStack(islandPointer current, stackPointer stackHead)\n{\n    stackPointer newStackElement;\n    stackPointer tempStackElement = stackHead;\n    if (newStackElement = AllocateMemoryForStack())\n    {\n        while (tempStackElement->next)\n            tempStackElement = tempStackElement->next;\n        newStackElement->next = tempStackElement->next;\n        tempStackElement->next = newStackElement;\n        newStackElement->data = current;\n        return 0;\n    }\n    else\n        return 1;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__tokenizer.4.c", "original_string": "void freetokens(TOKEN* t) {\n    free(t->token);\n    TOKEN* next = t->next;\n    free(t);\n    if(next != NULL)\n        freetokens(next);\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__22.0.c", "original_string": "int main()\n{\n    char str[10];\n    int tam, valor, num = false;\n    while (num == false)\n    {\n        puts(\"\\nInforme um n\u00famero:\");\n        scanf(\"%s\", str);\n        getchar();\n        tam = strlen(str);\n        valor = atoi(str);\n        if ((pow(10, (tam - 1))) <= valor)\n        {\n            num = true;\n        }\n        else if (num == false)\n        {\n            system(\"clear\");\n            puts(\"\\nN\u00famero inv\u00e1lido, digite novamente!\");\n        }\n    }\n    puts(\"\\nO n\u00famero \u00e9 de fato um n\u00famero\\n\");\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.13.c", "original_string": "void searching(int val, int *pos, struct btreeNode *myNode) {\n        if (!myNode) {\n                return;\n        }\n        if (val < myNode->val[1]) {\n                *pos = 0;\n        } else {\n                for (*pos = myNode->count;\n                        (val < myNode->val[*pos] && *pos > 1); (*pos)--);\n                if (val == myNode->val[*pos]) {\n                        printf(\"Given data %d is present in B-Tree\", val);\n                        return;\n                }\n        }\n        searching(val, pos, myNode->link[*pos]);\n        return;\n  }"}
{"author": "sdukesameer", "file": "c__seq_search.2.c", "original_string": "int main() {\n    int arr[MAX], n, val, pos;\n    scanf(\"%d\", &n);                    \n    if (n<=0) {\n            printf(\"ERROR: Empty list\\n\");\n            exit(EXIT_FAILURE);\n    }\n    inputArray( arr, n );             \n    scanf(\"%d\", &val);                \n    pos = search(arr, n, val); \n    if (pos != -1)\n        printf(\"Position of %d: %d\\n\", val, pos);\n    else\n        printf(\"All checked: %d not found\\n\", val);\n    return 0;\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_6.2.c", "original_string": "void addbegin()\n{\n    struct node* temp;\n    temp = (struct node*)malloc(sizeof(struct node));\n    printf(\"Enter an element to insert : \");\n    scanf(\"%d\", &temp->data);\n    printf(\"%d inserted.\\n\\n\", temp->data);\n    temp->left = NULL;\n    temp->right = NULL;\n    if(root == NULL)\n    {\n        root = temp;\n    }\n    else\n    {\n        temp->right = root;\n        root->left = temp;\n        root = temp;\n    }\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_7_a.0.c", "original_string": "int main()\n{\n    int one[8] = {5, 6, 8, 8, 10, -2, 0, 121};\n    int two[8] = {2, 1, 3, -4, 10, 21, 2, 233};\n    int three[8];\n    unsigned int naturalNumber = 8;\n    printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n    copyArrays(naturalNumber, one, two, three);\n    printf(\"\\nElementy tablicy3: \");\n    for(int i = 0; i < (sizeof(three)/sizeof(three[0])); i++){\n        printf(\"%d \", three[i]);\n    }\n    getchar();;\n    return 0;\n}"}
{"author": "deepaliajabsingjadhav", "file": "file__lseek_file.0.c", "original_string": "void FileRead(char *name, int position)\n{\n    int fd = 0, ret = 0;\n    char Mug[10] = {'\\0'};\n    fd = open(name,O_RDONLY);\n    if(fd == -1)\n    {\n        printf(\"Unable to open file\\n\");\n        return;\n    }\n    ret = lseek(fd,position,SEEK_SET);\n    printf(\"Return value of lseek : %d\\n\",ret);\n    ret = read(fd,Mug,10);\n    printf(\"Data from the file is : \\n\");\n    printf(\"Return value of read : %d\\n\",ret);\n    write(1,Mug,ret);\n    printf(\"\\n\");\n    close(fd);\n}"}
{"author": "fikepaci", "file": "monty__monty_funcs_1.1.c", "original_string": "void monty_pall(stack_t **stack, unsigned int line_number)\n{\n    stack_t *tmp = (*stack)->next;\n    while (tmp)\n    {\n        printf(\"%d\\n\", tmp->n);\n        tmp = tmp->next;\n    }\n    (void)line_number;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__ssh_exchange_hash.3.c", "original_string": "error_t sshGenerateExchangeHashSignature(SshConnection *connection, uint8_t *p,\n   size_t *written)\n{\n   error_t error;\n   SshHostKey *hostKey;\n   error = sshFinalizeExchangeHash(connection, connection->h,\n      &connection->hLen);\n   if(!error)\n   {\n      if(!connection->newKeysSent)\n      {\n         osMemcpy(connection->sessionId, connection->h, connection->hLen);\n         connection->sessionIdLen = connection->hLen;\n      }\n      hostKey = sshGetHostKey(connection);\n      if(hostKey != NULL)\n      {\n         error = sshGenerateSignature(connection, connection->serverHostKeyAlgo,\n            hostKey, connection->h, connection->hLen, p, written);\n      }\n      else\n      {\n         error = ERROR_INVALID_KEY;\n      }\n   }\n   return error;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Smanipulate.0.c", "original_string": "void main()\n{\n    char c[100];\n    int length,i,n,j,temp;\n    printf(\"Enter the string:\");\n    gets(c);\n    length=strlen(c);\n    printf(\"\\nEnter the number of shifts:\");\n    scanf(\"%d\",&n);\n    while(n!=0)\n    {\n        i=length-1;\n        j=i;\n        temp=c[i];\n        while(j>=0)\n        {\n            i--;\n             c[j]=c[i];\n             j--;\n        }\n        c[0]=temp;\n        n--;\n    }\n    printf(\"\\nAfter shifting:\");\n    puts(c);\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__cub2d.2.c", "original_string": "void        render(void)\n{\n    update();\n    draw_map();\n    cast_rays();\n    mlx_put_image_to_window(g_vars.mlx, g_vars.win, g_image.img, 0, 0);\n    mlx_destroy_image(g_vars.mlx, g_image.img);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__first_occurence.0.c", "original_string": "int SearchFirstOcc(char str[], char ch)\n{\n    int i = 0;\n    if((str == NULL) || (ch == '\\0'))\n    {\n        return -1;\n    }\n    while(str[i] != '\\0')\n    {\n            if(str[i] == ch)\n            {\n                break;\n            }\n        i++;\n    }\n    if(str[i] == ch)        \n    {\n        return i;\n    }\n    else                        \n    {\n        return -1;\n    }\n}"}
{"author": "theuwis", "file": "project-euler__main1.0.c", "original_string": "int main(void){\n    long input = 600851475143;\n    int i;\n    while(input%2 == 0){\n        printf(\"%d \", 2);\n        input = input/2;\n    }\n    for(i = 3; i <= sqrt(input); i += 2){\n        while(input%i == 0){\n            printf(\"%d \", i);\n            input = input/i;\n        }\n    }\n    if (input > 2) printf (\"%ld \", input);\n    printf(\"\\n\");\n    return EXIT_SUCCESS;\n}"}
{"author": "dishanp", "file": "DSA__q9.2.c", "original_string": "int main()\n{\n    int *arr, n;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element %d : \", i+1);\n        scanf(\"%d\", &arr[i]);\n    }\n    segregate(arr, n);\n    printf(\"Segregated array : \\n\");\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__AA.1.c", "original_string": "int busca(long int n, int k)\n{\n    for (int j = 0; (j <= k) && ((primos[j] * primos[j]) <= n); j++)\n    {\n        if ((n % primos[j]) == 0)\n        {\n            printf(\"composto\\n\");\n            return 0;\n        }\n    }\n    printf(\"primo\\n\");\n    return 0;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es22.0.c", "original_string": "void scambia(int v[], int dim, int i, int j){\n    if(dim > 0)\n    {\n        if((i >= 0) && (i <= dim) && (j >= 0) && (j <= dim))\n        {\n            int tmp = v[i];\n            v[i] = v[j];\n            v[j] = tmp;\n        }\n    }\n}"}
{"author": "andi-s0106", "file": "sorting_algorithms__107-quick_sort_hoare.0.c", "original_string": "int partition(int *array, int lo, int hi, size_t size)\n{\n    int i, j, pivot, tmp;\n    pivot = array[hi];\n    i = lo - 1;\n    j = hi + 1;\n    while (1)\n    {\n        while (array[++i] < pivot)\n        {\n            ;\n        }\n        while (array[--j] > pivot)\n        {\n            ;\n        }\n        if (i > j)\n            return (j);\n        if (i != j)\n        {\n            tmp = array[i];\n            array[i] = array[j];\n            array[j] = tmp;\n            print_array(array, size);\n        }\n    }\n}"}
{"author": "dle2005", "file": "Algorithm__Prim.0.c", "original_string": "void prim(int n, int **W, edge *F) {\n    int i, vnear, min;\n    edge e;\n    for(i = 2; i <= n; i++) {\n        nearest[i] = 1;\n        distance[i] = W[1][i];\n    }\n    printf(\"nearest = \");\n    for(i = 2; i <= n; i++) printf(\"%d \", nearest[i]);\n    printf(\"\\ndistance = \");\n    for(i = 2; i <= n; i++) printf(\"%d \", distance[i]);\n    printf(\"\\n\\n\");\n    for(int j = 0; j < n -1; j++) {\n        min = 999;\n        for(i = 2; i <= n; i++) \n            if(0 <= distance[i] && distance[i] <= min) {\n                min = distance[i];\n                vnear = i;\n            }\n        e.from = nearest[vnear];\n        e.end = vnear;\n        e.distance = distance[vnear];\n        F[j].from = e.from;\n        F[j].end = e.end;\n        F[j].distance = e.distance;\n        distance[vnear] = -1;\n        printf(\"path : V%d -> V%d distance %d\\n\\n\", e.from, e.end, e.distance);\n        for(i = 2; i <= n; i++)\n            if(W[i][vnear] < distance[i]) {\n                distance[i] = W[i][vnear];\n                nearest[i] = vnear;\n            }\n        printf(\"nearest = \");\n        for(i = 2; i <= n; i++) printf(\"%d \", nearest[i]);\n        printf(\"\\ndistance = \");\n        for(i = 2; i <= n; i++) printf(\"%d \", distance[i]);\n        printf(\"\\n\\n\");\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__parser-structure.6.c", "original_string": "CLASSVARDEC* parseclassvardecs(PARSER* p) {\n    CLASSVARDEC* head = parseclassvardec(p);\n    CLASSVARDEC* curr = head;\n    CLASSVARDEC* nextc;\n    while(nextc = parseclassvardec(p), nextc != NULL) {\n        curr->next = nextc;\n        curr = nextc;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}"}
{"author": "ria3999", "file": "cbnst__NEWTONS_BACKWARD_INTERPOLATION.0.c", "original_string": "float u_cal(float u, int n)\n{\n    float temp = u;\n    for (int i = 1; i < n; i++)\n        temp = temp * (u + i);\n    return temp;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q21.4.c", "original_string": "int main() \n{ \n    char exp[100], ans[100];\n    scanf(\"%s\", exp);\n    strrev(exp);\n    for(int i = 0 ; i < strlen(exp) ; i++)\n    {\n        if (exp[i] == ')')\n            exp[i] ='(';\n        else if (exp[i] == '(')\n            exp[i] =')';\n    }\n    infixToPostfix(exp, ans);\n    strrev(ans);\n    printf(\"%s \\n\", ans); \n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__sum0.1.c", "original_string": "int  ClientProcess(float  SharedMem[])\n     {\n     float sum=0,product=1;\n     int i;\n     for(i=0;i<10;i++)\n     {\n         sum+=(SharedMem[i]);\n     }\n     printf(\"the sum is %f\\n\",sum);\n     for(i=0;i<10;i++)\n     {\n         product*=(SharedMem[i]);\n     }\n     printf(\"the product are %f\\n\",product);\n     return (sum);\n     }"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__logica-classica.0.c", "original_string": "int main(void)\n{\n    float temp, frio, normal, quente;\n    printf(\"\\nInforme a temperatura ambiente em graus celsius: \");\n    scanf(\"%f\", &temp);\n    if (temp < 20)\n    {\n        frio = 1;\n        normal = 0;\n        quente = 0;\n    }\n    else if ((temp >= 20) && (temp <= 26))\n    {\n        frio = 0;\n        normal = 1;\n        quente = 0;\n    }\n    else\n    {\n        frio = 0;\n        normal = 0;\n        quente = 1;\n    }\n    if (frio == 1)\n    {\n        printf(\"\\nO aparelho est\u00e1 aquecendo\\n\\n\");\n    }\n    else if (normal == 1)\n    {\n        printf(\"\\nO aparelho est\u00e1 desligado\\n\\n\");\n    }\n    else if (quente == 1)\n    {\n        printf(\"\\nO aparelho est\u00e1 resfriando\\n\\n\");\n    }\n}"}
{"author": "2security", "file": "If-else__SalaryCal.0.c", "original_string": "int main()\n    {\n    float basicsal,HRA,DA;\n    printf(\"Enter the basic salary\");\n    scanf(\"%f\",&basicsal);\n    if(basicsal>20000)\n        {\n        HRA=basicsal*30/100;\n        DA=basicsal*95/100;\n        }\n    else if(basicsal<=20000)\n        {\n        HRA=basicsal*25/100;\n        DA=basicsal*90/100;\n        }\n    else if(basicsal<=10000)\n        {\n        HRA=basicsal*20/100;\n        DA=basicsal*80/100;\n        }\n    printf(\"\\n Gross salary=%f\\n\",basicsal+HRA+DA);\n    printf(\"\\n\");   \n    return 0;\n    }"}
{"author": "paawankohli", "file": "DSA-LAB__q23.4.c", "original_string": "void display(queue *q)\n{\n    int i;\n    for (i = q->front ; i<q->rear ; i++)\n        printf(\"%s\\t\",q->c[i]);\n    printf(\"\\n\");\n}"}
{"author": "dishanp", "file": "DSA__q51.0.c", "original_string": "int main()\n{\n    int arr1[100], n,counter=0;\n    int i, j, k;\n       printf(\"Number of elements to be stored in the array :\");\n       scanf(\"%d\",&n);\n       printf(\"Input %d elements in the array :\\n\",n);\n       for(i=0;i<n;i++)\n            {\n          printf(\"element - %d : \",i);\n          scanf(\"%d\",&arr1[i]);\n        }\n    printf(\"\\nThe unique elements found in the array are : \\n\");\n    for(i=0; i<n; i++)\n    {\n        counter=0;\n        for(j=0; j<i-1; j++)\n        {\n            if(arr1[i]==arr1[j])\n            {\n                counter++;\n            }\n        }\n       for(k=i+1; k<n; k++)\n        {\n            if(arr1[i]==arr1[k])\n            {\n                counter++;\n            }\n        }\n       if(counter==0)\n        {\n          printf(\"%d \",arr1[i]);\n        }\n    }\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__matrices_dinamicas.2.c", "original_string": "void mostrar_temperaturas(float **t, int f, int c){\n    for (int i = 0; i < f; i++){\n        for (int j = 0; j < c; j++){\n            printf(\"%f\\t\", t[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad9MatrixMultiply.2.c", "original_string": "void multiplyByTwo(int sourceArray[], int size){\n    int * pointerSourceArray = sourceArray;\n    for(int i = 0; i < size*5; i++){\n        *pointerSourceArray = *pointerSourceArray * 2;\n        pointerSourceArray++;\n    }\n}"}
{"author": "earth429", "file": "mulpre__simpleMultiple.0.c", "original_string": "int main(int argc, char **argv)\n{\n    int a = -5;\n    int b = -3;\n    int c, return_val;\n    return_val = simpleMultiple(a, b, &c);\n    printf(\"c = %d\\n\",c);\n    printf(\"\u623b\u308a\u5024 = %d\", return_val);\n    return 0;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_c_extended.3.c", "original_string": "static void on_disconnected(ble_lbs_c_t * p_ble_lbs_c, ble_evt_t const * p_ble_evt)\n{\n    if (p_ble_lbs_c->conn_handle == p_ble_evt->evt.gap_evt.conn_handle)\n    {\n        p_ble_lbs_c->conn_handle                    = BLE_CONN_HANDLE_INVALID;\n        p_ble_lbs_c->peer_lbs_db.button_cccd_handle = BLE_GATT_HANDLE_INVALID;\n        p_ble_lbs_c->peer_lbs_db.button_handle      = BLE_GATT_HANDLE_INVALID;\n        p_ble_lbs_c->peer_lbs_db.led_handle         = BLE_GATT_HANDLE_INVALID;\n        p_ble_lbs_c->peer_lbs_db.led_color_handle   = BLE_GATT_HANDLE_INVALID;\n    }\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__create_and_traverse_SINGLE_linked_list.1.c", "original_string": "void display_node(struct node*temp1)\n{\n    printf(\"The Elements are:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->link;\n    }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__print_memory.2.c", "original_string": "void    print_memory(const void *addr, size_t size)\n{\n    unsigned char   *adr;\n    size_t  i;\n    size_t  j;\n    i = 0;\n    j = 0;\n    adr = (unsigned char*)addr;\n    while (i < size)\n    {\n        j = 0;\n        while (j < 16 && i+j < size)\n        {\n            print_hex(adr[i + j]);\n            if (j%2)\n                write(1,\" \",1);\n            j++;\n        }\n        while (j < 16)\n        {\n            write(1, \"  \", 2);\n            if (j%2)\n                write(1, \" \",1);\n            j++;\n        }\n        j = 0;\n        while (j < 16 && i+j < size)\n        {\n            print_char(adr[i +j]);\n            j++;\n        }\n        write(1,\"\\n\",1);\n        i += 16;\n    }\n}"}
{"author": "jdes01", "file": "practicassoo__practica2ej3.6.c", "original_string": "int main(int argc, char const *argv[]){\n    if( argc < 2 || comprobacionArgumento( atoi(argv[1]) ) == 0 ){\n        printf(\"Error llame al programa de la siguiente forma:\\n\");\n        printf(\"./E3 2. o /E3 5\\n\");\n        exit(EXIT_FAILURE);\n    }\n    int numeroHilos = atoi(argv[1]);\n    vInfo *vPadre = malloc( sizeof(vInfo) ); \n    vPadre->numeroElementos = 10;\n    vPadre->vector = reservarMemoria( vPadre->numeroElementos );\n    rellenaVector( vPadre->vector, vPadre->numeroElementos );\n    printf(\"El vector padre es: \\n\");\n    imprimeVector( vPadre->vector, vPadre->numeroElementos );\n    vInfo * vHijos = creaHijos(vPadre->vector, numeroHilos); \n    pthread_t hilos[numeroHilos];\n    int * retorno, suma = 0;\n    for (int i = 0; i < numeroHilos; i++){\n        if( pthread_create( &hilos[i], NULL, (void *) sumaHilos, (void *) vHijos+( sizeof(vInfo)*i ) ) != 0 ){\n            fprintf(stderr, \"Error creating thread\\n\");\n            exit(EXIT_FAILURE); \n        }\n    }\n    for (int i = 0; i < numeroHilos; i++){\n        if(pthread_join( hilos[i], (void**) &retorno) ){\n            fprintf(stderr, \"Error joining thread\\n\");\n            exit(EXIT_FAILURE);\n        }\n        suma += *retorno;\n    }    \n    printf(\"\\nLa suma de los numeros de todos los vectores es: %d\\n\", suma);\n    exit(EXIT_SUCCESS);\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.29.c", "original_string": "ASMBLK* translatepop(VMTRANSLATOR* t) {\n    if(eq(t, 1, \"static\"))\n        return translatepopstatic(t);\n    if(eq(t, 1, \"pointer\"))\n        return translatepoppointer(t);\n    if(eq(t, 1, \"temp\"))\n        return translatepoptemp(t);\n    return translatepopgeneric(t);\n}"}
{"author": "DanielSalis", "file": "AED1__teste5.4.c", "original_string": "void imprimeLista(TipoLista* l){\n  TipoElemento *aux = l->primeiro;\n  int cont = 0;\n  while(cont != l->tamanho){\n    if(cont == 0)\n      printf(\"| \");\n    printf(\"soldado: %c \", aux->nome);\n    aux = aux->prox;\n    cont++;\n    if(cont != l->tamanho)\n      printf(\"-> \");\n    else\n      printf(\"|\");\n  }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_12.3.c", "original_string": "int main()\n{       FILE* F1;\n        FILE *F2;\n        F1 = fopen(\"input.txt\",\"r\");\n        F2 = fopen(\"output.txt\",\"w\");\n        if(F1 == NULL)\n        {\n                printf(\"input file not found\");\n                exit(0);\n        }\n          int flag=-1;;\n      char a,check;\n      char c;\n          int p,size,elt,q,t1,t2,res;\n          struct stack AA;\n          struct stack *A=&AA;\n          A->top=-1;\n        while(1)\n        {\n                fscanf(F1,\"%c\",&a);\n               if(a=='e' || a=='s');\n                else\n               {\n                        printf(\"invalid char input \");\n                        fprintf(F2,\"-999\");\n                        exit(0);\n                }\n                if(a=='e')\n                {  \n                fscanf(F1,\" \");\n        while(1)\n        {\n        fscanf(F1,\"%c\",&check);\n        if(check=='e' || check =='s' || check=='\\n')\n        {    fseek(F1,-1,1);\n            break;}\n        else\n            fseek(F1,-1,1);\n        t2=ftell(F1);\n        if(fscanf(F1,\"%d\",&elt));\n        else\n        {\n        flag=1;  \n        t1=ftell(F1);\n        if(t1!=t2)\n        {\n        fseek(F1,-1,1);\n        }\n        fscanf(F1,\"%c\",&c);\n        }\n        if(flag==-1)\n        {\n        A=push(A,elt);\n        }\n        if(flag==1)\n        {   int e1=pop(A);\n            A->top=A->top-1;\n            int e2=pop(A);\n             A->top=A->top-1;\n            res=evaluatepostfix(e1,e2,c,F2);\n            A=push(A,res);\n        }\n        flag=-1;\n        fscanf(F1,\" \");\n        }\n        fprintf(F2,\"%d\\n\",A->stk[A->top]);\n        A->top=-1;\n        } \n                if(a=='s')\n                        exit(0);\n                fscanf(F1,\"\\n\");\n        }\n        return 0;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__ft_itoa.1.c", "original_string": "int     ft_div(int nb)\n{\n    int div;\n    div = 1;\n    if (nb == 1)\n        return (div);\n    while (nb > 1)\n    {\n        div *= 10;\n        nb--;\n    }\n    return (div);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__stackTopStackBottom.1.c", "original_string": "int isFull(struct stack*ptr){\n    if(ptr->top == ptr->size-1){\n        printf(\"Stack is Full(overflow)..\\n\");\n        return 1;\n    }\n    else{\n        return 0;\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__tokenizer.17.c", "original_string": "TOKEN* tokenize(char* file) {\n    TOKEN* head = mktoken();\n    TOKEN* lastitem = head;\n    TOKEN* curitem = head;\n    STRING* tmptoken = mkstring(200);\n    CHARTYPE lasttype = space;\n    CHARTYPE curtype;\n    int lnscount = 1;\n    FILE* input = fopen(file, \"r\");\n    unsigned char c;\n    while(!feof(input)) {\n        c = fgetc(input);\n        if(c == '\\n')\n            lnscount++;\n        else if(c == '/' && handlecomment(input, &lnscount)) \n            continue;\n        else if(c == '\"') {\n            if(lasttype != space)\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            readstr(input, tmptoken, lnscount);\n            lastitem = curitem;\n            curitem = appendtokenraw(curitem, tmptoken, lnscount, string);\n            lasttype = space;\n            continue;\n        }\n        curtype = getchartype(c);\n        if(curtype == common) {\n            if(lasttype == charsymbol) {\n                lastitem = curitem;\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            }\n            append(tmptoken, c);\n        } else {\n            if(lasttype != space){\n                lastitem = curitem;\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            }\n            if(curtype == charsymbol)\n                append(tmptoken, c);\n        }\n        lasttype = curtype;\n    }\n    if(curitem == head) {\n        eprintf(\"File '%s' is empty\\n\", file);\n        exit(1);\n    }\n    lastitem->next = NULL;\n    free(curitem);\n    freestr(tmptoken);\n    fclose(input);\n    return head;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_25.0.c", "original_string": "int main()\n{\n    int vetor[50];\n    int i;\n    for(i= 0; i < 50; i++){\n        if(i %7 != 0 && i % 10 != 7 ){\n            printf(\"\\n %d \\n\", i);\n        }\n        else{\n            continue;\n        }\n    }\n    system(\"PAUSE\");\n    return 0;\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example51.0.c", "original_string": "int main()\n{\n    int asal,num1;\n    printf(\"pozitif bir tam say\u0131 giriniz:\\n\");\n    scanf(\"%d\",&num1);\n    if(num1==1)\n    {\n        printf(\"1 asal de\u011fildir\\n\");\n        return 0;    \n    }\n    asal=asalKontrol(num1,(num1/2));  \n    if(asal==1)\n        printf(\"%d asald\u0131r\\n\",num1);\n    else\n         printf(\"%d asal de\u011fildir\\n\",num1);\n   return 0;     \n}"}
{"author": "sdukesameer", "file": "dsa__list-del-rev.2.c", "original_string": "void delete(node** head, int key)\n{\n    if(*head==NULL)\n        printf(\"Oops! Can't delete, STACK EMPTY\\n\");\n    else\n    {\n        int c=0,f=0;\n        node* prev;\n        node* cur=*head;\n        while(cur != NULL)\n        {\n            c++;\n            if(c==1)\n            {    \n                if (cur->data==key)\n                {\n                    *head=cur->next;\n                    free(cur);\n                    cur=*head;\n                    f=1;c=0;\n                }\n                else\n                {\n                    prev=cur;\n                    cur=cur->next;\n                }\n            }\n            else\n            {\n                if(cur->data==key)\n                {\n                    prev->next=cur->next;\n                    free(cur);\n                    cur=prev->next;\n                    f=1;\n                }\n                else\n                {\n                    prev=cur;\n                    cur=cur->next;\n                }\n            }\n        }\n        if(f==0)\n            printf(\"NO MATCH FOUND\\n\");\n        else\n            printf(\"MATCH FOUND!\\nAll matching elements deleted\\n\");\n    }\n}"}
{"author": "davibernardos", "file": "DB-Projetos__e8.0.c", "original_string": "int main(int argc, char *argv[]) {\n    char opcaoMenu;\n    char opcaoJogarNovamnt;\n    char opcaoJogador1;\n    char opcaoJogador2;\n    int opcaoJogador3;\n    int opcaoComputador;\n    char nomeJogador1[15];\n    char nomeJogador2[15];\n    char nomeJogador3[15];\n    char nomeComputador[15];\n    int empates = 0;\n    float vitoriasJogador1 = 0;\n    float vitoriasJogador2 = 0;\n    float vitoriasJogador3 = 0;\n    float vitoriasComputador = 0;\n    float percentVitJog1;\n    float percentVitJog2;\n    float percentVitJog3;\n    float percentVitComp;\n    int totalPartidas = 0;\n    system (\"COLOR 0F\");\n    system (\"cls\");\n    printf (\"Bem vindo ao jogo JOKENPO!\");\n    printf (\"\\n\\nDigite 1 para o modo Humano X Humano.\");\n    printf (\"\\nDigite 2 para o modo Humano X Computador.\");\n    printf (\"\\nDigite 3 para sair do jogo.\");\n    printf (\"\\n\\nEscolha o modo de jogar: \");\n    opcaoMenu = getch();\n    switch (opcaoMenu)\n        {\n        case '1':\n            system(\"cls\");\n            system (\"COLOR 0E\");\n            printf (\"Jogo Jokenpo: Modo Humano X Humano.\");\n            printf (\"\\n\\nJogador 1 - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador1);\n            printf (\"\\nJogador 2 - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador2);\n            do\n            {\n                system(\"cls\");\n                printf (\"Jogo Jokenpo - Modo Humano X Humano.\");\n                printf (\"\\n\\nDigite 1 para PEDRA.\");\n                printf (\"\\nDigite 2 para PAPEL.\");\n                printf (\"\\nDigite 3 para TESOURA.\");\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador1);\n                opcaoJogador1 = getch();\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador2);\n                opcaoJogador2 = getch();\n                if (opcaoJogador1 == opcaoJogador2)\n                {\n                    printf (\"\\n\\n%s e %s, voces EMPATARAM!\", nomeJogador1,nomeJogador2);\n                    empates++;\n                }else\n                {\n                    if (opcaoJogador1 == '1' && opcaoJogador2 == '3')\n                    {\n                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador1);\n                        vitoriasJogador1++;                         \n                    }else\n                    {\n                        if (opcaoJogador1 == '2' && opcaoJogador2 == '1')\n                        {\n                            printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador1);\n                            vitoriasJogador1++; \n                        }else\n                        {\n                            if (opcaoJogador1 == '3' && opcaoJogador2 == '2')\n                            {\n                                printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador1);\n                                vitoriasJogador1++;\n                            }else\n                            {\n                                if (opcaoJogador1 == '1' && opcaoJogador2 == '2')\n                                {\n                                    printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador2);\n                                    vitoriasJogador2++;\n                                }else\n                                {\n                                    if (opcaoJogador1 == '2' && opcaoJogador2 == '3')\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador2);\n                                        vitoriasJogador2++;\n                                    }else\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador2);\n                                        vitoriasJogador2++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }   \n                sleep(2);\n                totalPartidas++;\n                printf (\"\\n\\n\\nDeseja jogar novamente? S/N\");\n                opcaoJogarNovamnt = getch();\n            }\n            while (opcaoJogarNovamnt == 's');\n            break;\n        case '2':\n            system (\"COLOR 0A\");\n            system(\"cls\");\n            printf (\"Jogo Jokenpo - Modo Humano X Computador.\");\n            printf (\"\\n\\nJogador - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador3);\n            printf (\"\\n%s - Digite um nome para o computador: \",nomeJogador3);\n            scanf (\"%s\", &nomeComputador);\n            do\n            {\n                system(\"cls\");\n                printf (\"Jogo Jokenpo - Modo Humano X Computador.\");\n                printf (\"\\n\\nDigite 1 para PEDRA.\");\n                printf (\"\\nDigite 2 para PAPEL.\");\n                printf (\"\\nDigite 3 para TESOURA.\");\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador3);\n                scanf (\"%d\", &opcaoJogador3);\n                printf (\"\\n%s: Escolha o que vai jogar:\", nomeComputador);\n                sleep (2);\n                srand((unsigned)time(NULL));\n                opcaoComputador = (rand() % 3 + 1);\n                if (opcaoJogador3 == opcaoComputador)\n                {\n                    printf (\"\\n\\n%s e %s, voces EMPATARAM!\", nomeJogador3,nomeComputador);\n                    empates++;\n                }else\n                {\n                    if (opcaoJogador3 == 1 && opcaoComputador == 3)\n                    {\n                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador3);\n                        vitoriasJogador3++;                         \n                    }else\n                    {\n                        if (opcaoJogador3 == 2 && opcaoComputador == 1)\n                        {\n                            printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador3);\n                            vitoriasJogador3++; \n                        }else\n                        {\n                            if (opcaoJogador3 == 3 && opcaoComputador == 2)\n                            {\n                                printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador3);\n                                vitoriasJogador3++;\n                            }else\n                            {\n                                if (opcaoJogador3 == 1 && opcaoComputador == 2)\n                                {\n                                printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeComputador);\n                                vitoriasComputador++;\n                                }else\n                                {\n                                    if (opcaoJogador3 == 2 && opcaoComputador == 3)\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeComputador);\n                                        vitoriasComputador++;\n                                    }else\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeComputador);\n                                        vitoriasComputador++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                sleep (2);\n                totalPartidas++;\n                printf (\"\\n\\n\\nDeseja jogar novamente? S/N\");\n                opcaoJogarNovamnt = getch();\n            }\n            while (opcaoJogarNovamnt == 's');\n            break;\n        case '3':\n            system (\"COLOR 0F\");\n            printf (\"\\n\\nSaindo do jogo...\");\n            return 0;\n        default:\n            system (\"COLOR 0F\");\n            printf (\"\\n\\nOpcao invalida. Saindo do jogo...\");\n            return 0;\n        }\n    system(\"cls\");\n    system (\"COLOR 0F\");\n    if (totalPartidas == 1 && empates == 1)\n    {\n        printf (\"Jogo Jokenpo. Resultados: Modo Humano X Humano.\");\n        printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);\n        printf (\"\\nTotal de empates: %d\", empates);\n        printf (\"\\n\\nNao houve ganhador.\");\n    }else\n    {\n        if (opcaoMenu == '1')\n        {\n            printf (\"Jogo Jokenpo. Resultados: Modo Humano X Humano.\");\n            printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);            printf (\"\\nTotal de empates: %d\", empates);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\", nomeJogador1,percentVitJog1 = (vitoriasJogador1 / (totalPartidas - empates)) * 100);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\\n\\n\", nomeJogador2,percentVitJog2 = (vitoriasJogador2 / (totalPartidas - empates)) * 100);   \n        }\n        else\n        {\n            if (opcaoMenu == '2')\n            printf (\"Jogo Jokenpo. Resultados: Modo Humano X Computador.\");\n            printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);\n            printf (\"\\nTotal de empates: %d\", empates);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\", nomeJogador3,percentVitJog3 = (vitoriasJogador3 / (totalPartidas - empates)) * 100);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\\n\\n\", nomeComputador,percentVitComp = (vitoriasComputador / (totalPartidas - empates)) * 100);\n        }\n    }\nreturn 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__duplicateLL.4.c", "original_string": "void removeDuplicate2(nptr head)\n{\n    if (head == NULL)\n        printf(\"Empty list\\n\");\n    nptr curr = head, dup = NULL;\n    while(curr != NULL && curr -> next != NULL)\n    {\n        if (curr -> data == curr -> next -> data)\n        {\n            dup = curr -> next;\n            curr -> next = dup -> next;\n            free(dup);\n        }\n        else\n            curr = curr -> next;\n    }\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_31.0.c", "original_string": "void populaVetorUniao() {\n    for (int c = 0; c < 10; c++) {\n        uniao[c] = vet1[c];\n    }\n    for (int i = 0; i <= 10; i++) {\n        int valorJaInseridoUniao = 0;\n        for (int j = 0; j < 10; j++) {\n            if (vet2[i] == uniao[j]) {\n                valorJaInseridoUniao = 1;\n            }\n        }\n        if (valorJaInseridoUniao == 0) {\n            uniao[i + 10] = vet2[i];\n        }\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__studentStruct.0.c", "original_string": "void readData(STUDENT* s)\n{\n    printf(\"Enter name: \");\n    scanf(\"%s\", (s->name));\n    printf(\"Enter roll number: \");\n    scanf(\"%d\", &(s->rollNum));\n    printf(\"Enter GPA: \");\n    scanf(\"%f\", &(s->gpa));\n}"}
{"author": "2security", "file": "Array__Symmetric.0.c", "original_string": "int main()\n    {\n    int i,j,r,c,**mat1,**mat2;\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    mat1=(int **)malloc(r*sizeof(int *));   \n    mat2=(int **)malloc(r*sizeof(int *));   \n    for(i=0;i<r;i++)\n        mat1[i]=(int *)malloc(c*sizeof(int ));\n    for(i=0;i<r;i++)\n        mat2[i]=(int *)malloc(c*sizeof(int ));\n    printf(\"\\n Enter the matrix \\n\");\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)                \n    scanf(\"%d\",&mat1[i][j]);\n    if(IsSymmetric(mat1,Transpose(mat1,mat2,r,c),r,c))\n        printf(\"\\nSymmetric matrix\");\n    else\n        printf(\"\\nMatrix is not Symmetric matrix\");\n    return 0;\n    }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__4,_5,_6.4.c", "original_string": "int main()\n{\n    int n;\n    func_t escolha;\n    do\n    {\n        do\n        {\n            printf(\"\\t(1) Fibonacci\\n\");\n            printf(\"\\t(2) Padovan\\n\");\n            printf(\"\\t(3) Catalan\\n\");\n            printf(\"\\t(4) Sair\\n\");\n            printf(\"\\n\\tDigite sua escolha: \");\n            scanf(\"%i\", &escolha);\n            getchar();\n            system(\"clear\");\n        } while (escolha != fib && escolha != pad && escolha != cat && escolha != quit);\n        if (escolha == quit) return 0;\n        le_numero(&n);\n        switch (escolha)\n        {\n            case fib:\n                printf(\"\\nFibonacci de %i = %li\\n\\n\", n, fibonacci(n));\n                break;\n            case pad:\n                printf(\"\\nPadovan de %i = %li\\n\\n\", n, padovan(n));\n                break;\n            case cat:\n                printf(\"\\nCatalan de %i = %li\\n\\n\", n, catalan(n));\n                break;\n        }\n        printf(\"\\nPressione ENTER para continuar: \");\n        getchar();\n        system(\"clear\");\n    } while (escolha != quit);\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__shell_client_misc.1.c", "original_string": "error_t shellClientChannelRequestCallback(SshChannel *channel,\n   const SshString *type, const uint8_t *data, size_t length,\n   void *param)\n{\n   error_t error;\n   ShellClientContext *context;\n   TRACE_INFO(\"Shell client: SSH channel request callback...\\r\\n\");\n   context = (ShellClientContext *) param;\n   if(sshCompareString(type, \"exit-status\"))\n   {\n      SshExitStatusReqParams requestParams;\n      error = sshParseExitStatusReqParams(data, length, &requestParams);\n      if(!error)\n      {\n         if(channel == &context->sshChannel)\n         {\n            context->exitStatus = requestParams.exitStatus;\n         }\n         else\n         {\n            error = ERROR_UNKNOWN_REQUEST;\n         }\n      }\n   }\n   else\n   {\n      error = ERROR_UNKNOWN_REQUEST;\n   }\n   return error;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__linkedlisr.1.c", "original_string": "void InsertLast(PPNODE Head, int no)\n{\n    PNODE newn = NULL;\n    PNODE temp = *Head;\n    newn = (PNODE)malloc(sizeof(NODE)); \n    newn-> data = no;   \n    newn-> next = NULL; \n    if(*Head == NULL) \n    {\n        *Head = newn;\n    }\n    else  \n    {\n            while(temp->next != NULL)\n            {\n                temp = temp->next;\n            }\n        temp -> next = newn;\n    }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__ip.0.c", "original_string": "int FormIp(int no1,int no2,int no3,int no4)\n{\n    int ret=0;\n    no1=no1 & 0x000000ff;\n    no2=no2 & 0x000000ff;\n    no3=no3 & 0x000000ff;\n    no4=no4 & 0x000000ff;\n    no1=no1<<24;\n    no2=no2<<16;\n    no3=no3<<8;\n    ret= no1 | no2 | no3 |no4;\n    return ret;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_certificate.0.c", "original_string": "error_t acmeClientSendDownloadCertRequest(AcmeClientContext *context,\n   char_t *buffer, size_t size, size_t *length)\n{\n   error_t error;\n   error = NO_ERROR;\n   while(!error)\n   {\n      if(context->requestState == ACME_REQ_STATE_INIT)\n      {\n         TRACE_DEBUG(\"\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"## DOWNLOAD CERTIFICATE #######################################################\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"\\r\\n\");\n         context->requestState = ACME_REQ_STATE_FORMAT_BODY;\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_BODY)\n      {\n         error = acmeClientFormatDownloadCertRequest(context);\n         if(!error)\n         {\n            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)\n      {\n         error = acmeClientFormatRequestHeader(context, \"POST\",\n            context->order.certificate);\n         if(!error)\n         {\n            context->requestState = ACME_REQ_STATE_SEND_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||\n         context->requestState == ACME_REQ_STATE_SEND_BODY ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||\n         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||\n         context->requestState == ACME_REQ_STATE_CLOSE_BODY)\n      {\n         error = acmeClientSendRequest(context);\n      }\n      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)\n      {\n         error = acmeClientParseDownloadCertResponse(context, buffer, size,\n            length);\n         context->requestState = ACME_REQ_STATE_INIT;\n         break;\n      }\n      else\n      {\n         error = ERROR_WRONG_STATE;\n      }\n   }\n   return error;\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__1000-sort_deck.3.c", "original_string": "void sort_deck(deck_node_t **deck)\n{\n    if (deck == NULL || *deck == NULL || (*deck)->next == NULL)\n        return;\n    quicksort(deck, 0, 51);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q2.7.c", "original_string": "void inorder(node *t)\n{\n    node* curr;\n    curr = t;\n    STACK s;\n    s.tos = -1;\n    push(&s, t);\n    curr = curr->left;\n    while (s.tos != -1 || curr != NULL)\n    {\n        while (curr != NULL)\n        {\n            push(&s, curr);\n            curr = curr->left;\n        }\n        curr = pop(&s);\n        printf(\"%d\\t\", curr->data);\n        curr = curr->right;\n    }\n}"}
{"author": "Oryx-Embedded", "file": "Common__date_time.6.c", "original_string": "int_t compareDateTime(const DateTime *date1, const DateTime *date2)\n{\n   int_t res;\n   if(date1->year < date2->year)\n      res = -1;\n   else if(date1->year > date2->year)\n      res = 1;\n   else if(date1->month < date2->month)\n      res = -1;\n   else if(date1->month > date2->month)\n      res = 1;\n   else if(date1->day < date2->day)\n      res = -1;\n   else if(date1->day > date2->day)\n      res = 1;\n   else if(date1->hours < date2->hours)\n      res = -1;\n   else if(date1->hours > date2->hours)\n      res = 1;\n   else if(date1->minutes < date2->minutes)\n      res = -1;\n   else if(date1->minutes > date2->minutes)\n      res = 1;\n   else if(date1->seconds < date2->seconds)\n      res = -1;\n   else if(date1->seconds > date2->seconds)\n      res = 1;\n   else if(date1->milliseconds < date2->milliseconds)\n      res = -1;\n   else if(date1->milliseconds > date2->milliseconds)\n      res = 1;\n   else\n      res = 0;\n   return res;\n}"}
{"author": "2security", "file": "Pointer__7ReverseArray.1.c", "original_string": "int* Reverse(int *a,int n)\n    {\n        int i,j=0,*b;\n        b=(int *)malloc(n*sizeof(int *));\n        for(i=n-1;i>=0;i--)\n        {\n            *(b+j)=*(a+i);\n            j++;\n        }       \n        return b;\n    }"}
{"author": "dishanp", "file": "DSA__q55.1.c", "original_string": "void display(struct node *p)\n{\n    while(p)\n    {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.12.c", "original_string": "TERM* parseidentifierterm(PARSER* p) {\n    TERM* t = parsecalltermnullified(p);\n    if(t == NULL)\n        if(nextequals(p, \"[\"))\n            return parsearrayterm(p);\n        else\n            return parsevarterm(p);\n    else\n        return t;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSL__ssl_misc.1.c", "original_string": "error_t sslComputeMac(TlsEncryptionEngine *encryptionEngine,\n   const TlsRecord *record, const uint8_t *data, size_t dataLen, uint8_t *mac)\n{\n   size_t padLen;\n   const HashAlgo *hashAlgo;\n   HashContext *hashContext;\n   hashAlgo = encryptionEngine->hashAlgo;\n   hashContext = (HashContext *) encryptionEngine->hmacContext->hashContext;\n   if(hashAlgo == MD5_HASH_ALGO)\n   {\n      padLen = 48;\n   }\n   else if(hashAlgo == SHA1_HASH_ALGO)\n   {\n      padLen = 40;\n   }\n   else\n   {\n      return ERROR_INVALID_PARAMETER;\n   }\n   hashAlgo->init(hashContext);\n   hashAlgo->update(hashContext, encryptionEngine->macKey, encryptionEngine->macKeyLen);\n   hashAlgo->update(hashContext, sslPad1, padLen);\n   hashAlgo->update(hashContext, &encryptionEngine->seqNum, sizeof(TlsSequenceNumber));\n   hashAlgo->update(hashContext, &record->type, sizeof(record->type));\n   hashAlgo->update(hashContext, (void *) &record->length, sizeof(record->length));\n   hashAlgo->update(hashContext, data, dataLen);\n   hashAlgo->final(hashContext, mac);\n   hashAlgo->init(hashContext);\n   hashAlgo->update(hashContext, encryptionEngine->macKey, encryptionEngine->macKeyLen);\n   hashAlgo->update(hashContext, sslPad2, padLen);\n   hashAlgo->update(hashContext, mac, hashAlgo->digestSize);\n   hashAlgo->final(hashContext, mac);\n   return NO_ERROR;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_client_misc.5.c", "original_string": "error_t scpClientReceiveDirective(ScpClientContext *context,\n   ScpDirective *directive)\n{\n   error_t error;\n   size_t n;\n   uint8_t opcode;\n   error = NO_ERROR;\n   while(!error)\n   {\n      if(context->bufferLen == 0)\n      {\n         error = sshReadChannel(&context->sshChannel, context->buffer, 1,\n            &n, 0);\n         if(!error)\n         {\n            context->bufferLen += n;\n         }\n      }\n      else if(context->bufferLen < SCP_CLIENT_BUFFER_SIZE)\n      {\n         opcode = context->buffer[0];\n         if(opcode == SCP_OPCODE_OK ||\n            opcode == SCP_OPCODE_END)\n         {\n            error = scpParseDirective(context->buffer, directive);\n            context->bufferLen = 0;\n            context->bufferPos = 0;\n            break;\n         }\n         else if(opcode == SCP_OPCODE_WARNING ||\n            opcode == SCP_OPCODE_ERROR ||\n            opcode == SCP_OPCODE_FILE ||\n            opcode == SCP_OPCODE_DIR ||\n            opcode == SCP_OPCODE_TIME)\n         {\n            n = SCP_CLIENT_BUFFER_SIZE - context->bufferLen;\n            error = sshReadChannel(&context->sshChannel, context->buffer +\n               context->bufferLen, n, &n, SSH_FLAG_BREAK_CRLF);\n            if(!error)\n            {\n               context->bufferLen += n;\n               if(context->bufferLen > 0 &&\n                  context->buffer[context->bufferLen - 1] == '\\n')\n               {\n                  context->buffer[context->bufferLen - 1] = '\\0';\n                  error = scpParseDirective(context->buffer, directive);\n                  context->bufferLen = 0;\n                  context->bufferPos = 0;\n                  break;\n               }\n               else\n               {\n                  error = ERROR_WOULD_BLOCK;\n               }\n            }\n         }\n         else\n         {\n            error = ERROR_INVALID_COMMAND;\n         }\n      }\n      else\n      {\n         error = ERROR_BUFFER_OVERFLOW;\n      }\n      if(error == ERROR_WOULD_BLOCK || error == ERROR_TIMEOUT)\n      {\n         error = scpClientProcessEvents(context);\n      }\n   }\n   return error;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica3-2.0.c", "original_string": "int main( int argc, const char * argv[]){\n    if (argc != 2){      \n        printf(\"Error\\n\");\n        exit(EXIT_FAILURE);\n    }\n    srand(time(NULL));      \n    int n = atoi(argv[1]);     \n    int *resultado;          \n    pthread_t thread[n];        \n    for(int i=0; i<n; i++){\n        if (pthread_create(&thread[i], NULL, suma, (void *) &indiceGlobal)){  \n            printf(\"Error %d\\n\", errno);\n            exit(EXIT_FAILURE);\n        }\n    }\n    for(int i=0; i<n; i++){\n        if (pthread_join(thread[i], (void **) &resultado )){\n            printf(\"Error %d\\n\", errno);\n            exit(EXIT_FAILURE);\n        }\n    }\n    printf(\"Valor del par %d\\n\", par);      \n    printf(\"Valor del impar %d\\n\", impar);\n    exit(EXIT_SUCCESS);     \n}"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLLcircular.5.c", "original_string": "void display(nptr head)\n{\n    nptr curr = head;\n    printf(\"                 \");\n    if(curr == NULL)\n        printf(\"EMPTY\");\n    while(curr -> right != head)\n    {\n        printf(\" %d \", curr -> data);\n        curr = curr -> right;\n    }\n    printf(\" %d\\n\", curr -> data);\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Insert_At_Any_Position_In_Single_Linked_List.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"Enter 1 for Creation or 0 for Termination:\");\n    scanf(\"%d\",&choice);\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->ptr = NULL;\n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->ptr = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want to enter more?(1/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_node(temp);\n    insert_at_N_position(head,temp);\n    getch();\n}"}
{"author": "zjzj-zz", "file": "1s_programing__sankaku.1.c", "original_string": "double dist(double x1, double y1, double x2, double y2){\n double r;\n r=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n return r;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__utils.2.c", "original_string": "void    ft_putstr(char *str)\n{\n    int i;\n    i = 0;\n    while (str[i] != '\\0')\n    {\n        ft_putchar(str[i]);\n        i++;\n    }\n}"}
{"author": "2security", "file": "Pointer__16ReverseString.1.c", "original_string": "char *Mystrrev(char *str)\n    {\n        char *begin,*end,temp;\n        char *rev;\n        int n=Mystrlen(str),i;\n        begin=str;\n        end=str;\n        for(i=0;i<n-1;i++)\n            end++;\n        for(i=0;i<n/2;i++)\n            {\n                temp=*end;\n                printf(\"%c \",*end);\n                *end=*begin;\n                *begin=temp;\n                begin++;\n                end--;\n            }\n        return str;\n    }"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__pll_36MHz.1.c", "original_string": "void pll_36MHz(void)\n{\n    PLLCON = 1<<0;              \n    PLLFEED = 0xAA;\n    PLLFEED = 0x55;             \n    PLLCFG = (1<<6)| 2; \n    PLLCFG &= ~(1<<5);\n    while(!(PLLSTAT & (1<<10)));            \n    PLLCON = (1<<1)|(1<<0);         \n    PLLFEED = 0xAA;\n    PLLFEED = 0x55;             \n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad1.0.c", "original_string": "int main()\n{\n    int n = 0;\n    FILE* fp = NULL;\n    fp = fopen(\"studenti.txt\", \"r\");\n    if (fp == NULL)\n    {   \n        printf(\"Datoteka nije pronadena!\\n\");\n        return 1;\n    }\n    while (!feof(fp))\n    {\n        if (fgetc(fp) == '\\n')\n            n++;\n    }\n    student* stud = NULL;\n    stud = (student*)malloc(n * sizeof(student));\n    if (stud == NULL)\n    {\n        printf(\"Neuspjesna alokacija memorije!\\n\");\n    }\n    rewind(fp);\n    upis(fp, stud, n);\n    fclose(fp);\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__timer0_timer1_isr.1.c", "original_string": "void timer_config(void)\n{\n        T0PR = 14;\n        T0MR0 = 2000000;\n        T0MCR = (1<<0)|(1<<1);\n        T1PR = 14;\n        T1MR0 = 2000000;\n        T1MCR = (1<<0)|(1<<1);\n        T1TCR = (1<<0);\n    T0TCR = (1<<0);\n}"}
{"author": "earth429", "file": "mulpre__zerosuppress.2.c", "original_string": "void setRnd(struct NUMBER *a, int k){\n    int i;\n    int judge;\n    clearByZero(a);\n    for (i = 0; i < k;i++){\n        a->n[i] = random() % 10; \n    }\n    judge = random() % 2; \n    switch (judge) {\n        case 1:\n            a->sign = 1;\n            break;\n        case 0:\n            a->sign = -1;\n            break;\n    }\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__tree.7.c", "original_string": "void postorder_1(struct database *node){\n    if(node == NULL) {\n        return;\n    } else {\n        postorder_1(node->right);\n        postorder_1(node->left);\n        printf(\"%d\\n\",node->roll_no);\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__33.0.c", "original_string": "int main()\n{\n    char nomes1[4][10], nomes2[4][10], quadrilha[4][2][10];\n    system(\"clear\");\n    printf(\"Informe os primeiros 4 nomes (sem acentua\u00e7\u00e3o):\\n\");\n    for (int i = 0; i < 4; i++)\n    {\n        scanf(\"%10[^\\n]s\", nomes1[i]);\n        getchar();\n    }\n    printf(\"\\nInforme os \u00faltimos 4 nomes (sem acentua\u00e7\u00e3o):\\n\");\n    for (int i = 0; i < 4; i++)\n    {\n        scanf(\"%10[^\\n]s\", nomes2[i]);\n        getchar();\n    }\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 2; j++)\n        {\n            if (j == 0)\n            {\n                strcpy(quadrilha[i][j], nomes1[i]);\n            }\n            else if (j == 1)\n            {\n                strcpy(quadrilha[i][j], nomes2[i]);\n            }\n        }\n    }\n    system(\"clear\");\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 2; j++)\n        {\n            if (j == 0)\n            {\n                printf(\"|\");\n            }\n            printf(\" %-10s \", quadrilha[i][j]);\n            if (j == 1)\n            {\n                printf(\"|\");\n            }\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zadOsmi.11.c", "original_string": "int CommandPrompt(Position current, StackPosition stackHead)\n{\n    Position C = current;\n    char userInput[MAX_DIR_LENGTH];\n    char command[5];\n    char directoryName[MAX_DIR_LENGTH];\n    Path(current, stackHead->next);\n    do {\n        fgets(userInput, MAX_DIR_LENGTH, stdin);\n        sscanf(userInput, \"%s %s\", command, directoryName);\n        if (!strcmp(command, \"md\"))\n        {\n            current = MakeDirectory(current, directoryName);\n            Path(current, stackHead->next);\n        }\n        else if (!strcmp(command, \"cd\"))\n        {\n            current = ChangeDirectory(current, stackHead, directoryName);\n            Path(current, stackHead->next);\n        }\n        else if (!strcmp(command, \"cd..\"))\n        {\n            if (current = ChangeToPreviousDirectory(stackHead) == NULL)\n                current = C;\n            Path(current, stackHead->next);\n        }\n        else if (!strcmp(command, \"dir\"))\n        {\n            PrintDirectory(current);\n            Path(current, stackHead->next);\n        }\n        else if (!strcmp(command, \"exit\"))\n            Remove(current);\n        else\n            printf(\"That's not an option!\");\n    } while (strcmp(command, \"exit\"));\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__i2c_receiver.2.c", "original_string": "void i2c_start(void)\n{\n    I2CONCLR = 1<<3;\n    I2CONSET = 1<<5;        \n    while(!(I2CONSET & (1<<3)));    \n    I2CONCLR = 1<<3;        \n    I2CONCLR = 1<<5;        \n}"}
{"author": "flora0110", "file": "hw02git__4108056029_2-2.2.c", "original_string": "int main(){\n    int i;\n    int *plat=malloc(20*sizeof(int));\n    int *plat2=malloc(20*sizeof(int));\n    for(i=0;i<20;i++){\n        plat[i]=64;\n        plat2[i]=plat[i];\n    }\n    FILE* rptr;\n    FILE* wfile;\n    rptr=fopen(\"test2-2.txt\",\"r\");\n    wfile=fopen(\"output2-2.txt\",\"w\");\n    if(rptr==NULL || wfile==NULL){\n        printf(\"open failure\\n\");\n        return 1;\n    }\n    else{\n        min = -1;\n        int now=0;\n        int now2=0;\n        char target;\n        char lasttarget;\n        howto ans;\n        howto2 ans2;\n        int i;\n        int count=1;\n        char *command;\n        char *command2;\n        MALLOC(command,10000*sizeof(char));\n        MALLOC(command2,10000*sizeof(char));\n        target=fgetc(rptr);\n        int totalstep=0;\n        int totalstep2=0;\n        int j1=0,j2=0;\n        while(target!='\\n' && target!=EOF){\n            if(target==' '){\n                target='@';\n            }\n            ans=fewstep(now,target,plat);\n            now+=ans.toplat;\n            plat[now]=target;\n            for(i=0;i<abs(ans.toplat);i++){\n                if(ans.toplat>0){\n                    command[j1++]='>';\n                }\n                else{\n                    command[j1++]='<';\n                }\n                totalstep++;\n            }\n            for(i=0;i<abs(ans.tostat);i++){\n                if(ans.tostat>0){\n                    command[j1++]='+';\n                }\n                else{\n                    command[j1++]='-';\n                }\n                totalstep++;\n            }\n            command[j1++]='.';\n            totalstep++;\n            if(count==1){\n                lasttarget=target;\n                count++;\n            }\n            else if(count==2){\n                count=1;\n                ans2=fewstep2(now2,lasttarget,target,plat2);\n                now2+=ans2.toplat;\n                plat2[now2]=lasttarget;\n                for(i=0;i<abs(ans2.toplat);i++){\n                    if(ans2.toplat>0){\n                        command2[j2++]='>';\n                    }\n                    else{\n                        command2[j2++]='<';\n                    }\n                    totalstep2++;\n                }\n                for(i=0;i<abs(ans2.tostat);i++){\n                    if(ans2.tostat>0){\n                        command2[j2++]='+';\n                    }\n                    else{\n                        command2[j2++]='-';\n                    }\n                    totalstep2++;\n                }\n                command2[j2++]='.';\n                totalstep2++;\n                now2+=ans2.toplat2;\n                plat2[now2]=target;\n                for(i=0;i<abs(ans2.toplat2);i++){\n                    if(ans2.toplat2>0){\n                        command2[j2++]='>';\n                    }\n                    else{\n                        command2[j2++]='<';\n                    }\n                    totalstep2++;\n                }\n                for(i=0;i<abs(ans2.tostat2);i++){\n                    if(ans2.tostat2>0){\n                        command2[j2++]='+';\n                    }\n                    else{\n                        command2[j2++]='-';\n                    }\n                    totalstep2++;\n                }\n                command2[j2++]='.';\n                totalstep2++;\n            }\n            target=fgetc(rptr);\n        }\n        if(count==2){\n            ans=fewstep(now2,target,plat2);\n            now2+=ans.toplat;\n            plat2[now2]=target;\n            for(i=0;i<abs(ans.toplat);i++){\n                if(ans.toplat>0){\n                    command2[j2++]='>';\n                }\n                else{\n                    command2[j2++]='<';\n                }\n                totalstep2++;\n            }\n            for(i=0;i<abs(ans.tostat);i++){\n                if(ans.tostat>0){\n                    command2[j2++]='+';\n                }\n                else{\n                    command2[j2++]='-';\n                }\n                totalstep2++;\n            }\n            command2[j2++]='.';\n            totalstep2++;\n        }\n        printf(\"\\ntotalstep1 %d \\n\",totalstep );\n        if(totalstep<=totalstep2){\n            for(i=0;i<j1;i++){\n                printf(\"%c\",command[i]);\n                fprintf(wfile,\"%c\",command[i]);\n            }\n            fprintf(wfile,\"\\ntotalstep :%d\\n\",totalstep );\n        }\n        else{\n            for(i=0;i<j2;i++){\n                printf(\"%c\",command2[i]);\n                fprintf(wfile,\"%c\",command2[i]);\n            }\n            fprintf(wfile,\"\\ntotalstep :%d\\n\",totalstep );\n        }\n    }\n    fclose(rptr);\n    fclose(wfile);\n}"}
{"author": "augustogunsch", "file": "jackc__parser-expressions.17.c", "original_string": "SUBROUTCALL* parsesubroutcall(PARSER* p) {\n    SUBROUTCALL* c = (SUBROUTCALL*)malloc(sizeof(SUBROUTCALL));\n    c->debug = getdebug(p);\n    if(nextequals(p, \".\")) {\n        c->parentname = parseidentifier(p);\n        next(p);\n    }\n    else\n        c->parentname = NULL;\n    c->name = parseidentifier(p);\n    checkcontent(p, \"(\");\n    c->parameters = parseexpressionlist(p);\n    checkcontent(p, \")\");\n    return c;\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_gpio.2.c", "original_string": "GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)\n{\n  GPIO_PinState bitstatus;\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\n  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)\n  {\n    bitstatus = GPIO_PIN_SET;\n  }\n  else\n  {\n    bitstatus = GPIO_PIN_RESET;\n  }\n  return bitstatus;\n}"}
{"author": "Mr-JoE1", "file": "Play-with-C__dec_to_octal.0.c", "original_string": "int main()\n{\n    int     number,cnt,i;\n    int     oct[32];\n    printf(\"Enter decimal number: \");\n    scanf(\"%d\",&number);\n    cnt=0;              \n    while(number>0)\n    {\n        oct[cnt]=number%8;\n        number=number/8;\n        cnt++;\n    }\n    printf(\"Octal value is: \");\n    for(i=(cnt-1); i>=0;i--)\n        printf(\"%d\",oct[i]);\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_any_pos_SLL.4.c", "original_string": "void insert_pos()\n{\n    struct node *newnode,*temp;\n    int pos,i=1;\n    printf(\"enter the positon =\");\n    scanf(\"%d\",&pos);\n    int leg=count();\n    if(pos>leg)\n    {\n        printf(\"Invalid positon \\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data = \");\n        scanf(\"%d\",& newnode->data);\n        newnode->next=temp->next;\n        temp->next=newnode;\n    }\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes2.8.c", "original_string": "float maximo(float *c){\n    float max = c[0];\n    for (int i = 1; i < MAX_CALIFICACIONES; i++){\n        if (max < c[i]){\n            max = c[i];\n        }\n    }\n    return max;\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad2-Strcmp.0.c", "original_string": "int main()\n{\n    int userNum;\n    printf(\"Podaj liczbe znakow.\\n\");\n    scanf(\"%d\", &userNum);\n    getNChars(userNum);\n    printf(\"\\n------------------------------------------\");\n    printf(\"\\nDziekuje. Dobranoc! To juz jest koniec!\\n\");\n    getchar();\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__DemoFOTAUpdateSelfTest.1.c", "original_string": "static bool runRandomSelfTest(uint8_t successRate)\n{\n  if (((uint8_t)((rand() % 100))) >= (successRate)) \n  {\n    printf(\"Firmware self test failed (reason: simulated pseudo-random failure)\\n\");\n    return false;\n  }\n  return true;\n}"}
{"author": "2security", "file": "String__10NoOfWord.1.c", "original_string": "int main()\n    {\n        char str[20];\n        int i=0,v=0,c=0;\n        printf(\"\\n Enter the string:: \");\n        gets(str);\n        printf(\"\\n No of word in the string is =%d\",Noofword(str));\n        return 0;\n    }"}
{"author": "kbtomic", "file": "StrukturePodataka__zad9.6.c", "original_string": "treePointer DeleteElement(int element, treePointer root)\n{\n    treePointer temp;\n    if (!root)\n        return root;\n    else if (element < root->data)\n        root->left = DeleteElement(element, root->left);\n    else if (element > root->data)\n        root->right = DeleteElement(element, root->right);\n    else\n    {\n        if (root->left && root->right)\n        {\n            temp = FindMin(root->right);\n            root->data = temp->data;\n            root->right = DeleteElement(temp->data, root->right);\n        }\n        else\n        {\n            temp = root;\n            if (!root->left)\n                root = root->right;\n            else if (!root->right)\n                root = root->left;\n            free(temp);\n        }\n    }\n    return root;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__timer0_1_int.1.c", "original_string": "void interrupt_config(void)\n{\n    VICIntSelect &= ~((1<<4)|(1<<5));           \n    VICVectCntl4    = (1<<5)|4;         \n    VICVectAddr4    = (long)timer0_isr1;        \n    VICVectCntl5    = (1<<5)|5;         \n    VICVectAddr5    = (long)timer1_isr2;\n    VICIntEnable    = (1<<4)|(1<<5);                \n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__selectsdclient.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    int rval,sockid;\n    sockid=socket(AF_INET,SOCK_STREAM,6);   \n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    struct sockaddr_in s,c;\n    system(\"clear\");\n    if(argc<2)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(1);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    char msg[30];\n    rval=connect(sockid,(struct sockaddr*)&s, sizeof(s)); \n    if(rval==-1)  \n    {   \n        perror(\"CONN-ERR:\");   \n        close(sockid);   \n        exit(1);\n    }\n    printf(\"\\nEnter the request message : \");  \n    scanf(\"%s\",msg);  \n    send(sockid,msg,sizeof(msg),0); \n    close(sockid);\n}"}
{"author": "shengelenge", "file": "wstep-do-programowania__zad14.0.c", "original_string": "double pierwiastek(double p, double E)\n{\n    double a = 1, b = p;\n    while (fabs(a - b) >= E)\n    {\n        a = (a + b) / 2;\n        b = p / a;\n    }\n    return a;\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise16.1.c", "original_string": "int main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n    int k , j;\n    int size = 5;\n    int arr[5];\n    printf(\"Enter elements of array: \");\n    for(k=0 ; k<size ; k++){\n        scanf(\"%d\",&arr[k]);\n    }\n    ReverseArray(arr,size);\n    printf(\"Array after being reversed: \");\n    for(j=0 ; j<size ; j++){\n        printf(\"%d \",arr[j]);\n    }\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__queue1.3.c", "original_string": "void display(int stack[])\n{\n    int i;\n    if(front==-1 || front>rear)\n    printf(\"\\nqueue is empty\");\n    else\n    {\n        printf(\"\\nqueue is :\\n\");\n        for(i=front;i<=rear;i++)\n        printf(\"\\t%d\",queue[i]);\n    }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__count_digit_string.0.c", "original_string": "int DigitCount(char *str)\n{\n    int iCnt = 0;\n    if(str == NULL)\n    {\n        return -1;\n    }\n    while(*str != '\\0')\n    {\n        if((*str >= '0') && (*str <= '9'))\n        {\n            iCnt++;\n        }\n        str++;\n    }\n    return iCnt;\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__goal_client.3.c", "original_string": "void send_msg_handler() {\n  char message[LENGTH] = {};\n    char buffer[LENGTH + 32] = {};\n  while(1) {\n    str_overwrite_stdout();\n    fgets(message, LENGTH, stdin);\n    str_trim_lf(message, LENGTH);\n    if (strcmp(message, \"exit\") == 0) {\n            break;\n    } else {\n      sprintf(buffer, \"%s: %s\\n\", name, message);\n      send(sockfd, buffer, strlen(buffer), 0);\n    }\n        bzero(message, LENGTH);\n    bzero(buffer, LENGTH + 32);\n  }\n  catch_ctrl_c_and_exit(2);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_ptx.1.c", "original_string": "void rstpPtxFsm(RstpBridgePort *port)\n{\n   RstpBridgeContext *context;\n   context = port->context;\n   if(!port->portEnabled)\n   {\n      rstpPtxChangeState(port, RSTP_PTX_STATE_TRANSMIT_INIT);\n   }\n   else\n   {\n      switch(port->ptxState)\n      {\n      case RSTP_PTX_STATE_TRANSMIT_INIT:\n      case RSTP_PTX_STATE_TRANSMIT_PERIODIC:\n      case RSTP_PTX_STATE_TRANSMIT_CONFIG:\n      case RSTP_PTX_STATE_TRANSMIT_TCN:\n      case RSTP_PTX_STATE_TRANSMIT_RSTP:\n         rstpPtxChangeState(port, RSTP_PTX_STATE_IDLE);\n         break;\n      case RSTP_PTX_STATE_IDLE:\n         if(port->selected && !port->updtInfo)\n         {\n            if(port->helloWhen == 0)\n            {\n               rstpPtxChangeState(port, RSTP_PTX_STATE_TRANSMIT_PERIODIC);\n            }\n            else\n            {\n               if(port->newInfo)\n               {\n                  if(port->txCount < rstpTxHoldCount(context))\n                  {\n                     if(port->sendRstp)\n                     {\n                        rstpPtxChangeState(port, RSTP_PTX_STATE_TRANSMIT_RSTP);\n                     }\n                     else\n                     {\n                        if(port->role == STP_PORT_ROLE_ROOT)\n                        {\n                           rstpPtxChangeState(port, RSTP_PTX_STATE_TRANSMIT_TCN);\n                        }\n                        else if(port->role == STP_PORT_ROLE_DESIGNATED)\n                        {\n                           rstpPtxChangeState(port, RSTP_PTX_STATE_TRANSMIT_CONFIG);\n                        }\n                        else\n                        {\n                        }\n                     }\n                  }\n               }\n            }\n         }\n         break;\n      default:\n         rstpFsmError(port->context);\n         break;\n      }\n   }\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__strcmp_ser.0.c", "original_string": "int main(int argc,char *argv [])\n{\n    char s[10],b[10];\n    int a,n;\n    const int SIZE =4096;\n    const char* name =\"os\";\n    int key,shmid;\n    void* shmptr;\n    if (argc<2)\n    {printf(\"enter the format ./'name',stringFFF,choice'1 or 0'\");}\n    key=shm_open(name,O_CREAT|O_RDWR,0666);\n      if (key < 0) {\n          printf(\"*** shmget error (server) ***\\n\");\n          exit(1);\n     }\n     ftruncate(key,SIZE);\n    shmptr=mmap(0,SIZE,PROT_WRITE,MAP_SHARED,key,0);\n    printf(\"atached to the shared memory\\n\");\n    strcpy(s,argv[1]);\n    n=strlen(s);\n    sprintf(shmptr,\"%d\",n-3);\n    strcpy(b,s);\n    a=atoi(argv[2]);\n    if (a==0)\n    {choice_zero(b);}\n    else if(a==1)\n    {choice_one(b);}\n    else\n    {return 0;}\n    sleep(10);\n    shmid=munmap(shmptr,SIZE);\n    key=shm_unlink(name);\n    return 1;\n}"}
{"author": "254Odeke", "file": "Operating-Systems_Lab__FramesAllocation.0.c", "original_string": "void main(){\n    int n,option,frames;\n    int size[10];\n    int i,a[10],total=0;\n    char p[10];\n    printf(\"No.of Processes present:\");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        printf(\"Enter the process name-\");\n        scanf(\"%s\",&p[i]);\n        printf(\"Enter the size of process-\");\n        scanf(\"%d\",&size[i]);\n    }\n    printf(\"No.of Frames present:\");\n    scanf(\"%d\",&frames);\n    while(1){\n        printf(\"\\n1.Fixed Allocation\\t2.Proportional Allocation\\t3.Exit:-\");\n        scanf(\"%d\",&option);\n        switch(option){\n            case 1: for(i=0;i<n;i++){\n                        printf(\"\\nAllocation of frames to process %c is %d\",p[i],frames/n);\n                    }\n                    break;\n            case 2: for(i=0;i<n;i++) total = total+size[i]; \n                    for(i=0;i<n;i++){\n                        printf(\"\\nAllocation of frames for process %c is %d\",p[i],(size[i]*frames)/total);\n                    }\n                    break;\n            case 3: exit(0);        \n            default: printf(\"\\nInvalid Selection\");\n        }\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_DCLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSL__ssl_misc.3.c", "original_string": "uint32_t sslVerifyMac(TlsEncryptionEngine *decryptionEngine,\n   const TlsRecord *record, const uint8_t *data, size_t dataLen,\n   size_t maxDataLen, const uint8_t *mac)\n{\n   size_t i;\n   size_t j;\n   size_t n;\n   size_t padLen;\n   size_t headerLen;\n   size_t paddingLen;\n   size_t blockSizeMask;\n   uint8_t b;\n   uint32_t c;\n   uint64_t bitLen;\n   const HashAlgo *hashAlgo;\n   HashContext *hashContext;\n   uint8_t temp1[SHA1_DIGEST_SIZE];\n   uint8_t temp2[SHA1_DIGEST_SIZE];\n   hashAlgo = decryptionEngine->hashAlgo;\n   hashContext = (HashContext *) decryptionEngine->hmacContext->hashContext;\n   if(hashAlgo == MD5_HASH_ALGO)\n   {\n      padLen = 48;\n   }\n   else if(hashAlgo == SHA1_HASH_ALGO)\n   {\n      padLen = 40;\n   }\n   else\n   {\n      return 1;\n   }\n   blockSizeMask = hashAlgo->blockSize - 1;\n   headerLen = decryptionEngine->macKeyLen + padLen + 11;\n   paddingLen = (headerLen + dataLen + hashAlgo->minPadSize - 1) & blockSizeMask;\n   paddingLen = hashAlgo->blockSize - paddingLen;\n   bitLen = (headerLen + dataLen) << 3;\n   if(hashAlgo->bigEndian)\n   {\n      bitLen = swapInt64(bitLen);\n   }\n   n = headerLen + maxDataLen + hashAlgo->minPadSize;\n   n = (n + hashAlgo->blockSize - 1) & ~blockSizeMask;\n   n -= headerLen;\n   hashAlgo->init(hashContext);\n   hashAlgo->update(hashContext, decryptionEngine->macKey, decryptionEngine->macKeyLen);\n   hashAlgo->update(hashContext, sslPad1, padLen);\n   hashAlgo->update(hashContext, &decryptionEngine->seqNum, sizeof(TlsSequenceNumber));\n   hashAlgo->update(hashContext, &record->type, sizeof(record->type));\n   hashAlgo->update(hashContext, (void *) &record->length, sizeof(record->length));\n   i = 0;\n   if(maxDataLen > 255)\n   {\n      hashAlgo->update(hashContext, data, maxDataLen - 255);\n      i += maxDataLen - 255;\n   }\n   while(i < n)\n   {\n      b = 0;\n      c = CRYPTO_TEST_LT_32(i, dataLen);\n      b = CRYPTO_SELECT_8(b, data[i], c);\n      c = CRYPTO_TEST_EQ_32(i, dataLen);\n      b = CRYPTO_SELECT_8(b, 0x80, c);\n      j = dataLen + paddingLen;\n      c = CRYPTO_TEST_GTE_32(i, j);\n      j += 8;\n      c &= CRYPTO_TEST_LT_32(i, j);\n      b = CRYPTO_SELECT_8(b, bitLen & 0xFF, c);\n      bitLen = CRYPTO_SELECT_64(bitLen, bitLen >> 8, c);\n      hashAlgo->update(hashContext, &b, sizeof(uint8_t));\n      i++;\n      if(((i + headerLen) & blockSizeMask) == 0)\n      {\n         hashAlgo->finalRaw(hashContext, temp1);\n         c = CRYPTO_TEST_EQ_32(i, dataLen + paddingLen + 8);\n         for(j = 0; j < hashAlgo->digestSize; j++)\n         {\n            temp2[j] = CRYPTO_SELECT_8(temp2[j], temp1[j], c);\n         }\n      }\n   }\n   hashAlgo->init(hashContext);\n   hashAlgo->update(hashContext, decryptionEngine->macKey, decryptionEngine->macKeyLen);\n   hashAlgo->update(hashContext, sslPad2, padLen);\n   hashAlgo->update(hashContext, temp2, hashAlgo->digestSize);\n   hashAlgo->final(hashContext, temp1);\n   TRACE_DEBUG(\"Read sequence number:\\r\\n\");\n   TRACE_DEBUG_ARRAY(\"  \", &decryptionEngine->seqNum, sizeof(TlsSequenceNumber));\n   TRACE_DEBUG(\"Computed MAC:\\r\\n\");\n   TRACE_DEBUG_ARRAY(\"  \", temp1, hashAlgo->digestSize);\n   for(b = 0, i = 0; i < hashAlgo->digestSize; i++)\n   {\n      b |= mac[i] ^ temp1[i];\n   }\n   return CRYPTO_TEST_NEQ_8(b, 0);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__AH.0.c", "original_string": "int main()\n{\n    int n, qtd = 0;\n    long int vet[1000], aux, aux2;\n    scanf(\"%i\", &n);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%li\", &vet[i]);\n        for (int j = i; j > 0; j--)\n        {\n            if (vet[j] < vet[j - 1])\n            {\n                aux = vet[j];\n                vet[j] = vet[j - 1];\n                vet[j - 1] = aux;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (i == 0)\n        {\n            aux2 = vet[i];\n            qtd++;\n        }\n        else if (vet[i] == aux2)\n        {\n            qtd++;\n        }\n        else if (vet[i] != aux2)\n        {\n            printf(\"%li %i\\n\", vet[i - 1], qtd);\n            qtd = 0;\n            aux2 = vet[i];\n            qtd++;\n        }\n        if (i == (n - 1))\n        {\n            printf(\"%li %i\\n\", vet[i], qtd);\n        }\n    }\n    return 0;\n}"}
{"author": "dle2005", "file": "Algorithm__Optimal_Binary_Search_Trees_v2.0.c", "original_string": "float sum(int i, int j, float *p) {\n    float result = 0;\n    for(int k = i; k <= j; k++)\n        result += p[k];\n    return result;\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_pwr.9.c", "original_string": "void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)\n{\n  assert_param(IS_PWR_REGULATOR(Regulator));\n  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));\n  MODIFY_REG(PWR->CR, (PWR_CR_PDDS | PWR_CR_LPDS), Regulator);\n  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));\n  if(STOPEntry == PWR_STOPENTRY_WFI)\n  {   \n    __WFI();\n  }\n  else\n  {\n    __SEV();\n    __WFE();\n    __WFE();\n  }\n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));  \n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_7.3.c", "original_string": "void traverse()\n{\n    struct node* temp;\n    if(top == NULL)\n    {\n        printf(\"Queue is Empty\\n\");\n    }\n    else\n    {\n        temp = top;\n        while(temp != NULL)\n        {\n            printf(\"%d-->\",temp->data);\n            temp = temp->link;\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__DemoFOTAUpdateWorkflow.2.c", "original_string": "void fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)\n{\n  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);\n}"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__3-1.0.c", "original_string": "int main(){\n  int x, r, rv2, n;\n  clock_t start, end;\n  double time;\n  printf(\"Size of the array\\n\");\n  scanf(\"%d\", &n);\n  int array[n];\n  for(int i = 0; i < n; i++)\n    array[i] = rand() % n+1;\n  selection_sort(array, n);\n  printf(\"============================\\n\");\n  for(int i = 0; i < n; i++)\n    printf(\"%d \", array[i]);\n  printf(\"\\n============================\\n\");\n  printf(\"\\nNumber you're looking for: \");\n  scanf(\"%d\", &x);\n  start = clock();\n  r = binsearch(x, array, n);\n  r == -1 ? printf(\"\\n%d was not found\\n\", x) : printf(\"\\n%d was found on %d\\n\", x, r);\n  end = clock();\n  time = (double) (end-start)/ CLOCKS_PER_SEC;\n  printf(\"On an array of %d elements, binsearch takes: %f segs\\n\", n, time);\n  start = clock();\n  rv2 = binsearchv2(x, array, n);\n  rv2 == -1 ? printf(\"\\n%d was not found\\n\", x) : printf(\"\\n%d was found on %d\\n\", x, rv2);\n  end = clock();\n  time = (double) (end-start)/ CLOCKS_PER_SEC;\n  printf(\"On an array of %d elements, binsearchV2 takes: %f segs\\n\", n, time);\n}"}
{"author": "Dhruvik-Chevli", "file": "DAALab__bst.3.c", "original_string": "void postorder(struct Node* root)\n{\n    if(!root)\n        return;\n    postorder(root->left);\n    postorder(root->right);\n    printf(\"%d \",root->data);\n    return;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-central-scanner-with-whitelist__nrf_dfu_flash.0.c", "original_string": "void dfu_fstorage_evt_handler(nrf_fstorage_evt_t * p_evt)\n{\n        if (NRF_LOG_ENABLED && (m_flash_operations_pending > 0))\n        {\n                m_flash_operations_pending--;\n        }\n        if (p_evt->result == NRF_SUCCESS)\n        {\n                NRF_LOG_DEBUG(\"Flash %s success: addr=%p, pending %d\",\n                              (p_evt->id == NRF_FSTORAGE_EVT_WRITE_RESULT) ? \"write\" : \"erase\",\n                              p_evt->addr, m_flash_operations_pending);\n        }\n        else\n        {\n                NRF_LOG_DEBUG(\"Flash %s failed (0x%x): addr=%p, len=0x%x bytes, pending %d\",\n                              (p_evt->id == NRF_FSTORAGE_EVT_WRITE_RESULT) ? \"write\" : \"erase\",\n                              p_evt->result, p_evt->addr, p_evt->len, m_flash_operations_pending);\n        }\n        if (p_evt->p_param)\n        {\n                ((nrf_dfu_flash_callback_t)(p_evt->p_param))((void*)p_evt->p_src);\n        }\n}"}
{"author": "revathy16296", "file": "rtos_lab_asssignment_1__3_com_999.0.c", "original_string": "int main(int argc,char *argv[])\n{\n    int array[SI],n=0,sum;\n    float product,average;\n    while(atoi(argv[i])!=999)\n    {\n    for(i=1;i<SI;i++)\n    {\n        array[i]=atoi(argv[i]);\n        n=n+1;\n        if(atoi(argv[i])==999)\n        break;\n    }\n    }\n    for(i=1;i<n;i++){\n    printf(\"%d\\n\",array[i]);}\n    sum=sum_of_num(array,n);\n    printf(\"the sum of number is %d\\n\",sum);\n    average=average_of_num(sum,n);\n    printf(\"the average is %f\\n\",average);\n    product=product_of_num(array,n);\n    printf(\"product of number is %f\",product);\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Single.4.c", "original_string": "void main()\n{\n    int ch;\n    char name[5];\n    while(1)\n    {\n        printf(\"\\nEnter choice : \");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1: \n            {\n                printf(\"\\nEnter file name : \");\n                scanf(\"%s\",name);\n                add_file(name[0]);\n                break;\n            }\n            case 2: \n            {\n                printf(\"\\nEnter file name : \");\n                scanf(\"%s\",name);\n                rem_file(name[0]);\n                break;\n            }\n            case 3:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__pthread_exit.1.c", "original_string": "void* thread_fun(void *arg)\n{\n    int i = (int)arg;\n    sleep(i);\n    if(i == 2)\n    {\n        pthread_exit(NULL);\n    }\n    printf(\"I'm %dth thread:pid = %d, tid = %lu\\n\", i+1, getpid(), pthread_self());\n    return NULL;\n}"}
{"author": "haon1026", "file": "linux-programming__rwlock.1.c", "original_string": "void *thread_read(void *arg)\n{\n    int i = (int)arg;\n    while(1)\n    {\n        pthread_rwlock_wrlock(&rwlock);     \n        printf(\"read %d:%lu: counter=%d\\n\", i, pthread_self(), counter);\n        pthread_rwlock_unlock(&rwlock);\n        usleep(2000);\n    }\n    return NULL;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__count_the_elem_in_DLL.0.c", "original_string": "int main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of element in the linked list\\n\");\n    printf(\"4.exit\\n\");\n    int choice;\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=5)\n    {\n        switch(choice)\n        {\n            case 1: printf(\"implementation\\n\");\n            creat();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of element in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"exit \\n\");\n            exit(0);\n            break;\n            default:printf(\"invalied choice \\n\");\n            break;\n        }\n         printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_eight_queens_puzzle_2.2.c", "original_string": "int Mov_Queen(int Tabla[8][8], int fila, int columna){   \n    int fila_actual = 0; \n    int columna_actual = 0; \n    int estado = 0; \n    for(int i = columna + 1; i < 8; i++) \n        if(Tabla[fila][i] == 1)\n            estado = 1;\n    for(int i = columna - 1; i >= 0; i--) \n       if(Tabla[fila][i] == 1)\n            estado = 1; \n    for(int i = fila - 1; i >= 0; i--) \n       if(Tabla[i][columna] == 1)\n            estado = 1; \n    for(int i = fila + 1; i < 8; i++) \n       if(Tabla[i][columna] == 1)\n            estado = 1;\n    fila_actual = fila - 1;\n    columna_actual = columna + 1;\n    while(columna_actual < 8 && fila_actual >= 0){    \n        if(Tabla[fila_actual][columna_actual] == 1)\n            estado = 1;\n        fila_actual--;\n        columna_actual++;\n    }\n    fila_actual = fila - 1;\n    columna_actual = columna - 1;\n    while(columna_actual >= 0 && fila_actual >= 0){    \n        if(Tabla[fila_actual][columna_actual] == 1)\n            estado = 1;\n        fila_actual--;\n        columna_actual--;\n    }\n    fila_actual = fila + 1;\n    columna_actual = columna - 1;\n    while(columna_actual >= 0 && fila_actual < 8){    \n        if(Tabla[fila_actual][columna_actual] == 1)\n            estado = 1;\n        fila_actual++;\n        columna_actual--;\n    }\n    fila_actual = fila + 1;\n    columna_actual = columna + 1;\n    while(columna_actual < 8 && fila_actual < 8){    \n        if(Tabla[fila_actual][columna_actual] == 1)\n            estado = 1;\n        fila_actual++;\n        columna_actual++;\n    }\n    return estado;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__LP.5.c", "original_string": "void main()\n{\n    int ch,i;\n    for(i=0;i<10;i++)\n    HASH[i]=-1;\n    printf(\"\\n1.INSERT\\n2.DELETE\\n3.SEARCH\\n4.DISPLAY\\n\\n\");\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                insert(key,val);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                delete(key,val);\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                search(key,val);\n                break;\n            }\n            case 4:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Stack.2.c", "original_string": "void pop()\n{\n    int flag = checkStackEmpty();\n    if(flag == 1)\n    {\n        printf(\"\\nPopped Element: %d\", (ptr.array[(ptr.top)--]));\n    }\n    else\n        printf(\"\\nStack is EMPTY!!!\");\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Stack.3.c", "original_string": "void display()\n{\n    int i = 0;\n    int flag = checkStackEmpty();\n    if(flag == 1)\n    {\n        printf(\"\\nElements present in the Stack are:- \\n\");\n        for(i=(ptr.top); i>-1; i--)\n        {\n            printf(\"%d\\t\", (ptr.array[i]));\n        }\n        printf(\"\\n\");\n    }\n    else\n        printf(\"\\nStack is EMPTY!!!\");\n}"}
{"author": "2security", "file": "String__4CompareTwoString.2.c", "original_string": "int main()\n    {\n        char str1[20],str2[20];\n        int i=0,len1,j=0,k;\n        printf(\"\\n Enter the first string\");\n        gets(str1);\n        printf(\"\\n Enter the second string\");\n        gets(str2);\n        printf(\"\\n Mystrcompare(%s,%s)=%d\",str1,str2,Mystrcompare(str1,str2));\n        return 0;\n    }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es20.1.c", "original_string": "int max_finder(int a, int b, int c){\n  if(a > b){\n        if( a > c){\n            return a;\n        } else return c;\n    } else if (b > c){\n        return b;\n    } else return c;\n}"}
{"author": "MartinMarinovich", "file": "MarinovichMartinLABIPP1G-__Parcial1_Laboratorio1.0.c", "original_string": "int main()\n{\n    setbuf(stdout,NULL);\n    eNotebook listaDeNotebooks[TAM_NOTEBOOKS];\n    eMarca listadoDeMarcas[TAM_MARCAS];\n    eTrabajo listadoDeTrabajos[TAM_TRABAJOS];\n    eTipo listadoDeTipos[TAM_TIPOS];\n    eServicio listadoDeServicios [TAM_SERVICIOS];\n    eCliente listadoDeClientes [TAM_NOTEBOOKS];\n    int proximoIdTrabajo = 100;\n    int proximoIdNotebook = 1;\n    int auxModificacion;\n    int auxBaja;\n    char opcionMenu;\n    if(!inicializarNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !inicializarTrabajo(listadoDeTrabajos,TAM_TRABAJOS))\n    {\n        printf(\"Sistema inicializado con exito!\\n\\n\");\n    }else\n    {\n        printf(\"Problema para inicializar el sistema\\n\");\n    }\n    hardCodearTipos(listadoDeTipos,TAM_TIPOS);\n    hardcodearMarcas(listadoDeMarcas,TAM_MARCAS);\n    hardCodearServicios(listadoDeServicios,TAM_SERVICIOS);\n    hardCodearClientes(listadoDeClientes,TAM_NOTEBOOKS);\n    hardCodearTrabajos(listadoDeTrabajos,TAM_TRABAJOS);\n    do\n    {\n        menu(&opcionMenu);\n        switch(opcionMenu)\n        {\n            case 1:\n                if(!altaNotebook(listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,TAM_NOTEBOOKS,TAM_CLIENTES,proximoIdNotebook,TAM_TIPOS,TAM_MARCAS))\n                {\n                    proximoIdNotebook++;\n                    printf(\"ALTA EXITOSA!\\n\");\n                }\n                else\n                {\n                    printf(\"Problema para realizar el alta\\n\");\n                }\n            break;\n            case 2:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    auxModificacion = modificarNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);\n                    if( auxModificacion == 0)\n                    {\n                        printf(\"Modificacion exitosa\\n\");\n                    }\n                    else if(auxModificacion == 2)\n                    {\n                        printf(\"La modificacion ha sido cancelada por usuario\\n\");\n                    }\n                    else\n                    {\n                        printf(\"Se ha producido un error en la modificacion\\n\");\n                    }\n                }else\n                {\n                    printf(\"No hay notebooks en el listado\\n\");\n                }\n            break;\n            case 3 :\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    auxBaja = bajaNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TIPOS,TAM_MARCAS);\n                    if( auxBaja == 0)\n                    {\n                        printf(\"Modificacion exitosa\\n\");\n                    }\n                    else if(auxBaja == 2)\n                    {\n                        printf(\"La baja ha sido cancelada por usuario\\n\");\n                    }\n                    else\n                    {\n                        printf(\"Se ha producido un error en la baja\\n\");\n                    }\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 4:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    ordenarNotebooks(listaDeNotebooks,TAM_NOTEBOOKS);\n                    listarNotebook(listaDeNotebooks, listadoDeMarcas,listadoDeClientes,listadoDeTipos,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 5:\n                system(\"cls\");\n                listarMarcas(listadoDeMarcas,TAM_MARCAS);\n            break;\n            case 6:\n                system(\"cls\");\n                listarTipos(listadoDeTipos,TAM_TIPOS);\n            break;\n            case 7:\n                system(\"cls\");\n                listarServicios(listadoDeServicios,TAM_SERVICIOS);\n            break;\n            case 8:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    if(altaTrabajo(listaDeNotebooks,listadoDeTrabajos,listadoDeServicios,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,\n                            TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_TIPOS,TAM_MARCAS,proximoIdTrabajo)==0)\n                    {\n                        proximoIdTrabajo++;\n                        printf(\"ALTA TRABAJO EXITOSA!\\n\");\n                    }else\n                    {\n                        printf(\"Se produjo un error al ingresa el trabajo\\n\");\n                    }\n                }else\n                {\n                    printf(\"No hay notebooks en la lista, no se puede ingresar trabajo\\n\");\n                }\n            break;\n            case 9:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) &&\n                    !verificarExistenciaTrabajo(listadoDeTrabajos,TAM_TRABAJOS))\n                {\n                    system(\"cls\");\n                    listarTrabajos(listadoDeTrabajos,listaDeNotebooks,listadoDeServicios,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS);\n                }else\n                {\n                    printf(\"No se ingresaron trabajos o notebooks\\n\");\n                }\n            break;\n            case 10:\n                system(\"cls\");\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    listarPorTipo(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeClientes,TAM_CLIENTES,TAM_MARCAS,listadoDeTipos,TAM_TIPOS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 11:\n                system(\"cls\");\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    listarPorMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS,TAM_TIPOS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 12:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    contarNotebooksMarcaYTipo(listaDeNotebooks, TAM_NOTEBOOKS,listadoDeMarcas,TAM_MARCAS,listadoDeClientes, TAM_CLIENTES, listadoDeTipos, TAM_TIPOS);\n                }\n            break;\n            case 13:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    listarNotebookXCadaMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_TIPOS,TAM_MARCAS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 14:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    marcaFavorita(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 15:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    notebookMasBarata(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_TIPOS,TAM_MARCAS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 16:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    listarTrabajosXNotebook(listadoDeTrabajos,listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,listadoDeServicios,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_MARCAS,TAM_TIPOS);\n                }\n            break;\n            case 17:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    mostrarSumaDeImportesXNotebook(listadoDeServicios, TAM_SERVICIOS, listadoDeTrabajos, listaDeNotebooks, TAM_NOTEBOOKS, listadoDeMarcas, listadoDeTipos, listadoDeClientes, TAM_CLIENTES, TAM_TIPOS, TAM_MARCAS, TAM_TRABAJOS);\n                }else\n                {\n                    printf(\"No hay notebooks o trabajos cargados\\n\");\n                }\n            break;\n        }\n    }while(opcionMenu != 19);\n    return 0;\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__test1.2.c", "original_string": "void make_crc32_table() {\n    unsigned int c;\n    int i = 0;\n    int bit = 0;\n    for(i = 0; i < 256; i++)\n    {\n        c  = (unsigned int)i;\n        for(bit = 0; bit < 8; bit++)\n        {\n            if(c&1)\n            {\n                c = (c >> 1)^(0xEDB88320);\n            }\n            else\n            {\n                c =  c >> 1;\n            }\n        }\n        crc32_table[i] = c;\n    }\n}"}
{"author": "jose120918", "file": "sorting_algorithms__1-main.1.c", "original_string": "int main(void)\n{\n    listint_t *list;\n    int array[] = {19, 48, 99, 71, 13, 52, 96, 73, 86, 7};\n    size_t n = sizeof(array) / sizeof(array[0]);\n    list = create_listint(array, n);\n    if (!list)\n        return (1);\n    print_list(list);\n    printf(\"\\n\");\n    insertion_sort_list(&list);\n    printf(\"\\n\");\n    print_list(list);\n    return (0);\n}"}
{"author": "andi-s0106", "file": "sorting_algorithms__old_insertion.0.c", "original_string": "void insertion_sort_list(listint_t **list)\n{\n    listint_t *key;\n    listint_t *tmp;\n    if (list == NULL || *list == NULL || (*list)->next == NULL)\n        return;\n    key = (*list)->next;\n    while (key != NULL)\n    {\n        if (key->next != NULL && key->next->n < key->n)\n        {\n            tmp = key->next;\n            key->prev->next = tmp;\n            if (tmp->next != NULL)\n                tmp->next->prev = key;\n            key->next = tmp->next;\n            tmp->prev = key->prev;\n            tmp->next = key;\n            key->prev = tmp;\n            print_list(*list);\n        }\n        else\n        {\n            tmp = key;\n            key = key->next;\n        }\n        while (tmp->prev != NULL && tmp->n < tmp->prev->n)\n        {\n            tmp->prev->next = tmp->next;\n            tmp->next = tmp->prev;\n            if (tmp->prev->prev != NULL)\n                tmp->prev->prev->next = tmp;\n            tmp->prev = tmp->prev->prev;\n            tmp->next->prev = tmp;\n            if (tmp->next->next != NULL)\n                tmp->next->next->prev = tmp->next;\n            if (tmp->prev == NULL)\n                *list = tmp;\n            print_list(*list);\n        }\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__ls-R.1.c", "original_string": "void isFile(char *filename)\n{\n    struct stat buf;\n    int ret = stat(filename, &buf);\n    if(ret == -1)\n    {\n        perror(\"stat error\");\n        return;\n    }\n    if(S_ISDIR(buf.st_mode))\n    {\n        readDir(filename);\n    }\n    printf(\"%s\\t%ld\\n\", filename, buf.st_size);\n    return;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q2_set1.1.c", "original_string": "nodeptr set_union(nodeptr a,nodeptr b)\n{\n    int i,flag=1;\n    nodeptr c,at,bt;\n    c=NULL;\n    at=a;\n    bt=b;\n    for(;at;at=at->link)\n        add(&c,at->data);\n    at=a;\n    for(;bt;bt=bt->link)\n    {\n        for(;at;at=at->link)          \n            if(bt->data==at->data)\n            {\n                flag=0;\n                break;\n            }\n        if(flag)                    \n            add(&c,bt->data);                       \n        flag=1;\n        at=a;\n    }\n    return c;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_37.3.c", "original_string": "int buscarMaiorValor(int j) {\n    int valorAAssumirPosicao = vetor[j];\n    posicaoReporNumero = NULL;\n    for (int i = j; i < 11; i++) {\n        if (valorAAssumirPosicao < vetor[i]) {\n            valorAAssumirPosicao = vetor[i];\n            posicaoReporNumero = i;\n        }\n    }\n    return valorAAssumirPosicao;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__doublylinkedlist.0.c", "original_string": "void insert(int tar,int pos)\n{\n    struct List* p=(struct List*)malloc(sizeof(struct List));\n    p->val=tar;\n    p->prev=NULL;\n    p->next=NULL;\n    if(start==NULL)\n    {\n        start=p;\n    }\n    else\n    {\n        if(pos==0)\n        {\n            p->next=start;\n            start=p;\n        }\n        else\n        {\n            temp=start;\n            for(i=0;i<(pos-1);i++)\n            {\n                temp=temp->next;\n            }\n            p->next=temp->next;\n            p->prev=temp;\n            temp->next->prev=p;\n            temp->next=p;   \n        }\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__sftp_server.3.c", "original_string": "error_t sftpServerStop(SftpServerContext *context)\n{\n   uint_t i;\n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n   TRACE_INFO(\"Stopping SFTP server...\\r\\n\");\n   if(context->running)\n   {\n      sshServerUnregisterChannelRequestCallback(context->sshServerContext,\n         sftpServerChannelRequestCallback);\n      context->stop = TRUE;\n      osSetEvent(&context->event);\n      while(context->running)\n      {\n         osDelayTask(1);\n      }\n      for(i = 0; i < context->numSessions; i++)\n      {\n         if(context->sessions[i].state != SFTP_SERVER_SESSION_STATE_CLOSED)\n         {\n            sftpServerCloseSession(&context->sessions[i]);\n         }\n      }\n   }\n   return NO_ERROR;\n}"}
{"author": "sdukesameer", "file": "dsa__dfs-a.0.c", "original_string": "void input(gph* g){\n    int i,j,f,x=1;\n    while(x){\n        printf(\"\\nEnter the number of vertices: \");\n        scanf(\"%d\",&g->n);\n        if(g->n>0)\n            x=0;\n        else\n            printf(\"Invalid input.\\n\");\n    }\n    g->mat=(int**) malloc(sizeof(int*)*g->n);\n    for(i=0;i<g->n;i++)\n        g->mat[i]=(int*)malloc(sizeof(int)*g->n);\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++)\n            g->mat[i][j]=-1;\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++){\n            if(g->mat[i][j]==1 || g->mat[i][j]==0)\n                continue;\n            if(i==j){\n                g->mat[i][j]=0;\n                continue;\n            }\n            x=1;\n            while(x){\n                printf(\"Is there an edge between %c and %c (Yes=1 & No=0): \",'A'+i,'A'+j);\n                scanf(\"%d\",&f);\n                if(f==0 || f==1){\n                    g->mat[i][j]=f;\n                    g->mat[j][i]=f;\n                    x=0;\n                }\n                else\n                    printf(\"Invalid input.\\n\");\n            }\n        }\n}"}
{"author": "ankitraj311", "file": "Socket-thread__test1.1.c", "original_string": "int main() \n{ \n    int i; \n    pthread_t tid; \n    for (i = 0; i < 3; i++) \n        pthread_create(&tid, NULL, myThreadFun, (void *)&tid); \n    pthread_exit(NULL); \n    return 0; \n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "2lista_de_C__main8.0.c", "original_string": "int main()\n{\n    int d1,d2,d3,d4,d5,d6;\n    unsigned long int contadora = 0;\n    for (d1 = 1; d1<=60;d1++)\n        if(d1 %2 != 1)\n    for (d2 = d1+1; d2<=60;d2++)\n        if(d2 %2 != 0)\n    for (d3 = d2+1; d3<=60;d3++)\n        if(d3 %2 != 1)\n    for (d4 = d3+1; d4<=60;d4++)\n        if(d4 % 2 != 0)\n    for (d5 = d4+1; d5<=60;d5++)\n        if(d5 % 2 !=1)\n    for (d6 = d5+1; d6<=60;d6++)\n        if(d6 % 2 != 0)\n    printf(\"[%d] [%d] [%d] [%d] [%d] [%d] \\n\",d1,d2,d3,d4,d5,d6);\n    contadora++;\n    printf(\"%u\",contadora);\n}"}
{"author": "mehedi9021", "file": "Data_Structure__circular_linked_list.0.c", "original_string": "int main()\n{\n    int n, data, choice=1;\n    head = NULL;\n    printf(\"Enter the total number of nodes in list: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    displayList();\n    return 0;\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__stack0.4.c", "original_string": "int main()\n{\n    push(10);\n    push(11);\n    push(12);\n    push(13);\n    push(14);\n    printf(\"Before pop\\n\");\n    int i;\n    for(i=0;i<count+1;i++)\n        printf(\"%d\\n\",arr[i]);\n    pop();\n    printf(\"After pop\\n\");\n    for(i=0;i<count+1;i++)\n        printf(\"%d\\n\",arr[i]);\n}"}
{"author": "behergue", "file": "Operating_Systems__myFS.9.c", "original_string": "int myQuota(MyFileSystem *myFileSystem)\n{\n    int freeCount = 0;\n    int i;\n    for(i = 0; i < myFileSystem->superBlock.diskSizeInBlocks; i++) {\n        if(myFileSystem->bitMap[i] == 0) {\n            freeCount++;\n        }\n    }\n    return freeCount;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__16_.2.c", "original_string": "void Filas(int contador1, int contador2)\n{\n    printf(\"\\n\");\n    if(contador1 < 8){\n        if(contador1 > 4){\n            Columnas(1, (contador2 - 1));\n            Filas(++contador1, --contador2);\n        }else{\n            Columnas(1,( contador1 - 1));\n            Filas(++contador1, --contador2);\n        }\n    }\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__cub2d.3.c", "original_string": "int         key_press(int keycode)\n{\n    if (keycode == 13)\n        g_player.walk_direction = 1;\n    if (keycode == 1)\n        g_player.walk_direction = -1;\n    if (keycode == 0)\n        g_player.turn_direction = -1;\n    if (keycode == 2)\n        g_player.turn_direction = 1;\n    return (0);\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__rpn_calc.1.c", "original_string": "int     isop(char   op)\n{\n    if (op == '+' || op == '-' || op == '/' || op == '%' || op == '*')\n        return (1);\n    return(0);\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__nrf_dfu_flash.3.c", "original_string": "ret_code_t nrf_dfu_flash_erase(uint32_t page_addr,\n                               uint32_t num_pages,\n                               nrf_dfu_flash_callback_t callback)\n{\n        ret_code_t rc;\n        NRF_LOG_DEBUG(\"nrf_fstorage_erase(addr=0x%p, len=%d pages), queue usage: %d\",\n                      page_addr, num_pages, m_flash_operations_pending);\n        rc = nrf_fstorage_erase(&m_fs, page_addr, num_pages, (void *)callback);\n        if ((NRF_LOG_ENABLED) && (rc == NRF_SUCCESS))\n        {\n                m_flash_operations_pending++;\n        }\n        else\n        {\n                NRF_LOG_WARNING(\"nrf_fstorage_erase() failed with error 0x%x.\", rc);\n        }\n        return rc;\n}"}
{"author": "dle2005", "file": "Algorithm__Sum_of_Subsets_v2.2.c", "original_string": "void main() {\n    int n, total;\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"W = \");\n    scanf(\"%d\", &W);\n    printf(\"\\n\");\n    w = (int *)malloc(sizeof(int) * (n+1));\n    include = (int *)malloc(sizeof(int) * (n+1));\n    save = (int *)malloc(sizeof(int) * (n+1));\n    for(int i = 1; i <= n; i++) {\n        printf(\"w[%d] : \", i);\n        scanf(\"%d\", &w[i]);\n    }\n    printf(\"\\n\");\n    for(int i = 1; i <= n; i++) total += w[i];\n    sum_of_subsets(0, 0, total);\n}"}
{"author": "behergue", "file": "Operating_Systems__myFS.11.c", "original_string": "int reserveBlocksForNodes(MyFileSystem *myFileSystem, DISK_LBA blocks[], int numBlocks)\n{\n    int i = 0;\n    int currentBlock = 0;\n    while((currentBlock < numBlocks) && (i < NUM_BITS)) {\n        if(myFileSystem->bitMap[i] == 0) {\n            myFileSystem->bitMap[i] = 1;\n            blocks[currentBlock] = i;\n            currentBlock++;\n        }\n        ++i;\n    }\n    return (i==NUM_BITS)?-1:0;\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad2.1.c", "original_string": "int numberOfDays(month, day, year){\n    int error = true; \n    int leapYear = false;\n    int result = day;\n    if((year%4==0) && ((year%400==0) || (year%100!= 0)))\n        leapYear = true; \n    for (int i = 0; i < 12; i++){\n        if(strcmp(month, months[i].name) == 0 || strcmp(month, months[i].abb) == 0 || atoi(month) == months[i].order){\n            error = false;\n            break; \n        }\n        result += months[i].days;\n        if(leapYear && months[i].order == 2)\n            result += 1;\n    }\n    if(day <= 0 || day > 31){\n        error = true; \n    }\n    if(error == true){\n        result = 0;\n    }\n    return result;\n}"}
{"author": "behergue", "file": "Operating_Systems__myFS.1.c", "original_string": "int findFileByName(MyFileSystem *myFileSystem, char *fileName)\n{\n    int i;\n    for(i = 0; i < MAX_FILES_PER_DIRECTORY; i++) {\n        if(myFileSystem->directory.files[i].freeFile == false) {\n            if(strcmp(fileName, myFileSystem->directory.files[i].fileName) == 0)\n                return i;\n        }\n    }\n    return -1;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader.1.c", "original_string": "void firmwareUpdateInfoReader_init(void)\n{\n  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);\n  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));\n  memset(updateVerificationData, 0, updateVerificationDataSize);\n  if (!createFirmwareUpdateInfoFile()) \n  {\n    return;\n  }\n  openFirmwareUpdateInfoFileInVSCode();\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__pushPopInStack.2.c", "original_string": "void push(struct stack*ptr, int val){\n    if(isFull(ptr)){\n        printf(\"Stack Overflow! Cannot push %d to the stack\\n\", val);\n    }\n    else{\n        ptr->top++;\n        ptr->arr[ptr->top]=val;\n    }\n}"}
{"author": "2security", "file": "Array__Symmetric.1.c", "original_string": "int IsSymmetric(int **mat1,int **mat2,int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            {\n            if(mat1[i][j]!=mat2[i][j])\n                return 0;\n            }\n        }\n    return 1;\n    }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__2.4.c", "original_string": "complex_t adicao(complex_t a, complex_t b)\n{\n    complex_t c;\n    c.real = a.real + b.real;\n    c.imaginario = a.imaginario + b.imaginario;\n    return c;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es51.0.c", "original_string": "int main(){\n  int dim;\n  int check = 0;\n  printf(\"dammi dim: \");\n  scanf(\"%d\", &dim);\n  int arr[dim];\n  printf(\"riempi array arr.\\n\");\n  for(int i = 0; i < dim; i++){\n    printf(\"dammi un numero: \");\n    scanf(\"%d\", &arr[i]);\n  }\n  for(int i = 0; i < dim; i++){\n  if(arr[i] != arr[dim - i - 1]){\n      check = 1;\n      i = dim; \n    }\n  }\n  if(check == 0){\n    printf(\"la sequenza \u00e8 palindroma.\\n\");\n  }else{\n    printf(\"la sequenza non \u00e8 palindroma.\\n\");\n  }\n  return(0);\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad5-LetterCheck.0.c", "original_string": "int main()\n{\n    char wholeText[1000];\n    FILE *f = fopen(\"testFile_Zad5.txt\", \"r\");    \n    if (f == NULL)\n    {\n        perror(\"Nie udalo sie otworzyc pliku testFile_Zad5.txt\");\n        return 1;\n    }\n    puts(\"Plik otwarty pomyslnie!\");\n    fscanf(f, \"%[]\", wholeText);\n    printf(\"\\nTekst z pliku:\\n%s\", wholeText);\n    printf(\"\\n\\n\");\n    for(int i = 0; i < strlen(wholeText); i++){\n        putchar(wholeText[i]);\n        printf(\" - \");\n        if(letterCheck(wholeText[i]) == -1){\n            printf(\"Znak nie jest liter\\245.\\n\");\n        } else {\n            printf(\"Jest %d liter\\245 alfabetu.\\n\", letterCheck(wholeText[i]));\n        }\n    }\n    fclose(f);\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q2_set1.0.c", "original_string": "void add(nodeptr* head,int x)\n{\n    nodeptr temp=(nodeptr)malloc(sizeof(node));\n    nodeptr t;\n    temp->data=x;\n    temp->link=NULL;\n    if(!(*head))\n        *head=temp;\n    else\n    {\n        for(t=(*head);t->link;t=t->link);\n        t->link=temp;\n    }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__ft_prime_sum.2.c", "original_string": "int     ft_atoi(char *str)\n{\n    int     i;\n    int     res;\n    i = 0;\n    res = 0;\n    while (str[i])\n    {\n        res *= 10;\n        res = str[i] - 48;\n        i++;\n    }\n    return (res);\n}"}
{"author": "dishanp", "file": "DSA__q1.5.c", "original_string": "int main()\n{\n    int m, n;\n    printf(\"Enter number of rows and columns : \");\n    scanf(\"%d%d\", &m, &n);\n    int **A = NULL, **sparserow = NULL, **sparsecol = NULL;\n    A = readmatrix(A, m, n);\n    sparserow = createsparserow(A, m, n);\n    sparsecol = createsparsecol(A, m, n);\n    displayrowmajor(sparserow);\n    displaycolmajor(sparsecol);\n}"}
{"author": "flora0110", "file": "hw02git__4108056029_2-2.1.c", "original_string": "howto2 fewstep2(int now,int target,int target2,int* plat){\n    min=-1;\n    int i,j;\n    howto2 ans;\n    int sum;\n    int toplat,tostat;\n    int right,left;\n    int pr,pl;\n    int sum2;\n    int toplat2,tostat2;\n    int right2,left2;\n    int pr2,pl2;\n    int temp;\n    for(i=0;i<20;i++){\n        if(i-now<0){\n            pr=i+1+19-now;\n        }\n        else{\n            pr=i-now;\n        }\n        if(now-i<0){\n            pl=i+1+19-now;\n        }\n        else{\n            pl=now-i;\n        }\n        toplat= (pr<pl)? pr:-pl;\n        if(target-plat[i]<0){\n            right = (90-plat[i])+1+target-64;\n        }\n        else{\n            right=target-plat[i];\n        }\n        if(plat[i]-target<0){\n            left = plat[i]-64+1+90-target;\n        }\n        else{\n            left=plat[i]-target;\n        }\n        tostat= (right<left)? right:-left;\n        sum=abs(tostat)+abs(toplat);\n        temp=plat[i];\n        plat[i]=target;\n        for(j=0;j<20;j++){\n            if(j-i<0){\n                pr2=j+1+19-i;\n            }\n            else{\n                pr2=j-i;\n            }\n            if(i-j<0){\n                pl2=j+1+19-i;\n            }\n            else{\n                pl2=i-j;\n            }\n            toplat2= (pr2<pl2)? pr2:-pl2;\n            if(target2-plat[j]<0){\n                right2 = (90-plat[j])+1+target2-64;\n            }\n            else{\n                right2=target2-plat[j];\n            }\n            if(plat[j]-target2<0){\n                left2 = plat[j]-64+1+90-target2;\n            }\n            else{\n                left2=plat[j]-target2;\n            }\n            tostat2= (right2<left2)? right2:-left2;\n            sum2=abs(tostat2)+abs(toplat2);\n            if(min==-1 || sum+sum2<min){\n                min=sum+sum2;\n                ans.toplat=toplat;\n                ans.tostat=tostat;\n                ans.toplat2=toplat2;\n                ans.tostat2=tostat2;\n            }\n        }\n        plat[i]=temp;\n    }\n    return ans;\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__BinarySearch.1.c", "original_string": "void getdata(int x[50],int n)\n      {\n        int k;\n        printf(\"enter the values in the array\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        } \n       }"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__14.0.c", "original_string": "int main()\n{\n    int hora_inicio, minuto_inicio, hora_fim, minuto_fim, minuto_total_inicio, minuto_total_fim, res_minuto, duracao_hora, duracao_minuto;\n    scanf(\"%i\", &hora_inicio);\n    scanf(\"%i\", &minuto_inicio);\n    scanf(\"%i\", &hora_fim);\n    scanf(\"%i\", &minuto_fim);\n    minuto_total_inicio = (hora_inicio * 60) + minuto_inicio;\n    minuto_total_fim = (hora_fim * 60) + minuto_fim;\n    res_minuto = minuto_total_fim - minuto_total_inicio;\n    duracao_hora = res_minuto / 60;\n    duracao_minuto = res_minuto % 60;\n    printf(\"\\n\\n\");\n    if (duracao_hora < 10)\n    {\n        printf(\"0%d\", duracao_hora);\n    }\n    else\n    {\n        printf(\"%d\", duracao_hora);\n    }\n    if (duracao_minuto < 10)\n    {\n        printf(\":0%d\", duracao_minuto);\n    }\n    else\n    {\n        printf(\":%d\", duracao_minuto);\n    }\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.38.c", "original_string": "ASMBLK* translatecall(VMTRANSLATOR* t) {\n    int retlablen;\n    char* retlab = mkretlab(t, &retlablen);\n    int framesize;\n    ASMBLK* blk = pushframe(t, retlab, retlablen, &framesize);\n    int nargs = atoi(t->currln->tokens[2]);\n    tcallsetarg.items[tcallsetarg.count-4] = atn(t, nargs + framesize);\n    mergeasmblks(blk, copytemplate(&tcallsetarg));\n    tcalljmp.items[tcalljmp.count-3] = at(t, t->currln->tokens[1]);\n    tcalljmp.items[tcalljmp.count-1] = enclosingparenthesis(t, retlab, retlablen);\n    mergeasmblks(blk, copytemplate(&tcalljmp));\n    return blk;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_after_pos_DLL.0.c", "original_string": "int main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of element in the linked list\\n\");\n    printf(\"4.insert an element after the position\\n\");\n    printf(\"5.exit\\n\");\n    int choice;\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=5)\n    {\n        switch(choice)\n        {\n            case 1: printf(\"implementation\\n\");\n            creat();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of element in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"inserting the element after the  position\\n\");\n            insert_at_after_pos();\n            break;\n            case 5:printf(\"exit \\n\");\n            exit(0);\n            break;\n            default:printf(\"invalied choice \\n\");\n            break;\n        }\n         printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_any_pos_DLL.4.c", "original_string": "void insert_at_pos()\n{\n    struct node *newnode,*temp;\n    int pos;\n    int i=1;\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    int leg=count();\n    if(pos>leg)\n    {\n        printf(\"Invalid position \\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=temp;\n        newnode->next=temp->next;\n        temp->next=newnode;\n        newnode->next->pre=newnode;\n    }\n}"}
{"author": "2security", "file": "Pointer__8Search.2.c", "original_string": "int main()\n    {\n        int *a,m,i,item;\n        printf(\"\\n Enter size of array1:: \");\n        scanf(\"%d\",&m);\n        a=(int *)malloc(m*sizeof(int *));\n        printf(\"\\n Enter %d elements of array::\",m);\n        for(i=0;i<m;i++)\n            scanf(\"%d\",&a[i]);\n        printf(\"\\n Enter the item to found\");\n        scanf(\"%d\",&item);\n        i=Search(a,m,item);\n        if(i==0)\n            printf(\"\\n %d is not found\",item);\n        else\n            printf(\"\\n %d is found at position %d\",item,i);\n        return 0;\n    }"}
{"author": "earth429", "file": "mulpre__power.1.c", "original_string": "int power(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    struct NUMBER i, tmp, i_tmp;\n    setInt(&i, 1);\n    clearByZero(c);\n    if(isZero(b) != -1){ \n        setInt(c, 1);\n        return 0;\n    } else if(numComp(b, &i) == 0){ \n        copyNumber(a, c);\n        return 0;\n    }\n    copyNumber(a, &tmp);\n    while(1){\n        if(numComp(&i, b) != -1){ \n            break;\n        }\n        multiple(a, &tmp, c);\n        copyNumber(c, &tmp);\n        increment(&i, &i_tmp);\n        copyNumber(&i_tmp, &i);\n    }\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__dequeue1.5.c", "original_string": "void display()\n{\n    int i;\n    if((front==-1 && rear==-1) || front>rear)\n    printf(\"\\nqueue is empty\");\n    else\n    {\n        printf(\"\\nqueue is :\\n\");\n        for(i=front;i<=rear;i++)\n        printf(\"\\t%d\",queue[i]);\n    }\n}"}
{"author": "sdukesameer", "file": "c__sum-of-digits-all-even-odd.3.c", "original_string": "int main()\n{\n    int ch;\n    while(1)\n    {\n        int n,ans=0;\n        printf(\"\\n1. Sum of the digits of a given number\\n\");\n        printf(\"2. Sum of even digits of a given number\\n\");\n        printf(\"3. Sum of the odd digits of a given number\\n\");\n        printf(\"4. Exit program\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            printf(\"\\nEnter the integer: \");\n            scanf(\"%d\",&n);\n            ans=sum(n);\n            printf(\"Sum of digits of %d = %d\\n\",n,ans);\n        }\n        else if(ch==2)\n        {\n            printf(\"\\nEnter the integer: \");\n            scanf(\"%d\",&n);\n            ans=evensum(n);\n            printf(\"Sum of even digits of %d = %d\\n\",n,ans);\n        }\n        else if(ch==3)\n        {\n            printf(\"\\nEnter the integer: \");\n            scanf(\"%d\",&n);\n            ans=oddsum(n);\n            printf(\"Sum of odd digits of %d = %d\\n\",n,ans);\n        }\n        else if(ch==4)\n        {\n            printf(\"\\nExitting program. Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"\\nINVALID CHOICE. TRY AGAIN!\\n\");\n    }\n    return 0;\n}"}
{"author": "2security", "file": "String__30SearchAlloccurrence.2.c", "original_string": "int main() {\n   char text[100];\n   char pattern[100];\n   printf(\"\\n Enter the string \");\n   gets(text);\n   printf(\"\\n Enter the string \");\n   gets(pattern);\n   KMPAlgorithm(text, pattern);\n   return 0;\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__server4.2.c", "original_string": "void* communication(void* pclient) {\n    int new_socket = *((int*)pclient);\n    free(pclient);\n    int n;\n    char buffer[BUFFER_SIZE] = {0}; \n    while(1) {\n        bzero(buffer, BUFFER_SIZE);\n        n = recv( new_socket , buffer, BUFFER_SIZE, 0); \n        if(n<0) {\n            printf(\"Reading Error!\\n\");\n        }\n        printf(\"Client: %s\\n\", buffer);\n        if(strncmp(buffer, \"close\", 5)==0) {\n            printf(\"Client with Socketfd: %d disconnected!\\n\", new_socket);\n            bzero(buffer, BUFFER_SIZE);\n            return NULL;\n        }\n        send(new_socket , buffer , strlen(buffer) , 0); \n    }\n    return NULL;\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_posix.2.c", "original_string": "OsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,\n   void *param, size_t stackSize, int_t priority)\n{\n   int_t ret;\n   pthread_t thread;\n   ret = pthread_create(&thread, NULL, (PthreadTaskCode) taskCode, param);\n   if(ret == 0)\n      return (OsTask *) thread;\n   else\n      return NULL;\n}"}
{"author": "Oryx-Embedded", "file": "Common__resource_manager.1.c", "original_string": "error_t resSearchFile(const char_t *path, DirEntry *dirEntry)\n{\n   bool_t found;\n   bool_t match;\n   uint_t n;\n   uint_t length;\n   ResEntry *resEntry;\n   ResHeader *resHeader = (ResHeader *) res;\n   if(resHeader->totalSize < sizeof(ResHeader))\n      return ERROR_INVALID_RESOURCE;\n   length = resHeader->rootEntry.dataLength;\n   resEntry = (ResEntry *) (res + resHeader->rootEntry.dataStart);\n   for(found = FALSE; !found && path[0] != '\\0'; path += n + 1)\n   {\n      for(n = 0; path[n] != '\\\\' && path[n] != '/' && path[n] != '\\0'; n++);\n      if(n == 0 && path[n] != '\\0')\n      {\n         path++;\n         for(n = 0; path[n] != '\\\\' && path[n] != '/' && path[n] != '\\0'; n++);\n      }\n      for(match = FALSE; !match && length > 0; )\n      {\n         if(length < sizeof(ResEntry))\n            return ERROR_INVALID_RESOURCE;\n         if(length < (sizeof(ResEntry) + resEntry->nameLength))\n            return ERROR_INVALID_RESOURCE;\n         if(resEntry->nameLength == n && !strncasecmp(resEntry->name, path, n))\n         {\n            if(resEntry->type == RES_TYPE_DIR)\n            {\n               length = resEntry->dataLength;\n               resEntry = (ResEntry *) (res + resEntry->dataStart);\n            }\n            else\n            {\n               if(path[n] != '\\0')\n                  return ERROR_INVALID_PATH;\n               found = TRUE;\n            }\n            match = TRUE;\n         }\n         else\n         {\n            length -= sizeof(ResEntry) + resEntry->nameLength;\n            resEntry = (ResEntry *) ((uint8_t *) resEntry + sizeof(ResEntry) + resEntry->nameLength);\n         }\n      }\n      if(!match)\n         return ERROR_NOT_FOUND;\n   }\n   if(!found)\n      return ERROR_NOT_FOUND;\n   dirEntry->type = resEntry->type;\n   dirEntry->volume = 0;\n   dirEntry->dataStart = resEntry->dataStart;\n   dirEntry->dataLength = resEntry->dataLength;\n   dirEntry->nameLength = 0; \n   return NO_ERROR;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__insert_element_at_begining_single_linked_list.1.c", "original_string": "void createList(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int data, i;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter node data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n; i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter node data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=temp->next;\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__search_a_node_from_list.2.c", "original_string": "void search(int key)\n{\n    struct node*temp;\n    temp=head;\n    while(temp!=NULL)\n    {\n        if(temp->data==key){\n        printf(\"Key found :)\");\n        temp=temp->next;\n        break;\n    }\n    else{\n        printf(\"Key not found :(\");\n        break;\n    }\n}\n}"}
{"author": "paawankohli", "file": "DSA-LAB__ip2.3.c", "original_string": "void display(NODE first)\n{\n    if (first==NULL)\n        printf(\"List Empty\\n\");\n    else\n    {\n        NODE p=first;\n        while (p->next!=NULL)\n        {\n            printf(\"%d \",p->data);\n            p=p->next;\n        }\n        printf(\"%d\\n\",p->data);\n    }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__is.0.c", "original_string": "int is_in_range(t_m *m, int x, int y)\n{\n    if (x < 0 || x >= m->len || y < 1 || y >= m->ac)\n        return (0);\n    return (1);\n}"}
{"author": "sdukesameer", "file": "c__rec_quick_sort.3.c", "original_string": "void quickSort(int arr[], int low, int high)\n{\n    if (low < high)\n    {\n        printf(\"%d: \",c++);\n        printArray(arr);\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__strCopy.0.c", "original_string": "void strCopy(char *source, char* destin)\n{\n    if (*source == '\\0')\n    {\n        *destin = '\\0';\n        return;\n    }\n    *destin = *source;\n    strCopy(source + 1, destin + 1);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__singlyLL.1.c", "original_string": "nptr reverse2(nptr head)\n{\n    if(head -> next == NULL)\n        return head;\n    nptr prev = NULL; \n    nptr curr = head;\n    nptr after = head -> next;\n    while(curr)\n    {\n        after = curr -> next;\n        curr -> next = prev;\n        prev = curr;\n        curr = after;\n    }\n    return prev;\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__strcmp.1.c", "original_string": "void choice_one(char b[SIZE])\n{\n    char p[SIZE]=\"SIOSFFF\";\n        if (strcmp(b,p)==0)\n        {printf(\"the value is matching with SIOS\\n\");}\n        else{\n        printf(\"the  string is not matching with SIOS\\n\");}\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_any_pos_CLL.4.c", "original_string": "void insert_at_pos()\n{\n    struct node *newnode,*temp;\n    int i=1;\n    int pos;\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    int leg=count();\n    if(pos>leg)\n    {\n        printf(\"Invalid position\\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=temp->next;\n        temp->next=newnode;\n    }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e90.2.c", "original_string": "int main (int argc, char *argv[]) {\n    char captchaG [6];\n    char *captcha;\n    char leitura [6];\n    int result;\n    srand (time (NULL));\n    printf (\"Digite conforme o Captcha \\n\");\n    captcha = gercaptcha (captchaG);\n    printf (\"Captcha: %s \\n\", captcha);\n    gets (leitura);\n    result = comparar (captcha, leitura); \n    if (result == 1)\n    {\n        printf (\"Deu ruim\");\n        }\n        if (result ==0)\n        {printf (\"Deu bom\");\n            }   \n    return 0;\n}"}
{"author": "2security", "file": "Star__MirroredHalfDiamondStar.0.c", "original_string": "int main()\n    {\n    int n,i,j,k,f;\n    printf(\"Enter how many columns\");\n    scanf(\"%d\",&n);\n    f=1;\n    for(i=1;i<=2*n-1;i++)\n        {\n            if(i<=n)\n                {\n                f++;\n                for(j=1;j<=n-i;j++) \n                    printf(\" \");\n                }\n            else\n                {\n                f--;\n                for(j=1;j<=i-n;j++) \n                    printf(\" \");\n                }\n            for(j=1;j<f;j++)    \n                printf(\"*\");\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_07.4.c", "original_string": "int main(int argc, char* argv[]) \n{ \n    int num; char s;int size;\n        int* arr;\n        F1 = fopen(argv[1], \"r\");\n        F2 = fopen(argv[2], \"w\");\n        while(1)\n        {\n        fscanf(F1 ,\"%c %d\",&s, &num);\n        if(s == 'r')\n        {\n                size = num;\n                arr = read(num);\n        }\n        else if(s == 's')\n        {\n                bubbleSort(arr, size);\n        display(arr, size);\n        }\n        else if(s == 'd')\n        {\n                display(arr, size);\n                fprintf(F2, \"\\n\");\n        }\n        else if(s == 't')\n                return 0;\n        }\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__sum_999.0.c", "original_string": "int main()\n{\n    int fd1[2],fd2[2];\n    pipe(fd1);\n    pipe(fd2);\n    printf(\"enter the array elements\\n\");\n    while(array[i]!=999)\n    {\n    for(i=0;i<SI;i++)\n    {\n        scanf(\"%d\",&array[i]);\n        n=i;\n        if(array[i]==999)\n        break;\n    }\n    }\n    pid_t pid;\n    pid=fork();\n    if(pid==0)\n    {\n        printf(\"inside child-----\\n\");\n        close(fd1[0]);\n        close(fd2[0]);\n        float product,sum;\n        sum=sum_of_num();\n        printf(\"the sum is %f\\n\",sum);\n        write(fd1[1],&sum,sizeof(sum));\n        product=product_of_num();\n        printf(\"the product is %f\\n\",product);\n        write(fd2[1],&product,sizeof(product));\n        close(fd1[1]);\n        close(fd2[1]);      \n    }\n    else\n    {\n        wait(NULL);\n        printf(\"-----inside parent process------\\n\");\n        close(fd1[1]);\n        close(fd2[1]);\n        float avg=0,sum,product;\n        read(fd1[0],&sum,sizeof(sum));\n        read(fd2[0],&product,sizeof(product));\n        printf(\"\\tthe sum is %f\\n\",sum);\n        avg=sum/SI;\n        printf(\"\\tthe average is %f\\n\",avg);\n        printf(\"\\tthe product is %f\\n\",product);\n        close(fd1[0]);\n        close(fd2[0]);\n    }\n        return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc.9.c", "original_string": "int count_leafnodes(node* root)\n{\n    if (root==NULL)\n        return 0;\n    if (root->left == NULL && root->right == NULL)\n        return 1;\n    else\n        return count_leafnodes(root->left) + count_leafnodes(root->right);\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.9.c", "original_string": "SUBROUTDEC* getsubroutdecfromlist(SUBROUTDEC* start, char* name) {\n    while(start != NULL) {\n        if(!strcmp(start->name, name))\n            return start;\n        start = start->next;\n    }\n    return NULL;\n}"}
{"author": "sdukesameer", "file": "dsa__list-push-pop-del-rec_rev-count.7.c", "original_string": "int main()\n{\n    int ch;\n    node* head=NULL;\n    while(1)\n    {\n        printf(\"\\n\");\n        printf(\"1. PUSH\\n\");\n        printf(\"2. POP\\n\");\n        printf(\"3. DELETE\\n\");\n        printf(\"4. REVERSE\\n\");\n        printf(\"5. COUNT\\n\");\n        printf(\"6. PRINT\\n\");\n        printf(\"7. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            head=push(head, n);\n        }\n        else if (ch==2)\n            head=pop(head);\n        else if (ch==3)\n        {\n            int key;\n            printf(\"Enter the element you want to delete: \");\n            scanf(\"%d\",&key);\n            delete(&head,key);\n        }\n        else if (ch==4)\n        {\n            if(head==NULL)\n                printf(\"CAN'T REVERSE, STACK EMPTY\\n\");\n            else\n            {\n                head=rec_reverse(head);\n                printf(\"Link-List Reversed\\n\");\n            }\n        }\n        else if (ch==5)\n            printf(\"Count of elements are= %d\\n\",count(head));\n        else if (ch==6)\n        {\n            node* temp=print(head);\n            if(temp==NULL)\n                printf(\"CAN'T PRINT, STACK EMPTY\\n\");\n            else\n                printf(\"\\t%d\\n\",temp->data);\n        }\n        else if (ch==7)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid, choice try again.\\n\");\n    }\n    return 0;\n}"}
{"author": "revathy16296", "file": "rtos_lab_asssignment_1__3_com_999.3.c", "original_string": "float product_of_num(int array[],int n)\n{\n    float product=1;\n    for(i=1;i<n;i++)\n    {\n        product*=array[i];\n    }\n    return product;\n}"}
{"author": "dle2005", "file": "Algorithm__Floyd_v2.0.c", "original_string": "void floyd2(int n, int **W, int **D, int **P) {\n    int i, j, k; \n    for(i = 0; i <= n; i++) \n        for(j = 0; j <= n; j++) \n            P[i][j] = 0;\n    for(i = 0; i <= n; i++) \n        for(j = 0; j <= n; j++) \n            D[i][j] = W[i][j]; \n    for(k = 1; k <= n; k++) \n        for(i = 1; i <= n; i++)\n            for(j = 1; j <= n; j++)\n                if(D[i][k] + D[k][j] < D[i][j]) { \n                    P[i][j] = k; \n                    D[i][j] = D[i][k] + D[k][j]; \n                }\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__sender.1.c", "original_string": "void output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n    }\n    printf(\"\\n\");\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__9sumof_rows_and_columns.1.c", "original_string": "void sumofrows(int b[][90],int r,int c)\n{\n    int sum=0,i,j;\n    for(i=0;i<r;i++)\n    {\n        for(j=0;j<c;j++)\n        {\n            sum=sum+b[i][j];\n        }\n        printf(\"hggh\");\n        printf(\"%d\",sum);\n    }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__rev_wstr.2.c", "original_string": "int main(int ac, char **av)\n{\n    char **word;\n    int i;\n    i = 0;\n    if (ac ==  2)\n    {\n        word = ft_split(av[1]);\n        while (word[i] != 0)\n            i++;\n        while(--i >= 0)\n        {\n            ft_pustr(word[i]);\n            write(1, \" \", 1);\n        }\n    }\n    write(1, \"\\n\", 1);\n}"}
{"author": "2security", "file": "If-else__Grade.0.c", "original_string": "int main()\n    {\n    float p,c,b,m,ca,t;\n    printf(\"Enter makrs of Physics\");\n    scanf(\"%f\",&p);\n    printf(\"Enter makrs of Chemistry\");\n    scanf(\"%f\",&c);\n    printf(\"Enter makrs of Bialogy\");\n    scanf(\"%f\",&b);\n    printf(\"Enter makrs of Mathematics\");\n    scanf(\"%f\",&m);\n    printf(\"Enter makrs of Computer\");\n    scanf(\"%f\",&ca);\n    t=((p+c+b+m+ca)/500)*100;\n    if(t>=90)\n        printf(\"\\nGRADE A\\n\");\n    else if(t>=90)\n        printf(\"\\nGRADE A\\n\");\n    else if(t>=80)\n        printf(\"\\nGRADE B\\n\");\n    else if(t>=70)\n        printf(\"\\nGRADE C\\n\");\n    else if(t>=60)\n        printf(\"\\nGRADE D\\n\");\n    else if(t>=40)\n        printf(\"\\nGRADE E\\n\");\n    else\n        printf(\"\\nGRADE F\\n\");\n    printf(\"\\n\");   \n    return 0;\n    }"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Linked.0.c", "original_string": "int ispossible()\n{\n    int i,ct=0;\n    for(i=0;i<16;i++)\n    {\n        if(disk[i].id==0)\n            ct++;\n    }\n    return(ct);\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__palhaco.8.c", "original_string": "int main(int argc, char *argv[])\n{\n     glutInit(&argc,argv);\n     glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);\n     glutInitWindowPosition(50,50);\n     glutInitWindowSize(600,600);\n     glutCreateWindow(\"Palhaco Animado - OpenGL\");\n     glutDisplayFunc(display);\n     glutTimerFunc(5, animate, 1);\n     init();\n     glutMainLoop();\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__Hackerrankques2.1.c", "original_string": "int gateOperation(int n, int k)\n{\n    int i,j;\n    int maxAND = 0;\n    int maxOR = 0;\n    int maxEXP = 0;\n    for(i=1;i<=n;i++)\n    {\n        for(j=i+1;j<=n;j++)\n        {\n            if(((i & j) > maxAND) && ((i & j) < k))\n            {\n                maxAND = i & j;\n            }\n            if(((i | j) > maxOR) && ((i | j) < k))\n            {\n                maxOR = i | j;\n            }\n            if(((i ^ j) > maxEXP) && ((i ^ j) < k))\n            {\n                maxEXP = i ^ j;\n            }\n        }\n    }\n    printf(\"%d \\n%d\\n%d\", maxAND, maxOR, maxEXP);\n}"}
{"author": "sahadipanjan6", "file": "Programs-in-C__P1.0.c", "original_string": "void main()\n{\n    float sum=0.0f;\n    int n=0;\n    int i=0;\n    printf(\"Enter the value of n: \");\n    scanf(\"%d\", &n);\n    for(i=1; i<=n; i++)\n    {\n        sum = sum + (factorial(i)/i);   \n    }\n    printf(\"Sum = %f\", sum);    \n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__stack1.3.c", "original_string": "void display(int stack[])\n{\n    int i;\n    if(top==-1)\n    printf(\"\\nstack is empty\");\n    else\n    {\n        printf(\"\\nstack is :\\n\");\n        for(i=0;i<=top;i++)\n        printf(\"\\t%d\",stack[i]);\n    }\n}"}
{"author": "2security", "file": "Pointer__8Search.1.c", "original_string": "int Search(int *a,int n,int item)\n    {\n        int i,j=0,pos=0;\n        for(i=0;i<n;i++)\n            {\n            if(*(a+i)==item)\n                {\n                    pos=i+1;\n                    break;\n                }\n            }       \n        return pos;\n    }"}
{"author": "ankitraj311", "file": "450_babbar__7_intersection_array_Geek_soted_array.2.c", "original_string": "int main()\n{\n  int arr1[] = {1,2,3,7,8,9,10}, arr2[] = {2, 8, 10, 15, 16, 100} ,no,j=0,temp=0,mid=0,n=0; \n  int size_arr1 = sizeof(arr1)/sizeof(int), size_arr2 = sizeof(arr2)/sizeof(int);\n  array_print(arr1,size_arr1);\n  array_print(arr2,size_arr2);\n  intersection_array(arr1,arr2,size_arr1,size_arr2);\n}"}
{"author": "flora0110", "file": "hw02git__4108056029_2-2.0.c", "original_string": "howto fewstep(int now,int target,int* plat){\n    min=-1;\n    int i;\n    howto ans;\n    int sum;\n    int toplat,tostat;\n    int right,left;\n    int pr,pl;\n    for(i=0;i<20;i++){\n        if(i-now<0){\n            pr=i+1+19-now;\n        }\n        else{\n            pr=i-now;\n        }\n        if(now-i<0){\n            pl=i+1+19-now;\n        }\n        else{\n            pl=now-i;\n        }\n        toplat= (pr<pl)? pr:-pl;\n        if(target-plat[i]<0){\n            right = (90-plat[i])+1+target-64;\n        }\n        else{\n            right=target-plat[i];\n        }\n        if(plat[i]-target<0){\n            left = plat[i]-64+1+90-target;\n        }\n        else{\n            left=plat[i]-target;\n        }\n        tostat= (right<left)? right:-left;\n        sum=abs(tostat)+abs(toplat);\n        if(min==-1 || sum<min){\n            min=sum;\n            ans.toplat=toplat;\n            ans.tostat=tostat;\n        }\n    }\n    return ans;\n}"}
{"author": "behergue", "file": "Computer_Structure__main.1.c", "original_string": "int loop(void)\n{\n    unsigned int buttons = read_button();\n    if (buttons & BUT1) {\n    }\n    if (buttons & BUT2) {\n    }\n    if (RL.moving) {\n        RL.iter--;\n        if (RL.iter == 0) {\n        }\n    }\n    Delay(2000); \n    return 0;\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_6_b.1.c", "original_string": "void copyArrays(unsigned int n, int * array1, int * array2){\n    int i = 0;\n    for(i; i < n; i++){\n        array2[i] = array1[n-1-i];\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__11.0.c", "original_string": "double exponencial(double a, int n)\n{\n    if (n == 0) return 1;\n    else if (n == 1) return a;\n    else if (n < 0) return exponencial(1/a, (-1)*n);\n    else if (n % 2 == 0) return exponencial(a, n/2) * exponencial(a, n/2);\n    else return exponencial(a, n-1) * exponencial(a, 1);\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__4menu_driven.0.c", "original_string": "void main()\n{\n    char option;\n    printf (\"choose the option\");\n    scanf(\"%c\",&option);\n    switch(option)\n    {\n    case'A':\n        sumofdigits();\n        break;\n    case'B':\n        perfectno();\n        break;\n    case'C':\n        sumofseries();\n        break;\n    case'D':\n        exit();\n        break;\n    }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__fprime.1.c", "original_string": "int     main(int ac, char **av)\n{\n    if (ac == 2)\n        fprime(atoi(av[1]));\n    printf(\"\\n\");\n    return (0);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__22_Dowhile.1.c", "original_string": "double Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    do{\n    Total *= numero;\n    ++i;\n    }while(i < exponente);\n    return Total;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__toggle_bit.0.c", "original_string": "int ToggleBit(int iNo, int iPos)\n{\n    int iMask = 0x00000001;\n    int iResult = 0;\n    if(iNo < 0)\n    {\n        iNo = -iNo;\n    }\n    if((iPos < 1) || (iPos > 32))\n    {\n        return 0;\n    }\n    iMask = iMask << (iPos -1);\n    iResult = iNo ^ iMask;\n    return iResult;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__24_ln.2.c", "original_string": "void ln(int contador, int iteraciones, double total, double X)\n{\n    if(contador <= iteraciones){\n        if(contador%2 == 0){\n            printf(\"+ %lf\", (Exp(contador + 1, X-1) / (contador+1)));\n            total = total + (Exp(contador + 1, X-1) / (contador+1));\n            ln(++contador,iteraciones,total,X);\n        }else{\n                        printf(\"- %lf\",(Exp(contador + 1, X-1) / (contador+1)));\n                        total = total - (Exp(contador + 1, X-1) / (contador+1));\n                        ln(++contador,iteraciones,total,X);\n                }\n    }else{\n        printf(\"\\n\\n\\n**El ln(%lf) es %lf\", X, total + (X -1));\n    }\n}"}
{"author": "andi-s0106", "file": "sorting_algorithms__107-quick_sort_hoare.1.c", "original_string": "void quicksort_hoare(int *array, int lo, int hi, size_t size)\n{\n    int p;\n    if (lo < hi)\n    {\n        p = partition(array, lo, hi, size);\n        quicksort_hoare(array, lo, p, size);\n        quicksort_hoare(array, p + 1, hi, size);\n    }\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__catavento.7.c", "original_string": "int main(int argc, char *argv[])\n{\n     glutInit(&argc,argv);\n     glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);\n     glutInitWindowPosition(50,50);\n     glutInitWindowSize(600,600);\n     glutCreateWindow(\"Catavento Animado - OpenGL\");\n     glutDisplayFunc(display);\n     glutSpecialFunc(rotacoes);\n     glutIdleFunc(anima);\n     glutMouseFunc(mouse);\n     init();\n     glutMainLoop();\n}"}
{"author": "sdukesameer", "file": "dsa__stk-push-pop.5.c", "original_string": "int main()\n{\n    int ch,x;\n    printf(\"Enter size of the working Stack:\\n\");\n    scanf(\"%d\",&x);\n    stack* stk=createstack(x);\n    while(1)\n    {\n        printf(\"\\n\");\n        printf(\"1. PUSH\\n\");\n        printf(\"2. POP\\n\");\n        printf(\"3. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            scanf(\"%d\",&n);\n            push(stk,n);\n        }\n        else if(ch==2)\n            pop(stk);\n        else if(ch==3)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid, choice try again.\\n\");\n    }\n    return 0;\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__a1.0.c", "original_string": "size_t num_rows(char *filename) {\n    size_t n = 0;\n    FILE *f = fopen(filename, \"r\");\n    for (char c = fgetc(f); c != EOF; c = fgetc(f))\n        if (c == '\\n') n++;\n    fclose(f);\n    return n;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__2.1.c", "original_string": "void le_complexs(complex_t *a, complex_t *b)\n{\n    printf(\"\\nDigite o 1\u00ba n\u00famero:\\n\");\n    printf(\"\\t-> Real: \");\n    scanf(\"%f\", &a->real);\n    getchar();\n    printf(\"\\t-> Imagin\u00e1rio: \");\n    scanf(\"%f\", &a->imaginario);\n    getchar();\n    printf(\"\\nDigite o 2\u00ba n\u00famero:\\n\");\n    printf(\"\\t-> Real: \");\n    scanf(\"%f\", &b->real);\n    getchar();\n    printf(\"\\t-> Imagin\u00e1rio: \");\n    scanf(\"%f\", &b->imaginario);\n    getchar();\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__unique2.4.c", "original_string": "void imprime(int ns[]){\n  for(int i = 0; i < 9; i++)\n    if(ns[i] != 0)\n      printf(\"%d\", ns[i]);\n  printf(\"\\n\");\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_pos_DCLL.3.c", "original_string": "int count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n    return c;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__vm-lines.4.c", "original_string": "void freeln(LINE* ln) {\n    for(int i = 0; i < ln->count; i++)\n        free(ln->tokens[i]);\n    free(ln->tokens);\n    free(ln);\n}"}
{"author": "augustogunsch", "file": "jackc__parser-expressions.16.c", "original_string": "SUBROUTCALL* parsesubroutcallnullified(PARSER* p) {\n    if(p->current->type != identifier)\n        return NULL;\n    anchorparser(p);\n    SUBROUTCALL* c = (SUBROUTCALL*)malloc(sizeof(SUBROUTCALL));\n    c->debug = getdebug(p);\n    if(nextequals(p, \".\")) {\n        c->parentname = p->current->token;\n        next(p);\n        next(p);\n    }\n    else\n        c->parentname = NULL;\n    if(p->current->type != identifier)\n        return nullsubroutcall(p, c);\n    c->name = p->current->token;\n    next(p);\n    if(differs(p, \"(\"))\n        return nullsubroutcall(p, c);\n    next(p);\n    c->parameters = parseexpressionlist(p);\n    if(differs(p, \")\"))\n        return nullsubroutcall(p, c);\n    next(p);\n    return c;\n}"}
{"author": "mandarvu", "file": "msc__problem71.0.c", "original_string": "int prime(int n) {\n  if (n % 2 == 0)\n    return 1;\n  else\n  {\n    for (int ii = 1; ii <= sqrt(n); ii++)\n    {\n      if (n % ii == 0)\n       return 1;\n    }\n  return 0;\n  }\n}"}
{"author": "mandarvu", "file": "msc__problem7.1.c", "original_string": "int main() {\n  int source[MAX], target[MAX];\n  printf(\"Enter %d numbers: \", MAX);\n  for (int i = 0; i < MAX; i++)\n    scanf(\"%d\", source + i);\n  printf(\"\\nThe Array is\\n\");\n  for (int i = 0; i < MAX; i++)\n    printf(\"%d\\t\",  *(source + i));\n  reverse_array(source, target);\n  printf(\"\\nThe reversed Array is\\n\");\n  for (int i = 0; i < MAX; i++)\n    printf(\"%d\\t\",  *(target + i));\n  return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__week_1.1.c", "original_string": "int Lsearch(int arr[], int n, int x)\n{\n    for(int i = 0 ; i < n ; i++)\n        if(arr[i] == x)\n            return i + 1;\n    return -1;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-tree.11.c", "original_string": "void freesubroutbody(SUBROUTBODY* b) {\n    if(b->vardecs != NULL)\n        freevardecs(b->vardecs);\n    if(b->statements != NULL)\n        freestatements(b->statements);\n    free(b);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__stp_conditions.4.c", "original_string": "bool_t stpSupersedesPortInfo(StpBridgePort *port, const StpBpdu *bpdu)\n{\n   bool_t res;\n   StpBridgeId rootId;\n   StpBridgeId bridgeId;\n   StpBridgeContext *context;\n   context = port->context;\n   rootId.priority = ntohs(bpdu->rootId.priority);\n   rootId.addr = bpdu->rootId.addr;\n   bridgeId.priority = ntohs(bpdu->bridgeId.priority);\n   bridgeId.addr = bpdu->bridgeId.addr;\n   res = FALSE;\n   if(stpCompareBridgeId(&rootId, &port->designatedRoot) < 0)\n   {\n      res = TRUE;\n   }\n   else if(stpCompareBridgeId(&rootId, &port->designatedRoot) > 0)\n   {\n   }\n   else if(ntohl(bpdu->rootPathCost) < port->designatedCost)\n   {\n      res = TRUE;\n   }\n   else if(ntohl(bpdu->rootPathCost) > port->designatedCost)\n   {\n   }\n   else if(stpCompareBridgeId(&bridgeId, &port->designatedBridge) < 0)\n   {\n      res = TRUE;\n   }\n   else if(stpCompareBridgeId(&bridgeId, &port->designatedBridge) > 0)\n   {\n   }\n   else\n   {\n      if(stpCompareBridgeId(&bridgeId, &context->bridgeId) != 0)\n      {\n         res = TRUE;\n      }\n      else if(ntohs(bpdu->portId) <= port->designatedPort)\n      {\n         res = TRUE;\n      }\n      else\n      {\n      }\n   }\n   return res;\n}"}
{"author": "sdukesameer", "file": "c__selection_sort.2.c", "original_string": "void selectionSort(int arr[], int len){ \n    int min,i,j,t;\n    for(i=0;i<len-1;i++)\n    {\n        min=i;   \n        for(j=i+1;j<len;j++)   \n        {\n            if(arr[j]<arr[min])\n                min=j;;\n        }\n        t=arr[i];\n        arr[i]=arr[min];   \n        arr[min]=t;\n        printf(\"Pass %d: \",i+1); \n        printArray(arr,len);   \n    }\n}"}
{"author": "theuwis", "file": "project-euler__main5.0.c", "original_string": "int main(void){\n    long answer = 1;\n    int nr_of_primes_found = 0, i;\n    bool is_prime = true;\n    while(1){\n        for(i = 2; i <= answer/2; i++){\n            if(answer % i == 0){\n                is_prime = false;\n                break;\n            }\n        }\n        if(is_prime){\n            nr_of_primes_found++;\n            if(nr_of_primes_found == NR_PRIME - 1){\n                break;\n            }           \n        }\n        is_prime = true;\n        answer++;\n    }\n    printf(\"answer=%ld\\n\", answer);\n    return EXIT_SUCCESS;\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__else-if.0.c", "original_string": "int main ()\n{\n    int a,b;\n    printf(\"l\u00fctfen bir say\u0131 giriniz:\");\n    scanf(\"%d\",&a);\n    printf(\"l\u00fctfen bir say\u0131 giriniz:\");\n    scanf(\"%d\",&b);\n    if(a<b)\n        printf(\"a b'den k\u00fc\u00e7\u00fckt\u00fcr\");\n    else if(a>b)\n        printf(\"a b'den b\u00fcy\u00fckt\u00fcr\");\n    else \n        printf(\"a b ye e\u015fittir\");\n    return 0;\n    }"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__wdt1.0.c", "original_string": "int main()\n{\n    IODIR1 |= (0xFF<<17);\n    WDMOD = (1<<0)|(1<<1);\n    WDTC = 0xFFFFFF;            \n    WDFEED = 0xAA;              \n    WDFEED = 0x55;\n    blink_led(24);          \n    while(1)\n    {\n        blink_led(17);\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc-a.6.c", "original_string": "int rec_height(list* node)\n{\n    if(node==NULL)\n    return 0;\n    else\n    {\n    int lheight=rec_height(node->left);\n    int rheight=rec_height(node->right);\n    if(lheight> rheight)\n        return (lheight+1);\n    else return (rheight+1);\n    }\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Selection_Sort.0.c", "original_string": "void main()\n{\n    int i = 0;\n    int size = 0;\n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n    selection_sort(input_array, size);\n    printf(\"\\nAfter Selection Sorting:- \\n\");\n    display(input_array, size);\n    printf(\"\\n\");\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__spi_decode.0.c", "original_string": "int main()\n{\n    PINSEL0 |= (1<<8)|(1<<10)|(1<<12);  \n    PINSEL0 &= ~((1<<9)|(1<<11)|(1<<13));\n    IODIR0 |= (1<<7);       \n    S0SPCR = (1<<2)|(1<<3)|(1<<4)|(1<<5);       \n    S0SPCCR = 8;        \n    spi_data(0x0C01);               \n    spi_data(0x0900);               \n    spi_data(0x0A00);               \n    spi_data(0x0B03);               \n    spi_data(0x0177);       \n    spi_data(0x021F);       \n    spi_data(0x034E);       \n    spi_data(0x043D);       \n}"}
{"author": "augustogunsch", "file": "jackc__compiler-statements.5.c", "original_string": "LINEBLOCK* compilewhile(SCOPE* s, STATEMENT* st) {\n    CONDSTATEMENT* w = st->whilestatement;\n    LINEBLOCK* blk = compileexpression(s, st->debug, w->expression);\n    pthread_mutex_lock(&(s->compiler->whilemutex));\n    static int whilecount = 0;\n    int mycount = whilecount;\n    whilecount++;\n    pthread_mutex_unlock(&(s->compiler->whilemutex));\n    char* explabel = mkcondlabel(\"WHILE_EXP\", mycount);\n    char* explabelln[] = { \"label\", explabel };\n    appendlnbefore(blk, mkln(explabelln));\n    appendln(blk, onetoken(\"not\"));\n    char* endlabel = mkcondlabel(\"WHILE_END\", mycount);\n    char* ifgoto[] = { \"if-goto\", endlabel };\n    appendln(blk, mkln(ifgoto));\n    blk = mergelnblks(blk, compilestatements(s, w->statements));\n    char* gotoln[] = { \"goto\", explabel };\n    appendln(blk, mkln(gotoln));\n    char* endlabelln[] = { \"label\", endlabel };\n    appendln(blk, mkln(endlabelln));\n    free(explabel);\n    free(endlabel);\n    return blk;\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad2-KopiowanieTablic.0.c", "original_string": "int main()\n{\n   int array1[7] = {8, 32, -4, 5, 6, 93, 345};\n   int array2[7];\n   int array3[7];\n   int arraySize = sizeof(array1)/sizeof(*array1);\n    copyArrayNormal(array1, array2, arraySize);\n    copyArrayPointer(array1, array3, arraySize);\n    printf(\"array1: \");\n    for(int i = 0; i < arraySize; i++){\n        printf(\"%d \", array1[i]);\n    }\n    printf(\"\\n\");\n    printf(\"array2: \");\n    for(int i = 0; i < sizeof(array2)/sizeof(*array2); i++){\n        printf(\"%d \", array2[i]);\n    }\n    printf(\"\\n\");\n    printf(\"array3: \");\n    for(int i = 0; i < sizeof(array3)/sizeof(*array3); i++){\n        printf(\"%d \", array3[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "earth429", "file": "mulpre__mulprec.0.c", "original_string": "void clearByZero(struct NUMBER *a){\n    int i;\n    for (i = 0; i < KETA;i++){\n        a->n[i] = 0;\n    }\n    setSign(a, 1);\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__arreglo_uni_dinamico_calloc.0.c", "original_string": "int main(){\n    int *calorias = NULL;\n    int tamanno;\n    printf(\"Ingresa cantidad de d\u00edas en que se registrar\u00e1n las calor\u00edas:\");\n    scanf(\"%d\", &tamanno);\n    calorias = (int *) calloc (tamanno, sizeof(int));\n    if (calorias != NULL){\n       printf(\"El promedio de calor\u00edas consumidas en %d d\u00edas fue %.2f\\n\"\n        , tamanno\n        , promedio_calorias(calorias, tamanno));\n        free(calorias);\n    } else {\n        printf(\"No se pudo reservar la memoria\\n\");\n    }\n    return 0;\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__test1.1.c", "original_string": "static void init_crc_table(void)\n{\n    unsigned int c;\n    unsigned int i, j;\n    for (i = 0; i < 256; i++) {\n        c = (unsigned int)i;\n        for (j = 0; j < 8; j++) {\n            if (c & 1)\n                c = 0xedb88320L ^ (c >> 1);\n            else\n                c = c >> 1;\n        }\n        crc_table[i] = c;\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_conditions.3.c", "original_string": "uint_t rstpEdgeDelay(RstpBridgePort *port)\n{\n   uint_t value;\n   if(port->operPointToPointMac)\n   {\n      value = rstpMigrateTime(port->context);\n   }\n   else\n   {\n      value = rstpMaxAge(port);\n   }\n   return value;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__tokenizer.14.c", "original_string": "void skipmultiln(FILE* input, int* lnscount) {\n    unsigned char c;\n    while(c = fgetc(input), c != '\\0')\n        if(c == '\\n')\n            (*lnscount)++;\n        else if(c == '*')\n            if(fgetc(input) == '/')\n                break;\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__sum_999_client.0.c", "original_string": "int main()\n{\n    key_t key;\n    int shmid,i;\n    struct Memory *shmptr;\n    key = ftok(\".\", 'x');\n    printf(\"key:%d\\n\",key);\n    shmid = shmget(key, sizeof(struct Memory), IPC_CREAT | 0666);\n     if (shmid < 0) {\n          printf(\"*** shmget error (server) ***\\n\");\n          exit(1);\n     }\n     shmptr=(struct Memory*)shmat(shmid,NULL,0);\n     if ((int) shmptr == -1) {\n          printf(\"*** shmat error (server) ***\\n\");\n          exit(1);\n     }\n     printf(\"client attached to shared memory\\n\");\n     printf(\"sum is %f\\n\",shmptr->arr[0]);\n     printf(\"product is %f\\n\",shmptr->arr[1]);\n     printf(\"average is %f\\n\",shmptr->arr[2]);\n     shmptr->status=TAKEN;\n     shmdt((void*)shmptr);\n     exit(0);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__testingbinary.1.c", "original_string": "struct node* find_minimum(struct node *root)\n{\n    if(root == NULL)\n        return NULL;\n    else if(root->left_child != NULL) \n        return find_minimum(root->left_child); \n    return root;\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_6.6.c", "original_string": "void del()\n{\n    struct node* temp;\n    int key, i = 1;\n    printf(\"Enter the location of element to delete : \");\n    scanf(\"%d\", &key);\n    if(key > length())\n    {\n        printf(\"Invalid Location to perform delete\\n\\n\");\n    }\n    else if(key == 1)\n    {\n        temp = root;\n        root = temp->right;\n        temp->left = NULL;\n        free(temp);\n    }\n    else if(key == length())\n    {\n        struct node * temp, *p;\n        p = root;\n        while(p->right != NULL)\n        {\n            p = p->right;\n        }\n        temp = p->left;\n        temp->right = NULL;\n        free(p);\n    }\n    else\n    {\n        struct node *p, *q;\n        temp = root;\n        while(i < key)\n        {\n            temp = temp->right;\n            i++;\n        }\n        q = temp->right;\n        p = temp->left;\n        p->right = q;\n        q->left = p;\n        free(temp);\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__pipe_multread.1.c", "original_string": "int main()\n{\n    int fd[2];\n    int ret = pipe(fd);\n    if(ret == -1)\n        sys_error(\"pipe error\");\n    int i;\n    for(i = 0; i < 2; i++)\n    {\n        pid_t pid = fork();\n        if(pid == -1)\n            sys_error(\"fork error\");\n        else if(pid == 0)\n            break;\n    }\n    char buf[1024];\n    int n;\n    if (i == 0)\n    {\n        close(fd[1]);\n        n = read(fd[0], buf, 6);\n        write(STDOUT_FILENO, buf, n);\n    }\n    else if (i == 1)\n    {\n        close(fd[1]);\n        n = read(fd[0], buf, 6);\n        write(STDOUT_FILENO, buf, n);\n    }\n    else if(i == 2)\n    {\n        close(fd[0]);\n        write(fd[1], \"hello world\\n\", strlen(\"hello world\\n\"));\n        wait(NULL);\n        wait(NULL);\n    }\n    return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__AF.0.c", "original_string": "void fibonacci(int maior)\n{\n    fib[0] = 1;\n    fib[1] = 1;\n    for (int a = 2; a <= maior; a++)\n    {\n        fib[a] = fib[a - 1] + fib[a - 2];\n    }\n}"}
{"author": "2security", "file": "Matrix__36Transpose.2.c", "original_string": "void Transpose(int mat1[][20],int mat2[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)\n        mat2[i][j]=mat1[j][i];\n    }"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_certificate.1.c", "original_string": "error_t acmeClientFormatDownloadCertRequest(AcmeClientContext *context)\n{\n   error_t error;\n   size_t n;\n   char_t *protected;\n   const char_t *payload;\n   payload = \"\";\n   protected = context->buffer;\n   error = acmeClientFormatJwsProtectedHeader(&context->accountKey,\n      context->account.url, context->nonce, context->order.certificate,\n      protected, &n);\n   if(!error)\n   {\n      error = jwsCreate(context->prngAlgo, context->prngContext, protected,\n         payload, context->accountKey.alg, context->accountKey.crv,\n         context->accountKey.privateKey, context->buffer, &context->bufferLen);\n   }\n   return error;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__card_dos.2.c", "original_string": "void deal( const int wDeck[][13], const char *wFace[], const char *wSuit[]){\n    int card, row, column;\n    for ( card = 1; card <= 5; card++){\n        for ( row = 0; row <= 3; row++){\n            for ( column = 0; column <= 12; column++){\n                if(wDeck[row][column] == card)\n                    printf(\"%5s of %-8s%c\", wFace[column], wSuit[row], (card % 2) == 0 ? '\\n' : '\\t');\n            }\n        }\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__52.0.c", "original_string": "int main()\n{\n    char nome1[100], sobrenome1[100], nome2[100], sobrenome2[100], sobrenome2_2[100];\n    int i1, j1, i2, j2, i1_2, tam_sobrenome1, tam_sobrenome2;\n    printf(\"\\nInforme o 1\u00ba nome: \");\n    scanf(\"%[^\\n]s\", nome1);\n    getchar();\n    printf(\"\\nInforme o 1\u00ba sorenomenome: \");\n    scanf(\"%[^\\n]s\", sobrenome1);\n    getchar();\n    printf(\"\\nInforme o 2\u00ba nome: \");\n    scanf(\"%[^\\n]s\", nome2);\n    getchar();\n    printf(\"\\nInforme o 2\u00ba sobrenome: \");\n    scanf(\"%[^\\n]s\", sobrenome2);\n    getchar();\n    strcpy(sobrenome2_2, sobrenome2);\n    tam_sobrenome1 = strlen(sobrenome1);\n    i1 = tam_sobrenome1;\n    while (sobrenome1[i1] != ' ')\n    {\n        i1--;\n    }\n    i1_2 = i1 + 1;\n    tam_sobrenome2 = strlen(sobrenome2);\n    j1 = 0;\n    while (sobrenome2[j1] != ' ')\n    {\n        j1++;\n    }\n    for (int k = (j1 + 1); k <= (j1 + i1); k++)\n    {\n        sobrenome2[k] = sobrenome1[i1_2];\n        i1_2++;\n    }\n    printf(\"\\n%s %s e %s %s.\\nAp\u00f3s casados se chamar\u00e3o:\\n%s %s e %s %s\\n\\n\",\n           nome1, sobrenome1, nome2, sobrenome2_2, nome1, sobrenome2, nome2, sobrenome2);\n    return 0;\n}"}
{"author": "sdukesameer", "file": "c__mult_mat.4.c", "original_string": "int main()\n{\n        int r1, c1, mat1[NROWS][NCOLS],r2, c2, mat2[NROWS][NCOLS],sum[NROWS][NCOLS];\n        scanf(\"%d%d\", &r1, &c1);\n        if (!isValidRC(r1, c1)) return 1;\n        readMat(mat1, r1, c1);\n        scanf(\"%d%d\", &r2, &c2);\n        if (!isValidRC(r2, c2)) return 1;\n        readMat(mat2, r2, c2);\n        multMat(r1, c1, mat1, r2, c2, mat2, sum);\n        dispMat(sum, r1, c2);\n        return 0;\n}"}
{"author": "MFarid94", "file": "Assignment4__Exercise9.0.c", "original_string": "char* LastLetters(char *str){\n    while(*str != '\\0'){\n        str++;\n    }\n    arr[0] = *(--str);\n    arr[1] = ' ';\n    arr[2] = *(--str);\n    arr[3] = '\\0';\n    return arr;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__stackTopStackBottom.4.c", "original_string": "int peek(struct stack* sp, int i){\n    int arrayInd = sp->top-i+1;\n    if(arrayInd<0){\n        printf(\"Not a valid position for stack\\n\");\n        return -1;\n    }\n    else{\n        return sp->arr[arrayInd];\n    }\n}"}
{"author": "andi-s0106", "file": "binary_trees__13-binary_tree_nodes.1.c", "original_string": "size_t count_nodes(const binary_tree_t *tree, size_t nodes)\n{\n    size_t left;\n    size_t right;\n    left = nodes;\n    right = nodes;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    if (tree->right != NULL || tree->right != NULL)\n    {\n        nodes = nodes + 1;\n    }\n    left = left + count_nodes(tree->left, left);\n    right = right + count_nodes(tree->right, right);\n    return (nodes + left + right);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__timer_2match.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | LED_ALL ;  \n    T0PR = 14;\n    T0MR0 = 1000000;\n    T0MR1 = 2000000;\n    T0MCR = (1<<0)|(1<<3)|(1<<4);   \n    T0TCR = (1<<1);     \n    T0TCR = (1<<0);  \n    while(1)\n    {\n        if(T0IR & (1<<0))  \n        {\n            IOSET1 = 1<<17;\n            T0IR = (1<<0); \n        }\n        else if(T0IR & (1<<1))  \n        {\n            IOCLR1 = 1<<17;\n            T0IR = (1<<1); \n        }\n    }\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Seg.1.c", "original_string": "void rem_program(int id)\n{\n    int i,j,k;\n    for(i=0;i<16;i++)\n    {\n        if(Mem[i]==id)\n            break;\n    }\n    for(k=15;k>=0;k--)\n    {\n        if(Mem[k]==id)\n            break;\n    }\n    j=k-i+1;\n    k=k+1;\n    while(k<16)\n    {\n        Mem[i]=Mem[k];\n        i++;\n        k++;\n    }\n    k=15;\n    while(j!=0)\n    {\n        Mem[k]=0;\n        k--;\n        j--;\n    }\n}"}
{"author": "earth429", "file": "mulpre__newton_practice.1.c", "original_string": "double newton(double x0) {\n    double x; \n    double b; \n    double e; \n    e = 1.e-7;\n    x = x0;\n    b = x0;\n    while(1){\n        b = x; \n        x = b - (f(b) / fdash(b));\n        printf(\"now x = %10.6lf\\n\", x);\n        if(fabs(x - b) < e){ \n            break;\n        }\n    }\n    return x;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__biggest_pal.2.c", "original_string": "void        pal(char *str)\n{\n    t_pal   pal;\n    t_pal   count;\n    t_pal   old;\n    int     i = 0;\n    int     max;\n    count.end = ft_strlen(str) - 1;\n    max = count.end;\n    while (str[i] != '\\0')\n    {\n        count.length = 1;\n        count.start = i;\n        old.start = i;\n        old.end = count.end;\n        max = count.end;\n        while (str[count.start] == str[count.end])\n        {\n            if (count.start == count.end || count.start + 1 == count.end)\n            {\n                if (old.end - old.start >= pal.length)\n                {\n                    pal.start = old.start;\n                    pal.end = old.end + 1;\n                    pal.length = old.end - old.start;\n                }\n                break ;\n            }\n            count.length++;\n            count.start++;\n            count.end--;\n        }\n        count.start = old.start;\n        count.end = old.end;\n        if (max == pal.length)\n            break ;\n        if (str[i + 1] == '\\0' && count.end > 0)\n        {\n            count.end--;\n            i = -1;\n        }\n        i++;\n    }\n    if (pal.length == 0)\n    {\n        ft_putstr(&str[ft_strlen(str) - 1]);\n        return ;\n    }\n    str[pal.end] = '\\0';\n    ft_putstr(&str[pal.start]);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CLL.7.c", "original_string": "void delete_beg()\n{\n    struct node *temp,*firstnode;\n    temp =head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    firstnode=head;\n    head=head->next;\n    temp->next=firstnode->next;\n    free(firstnode);\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.7.c", "original_string": "void doRightShift(struct btreeNode *myNode, int pos) {\n        struct btreeNode *x = myNode->link[pos];\n        int j = x->count;\n        while (j > 0) {\n                x->val[j + 1] = x->val[j];\n                x->link[j + 1] = x->link[j];\n        }\n        x->val[1] = myNode->val[pos];\n        x->link[1] = x->link[0];\n        x->count++;\n        x = myNode->link[pos - 1];\n        myNode->val[pos] = x->val[x->count];\n        myNode->link[pos] = x->link[x->count];\n        x->count--;\n        return;\n  }"}
{"author": "dishanp", "file": "DSA__q44.3.c", "original_string": "int main()\n{\n    int n;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n    {\n        scanf(\"%d\", &A[i]);\n    }\n    create(A, n);\n    printf(\"\\nThe list : \");\n    display(first);\n    printf(\"\\n\");\n    printf(\"The elements in reverse are : \");\n    reversedisplay(first);\n    printf(\"\\n\");\n}"}
{"author": "ria3999", "file": "cbnst__NEWTONS_BACKWARD_INTERPOLATION.2.c", "original_string": "int main()\n{\n    int n,i,j;\n    float x[90],value,sum=0;\n    float y[90][90];\n    printf(\"\\n\\n***INPUT***\\n\\n\");\n    printf(\"Enter n\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter value of x:\\n\");\n    for(i=0;i<n;i++)\n        scanf(\"%f\",&x[i]);\n    printf(\"Enter value of y:\\n\");\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<1;j++)\n        {\n            printf(\"Enter y[%d][%d] \",i,j);\n            scanf(\"%f\",&y[i][j]);\n        }\n    }\n    for (int i = 1; i < n; i++) {\n        for (int j = n - 1; j >= i; j--)\n            y[j][i] = y[j][i - 1] - y[j - 1][i - 1];\n    }\n    printf(\"Backward difference table:\\n\");\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= i; j++)\n            printf(\"%.2f \",y[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"Enter value of which you want the answer:\\n\");\n    scanf(\"%f\",&value);\n    sum = y[n - 1][0];\n    float u = (value - x[n - 1]) / (x[1] - x[0]);\n    for (int i = 1; i < n; i++) {\n        sum = sum + (u_cal(u, i) * y[n - 1][i]) /\n                                     fact(i);\n    }\n    printf(\"\\n\\n***OUTPUT***\\n\\n\");\n    printf(\"\\n Value at %f is %f\",value,sum);\n    return 0;\n}"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__2-3.0.c", "original_string": "void main(){\n  char s[100];\n  int res;\n  scanf(\"%s\", s);\n  res = htoi(s);\n  if(res >= 0)\n    printf(\"%d\\n\",res);\n  else\n    printf(\"Invalid Input\\n\");\n}"}
{"author": "dishanp", "file": "DSA__q4.1.c", "original_string": "int *multiply(int A[], int B[], int n, int m)\n{\n    int *prod = (int*)malloc((n + m - 1)*sizeof(int));\n    for (int i = 0; i < n + m - 1; i++)\n        prod[i] = 0;\n    for (int i = 0 ; i < n; i++)\n    {\n        for (int j = 0 ; j < m ; j++)\n            prod[i+j] += A[i]*B[j];\n    }\n    printPoly(prod, n+m-1);\n    return prod;\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_1-20.6.c", "original_string": "void path(int **d,char **maze,char** road,int fx,int fy,int num){\n    int row=fx;\n    int col=fy;\n    int i,j,nr,nc;\n    road[row][col]='*';\n    while(maze[row][col]!='S'){\n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            if (d[nr][nc] == d[row][col]-1){\n                row=nr;\n                col=nc;\n                break;\n            }\n        }\n        road[row][col]='*';\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__stk-push-pop.0.c", "original_string": "stack* createstack(unsigned int x)\n{\n    stack* ret=(stack* ) malloc(sizeof(stack));\n    ret->top=-1;\n    ret->size=x;\n    ret->arr=(int* )malloc(x * sizeof(int));\n    return ret;\n}"}
{"author": "mandarvu", "file": "msc__problem5.0.c", "original_string": "int main() {\n  int unsorted1[SIZE], unsorted2[SIZE], final[2*SIZE];\n  printf(\"Enter %d numbers in 1st array: \", SIZE);\n  for (int i = 0; i < SIZE; i++)\n    scanf(\"%d\",unsorted1 + i);\n  printf(\"Enter %d numbers in 2nd array: \", SIZE);\n  for (int i = 0; i < SIZE; i++)\n    scanf(\"%d\",unsorted2 + i);\n  printf(\"\\nArray 1:\\n\");\n  for (int i = 0; i < SIZE; i++)\n    printf(\"%d\\t\",  *(unsorted1 + i));\n  printf(\"\\nArray 2:\\n\");\n  for (int i = 0; i < SIZE; i++)\n    printf(\"%d\\t\",  *(unsorted2 + i));\n  merge_array(unsorted1, unsorted2, final);\n  printf(\"\\nMerged array\\n\");\n  for (int j = 0; j < (2 * SIZE); j++)\n    printf(\"%d  \",*(final + j));\n}"}
{"author": "ankitraj311", "file": "450_babbar__2_max_min_in_array_GEEk.1.c", "original_string": "int main()\n{\n  int arr[100] = {1000, 11, 445, 1, 330, 3000};\n  int no = 6;\n  struct pair minmax = max_min_array(arr,no);\n  printf(\"Max value is %d \\nMin value is %d\",minmax.min,minmax.max);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_CLL.4.c", "original_string": "void insert_beg()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node *)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    if(head==0)\n    {\n        head=newnode;\n        newnode->next=newnode;\n    }\n    else\n    {\n        temp=head;\n        while(temp->next!=head)\n        {\n            temp=temp->next;\n        }\n        temp->next=newnode;\n        newnode->next=head;\n        head=newnode;\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__ca3.6.c", "original_string": "void level_order_Traversal (BS_TREE *ar){\n    QUEUE q;\n    BS_TREE *ptr;\n    initialiseQueue (&q);\n    addQueue (ar, &q);\n    while (! isEmpty(q)){\n        ptr = deleteQueue (&q);\n        if ( ptr->left != NULL ) \n            addQueue (ptr->left, &q);\n        if ( ptr->right != NULL ) \n            addQueue (ptr->right, &q);\n        printf(\"\\t %d\", ptr->data);            \n    }\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_print_comb2.0.c", "original_string": "void ft_print_comb2(){\n    int x = 9;\n    int m = 0;\n    for(int i = 0; i<= 9; i++){\n        if(i == 9)\n            x = 8;\n        for(int j = 0; j <= x; j++){\n            for(int k = 0; k <= 9; k++){    \n                if(j != 0)\n                    m = 0;\n                for(int l = m; l <= 9; l++){\n                    if( i*10 + j != k*10+l){\n                        printf(\"%i%i %i%i, \", i,j,k,l);\n                    }\n                }\n            }\n        }\n    }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__linkedlisr.4.c", "original_string": "int main()\n{\n    int iRet = 0;\n    PNODE First = NULL;     \n    InsertFirst(&First, 51);    \n    InsertFirst(&First, 21);    \n    InsertFirst(&First, 11);    \n    Display(First);                 \n    iRet = Count(First);\n    printf(\"\\nNumber of elements are %d : \\n\",iRet);\n    InsertLast(&First,101);\n        InsertLast(&First,111);\n    Display(First);\n    return 0;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-central-scanner-with-whitelist__nrf_fstorage.7.c", "original_string": "bool nrf_fstorage_is_busy(nrf_fstorage_t const * p_fs)\n{\n    if ((p_fs == NULL) || (p_fs->p_api == NULL))\n    {\n        for (uint32_t i = 0; i < NRF_FSTORAGE_INSTANCE_CNT; i++)\n        {\n            p_fs = NRF_FSTORAGE_INSTANCE_GET(i);    \n            if (p_fs->p_api != NULL)\n            {\n                if (p_fs->p_api->is_busy(p_fs))\n                {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    return p_fs->p_api->is_busy(p_fs);\n}"}
{"author": "flora0110", "file": "hw02git__4108056029_2-1.0.c", "original_string": "int main(){\n    int i;\n    listpointer last,plat;\n    first=(listpointer)malloc(sizeof(list));\n    first->data=64;\n    last=first;\n    for(i=1;i<20;i++){\n        plat=(listpointer)malloc(sizeof(list));\n        plat->data=64;\n        plat->pre=last;\n        last->next=plat;\n        last=plat;\n    }\n    first->pre=plat;\n    plat->next=first;\n    FILE* rptr;\n    FILE* wfile;\n    rptr=fopen(\"test2-1.txt\",\"r\");\n    wfile=fopen(\"output2-1.txt\",\"w\");\n    if(rptr==NULL || wfile==NULL){\n        printf(\"open failure\\n\");\n        return 1;\n    }\n    else{\n        char control;\n        control=fgetc(rptr);\n        while(control!='\\n' && control!=EOF){\n            switch (control) {\n                case '+':\n                    first->data = ((first->data)+1)%64 +64;\n                    break;\n                case '-':\n                    first->data = (first->data)-1;\n                    if(first->data<64){\n                        first->data = first->data-64+91;\n                    }\n                    break;\n                case '>':\n                    first=first->next;\n                    break;\n                case '<':\n                    first=first->pre;\n                    break;\n                case '.':\n                    if(first->data==64){\n                        printf(\" \");\n                        fprintf(wfile,\" \");\n                    }\n                    else{\n                        printf(\"%c\",first->data);\n                        fprintf(wfile,\"%c\",first->data);\n                    }\n            }\n            control=fgetc(rptr);\n        }\n    }\n    fclose(wfile);\n    fclose(rptr);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__timer_1MR.2.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__27.1.c", "original_string": "int compare(char str1[],char str2[])\n{\n    int i=0,j=0,f=0;\n   while(str1[i]==str2[j])\n   {\n       if(str1[i]!='\\0'||str2[j]!='\\0')\n       {\n           f=1;\n           break;\n       }\n       i++;\n       j++;\n   }\n   if(f==1)\n    return 1;\n   else\n    return 0;\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_5.6.c", "original_string": "void delval(int value)\n{\n    struct node* temp, *p = root, *q;\n    q = root->link;\n    if(root->data == value)\n    {\n        temp = root;\n        root = temp->link;\n        temp->link = NULL;\n        free(temp);\n    }\n    else if(search(value) == 1)\n    {\n        while(q->data != value)\n        {\n            p = p->link;\n            q = p->link;\n        }\n        p->link = q->link;\n        q->link = NULL;\n        free(q);\n    }\n    else\n    {\n        printf(\"Value not found in the list.\\n\\n\");\n    }\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__optimized_server.0.c", "original_string": "void *get_in_addr(struct sockaddr *sa)\n{\n    if (sa->sa_family == AF_INET) {\n        return &(((struct sockaddr_in*)sa)->sin_addr);\n    }\n    return &(((struct sockaddr_in6*)sa)->sin6_addr);\n}"}
{"author": "fikepaci", "file": "binary_trees__114-bst_remove.1.c", "original_string": "bst_t *bst_delete(bst_t *root, bst_t *node)\n{\n    bst_t *parent = node->parent, *successor = NULL;\n    if (node->left == NULL)\n    {\n        if (parent != NULL && parent->left == node)\n            parent->left = node->right;\n        else if (parent != NULL)\n            parent->right = node->right;\n        if (node->right != NULL)\n            node->right->parent = parent;\n        free(node);\n        return (parent == NULL ? node->right : root);\n    }\n    if (node->right == NULL)\n    {\n        if (parent != NULL && parent->left == node)\n            parent->left = node->left;\n        else if (parent != NULL)\n            parent->right = node->left;\n        if (node->left != NULL)\n            node->left->parent = parent;\n        free(node);\n        return (parent == NULL ? node->left : root);\n    }\n    successor = inorder_successor(node->right);\n    node->n = successor->n;\n    return (bst_delete(root, successor));\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.41.c", "original_string": "VMTRANSLATOR* mkvmtranslator(char* classname, LINEBLOCK* vmlines) {\n    VMTRANSLATOR* transl = (VMTRANSLATOR*)malloc(sizeof(VMTRANSLATOR));\n    transl->currln = vmlines->head;\n    transl->start = vmlines->head;\n    transl->garbage = NULL;\n    transl->retind = 0;\n    transl->cmpind = 0;\n    transl->classname = classname;\n    transl->classnamelen = strlen(classname);\n    return transl;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__keypad.1.c", "original_string": "void row_key(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(ROW);\n        IODIR1 = IODIR1 | (COL);\n        val = (IOPIN1 & ROW); \n        val = val >> 21;\n        switch(val)\n        {\n            case 0x0E: \n                lcd_str(\"R1\");\n                col_key();\n                break;\n            case 0x0D:\n                lcd_str(\"R2\");\n                col_key();\n                break;\n            case 0x0B:\n                lcd_str(\"R3\");\n                col_key();\n                break;\n            case 0x07:\n                lcd_str(\"R4\");\n                col_key();\n                break;\n            default:\n                delay(1000);\n                lcd_cmd(0x01);\n        }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_any_pos_DLL.4.c", "original_string": "void delete_at_pos()\n{\n    struct node *temp;\n    int pos;\n    int i=1;\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    temp=head;\n    while(i<pos)\n    {\n        temp=temp->next;\n        i++;\n    }\n    if(temp->next==0)\n    {\n        temp->pre->next=0;\n        free(temp);\n    }\n    else\n    {\n        temp->next->pre=temp->pre;\n        temp->pre->next=temp->next;\n        free(temp);\n    }\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__sender.1.c", "original_string": "void output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n    }\n    printf(\"\\n\");\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__i2c_MasterTxMode.0.c", "original_string": "int main()\n{   \n    lcd_config();\n    i2c_init();\n    i2c_Start();\n    i2c_tx_data(0xA0);          \n    i2c_tx_data(0x01);          \n    i2c_tx_data('C');   \n    i2c_tx_data('R');   \n    i2c_tx_data('A');   \n    i2c_tx_data('N');\n    i2c_tx_data('E');   \n    i2c_tx_data('S');       \n    i2c_stop();\n    lcd_str(\"Data sent\");\n}"}
{"author": "davibernardos", "file": "DB-PJ__e60.0.c", "original_string": "char * gerarCaptcha(char captcha[6] )\n {\n   int cont;\n   for (cont = 0 ; cont < 4 ; cont++)\n    {\n       captcha[cont] = 97 + (rand() % 25);\n    }\n    for (cont = 4 ; cont < 6 ; cont++)\n    {\n       captcha[cont] = 48 + (rand() % 9);\n    }\n    captcha[0] = (captcha[0] - 32);\n    return captcha;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica2-3.2.c", "original_string": "void * sumaVector (void* v){            \n    int *suma = malloc(sizeof(int));    \n    *suma = 0;                          \n    Vector *estructura;                 \n    estructura = (Vector*) v;           \n    if(estructura->hebras == 2){                                    \n        for(int j=estructura->i; j<(estructura->i)+5; j++){         \n            *suma = *suma + estructura->vector[j];\n        }\n        estructura->i = estructura->i + 5;\n        pthread_exit((void**)suma);                                 \n    }\n    else{                                                           \n        for(int j=estructura->i; j<(estructura->i)+2; j++){         \n            *suma = *suma + estructura->vector[j];\n        }\n        estructura->i = estructura->i + 2;\n        pthread_exit((void**)suma);                                 \n    }\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad2-CharInColumns.0.c", "original_string": "int main()\n{\n    char userChar;\n    int columnStart;\n    int columnEnd;\n    printf(\"Podaj znak: \");\n    scanf(\"%c\", &userChar);\n    printf(\"Podaj pocz\\245tkow\\245 kolumn\\251: \");\n    scanf(\"%d\", &columnStart);\n    printf(\"Podaj ko\\344cow\\245 kolumn\\251: \");\n    scanf(\"%d\", &columnEnd);\n    rzad_zn(userChar,columnStart, columnEnd);\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__post-eva.7.c", "original_string": "int main()\n{\n    while(1)\n    {\n        char exp[MAX+1];\n        printf(\"\\nTo exit enter a blank expression.\\n\");\n        printf(\"Enter a postfix expression: \");\n        gets(exp);\n        if(strlen(exp)>50){\n            printf(\"Overflow, expression length greater than 50.\\n\");\n            break;\n        }\n        else if(strlen(exp)==0){\n            printf(\"No expression found.\\n\");\n            break;\n        }\n        else\n        { \n            float ans=evaluatePostfix(exp);\n            if(ans)\n                printf(\"Postfix Evaluation: %.2f\\n\",ans);\n        }\n    }\n    return 0;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__testingbinary.5.c", "original_string": "void inorder(struct node *root)\n{\n    if(root!=NULL) \n    {\n        inorder(root->left_child); \n        printf(\" %d \", root->data); \n        inorder(root->right_child);\n    }\n}"}
{"author": "shengelenge", "file": "wp-lab3__zad3.1.c", "original_string": "int main()\n{\n    unsigned int n;\n    printf(\"Podaj liczbe naturlana: \");\n    scanf(\"%d\", &n);\n    if (czy_pierwsza(n))\n        printf(\"Liczba %u jest pierwsza.\\n\", n);\n    else\n        printf(\"Liczba %u nie jest pierwsza.\\n\", n);\n    return 0;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_22.0.c", "original_string": "int main()\n{\n    int i,j,z;\n    int a[3];\n    int b[3];\n    int c[3];\n    for(i = 0; i < 3; i++){\n        printf(\"Digite um valor para a: \", i);\n        scanf(\"%d\",&a[i]);\n    }\n        printf(\"\\n \\n\");\n    for(j = 0; j < 3; j++){\n        printf(\"Digite um valor para b: \", j);\n        scanf(\"%d\",&b[j]);\n    }\n    for(i = 0; i < 3; i++){\n    printf(\"\\n vetor a:  %d \\n \", a[i]);\n    }\n    for(j = 0; j < 3; j++){\n    printf(\"\\n vetor b: %d \\n \", b[j]);\n    }\n    for(z = 0; z < 3; z++){\n        if( z %2 ==0){\n            c[z] = a[z];\n        }\n        else if( z %2 != 0){\n            c[z] = b[z];\n        }\n        printf(\"\\n vetor c: %d \\n\",c[z]);\n    }\n    system(\"PAUSE\");\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__WDT2.0.c", "original_string": "int main()\n{\n    IODIR1 |= (0xFF<<17);\n    WDMOD = (1<<0)|(1<<1);\n    WDTC = 0xFFFFFF;            \n    WDFEED = 0xAA;\n    WDFEED = 0x55;\n    blink_led(24);          \n    while(1)\n    {\n        if(WDTV <= 0x800000)\n        {\n                WDFEED = 0xAA;\n                WDFEED = 0x55;\n        }\n        IOSET1 = 1<<17;  \n        delay_ms(100);\n        IOCLR1 = 1<<17;   \n        delay_ms(100);\n    }\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__receiver3.2.c", "original_string": "int output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n        if(i %9 == 0 && i!=0) printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__telephone1.2.c", "original_string": "void *add_element(void *para)\n{\n    FILE *fp;\n    struct tele temp;\n    fp=fopen(\"details.txt\",\"w+\");\n                printf(\"enter the number of customers\\n\");\n                scanf(\"%d\",&limit);\n                for(i=beg;i<limit+beg;i++)\n                {\n                    printf(\"enter the name of customer no %d:\\t\",i+1);\n                    scanf(\"%s\",cust[i].name);\n                    printf(\"enter the sir name:\\t\");\n                    scanf(\"%s\",cust[i].sir_name);\n                    printf(\"enter the phone number\\t\");\n                    scanf(\"%s\",cust[i].number);\n                }\n                beg=limit+beg;\n                for(i=0;i<beg;i++)\n                {\n                    for(j=0;j<beg-1;j++)\n                    {\n                        c=strcmp(cust[j].name,cust[j+1].name);\n                        if(c>0)\n                        {\n                            temp=cust[j];\n                            cust[j]=cust[j+1];\n                            cust[j+1]=temp;\n                    }}\n                }\n                fclose(fp);\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-2new0.1.c", "original_string": "char*** make3darr(int rows, int cols,int hei){\n    char ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es7.4.c", "original_string": "int main() {\n  NumeroComplesso x;\n  printf(\"Inserire parte reale e immaginaria di x: \");\n  scanf(\"%f %f\", &x.reale, &x.immaginaria);\n  NumeroComplesso y;\n  printf(\"Inserire parte reale e immaginaria di y: \");\n  scanf(\"%f %f\", &y.reale, &y.immaginaria);\n  printf(\"\\nx = \");\n  stampa_complesso(x);\n  printf(\"\\ny = \");\n  stampa_complesso(y);\n  NumeroComplesso s = somma(x, y);\n  printf(\"\\nx + y = \");\n  stampa_complesso(s);\n  NumeroComplesso p = prodotto(x, y);\n  printf(\"\\nx*y = \");\n  stampa_complesso(p);\n  int n = 5; \n  NumeroComplesso z[n];\n  for(int i=0; i<n; i++){\n    z[i].reale = i;\n    z[i].immaginaria = i+3;\n  }\n NumeroComplesso s1 = somma_array(z, n); \n printf(\"\\nLa somma di tutti gli elementi nell'array \u00e8:\\ns1 = \");\n stampa_complesso(s1);\n  return(0);\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__str_capitilizer.1.c", "original_string": "int     ft_tolower(char a, char b, int i)\n{\n    if (a != ' ' && a != '\\t' && i != -1)\n    {\n        if (b >= 'A' && b <= 'Z')\n            return (1);\n    }\n    return (0);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q42.0.c", "original_string": "void add(QUEUE* q, int ele)\n{\n    if(q->top1 == MAX)\n    {\n        printf(\"QUEUE FULL \\n\");\n        return;\n    }\n    q->top1++;\n    q->stack1[q->top1] = ele;\n}"}
{"author": "sdukesameer", "file": "dsa__n-queen-a.1.c", "original_string": "int queens(int arr[N][N],int n){\n    if(n>=N)\n        return 1;\n    for (int i = 0; i < N; i++)\n    {\n        if(safe(arr,i,n)){\n            arr[i][n]=1;\n            if(queens(arr,n+1))\n                return 1;\n            arr[i][n]=0;\n        }\n    }\n    return 0;\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__odd_even_threads.1.c", "original_string": "void *even_file_open(void *para)\n{\n    FILE *fpe;\nprintf(\"even file opening-----\\n\");\nfpe=fopen(\"even.txt\",\"r\");\nwhile (fgets(words,sizeof(words),fpe)!=NULL)\n{\n    printf(\"\\t%s\",words);\n}\nfclose(fpe);\n}"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post.2.c", "original_string": "void iter_insertion(node** root, int n)\n{\n    node*** temp=&root;\n    while(**temp!=NULL)\n    {\n        if(n < (**temp)->data) *temp=&(**temp)->left;\n        else *temp=&(**temp)->right;\n    }\n    **temp=createNode(n);\n}"}
{"author": "dishanp", "file": "DSA__q34.4.c", "original_string": "void insert(struct node *p, int index, int x)\n{\n    if(index < 0 || index > length(first))\n    {\n        printf(\"\\nInvalid index\\n\");\n        return;\n    }\n    struct node *t = (struct node*)malloc(sizeof(struct node));\n    t->data = x;\n    if(index == 0)\n    {\n        t->next = first;\n        first = t;\n    }\n    else\n    {\n        for(int i = 0; i < index - 1 ; i++)\n            p = p->next;\n        t->next = p->next;\n        p->next = t;\n    }\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad20.0.c", "original_string": "int main()\n{\n    int tablica[10];\n    int userNumber;\n    int licznik = 0;\n    int size = sizeof(tablica)/sizeof(tablica[0]);\n    while(licznik < 10) {\n        printf(\"Podaj liczbe nr %d do tablicy: \", licznik + 1);\n        scanf(\"%d\", &userNumber);\n        tablica[licznik] = userNumber;\n        licznik++;\n    }\n    printf(\"\\n\");\n    wypisz(tablica, size);\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "haon1026", "file": "linux-programming__loop_create_pthread_err.2.c", "original_string": "int main()\n{\n    int i;\n    int ret;\n    pthread_t tid;\n    for(i = 0; i < 5; i++)\n    {\n        ret = pthread_create(&tid, NULL, thread_fun, (void*)&i);    \n        if(ret != 0)\n            sys_err(\"pthread_create error\");\n    }\n    sleep(6);\n    printf(\"I'm main thread:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n    return 0;    \n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.0.c", "original_string": "void doubledeclaration(const char* name, DEBUGINFO* d1, DEBUGINFO* d2) {\n    eprintf(\"Double declaration of '%s' at '%s', line %i; previously defined at '%s', line %i\\n\",\n                name, d1->file, d1->definedat, d2->file, d2->definedat);\n    exit(1);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_DCLL.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.insert the element at the beginning position in the linked list\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4: printf(\"insert the element at the beginning position in the linked list\\n\");\n            insert_beg();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "SugumaranEvil", "file": "Linux_programming__mp3_rcv.0.c", "original_string": "int main()\n{\n   int ret_val;\n   int fd,fd_1;\n   char buffer[9000000];\n   ssize_t ret_read,ret_write;\n   fd = open(\"fifo\",O_RDONLY);\n   perror(\"open :\");\n   ret_read = read(fd,buffer,9000000);\n   perror(\"read :\");\n   fd_1 = open(\"rcv.mp3\", O_CREAT | O_WRONLY ,0764);\n   perror(\"read :\");\n   ret_write = write(fd_1,buffer,9000000);\n   perror(\"close :\");\n   close(fd);\n   close(fd_1);\n}"}
{"author": "Dhruvik-Chevli", "file": "PPLab__q2.0.c", "original_string": "int main(int argc,char* argv[]){\n    int rank,size,*a=NULL,*c=NULL;\n    float res,*b=NULL;\n    if(argc<1){\n        printf(\"Enter m as command line argument\");\n        exit(EXIT_FAILURE);\n    }\n    MPI_Init(&argc,&argv);\n    int m=atoi(argv[1]);\n    MPI_Comm_size(MPI_COMM_WORLD,&size);\n    MPI_Comm_rank(MPI_COMM_WORLD,&rank);\n    a=(int*)malloc(m*size*sizeof(int));\n    b=(float*)malloc(size*sizeof(float));\n    c=(int*)malloc(m*sizeof(int));\n    if(rank==0){\n        printf(\"Enter %d numbers.\\n\",m*size);\n        for(int i=0;i<m*size;i++)\n            scanf(\"%d\",&a[i]);\n    }\n    MPI_Scatter(a,m,MPI_INT,c,m,MPI_INT,0,MPI_COMM_WORLD);\n    res=0;\n    for(int i=0;i<m;i++){\n        res+=c[i];\n    }\n    res/=m;\n    printf(\"Process[%d]: Average is %f\\n\",rank,res);\n    MPI_Gather(&res,1,MPI_FLOAT,b,1,MPI_FLOAT,0,MPI_COMM_WORLD);\n    if(rank==0){\n        res=0;\n        for(int i=0;i<size;i++) res+=b[i];\n        res/=size;\n        printf(\"Process[%d]: The overall average is %f\\n\",rank,res);\n    }\n    MPI_Finalize();\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__queueOfInt.1.c", "original_string": "void display(que* pq)\n{\n    int i;\n    printf(\"\\n\");\n    if (pq->front ==  -1)\n    {\n        printf(\"Queue is empty\");\n        return;\n    }\n    if (pq->front > pq->rear)\n    {\n        for (i = pq->front; i < size; i++)\n            printf(\"%d \", pq->queue[i]);\n        for (i = 0; i <= pq->rear; i++)\n            printf(\"%d \", pq->queue[i]);\n    }\n    else\n    {\n        for (i = pq->front; i <= pq->rear; i++)\n            printf(\"%d \", pq->queue[i]);\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__stack.5.c", "original_string": "int main() {\n   push(3);\n   push(5);\n   push(9);\n   push(1);\n   push(12);\n   push(15);\n   printf(\"Element at top of the stack: %d\\n\" ,peek());\n   printf(\"Elements: \\n\");\n   while(!isempty()) {\n      int data = pop();\n      printf(\"%d\\n\",data);\n   }\n   printf(\"Stack full: %s\\n\" , isfull()?\"true\":\"false\");\n   printf(\"Stack empty: %s\\n\" , isempty()?\"true\":\"false\");\n   return 0;\n}"}
{"author": "haon1026", "file": "linux-programming__pthread_join.2.c", "original_string": "int main()\n{\n    pthread_t tid;\n    int ret = pthread_create(&tid, NULL, thread_fun, NULL);\n    if(ret != 0)\n        sys_err(\"pthread_create error\");\n    struct thrd *retval;\n    ret = pthread_join(tid, (void**)&retval);\n    if(ret != 0)\n        sys_err(\"pthread join error\");\n    printf(\"child thread exit with var = %d, str = %s\\n\", retval->var, retval->str);\n    pthread_exit(NULL);\n}"}
{"author": "earth429", "file": "mulpre__bisection_test.0.c", "original_string": "int main(int argc, char ** argv)\n{\n    double a, b; \n    double x; \n    int r; \n    a = 1.0;\n    b = 4.0;\n    r = bisection(a, b, &x);\n    printf(\"x = %lf\\n\", x);\n    printf(\"\u623b\u308a\u5024 = %d\\n\", r);\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc-a.8.c", "original_string": "int rec_count(list* node)\n{\n    int x=1;\n    if(node==NULL)\n        return 0;\n    else\n    {\n        x+=rec_count(node->left);\n        x+=rec_count(node->right);\n        return x;\n    }\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__LinearSearch.0.c", "original_string": "int main()\n{\n    int a[100];\n    int n,i,count=0,item;\n    printf(\"Enter the size of array\");\n    scanf(\"%d\",&n);\n    printf(\"Enter the numbers in array \\n\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    printf(\"The elements in array are: \\n\");\n     for(i=0;i<n;i++)\n    {\n        printf(\"%d\",a[i]);\n    }\n    printf(\"Enter the no. to be searched \\n\");\n    scanf(\"%d\",&item);\n    count++;\n    for(i=0;i<n;i++)\n    {\n        count++;\n        if(a[i]==item)\n        {\n            count++;\n            printf(\"\\n Number found at position %d \\n\",i);\n            count++;\n            break;\n        }\n        count++;\n    }\n    if(i==n)\n    {\n        printf(\"No.not found\");  \n    }\n    printf(\"Count=%d\",count);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__25_Dowhile.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular sen(X) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    do{\n        if(i%2 == 0)\n            Suma_total += Exp(X, (i*2)+1) / Fac((i*2)+1);\n        else\n            Suma_total -= Exp(X, (i*2)+1) / Fac((i*2)+1);\n        ++i;\n    }while(i <= veces);\n    printf(\"sen(%i) es igual a %lf\", X, (Suma_total + X));\n    return 0;\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__a2.1.c", "original_string": "int main() {\n    char *filename = \"Passports.txt\";\n    FILE *f = fopen(filename, \"r\");\n    size_t count = 0;\n    char cur = '\\0';\n    bool *info = calloc(sizeof(bool), 7);\n    char *curs = calloc(sizeof(char), 3);\n    for (cur = fgetc(f); cur != EOF; cur = fgetc(f)) {\n        if (cur == ':') switch (curs[0] + curs[1] + curs[2]) {\n            case 333: \n                info[0] = true; break;\n            case 340: \n                info[1] = true; break;\n            case 336: \n                info[2] = true; break;\n            case 323: \n                info[3] = true; break;\n            case 311: \n                info[4] = true; break;\n            case 308: \n                info[5] = true; break;\n            case 317: \n                info[6] = true; break;\n        }\n        if (cur == '\\n' && curs[2] == '\\n') {\n            if (is_pass(info)) count++;\n            free(info);\n            info = calloc(sizeof(bool), 7);\n        }\n        curs[0] = curs[1];\n        curs[1] = curs[2];\n        curs[2] = cur;\n    }\n    printf(\"Answer: %zu\\n\", count);\n    free(info);\n    free(curs);\n    fclose(f);\n    return 0;\n}"}
{"author": "2security", "file": "Matrix__25ScalarMultiplication.0.c", "original_string": "void displayMat(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%-3d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }"}
{"author": "sdukesameer", "file": "c__selection_sort.0.c", "original_string": "void inputArray(int arr[], int len){   \n    for (int i = 0; i < len; i++)\n        scanf(\"%d\", &arr[i]);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__merg_sort.0.c", "original_string": "void merge(int a[],int lb,int mid,int ub)\n{\n    int i,j,k,b[10];\n    i=lb;\n    j=mid+1;\n    k=lb;\n    while(i<=mid && j<=ub)\n    {\n        if(a[i]<a[j])\n        {\n            b[k]=a[i];\n            i++;\n            k++;\n        }\n        else\n        {\n            b[k]=a[j];\n            j++;\n            k++;\n        }\n    }\n    if(i>mid)\n    {\n        while(j<=ub)\n        {\n            b[k]=a[j];\n            j++;\n            k++;\n        }\n    }\n    else\n    {\n        while(i<=mid)\n        {\n            b[k]=a[i];\n            i++;\n            k++;\n        }\n    }\n    for(k=lb;k<=ub;k++)\n    {\n        a[k]=b[k];\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__bst-del_int-iter_in-pre.7.c", "original_string": "void preorder(node* root) \n{ \n    int c=-1;\n    node* stack[nodes(root)];\n    stack[++c]=root;\n    while(c!=-1)\n    {\n        printf(\"\\t%d\\n\",stack[c--]->data);\n        node* temp=stack[c+1];\n        if(temp->right)\n            stack[++c]=temp->right;\n        if(temp->left)\n            stack[++c]=temp->left;\n    }\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__queue_at_the_school.1.c", "original_string": "void change(char s[], int i, int j){\n  char aux = s[i];\n  s[i] = s[j];\n  s[j] = aux;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__stackTopStackBottom.7.c", "original_string": "int main()\n{\n    struct stack *sp=(struct stack*)malloc(sizeof(struct stack));\n    sp->size=10;\n    sp->top= -1;\n    sp->arr= (int *)malloc(sp->size* sizeof(int));\n    printf(\"Before pushing, Full: %d\\n\", isFull(sp));\n    printf(\"Before pushing, Empty: %d\\n\", isEmpty(sp));\n    push(sp, 56);\n    push(sp, 55);\n    push(sp, 54);\n    push(sp, 53);\n    push(sp, 52);\n    push(sp, 51);\n    push(sp, 50);\n    push(sp, 49);\n    push(sp, 48);\n    push(sp, 47); \n    push(sp, 46); \n    printf(\"After pushing, Full: %d\\n\", isFull(sp));\n    printf(\"After pushing, Empty: %d\\n\", isEmpty(sp));\n    printf(\"Popped %d from the stack\\n\", pop(sp));\n    printf(\"The top most value of this stack is %d\\n\", stackTop(sp));\n     printf(\"The bottom most value of this stack is %d\\n\", stackBottom(sp));\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__ca3.1.c", "original_string": "void addQueue (BS_TREE * at, QUEUE *aq){\n    if (aq->rear == MAX-1)\n        exit(0); \n    else\n        aq->elements [++(aq->rear)]=at;\n}"}
{"author": "earth429", "file": "mulpre__warizan.0.c", "original_string": "int main(int argc, char **argv)\n{\n    double t1 = time(NULL);\n    struct NUMBER a, b, c, d;\n    int x, y;\n    int i;\n    x = 100000000;\n    y = 2;\n    setInt(&a, x);\n    setInt(&b, y);\n    printf(\"x = %d\\ny = %d\\nx / y = %d\\nx %% y = %d\\n\", x, y, x / y, x % y);\n    dispNumberZeroSuppress(&a);\n    puts(\"\");\n    dispNumberZeroSuppress(&b);\n    puts(\"\");\n    divide(&a, &b, &c, &d);\n    dispNumberZeroSuppress(&c);\n    puts(\"\");\n    dispNumberZeroSuppress(&d);\n    puts(\"\");\n    double t2 = time(NULL);\n    printf(\"\u51e6\u7406\u6642\u9593:%f\\n\", t2 - t1);\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q33.2.c", "original_string": "char dequeueleft(queue *q)\n{\n    if (q->front==q->rear)\n    {\n        printf(\"Queue Empty\");\n        return '\\0';\n    }\n    else\n        return q->c[(q->front)++];\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_eight_queens_puzzle.2.c", "original_string": "int Mov_Queen(int Tabla[8][8], int fila, int columna){   \n    int fila_actual = 0; \n    int columna_actual = 0; \n    int estado = 0; \n    for(int i = columna + 1; i < 8; i++) \n        if(Tabla[fila][i] == 1)\n            estado = 1;\n    for(int i = columna - 1; i >= 0; i--) \n       if(Tabla[fila][i] == 1)\n            estado = 1; \n    for(int i = fila - 1; i >= 0; i--) \n       if(Tabla[i][columna] == 1)\n            estado = 1; \n    for(int i = fila + 1; i < 8; i++) \n       if(Tabla[i][columna] == 1)\n            estado = 1;\n    fila_actual = fila - 1;\n    columna_actual = columna + 1;\n    while(columna_actual < 8 && fila_actual >= 0){    \n        if(Tabla[fila_actual][columna_actual] == 1)\n            estado = 1;\n        fila_actual--;\n        columna_actual++;\n    }\n    fila_actual = fila - 1;\n    columna_actual = columna - 1;\n    while(columna_actual >= 0 && fila_actual >= 0){    \n        if(Tabla[fila_actual][columna_actual] == 1)\n            estado = 1;\n        fila_actual--;\n        columna_actual--;\n    }\n    fila_actual = fila + 1;\n    columna_actual = columna - 1;\n    while(columna_actual >= 0 && fila_actual < 8){    \n        if(Tabla[fila_actual][columna_actual] == 1)\n            estado = 1;\n        fila_actual++;\n        columna_actual--;\n    }\n    fila_actual = fila + 1;\n    columna_actual = columna + 1;\n    while(columna_actual < 8 && fila_actual < 8){    \n        if(Tabla[fila_actual][columna_actual] == 1)\n            estado = 1;\n        fila_actual++;\n        columna_actual++;\n    }\n    return estado;\n}"}
{"author": "MFarid94", "file": "Assignment-2__Exercise8.1.c", "original_string": "int main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);                            \n    setvbuf(stderr , NULL , _IONBF , 0);\n    int number1, number2;                                           \n    printf(\"Enter first number: \");\n    scanf(\"%d\",&number1);                                           \n    printf(\"Enter second number: \");\n    scanf(\"%d\",&number2);                                           \n    display_prime(number1,number2);                                 \n    return 0;\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Deletion_At_The_End_of_A_Single_Linked_List.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"Enter 1 for Creation or Enter 0 for Termination:\");\n    scanf(\"%d\",&choice);\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the Data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->ptr = NULL;\n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->ptr = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want to more?(1/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_nodes(temp);\n    delete_at_end(head,temp);\n    getch();\n}"}
{"author": "augustogunsch", "file": "jack-compiler__tokenizer.16.c", "original_string": "void readstr(FILE* input, STRING* tmp, int definedat) {\n    unsigned char c;\n    while(c = fgetc(input), c != '\\0') {\n        if(c == '\\n') {\n            eprintf(\"Unexpected end of line; line %i\", definedat);\n            exit(1);\n        }\n        if(c == '\"')\n            break;\n        append(tmp, c);\n    }\n    append(tmp, '\\0');\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__BinarySearch.2.c", "original_string": "void putdata(int x[50], int n)\n       {\n          int k;\n          for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n         }\n          printf(\"\\n\");\n       }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__AA.0.c", "original_string": "int primov(long int n)\n{\n    primos[0] = 2;\n    int k = 0, primo;\n    for (long int i = 3; (primos[k] * primos[k]) <= n; i += 2)\n    {\n        primo = true;\n        for (int j = 0; (j <= k) && (primo == true); j++)\n        {\n            if ((i % primos[j]) == 0)\n            {\n                primo = false;\n            }\n        }\n        if (primo == true)\n        {\n            primos[k + 1] = i;\n            k++;\n        }\n    }\n    return k;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica2-3.1.c", "original_string": "void imprimeVector (int *vector){       \n    printf(\"El vector es:\\n\");\n    printf(\"| \");\n    for (int i = 0; i < 10; ++i){ printf(\"%d | \",vector[i]); }\n    printf(\"\\n\");\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__ft_prime_sum.1.c", "original_string": "void        ft_putnbr(int nb)\n{\n    if (nb < 0)\n        nb *= -1;\n    if (nb > 9)\n    {\n        ft_putnbr(nb / 10);\n        ft_putnbr(nb % 10);\n    }\n    else\n        ft_putchar(nb + 48);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q4_dupl.3.c", "original_string": "int main()\n{\n    nodeptr a,b,u,in;\n    int n,i,t;\n    a=NULL;\n    printf(\"\\nEnter number elements of list\");\n    scanf(\"%d\",&n);\n    printf(\"\\nEnter elements\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&t);\n        add(&a,t);\n    }\n    display(a);\n    del(a);\n    display(a);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__M.1.c", "original_string": "int main()\n{\n    int n, av[10000], bv[10000], cv[10000], xv[100000], yv[100000], zv[100000], a, b, c, x, y, z, k = 0, solucao, solucao2, aux;\n    scanf(\"%i\", &n);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%i\", &av[i]);\n        scanf(\"%i\", &bv[i]);\n        scanf(\"%i\", &cv[i]);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        sistema (av[i], bv[i], cv[i]);\n    }\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__io.12.c", "original_string": "void freefilelist(FILELIST* fs) {\n    free(fs->name);\n    free(fs->fullname);\n    free(fs->outname);\n    FILELIST* next = fs->next;\n    free(fs);\n    if(next != NULL)\n        freefilelist(next);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q13.1.c", "original_string": "void display(que* pq)\n{\n    int i;\n    printf(\"\\n\");\n    if (pq->front ==  -1)\n    {\n        printf(\"Queue is empty\");\n        return;\n    }\n    if (pq->front > pq->rear)\n    {\n        for (i = pq->front; i < size; i++)\n            printf(\"%s\\n\", pq->queue[i]);\n        for (i = 0; i <= pq->rear; i++)\n            printf(\"%s\\n\", pq->queue[i]);\n    }\n    else\n    {\n        for (i = pq->front; i <= pq->rear; i++)\n            printf(\"%s\\n\", pq->queue[i]);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__insertAfter.3.c", "original_string": "void display(nptr head)\n{\n    nptr temp = head;\n    while(temp != NULL)\n    {\n        printf(\"%d --> \", temp -> data);\n        temp = temp->next;\n    }\n    printf(\"NULL\\n\");\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad3-CharInRows.0.c", "original_string": "int main()\n{\n    char userChar;\n    int charsInRow;\n    int numberOfRows;\n    printf(\"Podaj znak: \");\n    scanf(\"%c\", &userChar);\n    printf(\"Podaj ilo\\230\\206 znak\\242w w wierszu: \");\n    scanf(\"%d\", &charsInRow);\n    printf(\"Podaj liczb\\251 wierszy: \");\n    scanf(\"%d\", &numberOfRows);\n    wiersz_zn(userChar,charsInRow, numberOfRows);\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.25.c", "original_string": "ASMBLK* translatepopstatic(VMTRANSLATOR* t) {\n    tpopstat.items[tpopstat.count-2] = dotat(t, t->classname, t->currln->tokens[2]);\n    tpopstat.items[tpopstat.count-1] = mkstr(t, \"M=D\");\n    return copytemplate(&tpopstat);\n}"}
{"author": "dishanp", "file": "DSA__q55.3.c", "original_string": "int main()\n{\n    int n, key;\n    printf(\"Number of elements : \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n        scanf(\"%d\", &A[i]);\n    create(A, n);\n    printf(\"Enter key : \");\n    scanf(\"%d\", &key);\n    sortinsert(first, key);\n    display(first);\n}"}
{"author": "dishanp", "file": "DSA__q72.3.c", "original_string": "void insertodd(struct node *p, int index, int key)\n{\n    struct node *t = (struct node *)malloc(sizeof(struct node));\n    t->data = key;\n    if(index == 0)\n    {\n        t->next = odd;\n        odd = t;\n    }\n    else\n    {\n        for(int i = 0 ; i < index - 1 ; i++)\n        {\n            p = p->next;\n        }\n        t->next = p->next;\n        p->next = t;\n    }\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "2lista_de_C__main15.0.c", "original_string": "int main()\n{\n    int a;\n    int b;\n    int c;\n    int d = 0;\n    int cont = 0;\n    printf(\"digite o tamanho da sequencia: \");\n    scanf(\"%d\",&a);\n    for(b = 0;b < a; b++)\n    {\n        printf(\"digite um numero: \");\n        scanf(\"%d\",&c);\n        if(c < d)\n        {\n            cont++;\n            d = 0 + c;\n        }\n    }\n        if(cont <= 0)\n        {\n            printf(\"esta ordenado.\");\n        }else\n        {\n            printf(\"nao esta ordenada.\");\n        }\n}"}
{"author": "Oryx-Embedded", "file": "Common__cpu_endian.6.c", "original_string": "uint32_t reverseInt32(uint32_t value)\n{\n   value = ((value & 0xFFFF0000UL) >> 16) | ((value & 0x0000FFFFUL) << 16);\n   value = ((value & 0xFF00FF00UL) >> 8) | ((value & 0x00FF00FFUL) << 8);\n   value = ((value & 0xF0F0F0F0UL) >> 4) | ((value & 0x0F0F0F0FUL) << 4);\n   value = ((value & 0xCCCCCCCCUL) >> 2) | ((value & 0x33333333UL) << 2);\n   value = ((value & 0xAAAAAAAAUL) >> 1) | ((value & 0x55555555UL) << 1);\n   return value;\n}"}
{"author": "tadeograch", "file": "sorting_algorithms__102-counting_sort.0.c", "original_string": "void counting_sort(int *array, size_t size)\n{\n    int i, j, max = 0;\n    int *new_arr, *new_new;\n    if (size < 2)\n        return;\n    for (i = 0; i <= (int)size; i++)\n    {\n        if (array[i] > max)\n            max = array[i];\n    }\n    max += 1;\n    new_arr = (int *) malloc(sizeof(int) * max);\n    for (i = 0; i <= max; i++)\n        new_arr[i] = 0;\n    for (i = 0; i < (int)size; i++)\n        new_arr[array[i]] += 1;\n    for (i = 0; i < max; i++)\n    {\n        j = i + 1;\n        new_arr[j] += new_arr[i];\n    }\n    print_array(new_arr, max);\n    new_new = malloc(sizeof(int) * size);\n    for (i = 0; i < (int)size; i++)\n    {\n        new_arr[array[i]] -= 1;\n        new_new[new_arr[array[i]]] = array[i];\n    }\n    for (i = 0; i < (int)size; i++)\n        array[i] = new_new[i];\n    free(new_new);\n    free(new_arr);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__DemoFOTAUpdateWorkflow0.2.c", "original_string": "void fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)\n{\n  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__queue1.4.c", "original_string": "void main()\n{\n    int ch;\n    printf(\"1.ENQUEUE\\n2.DEQUEUE\\n3.SEARCH\\n4.PRINT\\n\\n\");\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the value to insert:\");\n                scanf(\"%d\",&value);\n                enqueue(queue,value);\n                break;\n            }\n            case 2:\n            {\n                dequeue(queue);\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the value to search:\");\n                scanf(\"%d\",&value);\n                search(queue,value);\n                break;\n            }\n            case 4:\n            {\n                display(queue);\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"author": "earth429", "file": "mulpre__divBy10.6.c", "original_string": "int isZero(struct NUMBER *a){\n    int i;\n    for (i = 0; i < KETA;i++){\n        if(a->n[i] != 0){\n            return -1;\n        }\n    }\n    return 0;\n}"}
{"author": "behergue", "file": "Computer_Structure__main0.0.c", "original_string": "void timer_ISR(void)\n{\n    if (RL.direction == 1) \n    {\n        if (RL.position + 1 < 6)\n        {\n            RL.position += 1;\n        }\n        else\n        {\n            RL.position = 0;\n        }\n    }\n    else\n    {\n        if (RL.position - 1 >= 0)\n        {\n            RL.position -= 1;\n        }\n        else\n        {\n            RL.position = 5;\n        }\n    }\n    D8Led_segment(RL.position);\n}"}
{"author": "earth429", "file": "mulpre__kaijyou.2.c", "original_string": "int factorial(struct NUMBER *a, struct NUMBER *b) {\n    if(isZero(a) != -1){ \n        setInt(b, 1);\n        return 0;\n    } else if(getSign(a) == -1){ \n        return -2;\n    }\n    struct NUMBER one;\n    setInt(&one, 1);\n    if(numComp(a, &one) == 0){ \n        setInt(b, 1);\n        return 0;\n    }\n    clearByZero(b);\n    tailCall(a, b, &one);\n    return 0;\n}"}
{"author": "2security", "file": "Array__TraceNormMat.1.c", "original_string": "void displayMat(int **mat,int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CDLL.5.c", "original_string": "void insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    temp=head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    temp->next=newnode;\n    newnode->pre=temp;\n    newnode->next=head;\n    head->pre=newnode;\n}"}
{"author": "fikepaci", "file": "monty__monty_funcs_2.1.c", "original_string": "void monty_sub(stack_t **stack, unsigned int line_number)\n{\n    if ((*stack)->next == NULL || (*stack)->next->next == NULL)\n    {\n        set_op_tok_error(short_stack_error(line_number, \"sub\"));\n        return;\n    }\n    (*stack)->next->next->n -= (*stack)->next->n;\n    monty_pop(stack, line_number);\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_2_2_5.1.c", "original_string": "float powerOfTwo(int n){\n    float result = 1;\n    if(n >= 0){\n        for(int i = 0; i < n; i++){\n            result = result * 2;\n        }\n    } else {\n        for(int i = 0; i > n; i--){\n            result = result * 2;\n        }\n        result = 1 / result;\n    }\n    return result;\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Insert_at_begin_In_the_Single_Linked_LIst.2.c", "original_string": "void insert_at_begin(struct node*head1,struct node*temp1)\n{\n    struct node*tempo;\n    tempo = (struct node*) malloc (sizeof(struct node));\n    printf(\"\\nEnter the data:\\n\");\n    scanf(\"%d\",&tempo->data);\n    tempo->ptr = temp1;\n    head1 = temp1 = tempo;\n    printf(\"After Insertion:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-3test.1.c", "original_string": "char*** make3darr(int rows, int cols,int hei){\n    char ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client1.1.c", "original_string": "int main() \n{ \n    int sockfd, connfd; \n    struct sockaddr_in servaddr, cli; \n    sockfd = socket(AF_INET, SOCK_STREAM, 0); \n    if (sockfd == -1) { \n        printf(\"socket creation failed...\\n\"); \n        exit(0); \n    } \n    else\n        printf(\"Socket successfully created..\\n\"); \n    bzero(&servaddr, sizeof(servaddr)); \n    servaddr.sin_family = AF_INET; \n    servaddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); \n    servaddr.sin_port = htons(PORT); \n    if (connect(sockfd, (SA*)&servaddr, sizeof(servaddr)) != 0) { \n        printf(\"connection with the server failed...\\n\"); \n        exit(0); \n    } \n    else\n        printf(\"connected to the server..\\n\"); \n    comm(sockfd); \n    close(sockfd); \n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListDelete.3.c", "original_string": "struct Node * deleteLastNode(struct Node * head){\n     struct Node *p = head;\n     struct Node *q = head->next;\n     while(q->next != NULL){\n          p = p->next;\n          q = q->next;\n     }\n     p->next = NULL;\n     free(q);\n     return head;\n}"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__3-1.1.c", "original_string": "int binsearch(int x, int v[], int n){\n  int low, high, mid;\n  low = 0;\n  high = n-1;\n  while(low <= high){\n    mid = (low+high) /2;\n    if(x < v[mid])\n      high = mid - 1;\n    else if(x > v[mid])\n      low = mid + 1;\n    else \n      return mid;\n  }\n  return -1; \n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__test.4.c", "original_string": "void delay(int ct)\n{int i,j;\n{\nfor(i=0;i<=ct;i++)\nfor(j=0;j<=6000;++j)\n{}\n}\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__BinHexConverter.2.c", "original_string": "size_t convertBinValueToHexString8(uint8_t inputValue, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < 2) \n  {\n    return 0;\n  }\n  outputStr[0] = convertBinValueToHexDigit(((inputValue & 0xF0u) >> 4), upperCase);\n  outputStr[1] = convertBinValueToHexDigit((inputValue & 0x0Fu), upperCase);\n  return 2;\n}"}
{"author": "haon1026", "file": "linux-programming__zoom.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    pid_t pid = fork();\n    if(pid == -1)\n    {\n        perror(\"fork error\");\n        exit(1);\n    }\n    else if(pid == 0)\n    {\n        printf(\"I'm child, my parent pid = %d, going to sleep 10s\\n\", getppid());\n        sleep(10);\n        printf(\"--------child die---------\\n\");\n    }\n    else if(pid > 0)\n    {\n        while(1)\n        {\n            printf(\"I'm parent, pid = %d, myson = %d\\n\", getpid(), pid);\n            sleep(1);\n        }\n    }\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__stk-by-array.2.c", "original_string": "void pop(stack* stk)\n{\n    if(stk->top==-1)\n        printf(\"STACK EMPTY!\\n\");\n    else\n        printf(\"%d popped from stack.\\n\",stk->arr[stk->top--]);\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__p.2.c", "original_string": "void    print_memory(const void *addr, size_t size)\n{\n    size_t i;\n    size_t j;\n    unsigned char *ptr;\n    i = 0;\n    j = 0;\n    ptr = (unsigned char*)addr;\n    while (i < size)\n    {\n        j = 0;\n        while (j < 16 && i + j < size)\n        {\n            ft_print_hex(ptr[i + j]);\n            if (j % 2)\n                write(1, \" \", 1);\n            j++;\n        }\n        while (j < 16)\n        {\n            write(1, \"  \", 2);\n            if (j % 2)\n                write(1, \" \", 1);\n            j++;\n        }\n        j = 0;\n        while (j < 16 && i + j < size)\n        {\n            ft_print_char(ptr[i + j]);\n            j++;\n        }\n        write(1, \"\\n\", 1);\n        i += 16;\n    }\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__palhaco.4.c", "original_string": "void desenhaCabeloEsquerda(){\n    glPushMatrix();\n        glColor3f(1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(-2.5, 0.0, 0.0);\n        glutWireSphere(0.5, 10, 10);\n    glPopMatrix();\n    glPushMatrix();\n        glColor3f(1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(-2.2, 0.7 , 0.0);\n        glutWireSphere(0.5, 10, 10);\n    glPopMatrix();\n    glPushMatrix();\n        glColor3f(1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(-2.2, -0.7, 0.0);\n        glutWireSphere(0.5, 10, 10);\n    glPopMatrix();\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__unique.2.c", "original_string": "int check_number(int n, int ns[], int i){\n  for(int j = 0; j <= i; j++)\n    if( n == ns[j])\n      return 0;\n  return 1;\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__PrimeNumFunc.0.c", "original_string": "int main()\n{\n    int l,u,check,temp,i;\n    printf(\"enter l and u:\\n\");\n    scanf(\"%d%d\",&l,&u);\n    if(l>u)\n    {\n        temp = l;\n        l = u;\n        u = temp;\n    }\n    for(i = l;i <= u;i++)\n    {\n        if(i == 1 || i == 0)\n        continue;\n        check = 0;\n        check = checkPrime(i);\n        if(check == 0)\n        {\n           printf(\"%d\\n\",i);\n        } \n    }\n    return 0;\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__0-bubble_sort.0.c", "original_string": "void bubble_sort(int *array, size_t size)\n{\n    size_t i = 0, sz = size;\n    int flag = 0, tmp = 0;\n    if (array == NULL || size < 2)\n        return;\n    while (1)\n    {\n        i = 0;\n        while (i < (sz - 1))\n        {\n            if (array[i + 1] < array[i])\n            {\n                tmp = array[i];\n                array[i] = array[i + 1];\n                array[i + 1] = tmp;\n                print_array(array, size);\n                flag = 1;\n            }\n            i++;\n        }\n        if (flag == 0)\n            break;\n        flag = 0;\n        sz--;\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc.6.c", "original_string": "int height(node* root)\n{\n    if(root==NULL)\n        return 0;\n    else\n    {\n        int lheight=height(root->left);\n        int rheight=height(root->right);\n        if(lheight>rheight)\n            return lheight+1;\n        else\n            return rheight+1;\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.24.c", "original_string": "ASMBLK* translatepush(VMTRANSLATOR* t) {\n    if(eq(t, 1, \"constant\"))\n        return translatepushconst(t);\n    if(eq(t, 1, \"static\"))\n        return translatepushstatic(t);\n    if(eq(t, 1, \"pointer\"))\n        return translatepushpointer(t);\n    if(eq(t, 1, \"temp\"))\n        return translatepushtemp(t);\n    return translatepushgeneric(t);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__InsertionAtGiven.1.c", "original_string": "struct InsertionAtGiven* insertAfterValue(struct InsertionAtGiven*head, int info, int value){\n     struct InsertionAtGiven*ptr=head;\n     struct InsertionAtGiven*q= head->next;\n     struct InsertionAtGiven*insert;\n     insert->data=value;\n     while (ptr->data!=info)\n     {\n         ptr=ptr->next;\n         q=q->next;\n     }\n     ptr->next=insert;\n     insert->next=q;\n     return head;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__row_keys.0.c", "original_string": "int main()\n{\n    int val;\n    IODIR1 = IODIR1 & ~ROWS;        \n    IODIR1 = IODIR1 | COLS;         \n    lcd_config();\n    while(1)\n    {\n        val = IOPIN1 & ROWS;        \n        val = val >> 21;\n        switch(val)\n        {\n            case 0x0E:  lcd_str(\"r1\");  delay(300); break;\n            case 0x0D:  lcd_str(\"r2\");  delay(300); break;\n            case 0x0B:  lcd_str(\"r3\");  delay(300); break;\n            case 0x07:  lcd_str(\"r4\");  delay(300); break;\n        }\n    }\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__estructuras_intro.0.c", "original_string": "int main(){\n    int x1 = 1;\n    int x2, x3, x4, x5 = 10;\n    int numeros[] = {1, 2, 3, 4};\n    x2 = x1; \n    printf(\"Ingresa la matricula:\");\n    scanf(\"%d\", &e1.matricula);\n    printf(\"Ingresa el nombre:\");\n    fflush(stdin);\n    fgets(e1.nombre, MAX_ALUMNO, stdin);\n    for (int i = 0; i < MAX_CALIFICACIONES; i++){\n        printf(\"Ingresa calificacion %d: \", i + 1);\n        scanf(\"%f\", &e1.calificaciones[i]);   \n    }\n    for (int i = 0; i < MAX_ASISTENCIA; i++){\n        printf(\"Ingresa asistencia del d\u00eda %d: \", i + 1);\n        scanf(\"%d\", &e1.asistencias[i]);   \n    }\n    printf(\"\\n\\nDatos del alumno capturado:\\n\");\n    printf(\"Matricula: %d\\n\", e1.matricula);\n    printf(\"Nombre: %s\\n\", e1.nombre);\n    for (int i = 0; i < MAX_CALIFICACIONES; i++){\n        printf(\"Califaci\u00f3n %d: %f\\n\", i+1, e1.calificaciones[i]);\n    }\n    for (int i = 0; i < MAX_ASISTENCIA; i++){\n        printf(\"Asistencias %d: %d\\n\", i+1, e1.asistencias[i]);\n    }\n    char mensaje[] = \"hola\";\n    mensaje = \"hola mundo\";\n    strcpy(mensaje, \"hola mundo\");\n    e2 = e1;\n    e3.matricula = 456;\n    strcpy(e3.nombre, \"Juan Carlos\");\n    e3.calificaciones[0] = 10.0;\n    e3.calificaciones[1] = 10.0;\n    e3.calificaciones[2] = 10.0;\n    e3.calificaciones[3] = 10.0;\n    e3.asistencias[0] = 1;\n    e3.asistencias[4] = 1;\n    int x = 7;\n    int *p_num;\n    p_num = &x;\n    *p_num = 10;\n    printf(x);\n    int arreglo_numeros = {1, 2, 3, 4};\n    int *arreglo;\n    arreglo = &arreglo_numeros;\n    arreglo[0] = 5;\n    *(arreglo + 0) = 5;\n    struct estudiante *p_e1;\n    p_e1 = &e1;\n    p_e1->matricula = 567;\n    strcpy(p_e1->nombre, \"Jose Garcia\");\n    p_e1->calificaciones[0] = 10.0;\n    p_e1->calificaciones[1] = 10.0;\n    p_e1->calificaciones[2] = 10.0;\n    p_e1->calificaciones[3] = 10.0;\n    p_e1->asistencias[0] = 1;\n    return 0;\n}"}
{"author": "sahadipanjan6", "file": "Programs-in-C__Armstrong_Number.0.c", "original_string": "void main()\n{\n    int number = 0;\n    int count = 0;\n    int copy = 0;\n    int second_copy = 0;\n    int sum = 0;\n    printf(\"\\nEnter any number: \");\n    scanf(\"%d\", &number);\n    copy = number;\n    second_copy = copy;\n    while(copy != 0)\n    {\n        count++;\n        copy /= 10;\n    }\n    while(second_copy != 0)\n    {\n        sum += pow((second_copy%10), count);\n        second_copy /= 10;\n    }\n    if(sum == number)\n        printf(\"\\n%d is an Armstrong Number\\n\", number);\n    else\n        printf(\"\\n%d is NOT an Armstrong Number\\n\", number);\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_33.0.c", "original_string": "void compactarVetor() {\n    for (int i = 0; i < 15; i++) {\n        if (vetor[i] == 0) {\n            for (int j = i; j < 15; j++) {\n                vetor[j] = vetor[j + 1];\n            }\n        }\n    }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__position_biton_off.1.c", "original_string": "int main()\n{\n    int iNo = 0, iPos;\n    BOOL bRet = FALSE;\n    printf(\"Enter number\\n\");\n    scanf(\"%d\",&iNo);\n    printf(\"Enter the position\\n\");\n    scanf(\"%d\",&iPos);\n    bRet = CheckBit(iNo,iPos);\n    if(bRet == TRUE)\n    {\n        printf(\"Bit is on\\n\");\n    }\n    else\n    {\n        printf(\"Bits is Off\\n\");\n    }\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_windows.2.c", "original_string": "OsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,\n   void *param, size_t stackSize, int_t priority)\n{\n   void *handle;\n   handle = CreateThread(NULL, 0,\n      (LPTHREAD_START_ROUTINE) taskCode, param, 0, NULL);\n   return handle;\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b1.3.c", "original_string": "size_t encountered(bool **trees, int n, int m, int rowadd, int coladd) {\n    size_t count = 0;\n    size_t j = 0;\n    for (size_t i = 0; i < n; i += rowadd) {\n        if (trees[i][j]) count++;\n        j = (j + coladd) % m;\n    }\n    return count;\n}"}
{"author": "earth429", "file": "mulpre__simpleMultiple.1.c", "original_string": "int simpleMultiple(int a, int b, int *c) {\n    int i = 1;\n    int tmp;\n    int flag_a = 0; \n    int flag_b = 0; \n    if(a < 0){\n        a = abs(a);\n        flag_a++;\n    } else if(b < 0){\n        b = abs(b);\n        flag_b++;\n    }\n    if(a < b){\n        tmp = a;\n        a = b;\n        b = tmp;\n    }\n    *c = a;\n    while(1){\n        *c += a;\n        i++;\n        if(i == b){\n            break;\n        }\n    }\n    if(flag_a != 0 && flag_b != 0){\n    } else if(flag_a != 0){\n        *c *= -1;\n    } else if(flag_b != 0){\n        *c *= -1;\n    }\n    return 0; \n}"}
{"author": "fikepaci", "file": "monty__int_to_string.3.c", "original_string": "void fill_numbase_buff(unsigned int num, unsigned int base,\n        char *buff, int buff_size)\n{\n    int rem, i = buff_size - 1;\n    buff[buff_size] = '\\0';\n    while (i >= 0)\n    {\n        rem = num % base;\n        if (rem > 9) \n            buff[i] = rem + 87; \n        else\n            buff[i] = rem + '0';\n        num /= base;\n        i--;\n    }\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Search_In_A_Single_Linked_List.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"ENTER 1 FOR CREATION ELSE ENTER 0 FOR TERMINATION:\");\n    scanf(\"%d\",&choice);\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->link = NULL;\n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->link = newnode;\n            temp = newnode;\n        }\n        printf(\"DO YOU WANT TO ENTER MORE?(1/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_node(temp);\n    search_node(head,temp);\n    getch();\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__robo.5.c", "original_string": "void tecladoEspecial(int tecla, int x, int y)\n{\n  switch (tecla)\n  {\n  case GLUT_KEY_RIGHT:\n    printf(\"%f\\n\", thetaPerna);\n    if (thetaPerna > -6.000000)\n    {\n      thetaPerna -= 7.0;\n    }\n    break;\n  case GLUT_KEY_LEFT:\n    printf(\"%f\\n\", thetaPerna);\n    if (thetaPerna <= +84.0000)\n    {\n      thetaPerna += 7.0;\n    }\n    break;\n  case GLUT_KEY_UP:\n    printf(\"%f\\n\", thetaBraco);\n    if (thetaBraco >= -84.0000)\n    {\n      thetaBraco -= 7.0;\n    }\n    break;\n  case GLUT_KEY_DOWN:\n    printf(\"%f\\n\", thetaBraco);\n    if (thetaBraco < 22.000000)\n    {\n      thetaBraco += 7.0;\n    }\n    break;\n  default:\n    break;\n  }\n  glutPostRedisplay();\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler2.4.c", "original_string": "void DeleteFirst(PPNODE Head, PPNODE Tail)\n{\n    if((*Head == NULL) && (*Tail == NULL))\n    {\n        return;\n    }\n    if(*Head == *Tail)\n    {\n        free(*Head);\n        *Head = NULL;\n        *Tail = NULL;\n        return;\n    }\n    else\n    {\n        *Head = (*Head)->next;\n        free((*Tail)->next);\n        (*Tail)->next = *Head;\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__90.0.c", "original_string": "void insere_aluno(FILE *arq)\n{\n    aluno_t aluno;\n    int tam;\n    printf(\"\\nDigite o nome do aluno: \");\n    fgets(aluno.nome, 102, stdin);\n    tam = strlen(aluno.nome);\n    if (aluno.nome[tam - 1] == '\\n')\n    {\n        aluno.nome[tam - 1] = '\\0';\n    }\n    printf(\"Digite a nota da primeira prova: \");\n    scanf(\"%i\", aluno.prova[0]);\n    getchar();\n    printf(\"Digite a nota da segunda prova: \");\n    scanf(\"%i\", aluno.prova[1]);\n    getchar();\n    printf(\"Digite a nota da terceira prova: \");\n    scanf(\"%i\", aluno.prova[2]);\n    getchar();\n    printf(\"Digite a nota do primeiro trabalho: \");\n    scanf(\"%i\", aluno.trab[0]);\n    getchar();\n    printf(\"Digite a nota do segundo trabalho: \");\n    scanf(\"%i\", aluno.trab[1]);\n    getchar();\n    fseek(arq, 0, SEEK_END);\n    fwrite(&aluno, sizeof(aluno), 1, arq);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__2.0.c", "original_string": "int main()\n{\n    complex_t a, b, c;\n    int escolha;\n    do\n    {\n        do\n        {\n            printf(\"\\nCalculadora de n\u00fameros complexs:\\n\");\n            printf(\"\\n\\t(1) Adi\u00e7\u00e3o\\n\");\n            printf(\"\\t(2) Subtra\u00e7\u00e3o\\n\");\n            printf(\"\\t(3) Multiplica\u00e7\u00e3o\\n\");\n            printf(\"\\t(4) Divis\u00e3o\\n\");\n            printf(\"\\t(5) Sair\\n\");\n            printf(\"\\n\\tDigite sua escolha: \");\n            scanf(\"%i\", &escolha);\n            getchar();\n            system(\"clear\");\n        } while (escolha != 1 && escolha != 2 && escolha != 3 && escolha != 4 && escolha != 5);\n        switch (escolha)\n        {\n            case 1:\n                le_complexs(&a, &b);\n                c = adicao(a,b);\n                imprime_complex(&c);\n                break;\n            case 2:\n                le_complexs(&a, &b);\n                c = subtracao(a,b);\n                imprime_complex(&c);\n                break;\n            case 3:\n                le_complexs(&a, &b);\n                c = multiplicacao(a,b);\n                imprime_complex(&c);\n                break;\n            case 4:\n                le_complexs(&a, &b);\n                c = divisao(a,b);\n                imprime_complex(&c);\n                break;\n            case 5:\n                return 0;\n        }\n        printf(\"\\nPressione ENTER para continuar: \");\n        getchar();\n        system(\"clear\");\n    } while (escolha != 5);\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__dfs-a.6.c", "original_string": "void free_graph(gph* g){\n    for(int i=0; i<g->n; i++)\n        free(g->mat[i]);\n    free(g->mat);\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-1.1.c", "original_string": "char*** make3darr(int rows, int cols,int hei){\n    char ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__talker.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    int rval,sockid,itr,i;\n    char msg[100];\n    struct sockaddr_in lis;\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(1);\n    }\n    lis.sin_family=AF_INET;\n    lis.sin_port=htons(atoi(argv[2]));\n    lis.sin_addr.s_addr=inet_addr(argv[1]);\n    sockid=socket(AF_INET,SOCK_DGRAM,0);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    printf(\"\\nEnter the number of messages to be sent: \");\n    scanf(\"%d\",&itr);\n    for(i=1;i<=itr;i++)\n    {\n        strncpy(msg,\" \",100);\n        printf(\"Enter the message %d : \",i);\n        scanf(\"%s\",msg);\n        rval=sendto(sockid,msg,sizeof(msg),0,(struct sockaddr*)&lis,sizeof(lis));\n        if(rval<=0)\n        {\n            perror(\"MSG-SND-ERR:\");\n            close(sockid);\n            exit(1);\n        }\n        printf(\"\\nMessage sent successfully\\n\");\n        if(strcmp(msg,\"EXIT\")==0)\n        {\n            close(sockid);\n            exit(1);\n        }\n    }\n    close(sockid);\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.26.c", "original_string": "ASMBLK* translatepoppointer(VMTRANSLATOR* t) {\n    tpoppointer.items[tpoppointer.count-2] = mkpointerind(t);\n    tpoppointer.items[tpoppointer.count-1] = mkstr(t, \"M=D\");\n    return copytemplate(&tpoppointer);\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise19.1.c", "original_string": "int main(void){\n    setvbuf(stdout, NULL, _IONBF, 0);\n    setvbuf(stderr, NULL, _IONBF, 0);\n    int size = 5;\n    int arrayA[size];\n    int arrayB[size];\n    int i;\n    int result;\n    printf(\"Enter array A elements: \");\n    for(i=0 ; i<size ; i++){\n        scanf(\"%d\",&arrayA[i]);\n    }\n    printf(\"Enter array B elements: \");\n    for(i=0 ; i<size ; i++){\n        scanf(\"%d\",&arrayB[i]);\n    }\n    result = CheckIdentical(arrayA, arrayB ,size);\n    if(result == TRUE){\n        printf(\"Two arrays are not identical\");\n    }\n    else if(result == FALSE){\n        printf(\"Two arrays are identical\");\n    }\n    return 0;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__digit_addition.0.c", "original_string": "int SumI(int iNo)\n{\n    int iSum = 0;\n    while(iNo != 0)\n    {\n            iSum = iSum + (iNo % 10);\n        iNo = iNo / 10;\n    }\n    return iSum;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_CLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d\",temp->data);\n    printf(\"\\n\");\n}"}
{"author": "davibernardos", "file": "DB-Projetos__e11.0.c", "original_string": "int main(int argc, char *argv[]) {\n        int pontosJogador1=0, pontosComputador=0, pontosJogador2=0;\n        int jogador1, computador, jogador2;\n        int numeroPartidas=0, numeroPartidasJogador2=0, numeroPartidasComputador=0, empate=0;\n        int continuar=1, mododejogo;\n        float percJogador1=0, percJogador2=0, percComputador=0;\n        while(continuar == 1) {\n            printf (\"-------\\n\");\n            printf (\"JOKENPO\\n\");\n            printf (\"-------\\n\\n\");\n            printf (\"Quem sera o seu oponente:\\n\"\n                    \"1. Computador\\n\"\n                    \"2. Jogador\\n\");\n            scanf(\"%d\", &mododejogo);\n            printf (\"\\n\");\n            numeroPartidas++;\n            switch (mododejogo)\n            {\n            case 1: printf (\"Jogador X Computador\\n\\n\");\n                    printf (\"1. Pedra\\n\");\n                    printf (\"2. Papel\\n\");\n                    printf (\"3. Tesoura\\n\");\n                    scanf (\"%d\", &jogador1);\n                   numeroPartidasComputador++;\n                    srand(time(NULL));\n                    computador = rand() % 3; \n                    computador++;   \n                    switch (computador)\n                    {\n                        case 1: printf (\"Computador --> Pedra\\n\");break;\n                        case 2: printf (\"Computador --> Papel\\n\");break;                        \n                        case 3: printf (\"Computador --> Tesoura\\n\");break;                  \n                    }\n                if ((jogador1 == 1 && computador==3) || (jogador1 == 2 && computador == 1) || (jogador1 == 3 && computador == 2)) \n                {\n                    printf(\"Voce venceu!\\n\\n\\n\");\n                    pontosJogador1++;\n                } else if (jogador1 == computador) \n                {\n                    printf (\"Empate!\\n\\n\\n\");\n                    empate++;\n                }\n                else\n                {\n                    printf (\"Computador venceu!\\n\\n\\n\");\n                    pontosComputador++;\n                }\n                printf(\"Continuar: \\n\\n1.Sim\\n2.Nao\\n\");\n                scanf(\"%d\", &continuar);\n                system(\"cls\");\n            break;\n            case 2: printf (\"Jogador1 X Jogador2\\n\\n\");\n                    printf (\"1. Pedra\\n\");\n                    printf (\"2. Papel\\n\");\n                    printf (\"3. Tesoura\\n\");\n                    scanf (\"%d\", &jogador1);\n                    scanf (\"%d\", &jogador2);\n                    numeroPartidasJogador2++;\n                    switch (jogador1)\n                    {\n                        case 1: printf (\"Jogador1 --> Pedra\\n\");break;\n                        case 2: printf (\"Jogador1 --> Papel\\n\");break;\n                        case 3: printf (\"Jogador1 --> Tesoura\\n\");break;\n                    }\n                    switch (jogador2)\n                    {\n                        case 1: printf (\"Jogador2 --> Pedra\\n\");break;\n                        case 2: printf (\"Jogador2 --> Papel\\n\");break;\n                        case 3: printf (\"Jogador2 --> Tesoura\\n\");break;\n                    }\n                    if ((jogador1 == 1 && jogador2 == 3) || (jogador1 == 2 && jogador2 == 1) || (jogador1 == 3 && jogador2 == 2)) \n                        {\n                            printf(\"Jogador1 venceu!\\n\\n\");\n                            pontosJogador1++;\n                        } else if (jogador1 == jogador2) \n                        {\n                            printf (\"Empate!\\n\\n\");\n                            empate ++;\n                        }else\n                        {\n                            printf (\"Jogador2 venceu!\\n\\n\");\n                            pontosJogador2++;\n                        }\n                printf(\"Continuar: \\n\\n1.Sim\\n2.Nao\\n\");\n                scanf(\"%d\", &continuar);\n                system(\"cls\");\n            break;\n            }\n        }\n        percJogador1 = (pontosJogador1 * 100) / (numeroPartidas);\n        percJogador1 = percJogador1;\n        if(numeroPartidasJogador2 != 0)\n            percJogador2 = (pontosJogador2 * 100) / (numeroPartidasJogador2);\n        percComputador = (pontosComputador * 100) / (numeroPartidasComputador);\n        printf(\"Percentual Jogador1: %f\\n\", percJogador1);\n        printf(\"Percentual Computador: %f\\n\", percComputador);\n        printf(\"Percentual Jogador2: %f\\n\", percJogador2);\n        printf(\"Empate: %d\\n\", empate);\n        printf(\"Numero Partidas: %d\\n\", numeroPartidas);\n        printf(\"Pontos Jogador1: %d\\n\", pontosJogador1);\n        printf(\"Pontos Jogador2: %d\\n\", pontosJogador2);\n        printf(\"Pontos Computador: %d\\n\", pontosComputador);\n        return 0;\n    }"}
{"author": "augustogunsch", "file": "jackc__tokenizer.6.c", "original_string": "CHARTYPE getchartype(unsigned char c) {\n    if(isspace(c)) return space;\n    if(isalnum(c) || c == '_' || c == '\"') return common;\n    return charsymbol;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__menu.0.c", "original_string": "void agregar_alumno(){\n    printf(\"Ingresa la matr\u00edcula:\");\n    scanf(\"%d\", &matricula);\n    printf(\"Ingresa el inical del nombre del alumno:\");\n    scanf(\" %c\", &inicial_nombre);\n    printf(\"Ingresa calificaci\u00f3n 1:\");\n    scanf(\"%f\", &calificacion1);\n    printf(\"Ingresa calificaci\u00f3n 2:\");\n    scanf(\"%f\", &calificacion2);\n    printf(\"Ingresa calificaci\u00f3n 3:\");\n    scanf(\"%f\", &calificacion3);\n    printf(\"Ingresa calificaci\u00f3n final:\");\n    scanf(\"%f\", &calificacionf);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListAllOperations.1.c", "original_string": "struct Node *insertAtFirst(struct Node *head, int data)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     ptr->next = head;\n     ptr->data = data;\n     return ptr;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__i2c_MasterTxMode.2.c", "original_string": "void i2c_Start(void)\n{\n    I2CONCLR = (1<<3);      \n    I2CONSET = (1<<5);          \n    while(!(I2CONSET &(1<<3)));\n    I2CONCLR = (1<<5);          \n    I2CONCLR = (1<<3);          \n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__ip.1.c", "original_string": "void split(int no)\n{\n    int a,b,c,d;\n    a=no & 0xff000000;\n    b=no & 0x00ff0000;\n    c=no & 0x0000ff00;\n    d=no & 0x000000ff;\n    a = a>>24;\n    b=b>>16;\n    c=c>>8;\n    printf(\"\\nfirt number is : %d\\n\",a);\n    printf(\"second number is :%d\\n\",b);\n    printf(\"third number is :%d\\n\",c);\n    printf(\"fourt number is :%d\\n\",d);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__timer.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | LED_ALL ;  \n    T0PR = 14;\n    T0MR0 = 2000000;\n    T0MCR = (1<<0)|(1<<1);  \n    T0TCR = (1<<1);     \n    T0TCR = (1<<0);  \n    while(1)\n    {\n        if(T0IR & (1<<0))  \n        {\n            blink_led(17);\n            T0IR = (1<<0); \n        }\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-statements.6.c", "original_string": "LINEBLOCK* compilelet(SCOPE* s, STATEMENT* st) {\n    LETSTATEMENT* l = st->letstatement;\n    LINEBLOCK* blk = compileexpression(s, st->debug, l->expression);\n    if(l->arrayind != NULL) {\n        appendlnbefore(blk, onetoken(\"add\"));\n        appendlnbefore(blk, pushvar(s, st->debug, l->varname));\n        blk = mergelnblks(compileexpression(s, st->debug, l->arrayind), blk);\n        appendln(blk, poptemp());\n        appendln(blk, popthatadd());\n        appendln(blk, pushtemp());\n        appendln(blk, popthat());\n    }\n    else\n        appendln(blk, popvar(s, st->debug, l->varname));\n    return blk;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_08.0.c", "original_string": "int* read(int n)\n{\n        int i;\n        int s = sizeof(int);\n        int* arr1= (int*)malloc(s * n);\n        for(i = 0; i<n; i++)\n        {\n                fscanf(F1, \"%d\", (arr1+i));\n        }\n        return arr1;\n}"}
{"author": "tadeograch", "file": "monty__aux_functions.2.c", "original_string": "unsigned int dlistint_len(const stack_t *h)\n{\n    unsigned int n = 0;\n    if (h == NULL)\n    {\n        return (0);\n    }\n    while (h != NULL)\n    {\n        n++;\n        h = h->next;\n    }\n    return (n);\n}"}
{"author": "mehedi9021", "file": "Data_Structure__search_node.2.c", "original_string": "void search(int key)\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=NULL)\n    {\n        if(temp->data==key)\n        {\n            printf(\"Key found :)\");\n            temp=temp->next;\n            break;\n        }\n        else\n        {\n            printf(\"Key not found :(\");\n            break;\n        }\n    }\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad4.1.c", "original_string": "int unosPrvi(pozicija p)\n{\n    FILE* fp = NULL;\n    fp = fopen(\"pol1.txt\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"Neuspjesno otvaranje datoteke!\\n\");\n        return 1;\n    }\n    while (!feof(fp))\n    {\n        pozicija q = NULL;\n        q = (pozicija)malloc(sizeof(struct polinom));\n        if (q == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        pozicija pret, temp;\n        temp = p->next;\n        pret = p;\n        fscanf(fp, \"%d %d\", &q->koeficijent, &q->eksponent);\n        while (temp != NULL && temp->eksponent < q->eksponent)\n        {\n            pret = temp;\n            temp = temp->next;\n        }\n        pret->next = q;\n        if (temp != NULL)\n            q->next = temp;\n        else\n            q->next = NULL;\n    }\n    return 0;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__double_insert_at_any_position.2.c", "original_string": "void displayListFromFirst()\n{\n    struct node * temp;\n        temp = head;\n        printf(\"\\n\\nDATA IN THE LIST From First:\\n\");\n        while(temp != NULL)\n        {\n            printf(\"DATA = %d\\n\", temp->data);\n            temp = temp->next;\n        }\n    }"}
{"author": "dle2005", "file": "Algorithm__Chained_Matrix_Multiplication_v2.2.c", "original_string": "int minmult(int n, int *d, int **P) {\n    index i, j, k, diagonal;\n    for(int i = 1; i <= n; i++)\n        M[i][i] = 0;\n    for(diagonal = 1; diagonal <= n - 1; diagonal++) {\n        for(i = 1; i <= n - diagonal; i++) {\n            j = i + diagonal;\n            k = minimum(i, j, M, d);\n            M[i][j] = M[i][k] + M[k+1][j] + d[i-1] * d[k] * d[j];\n            P[i][j] = k;\n        }\n    }\n    printf(\"M = \\n\");\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= n; j++)\n            printf(\"%-4d\", M[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    return M[1][n];\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__additional_check.1.c", "original_string": "void    check_frgb(char **colors, int cc, int cw)\n{\n    if (g_cr != -1 && g_cg != -1 && g_cb != -1)\n    {\n        ft_putstr(\"Error\\ndouble includion\\n\");\n        exit(0);\n    }\n    if (cc != 3 || cw != 2)\n    {\n        ft_putstr(\"Error\\nWrong number of parametres in floor colors!\\n\");\n        exit(0);\n    }\n    else if (!array_is_rgb(colors))\n    {\n        ft_putstr(\"Error\\nWrong parametres in floor colors!\\n\");\n        exit(0);\n    }\n    else\n        get_frgb(atoi(&colors[0][0]), atoi(&colors[1][0]), atoi(&colors[2][0]));\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__21_sum_+ive_-ive.0.c", "original_string": "int main()\n{\n  int i,j,k,array[100],no=0, neg_sum = 0, pos_sum = 0;\n  printf(\"Enter How many numbers you want to Enter\");\n  scanf(\"%d\",&no);\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    if( array[i] < 0)\n    {\n      neg_sum = neg_sum - (-array[i]);\n    }\n    if( array[i] > 0)\n    {\n     pos_sum = pos_sum + (array[i]);\n    }\n  }\n  printf(\"Neg_Sum is %d Pos_Sum is %d\",neg_sum,pos_sum);\n}"}
{"author": "shengelenge", "file": "wstep-do-programowania__zad2.0.c", "original_string": "int main()\n{\n    double a, b, c;\n    printf(\"Podaj 3 liczby typu double:\\n\");\n    scanf(\"%lf\\n%lf\\n%lf\", &a, &b, &c);\n    if (a > b && a > c)\n    {\n        if (b > c)\n        {\n            printf(\"%.2lf, %.2lf, %.2lf\", c, b,a);\n        } else\n            printf(\"%.2lf, %.2lf, %.2lf\", b, c, a);\n    }\n    if (b > a && b > c)\n    {\n        if (a > c)\n        {\n            printf(\"%.2lf, %.2lf, %.2lf\", c, a, b);\n        } else\n            printf(\"%.2lf, %.2lf, %.2lf\", a, c, b);\n    }\n    if (c > a && c > b)\n    {\n        if (a > b)\n        {\n            printf(\"%.2lf, %.2lf, %.2lf\", b, a, c);\n        } else\n            printf(\"%.2lf, %.2lf, %.2lf\", a, b, c);\n    }\n    return 0;\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__strcmp.2.c", "original_string": "void choice_zero(char b[SIZE])\n{\n        char r[SIZE]=\"MCISFFF\";\n        if (strcmp(b,r)==0)\n        {printf(\"the value is matching with MCIS\\n\");}\n        else{\n        printf(\"the  string is not matching with MCIS\\n\");\n        }\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__SelectionSort.2.c", "original_string": "void putdata(int x[50], int n)\n         {\n          int k;\n          for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n           }\n          printf(\"\\n\");\n          }"}
{"author": "paawankohli", "file": "DSA-LAB__week_1.3.c", "original_string": "int secLar(int a[], int n)\n{\n    int first, second;\n    first = second = -99999;\n    for(int i = 0; i < n ; i++)\n        if(a[i] > first)\n        {\n            second = first;\n            first = a[i];\n        }\n        else if(a[i] > second && a[i] < first)\n            second = a[i];\n    return second;\n}"}
{"author": "rgautam320", "file": "Data-Structure__main13.0.c", "original_string": "int main()\n{\n    printf(\"Implementation of Kruskal's Algorithm\\n\");\n    printf(\"Enter the number of vertices: \");\n    scanf(\"%d\", &n);\n    printf(\"\\nEnter the cost adjacency matrix: \\n\");\n    for (i = 1; i <= n; i++)\n    {\n        for (j = 1; j<= n; j++)\n        {\n            scanf(\"%d\", &cost[i][j]);\n            if (i == j)\n            {\n                cost[i][j] = 0;\n            }\n            else if(cost[i][j]==0)\n            {\n                cost[i][j] = 999;\n            }\n        }\n    }\n    printf(\"The Adjacency Matrix is:\\n\");\n    for(i = 1; i <= n; i++)\n    {\n        for(j = 1; j <= n; j++)\n        {\n            printf(\"%d\\t\", cost[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"The edges of Minimum Cost Spanning Tree are: \");\n    while(m < n)\n    {\n        for(i = 1, min = 999; i <= n; i++)\n        {\n            for(j = 1; j <= n; j++)\n            {\n                if(cost[i][j] < min)\n                {\n                    min = cost[i][j];\n                    a = i;\n                    b = j;\n                }\n            }\n        }\n        if(uni(find(a), find(b)))\n        {\n            printf(\"\\n%d. edge (%d, %d) = %d\\n\", m++, a, b, min);\n            mincost += min;\n        }\n        cost[a][b] = cost[b][a] = 999;\n    }\n    printf(\"\\nMinimum Cost = %d\\n\", mincost);\n    return 0;\n}"}
{"author": "earth429", "file": "mulpre__sub.1.c", "original_string": "int sub(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    int h = 0;\n    int i;\n    int return_val;\n    int x, y; \n    struct NUMBER a_abs, b_abs; \n    clearByZero(c);\n    if(getSign(a) > 0 && getSign(b) > 0){ \n        return_val = numComp(a, b); \n        switch (return_val)\n        {\n        case 1: \n            for (i = 0; i < KETA;i++){\n                x = a->n[i] - h;\n                y = b->n[i];\n                if(x < y){\n                    c->n[i] = 10 + x - y;\n                    h = 1; \n                } else if(x >= y){\n                    c->n[i] = x - y;\n                    h = 0; \n                }\n            }\n            if(h != 0){ \n                return -1;\n            }\n            return 0; \n        case -1: \n            sub(b, a, c);\n            setSign(c, -1);\n            return 0;\n        case 0: \n            return 0;\n        }\n    } else if(getSign(a) > 0 && getSign(b) < 0){ \n        getAbs(b, &b_abs);\n        add(a, &b_abs, c);\n        return 0; \n    } else if(getSign(a) < 0 && getSign(b) > 0){ \n        getAbs(a, &a_abs);\n        add(&a_abs, b, c);\n        setSign(c, -1);\n        return 0; \n    } else if(getSign(a) < 0 && getSign(b) < 0){ \n        getAbs(b, &b_abs);\n        add(a, &b_abs, c);\n        return 0; \n    }\n    return 100; \n}"}
{"author": "deessee0", "file": "Appunti-C__SommaArray.0.c", "original_string": "void lettura(int v[], int dim)\n{\n    int i=0;\n    for(i=0;i<dim;i++)\n    {\n        scanf(\"%d\", &v[i]);\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_conditions.4.c", "original_string": "uint_t rstpForwardDelay(RstpBridgePort *port)\n{\n   uint_t value;\n   if(port->sendRstp)\n   {\n      value = rstpHelloTime(port);\n   }\n   else\n   {\n      value = rstpFwdDelay(port);\n   }\n   return value;\n}"}
{"author": "dishanp", "file": "DSA__q1.2.c", "original_string": "int** createsparsecol(int **p, int m, int n)\n{\n    int c = num + 1;\n    int **sparse = (int**)malloc(3 * sizeof(int*));\n    for(int i = 0 ; i < 3 ; i++)\n    {\n        sparse[i] = (int*)malloc(c * sizeof(int));\n    }\n    sparse[0][0] = m;\n    sparse[1][0] = n;\n    sparse[2][0] = num;\n    int k = 1;\n    for(int i = 0 ; i < m ; i++)\n    {\n        for(int j = 0 ; j < n ; j++)\n        {\n            if(p[i][j] != 0)\n            {\n                sparse[0][k] = i;\n                sparse[1][k] = j;\n                sparse[2][k] = p[i][j];\n                k++;\n            }\n        }\n    }\n    return sparse;\n}"}
{"author": "augustogunsch", "file": "jackc__vm-lines.7.c", "original_string": "LINEBLOCK* mklnblk(LINE* start) {\n    LINEBLOCK* blk = (LINEBLOCK*)malloc(sizeof(LINEBLOCK));\n    blk->head = start;\n    blk->tail = start;\n    return blk;\n}"}
{"author": "theuwis", "file": "AdventOfCode2016__main11.0.c", "original_string": "int main(void){\n    while(strlen(input) < DATA_TO_FILL){\n        int len = strlen(input);\n        input[len - 1] = '0';\n        for(int i = len, j = len; i >= 0; i--, j++){\n            if(input[i] == '0'){\n                input[j] = '1';\n            }\n            else{\n                input[j] = '0';\n            }\n        }\n    }\n    input[DATA_TO_FILL] = '\\0';\n    strcpy(checksum, input);\n    while((strlen(checksum))%2 == 0){\n        memset(dummy, 0, sizeof(dummy));\n        int len = strlen(checksum);\n        for(int i = 0, j = 0; i < len; i += 2, j++){\n            if(checksum[i] == checksum[i + 1]){\n                dummy[j] = '1';\n            }\n            else{\n                dummy[j] = '0';\n            }\n        }\n        strcpy(checksum, dummy);\n    }\n    printf(\"checksum=%s (len=%ld)\\n\", checksum, strlen(checksum));\n    return EXIT_SUCCESS;\n}"}
{"author": "rgautam320", "file": "Data-Structure__main19.3.c", "original_string": "int is_operator(char symbol)\n{\n    if(symbol == '^' || symbol == '/' || symbol == '*' || symbol == '+' || symbol == '-')\n        return 1;\n    else\n        return 0;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__29_intersection_array.0.c", "original_string": "int main()\n{\n  int a = 0, i=0,j=0,k=0,len_array1=0,len_array2=0,temp=0, total_count = 0;\n  printf(\"Enter Length of array1 and array2\");\n  scanf(\"%d%d\",&len_array1,&len_array2);\n  int array1[len_array1],array2[len_array2],array3[len_array1+len_array2];\n  int intersection_arr[100];\n  printf(\"Enter Element of Array1\\n\");\n  for(i=0; i<len_array1; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  printf(\"Enter Element of Array2\\n\");\n  for(i=0; i<len_array2; i++)\n  {\n    scanf(\"%d\",&array2[i]);\n  }\n  for(i=0;i<len_array1;i++)\n  {\n    array3[j] = array1[i];\n    j++;\n  }\n  for(i=0;i<len_array2;i++)\n  {\n    array3[j] = array2[i];\n    j++;\n  }\n  for(i=0;i<total_count;i++)\n  {\n    for(j=i+1; j<len_array1+len_array2;j++)\n    {\n      if(array3[i] > array3[j])\n      {\n        temp = array3[i];\n    array3[i] = array3[j];\n    array3[j] = temp;\n      }\n    }\n  }\n  total_count = len_array1+len_array2;\n  for(i=0; i<len_array1+len_array2; i++)\n  {\n    printf(\"%d \",array3[i]);\n  }\n  for(i=0;i<len_array1;i++)\n  {\n    for(j=0; j<len_array2;j++)\n    {\n      if(array1[i] == array2[j])\n      {\n        intersection_arr[k] = array1[i];\n    k++;\n      }\n    }\n  }\n  printf(\"\\nArray After Intersection\\n\");\n  for(i=0; i<k; i++)\n  {\n    printf(\"%d \",intersection_arr[i]);\n  }\n}"}
{"author": "dishanp", "file": "DSA__q44.1.c", "original_string": "void display(struct node *p)\n{\n    while(p)\n    {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_3.2.c", "original_string": "int main()\n{\n    printf(\"Enter a String to Check\\n\");\n    scanf(\"%s\", stack);\n    len = strlen(stack);\n    for(i = 0; i<len; i++)\n    {\n        push(stack[i]);\n    }\n    for(i = 0; i<len; i++)\n    {\n        if(stack[i]==pop())\n        {\n            count++;\n        }\n    }\n    if(count == len)\n    {\n        printf(\"Given string is Palindrome\\n\");\n    }\n    else\n    {\n        printf(\"Given string is not Palindrome\\n\");\n    }\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.7.c", "original_string": "TERM* parseunaryopterm(PARSER* p) {\n    TERM* t = mkterm(unaryopterm);\n    t->unaryop = p->current->token[0];\n    next(p);\n    t->expression = parseterm(p);\n    t->expression->next = NULL;\n    return t;\n}"}
{"author": "flora0110", "file": "hw01git__check_ans_2-10.2.c", "original_string": "int main(){\n    FILE *ans;\n    FILE *myans;\n    int control;\n    char ansname[50],myansname[50];\n    FILE *pfile;\n    char name[50];\n    for(control=1;control<=100;control++){\n        sprintf(ansname,\"test%d_ans.txt\",control);\n        sprintf(myansname,\"4108056029test%d_ans.txt\",control);\n        sprintf(name,\"test%d.txt\",control);\n        pfile = fopen(name,\"r\");\n        ans=fopen(ansname,\"r\");\n        myans=fopen(myansname,\"r\");\n        if(NULL==ans || NULL == myans){\n            printf(\"Open failure\\n\");\n            if(NULL == myans){\n                printf(\"my ans Open failure\\n\");\n            }\n            if(NULL == ans){\n                printf(\"ans Open failure\\n\");\n            }\n            return 1;\n        }\n        else{\n            int i,j,k;\n            int nans,nmy;\n            fscanf(ans,\"%*[a-zA-Z] %*[a-zA-Z]: \");\n            fscanf(ans,\"%d\",&nans);\n            printf(\"%d: %d \",control,nans );\n            fscanf(myans,\"%*[a-zA-Z] %*[a-zA-Z]: \");\n            fscanf(myans,\"%d\",&nmy);\n            printf(\"%d\\n\",nmy );\n            if(nans!=nmy){\n                printf(\"path length error in test%d\\n\",control);\n                printf(\"ans : %d   myans : %d\\n\\n\",nans,nmy );\n            }\n            fscanf(ans,\"%*s\");\n            fscanf(myans,\"%*s\");\n            char* ansb = make1darr(MAXLEN);\n            char* myb = make1darr(MAXLEN);\n            char* bottom = make1darr(MAXLEN);\n            int n=0;\n            char y;\n            fgetc(ans);\n            fgetc(myans);\n            ansb[n]=fgetc(ans);\n            myb[n]=fgetc(myans);\n            bottom[n]=fgetc(pfile);\n            while(ansb[n]!='\\n' || myb[n]!='\\n'){\n                fgetc(ans);\n                fgetc(myans);\n                fgetc(pfile);\n                ansb[++n]=fgetc(ans);\n                myb[n]=fgetc(myans);\n                bottom[n]=fgetc(pfile);\n            }\n            int len=0;\n            char ansm[n/2+1][n][n],mym[n/2+1][n][n],maze[n/2+1][n][n];\n            for(i=0;i<n/2+1;i++){\n                for(j=0;j<n;j++){\n                    for(k=0;k<n;k++){\n                        if(i==0 && j==0){\n                            ansm[i][j][k]=ansb[k];\n                            mym[i][j][k]=myb[k];\n                            maze[i][j][k]=bottom[k];\n                        }\n                        else if(j >= len && j < n-len && k >= len && k < n-len){\n                            fscanf(ans,\"%c \",&ansm[i][j][k]);\n                            fscanf(myans,\"%c \",&mym[i][j][k]);\n                            fscanf(pfile,\"%c \",&maze[i][j][k]);\n                        }\n                        else{\n                            mym[i][j][k]='X';\n                            ansm[i][j][k]='X';\n                            maze[i][j][k]='X';\n                        }\n                    }\n                }\n                len++;\n            }\n            int check=0,counter=0;\n            int hei[10],row[10],col[10];\n            char ans[10],myans[10];\n            for(i=0;i<n/2+1;i++){\n                for(j=0;j<n;j++){\n                    for(k=0;k<n;k++){\n                        if(mym[i][j][k]!=ansm[i][j][k]){\n                            row[counter]=j;\n                            col[counter]=k;\n                            hei[counter]=i;\n                            ans[counter]=ansm[i][j][k];\n                            myans[counter]=mym[i][j][k];\n                            counter++;\n                            check=1;\n                        }\n                    }\n                }\n            }\n            if(check){\n                if((((row[0]+1==row[1]  || row[0]-1==row[1]) && (col[0]+1==col[1] ||  col[0]-1==col[1])) &&(ans[0]==myans[1]&&ans[1]==myans[0])&&counter==2)){\n                }\n                else {\n                    printf(\"map error\\n\");\n                    for(i=0;i<counter;i++){\n                        printf(\"in %d %d %d\\n\",hei[i],row[i],col[i]);\n                        printf(\"ans : %c  myans : %c\\n\", ans[i],myans[i]);\n                    }\n                    printf(\"\\n----------myans & ans---------\\n\" );\n                    for(i=0;i<n/2+1;i++){\n                        for(j=0;j<n;j++){\n                            for(k=0;k<n;k++){\n                                printf(\"%c \",mym[i][j][k] );\n                            }\n                            printf(\"    \");\n                            for(k=0;k<n;k++){\n                                printf(\"%c \",ansm[i][j][k] );\n                            }\n                            printf(\"    \");\n                            for(k=0;k<n;k++){\n                                printf(\"%c \",maze[i][j][k] );\n                            }\n                            printf(\"\\n\");\n                        }\n                        printf(\"\\n\");\n                    }\n                }\n            }\n        }\n        fclose(ans);\n        fclose(myans);\n    }\n}"}
{"author": "sahadipanjan6", "file": "Programs-in-C__P3.1.c", "original_string": "int isSparse(int arr[10][10], int rows, int cols)\n{\n    int count=0;\n    int i=0;\n    int j=0;\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<cols; j++)\n        {\n            if(arr[i][j] == 0)\n                count++;\n            else\n                continue;\n        }\n    }\n    if(count > (rows*cols))\n        return 1;\n    else\n        return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.5.c", "original_string": "VAR* getvarinvars(VAR* vars, const char* name) {\n    while(vars != NULL) {\n        if(!strcmp(vars->name, name))\n            return vars;\n        vars = vars->next;\n    }\n    return NULL;\n}"}
{"author": "MFarid94", "file": "Assignment-2__Exercise16.1.c", "original_string": "int main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);                            \n    setvbuf(stderr , NULL , _IONBF , 0);\n    unsigned int number;\n    int ones_count;\n    printf(\"Enter an 8-bit number: \");\n    scanf(\"%d\",&number);                                            \n    ones_count = countOnes(number);                                 \n    printf(\"Number of 1's in given number is %d\",ones_count);\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__DemoFOTAUpdateWorkflow.3.c", "original_string": "void fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)\n{\n  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;\n  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-structure.4.c", "original_string": "LINEBLOCK* compilefunbody(SCOPE* s, CLASS* cl, SUBROUTDEC* d) {\n    SUBROUTBODY* b = d->body;\n    SCOPE* myscope = mkscope(s);\n    myscope->currclass = cl;\n    if(b->vardecs != NULL)\n        addlocalvars(myscope, b->vardecs);\n    if(b->statements == NULL) {\n        eprintf(\"Subroutine body has no statements; file '%s', line %i\\n\",\n                d->debug->file, d->debug->definedat);\n        exit(1);\n    }\n    STATEMENT* last;\n    LINEBLOCK* head = compilestatementsretlast(myscope, b->statements, &last);\n    if(last->type != returnstatement) {\n        eprintf(\"Subroutine must end with a return statement; file '%s', line %i\\n\",\n                last->debug->file, last->debug->definedat);\n        exit(1);\n    }\n    freescope(myscope);\n    return head;\n}"}
{"author": "ankitraj311", "file": "450_babbar__2_max_min_in_array_GEEk_2.1.c", "original_string": "int main()\n{\n  int arr[100] = {1000, 11, 445, 1, 330, 3000};\n  int no = 6;\n  struct pair minmax = max_min_array(arr,0,no-1);\n  printf(\"Max value is %d \\nMin value is %d\",minmax.min,minmax.max);\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_c_extended.10.c", "original_string": "uint32_t ble_lbs_led_color_send(ble_lbs_c_t * p_ble_lbs_c, uint8_t *colors)\n{\n    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c);\n    if (p_ble_lbs_c->conn_handle == BLE_CONN_HANDLE_INVALID)\n    {\n        return NRF_ERROR_INVALID_STATE;\n    }\n    if (p_ble_lbs_c->peer_lbs_db.led_color_handle == BLE_GATT_HANDLE_INVALID)\n    {\n        return NRF_ERROR_INVALID_STATE;\n    }\n    NRF_LOG_INFO(\"writing LED color %i, %i, %i\", colors[0], colors[1], colors[2]);\n    tx_message_t * p_msg;\n    p_msg              = &m_tx_buffer[m_tx_insert_index++];\n    m_tx_insert_index &= TX_BUFFER_MASK;\n    p_msg->req.write_req.gattc_params.handle   = p_ble_lbs_c->peer_lbs_db.led_color_handle;\n    p_msg->req.write_req.gattc_params.len      = 4;\n    p_msg->req.write_req.gattc_params.p_value  = p_msg->req.write_req.gattc_value;\n    p_msg->req.write_req.gattc_params.offset   = 0;\n    p_msg->req.write_req.gattc_params.write_op = BLE_GATT_OP_WRITE_CMD;\n    memcpy(p_msg->req.write_req.gattc_value, colors, 3);\n    p_msg->conn_handle                         = p_ble_lbs_c->conn_handle;\n    p_msg->type                                = WRITE_REQ;\n    tx_buffer_process();\n    return NRF_SUCCESS;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e7.0.c", "original_string": "int main(int argc, char *argv[]) \n{\n    int opcao, opcaoDeJogadaHumano, opcaoDeJogadaComputador, opcaoDeJogadaHumano1, opcaoDeJogadaHumano2;\n    int numeroDePartidas = 0, numeroDeVitoriasHumano = 0, numeroDeVitoriasComputador = 0;\n    int numeroDeVitoriasHumano1 = 0, numeroDeVitoriasHumano2 = 0, numeroDeEmpates = 0;\n    while(1)\n    {\n        system(\"cls\");\n        printf(\"Jogo Jokenpo\\n\\n\");\n        printf(\"(1) humano x computador\\n\");\n        printf(\"(2) humano x humano\\n\");\n        printf(\"(3) resultado\\n\");\n        printf(\"(4) sair\\n\\n\");\n        printf(\"Escolha uma das opcoes acima: \");\n        scanf(\"%d\", &opcao);\n        if(opcao == 1)\n        {\n            numeroDePartidas++;\n            printf(\"\\n(1) = pedra\\n\");\n            printf(\"(2) = papel\\n\");\n            printf(\"(3) = tesoura\\n\");\n            printf(\"\\nopcao de jogada humano: \");\n            scanf(\"%d\", &opcaoDeJogadaHumano);\n            opcaoDeJogadaComputador = rand()%3;\n            printf(\"opcao de jogada computador: %d\\n\\n\", opcaoDeJogadaComputador);\n            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 1)\n            {\n                printf(\"empate\\n\");\n                numeroDeEmpates++;\n            }\n            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 2)\n            {\n                printf(\"computador ganha\\n\");\n                numeroDeVitoriasComputador++;\n            }\n            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 3)\n            {\n                printf(\"humano ganha\\n\");\n                numeroDeVitoriasHumano++;\n            }\n            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 2)\n            {\n                printf(\"empate\\n\");\n                numeroDeEmpates++;\n            }\n            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 1)\n            {\n                printf(\"humano ganha\\n\");\n                numeroDeVitoriasHumano++;\n            }\n            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 3)\n            {\n                printf(\"computador ganha\\n\");\n                numeroDeVitoriasComputador++;\n            }\n            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 3)\n            {\n                printf(\"empate\\n\");\n                numeroDeEmpates++;\n            }\n            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 1)\n            {\n                printf(\"computador ganha\\n\");\n                numeroDeVitoriasComputador++;\n            }\n            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 2)\n            {\n                printf(\"humano ganha\\n\");\n                numeroDeVitoriasHumano++;\n            }\n            system(\"pause\");\n        }\n        else\n        {\n            if(opcao == 2)\n            {\n                numeroDePartidas++;\n                printf(\"\\n1 = pedra\\n\");\n                printf(\"2 = papel\\n\");\n                printf(\"3 = tesoura\\n\");\n                printf(\"\\nopcao de jogada humano 1: \");\n                scanf(\"%d\", &opcaoDeJogadaHumano1);\n                printf(\"\\nopcao de jogada humano 2: \");\n                scanf(\"%d\", &opcaoDeJogadaHumano2);\n                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 1)\n                {\n                    printf(\"\\nempate\\n\");\n                    numeroDeEmpates++;\n                }\n                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 2)\n                {\n                    printf(\"\\nhumano 2 ganha\\n\");\n                    numeroDeVitoriasHumano2++;\n                }\n                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 3)\n                {\n                    printf(\"\\nhumano 1 ganha\\n\");\n                    numeroDeVitoriasHumano1++;\n                }\n                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 2)\n                {\n                    printf(\"\\nempate\\n\");\n                    numeroDeEmpates++;\n                }\n                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 1)\n                {\n                    printf(\"\\nhumano 1 ganha\\n\");\n                    numeroDeVitoriasHumano1++;\n                }\n                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 3)\n                {\n                    printf(\"\\nhumano 2 ganha\\n\");\n                    numeroDeVitoriasHumano2++;\n                }\n                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 3)\n                {\n                    printf(\"\\nempate\\n\");\n                    numeroDeEmpates++;\n                }\n                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 1)\n                {\n                    printf(\"\\nhumano 2 ganha\\n\");\n                    numeroDeVitoriasHumano2++;\n                }\n                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 2)\n                {\n                    printf(\"\\nhumano 1 ganha\\n\");\n                    numeroDeVitoriasHumano1++;\n                }\n                system(\"pause\");\n            }\n            else\n            {\n                if(opcao == 3)\n                {\n                    printf(\"\\nNumero de partidas: %d\\n\", numeroDePartidas);\n                    printf(\"Numero de vitorias humano: %d\\n\", numeroDeVitoriasHumano);\n                    printf(\"Numero de vitorias computador: %d\\n\", numeroDeVitoriasComputador);\n                    printf(\"Numero de vitorias humano 1: %d\\n\", numeroDeVitoriasHumano1);\n                    printf(\"Numero de vitorias humano 2: %d\\n\", numeroDeVitoriasHumano2);\n                    printf(\"Numero de empates: %d\\n\\n\", numeroDeEmpates);\n                    system(\"pause\");\n                }\n                else\n                {\n                    if(opcao == 4)\n                    {\n                        exit(0);\n                    }\n                    else\n                    {\n                        printf(\"\\nopcao invalida\\n\\n\");\n                    }\n                    system(\"pause\");\n                }\n            }\n        }\n    }\n    return 0;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__search_a_node_from_list.0.c", "original_string": "int main()\n{\n    int n, key;\n    printf(\"Enter the total number of nodes: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    printf(\"\\nData in the list \\n\");\n    displayList();\n    printf(\"\\nEnter data which u wnt to srch: \");\n    scanf(\"%d\", &key);\n    search(key);\n    return 0;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__linkedlisr.0.c", "original_string": "void InsertFirst(PPNODE Head, int no)\n{\n    PNODE newn = NULL;\n    newn = (PNODE)malloc(sizeof(NODE)); \n    newn-> data = no;   \n    newn-> next = NULL; \n    if(*Head == NULL) \n    {\n        *Head = newn;\n    }\n    else  \n    {\n        newn -> next = *Head;\n        *Head = newn;\n    }\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__55_frequency_of_each_sentance.0.c", "original_string": "int main()\n{\n  int i,j,k, count = 0, frequency[26] = {0};\n  char str_arr[100], f;\n  printf(\"Enter String to find Frequency\");\n  scanf(\"%[^\\n]s\",str_arr);\n  for(i=0; str_arr[i] != '\\0'; i++)\n  {\n    if(str_arr[i] >= 'a' && str_arr[i] <= 'z')\n    {\n      frequency[str_arr[i] - 'a']++;   \n    }\n    if(str_arr[i] >= 'A' && str_arr[i] <= 'Z')\n    {\n      frequency[str_arr[i] - 'A']++;   \n    }\n  }\n  for(i=0; i<26; i++)\n  {\n    if(frequency[i] != 0)\n    {\n      printf(\"%c is Repeated %d times\\n\",i+'a',frequency[i]);\n    }\n  }\n}"}
{"author": "2security", "file": "Matrix__38CheckIdentityMatrix.1.c", "original_string": "int main()\n    {\n    int i,j,r,c,mat1[20][20],mat2[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    printf(\"\\n Enter the matrix \\n\");\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)                \n    scanf(\"%d\",&mat1[i][j]);\n    if(checkIdentity(mat1,r,c)==1)\n        printf(\"Matrix is identity matrix of order %d\",r);\n    else\n        printf(\"Matrix is not identity matrix\");\n    return 0;\n    }"}
{"author": "sdukesameer", "file": "dsa__dll-ins-seq-sor-del-a.5.c", "original_string": "void printrev(list* head)\n{\n    list* dll=head;\n    while (dll->next!=NULL)\n        dll=dll->next;\n    while(dll!=NULL)\n    {\n        printf(\"%d  \",dll->key);\n        dll=dll->prev;\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__2mult_thread_server.0.c", "original_string": "void *do_work(void *arg)\n{\n    struct clnt_info *p_cInfo = (struct clnt_info *)arg;\n    char buf[BUFSIZ];\n    char str[16];       \n    int n;\n    while(1)\n    {\n        n = Read(p_cInfo->clnt_sock, buf, sizeof(buf));\n        if(n == 0)\n        {\n            printf(\"the client %d closed...\\n\", p_cInfo->clnt_sock);\n            break;\n        }\n        printf(\"received from %s at PORT %d\\n\", inet_ntop(AF_INET, &(p_cInfo->clnt_addr.sin_addr), str, sizeof(str)), ntohs(p_cInfo->clnt_addr.sin_port));  \n        for(int i = 0; i < n; i++)\n        {\n            buf[i] = toupper(buf[i]);\n        }\n        Write(STDOUT_FILENO, buf, n);\n        Write(p_cInfo->clnt_sock, buf, n);\n    }\n    Close(p_cInfo->clnt_sock);\n    return (void*)0;        \n}"}
{"author": "254Odeke", "file": "Operating-Systems_Lab__Round_Robin_CPU_Scheduling_Simulation.0.c", "original_string": "void main(){\nint et[30],ts,n,i,x=0,tot=0; char pn[10][10];\nprintf(\"Enter the no of processes:\"); scanf(\"%d\",&n);\nprintf(\"Enter the time quantum:\"); scanf(\"%d\",&ts); for(i=0;i<n;i++)\n{\nprintf(\"enter process name & estimated time:\"); scanf(\"%s %d\",pn[i],&et[i]);\n}\nprintf(\"The processes are:\"); for(i=0;i<n;i++)\nprintf(\"process %d: %s\\n\",i+1,pn[i]); for(i=0;i<n;i++)\ntot=tot+et[i];\nwhile(x!=tot)\n{\nfor(i=0;i<n;i++)\n{\nif(et[i]>ts)\n{\nx=x+ts;\nprintf(\"\\n %s -> %d\",pn[i],ts);\net[i]=et[i]-ts;\n}\nelse if((et[i]<=ts)&&et[i]!=0)\n{\nx=x+et[i];\nprintf(\"\\n %s -> %d\",pn[i],et[i]); et[i]=0;}\n}\n}\nprintf(\"\\n Total Estimated Time:%d\",x); getch();\n}"}
{"author": "haon1026", "file": "linux-programming__fifo_w.1.c", "original_string": "int main(int argc, char *argv[])\n{\n    if(argc < 2)\n    {\n        printf(\"enter a fifo name\\n\");\n        return -1;\n    }\n    int fd = open(argv[1], O_WRONLY);\n    if(fd < 0)\n        sys_error(\"open error\");\n    int i = 0;\n    char buf[1024];\n    while(1)\n    {\n        sprintf(buf, \"hello world %d\\n\", i++);\n        write(fd, buf, strlen(buf));\n        sleep(1);\n    }\n    close(fd);\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__MVT.0.c", "original_string": "void main()\n{\n    int n,i,rem,EF=0;\n    printf(\"\\Enter the size of memory : \");\n    scanf(\"%d\",&Mem);\n    printf(\"\\nEnter the number of programs : \");\n    scanf(\"%d\",&n);\n    struct program p[n];\n    rem=Mem;\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter name : \");\n        scanf(\"%s\",p[i].name);\n        printf(\"\\nEnter size : \");\n        scanf(\"%d\",&p[i].size);\n        p[i].status=0;\n    }\n    for(i=0;i<n;i++)\n    {\n        if(p[i].size<=rem)\n        {\n            p[i].status=1;\n            rem=rem-p[i].size;\n        }\n    }\n    EF=rem;\n    printf(\"\\nprogram\\tsize\\tstatus\\n\");\n    for(i=0;i<n;i++)\n        printf(\"%s\\t%d\\t%d\\n\",p[i].name,p[i].size,p[i].status);\n    printf(\"\\nTotal External Fragmentation is : %d\",EF);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__duplicateLL.5.c", "original_string": "int main()\n{\n    printf(\"1. Insert Rear     2. Display     3. Remove Duplicates     0. Exit\\n\");\n    int ch, ele;\n    nptr head = NULL;\n    do\n    {\n        printf(\"Command: \"); scanf(\"%d\", &ch);\n        switch(ch)\n        {\n            case 1:\n                    scanf(\"%d\", &ele);\n                    insertRear(head, ele);\n                    break;\n            case 2:\n                    display(head);\n                    break;\n            case 3: \n                    removeDuplicate2(head);\n        }\n    }while(ch != 0);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_SLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "mehedi9021", "file": "C__order_and_coefficient_of_mattrix.0.c", "original_string": "int main()\n{\n    int array[10][10];\n    int i, j, m, n, sum = 0;\n    printf(\"Enter the order of the matrix\\n\");\n    scanf(\"%d %d\", &m, &n);\n    printf(\"Enter the co-efficients of the matrix\\n\");\n    for (i = 0; i < m; ++i)\n    {\n        for (j = 0; j < n; ++j)\n        {\n            scanf(\"%d\", &array[i][j]);\n        }\n    }\n    for (i = 0; i < m; ++i)\n    {\n        for (j = 0; j < n; ++j)\n        {\n            sum = sum + array[i][j] ;\n        }\n        printf(\"Sum of the %d row is = %d\\n\", i, sum);\n        sum = 0;\n    }\n    sum = 0;\n    for (j = 0; j < n; ++j)\n    {\n        for (i = 0; i < m; ++i)\n        {\n            sum = sum + array[i][j];\n        }\n        printf(\"Sum of the %d column is = %d\\n\", j, sum);\n        sum = 0;\n    }\n    return 0;\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__test.3.c", "original_string": "unsigned int crc32lql(unsigned char *string, unsigned int size) {\n    make_crc32_table();\n    unsigned int crc = 0xffffffff;\n    while(size--)\n        crc = (crc >> 8)^(crc32_table[(crc ^ *string++)&0xff]);\n    return crc;\n}"}
{"author": "haon1026", "file": "linux-programming__pipe1.1.c", "original_string": "int main()\n{\n    int fd[2];\n    int ret = pipe(fd);\n    if(ret == -1)\n        sys_error(\"pipe error\");\n    char str[] = \"hello world\\n\";\n    char buf[100];\n    int pid = fork();\n    if(pid == 0)\n    {\n        close(fd[1]);\n        int n = read(fd[0], buf, sizeof(buf));\n        if(n > 0)\n        {\n            printf(\"%s\", buf);\n        }\n        else\n        {\n            sys_error(\"read error\");\n        }\n        close(fd[0]);\n    }\n    else if (pid > 0)\n    {\n        close(fd[0]);\n        int n = write(fd[1], str, strlen(str));\n        if(n > 0)\n        {\n            printf(\"write ok, n = %d\\n\", n);\n        }\n        sleep(1);\n        close(fd[1]);\n    }\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__ext1_intr.1.c", "original_string": "void intr_config(void)\n{\n    PINSEL0 |= (1<<29);\n    PINSEL0 &= ~(1<<28);    \n    VICIntSelect &= ~(1<<15);       \n    VICVectCntl1    = (1<<5)| 15;   \n    VICVectAddr1    =   (long)eint1_isr;\n    VICIntEnable = 1<<15;\n    EXTMODE = (1<<1);       \n    EXTPOLAR    = (1<<1);       \n}"}
{"author": "ankitraj311", "file": "450_babbar__3_kth_small_SELF_MADE.1.c", "original_string": "int kmin(int arr[], int size, int k)\n{\n  int  temp = 0, count = 0, index = 0;\n  while(count <= k)\n  { \n    int min = arr[count], index = count;\n    for(int i = count; i < size; i++)\n    {\n      if(min > arr[i])\n      {\n        min = arr[i];\n    index = i;\n      }\n    }\n    if(count != index)\n    {\n      temp = arr[index];\n      arr[index] = arr[count];\n      arr[count] = temp;\n    }\n    count++;\n  }\n  return (count-1);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__1.1.c", "original_string": "void le_turma(aluno_t *turma, int n)\n{\n    for(int i = 0; i < n; i++)\n    {\n        printf(\"\\nDigite os dados do %i\u00ba aluno:\\n\", i+1);\n        printf(\"\\t-> Nome: \");\n        fgets(turma[i].nome, 82, stdin);\n        int tam = strlen(turma[i].nome);\n        if (turma[i].nome[tam - 1] == '\\n')\n        {\n            turma[i].nome[tam - 1] = '\\0';\n        }\n        printf(\"\\t-> Idade: \");\n        scanf(\"%i\", &turma[i].idade);\n        getchar();\n        printf(\"\\t-> Semestre: \");\n        scanf(\"%i\", &turma[i].semestre);\n        getchar();\n        printf(\"\\t-> Renda mensal: \");\n        scanf(\"%f\", &turma[i].renda_mensal);\n        getchar();\n    }\n    system(\"clear\");\n}"}
{"author": "sdukesameer", "file": "dsa__bst-del_int-iter_in-pre.0.c", "original_string": "node* createNode(int n)\n{\n    node* newNode=(node*)malloc(sizeof(node));\n    newNode->data=n;\n    newNode->left=NULL;\n    newNode->right=NULL;\n    return newNode;\n}"}
{"author": "2security", "file": "Array__Transpose.2.c", "original_string": "void Transpose(int **mat1,int **mat2,int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)\n        mat2[i][j]=mat1[j][i];\n    }"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__LRU.2.c", "original_string": "int isthere(int page)\n{\n    int i,flag=-1;\n    for(i=0;i<3;i++)\n    {\n        if(Queue[i]==page)\n        {\n            flag=1;\n            break;\n        }\n    }   \n    return(flag);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__BinHexConverter0.4.c", "original_string": "size_t convertBinDataToHexString8(uint8_t *inputData, size_t inputDataSize, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < inputDataSize * 2) \n  {\n    return 0;\n  }\n  outputStr[0] = '\\0';\n  size_t count = 0;\n  for ( size_t i = 0 ; i < inputDataSize; i++ )\n  {\n    count += convertBinValueToHexString8(inputData[i], outputStr + 2 * i, outputStrSize - count, upperCase);\n  }\n  if (outputStrSize > count) \n  {\n    outputStr[count++] = '\\0';\n  }\n  return count;\n}"}
{"author": "Oryx-Embedded", "file": "Common__str.2.c", "original_string": "void strRemoveTrailingSpace(char_t *s)\n{\n   char_t *end;\n   for(end = NULL; *s != '\\0'; s++)\n   {\n      if(!isspace((uint8_t) *s))\n         end = NULL;\n      else if(!end)\n         end = s;\n   }\n   if(end)\n      *end = '\\0';\n}"}
{"author": "behergue", "file": "Operating_Systems__fuseLib.1.c", "original_string": "void mode_string(mode_t mode, char *str)\n{\n    str[0] = mode & S_IRUSR ? 'r' : '-';\n    str[1] = mode & S_IWUSR ? 'w' : '-';\n    str[2] = mode & S_IXUSR ? 'x' : '-';\n    str[3] = mode & S_IRGRP ? 'r' : '-';\n    str[4] = mode & S_IWGRP ? 'w' : '-';\n    str[5] = mode & S_IXGRP ? 'x' : '-';\n    str[6] = mode & S_IROTH ? 'r' : '-';\n    str[7] = mode & S_IWOTH ? 'w' : '-';\n    str[8] = mode & S_IXOTH ? 'x' : '-';\n    str[9] = '\\0';\n}"}
{"author": "ankitraj311", "file": "Socket-thread__second_thread.0.c", "original_string": "void* thread_fun(void *vargp)\n{ \n  int myid = *(int *)vargp;\n  static int s = 0;\n  ++s;\n  ++g;\n   while(1)\n   {\n     int i = 1;\n   }\n  printf(\"Thread Id u: %d, Thread Id d: %d, Static: %d, Global: %d\\n\",myid,myid,++s,++g);\n}"}
{"author": "behergue", "file": "Computer_Structure__tipos-estru.0.c", "original_string": "int main() {\n    st.cx = 1;\n    st.cy = 2;\n    st.lat = 3;\n    st.longitud = 4;\n    status |=  LED1;\n    status &=  ~LED1;\n    status ^= (LED1 | LED2);\n    status = (tabla[7]<< 4 ) | tabla [2] | (tabla[4]<<8);\n    status  = (status & ~(0xf << 12)) | (0x7 << 12);\n    puntero = tabla;\n    puntero++;\n    puntero2 = str_tecla;\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_last_DLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_print_combn.5.c", "original_string": "void comb4(int *numeros,int a,int b,int c, int d)\n{\n  while(a<=6)\n       {\n          while(b<=7)\n               {\n                while(c<=8)\n                     {\n                      while(d<=9)\n                          {\n                            printf(\"%i%i%i%i, \",numeros[a],numeros[b],numeros[c],numeros[d]);\n                            d=d+1;\n                          }\n                      c=c+1;\n                      d=c+1;\n                     }     \n                b=b+1;\n                c=b+1;\n                d=c+1;\n               } \n          a=a+1;\n          b=a+1;\n          c=b+1;\n          d=c+1;\n       }\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__18_.2.c", "original_string": "void Filas(int contador)\n{\n        if(contador < 11){\n                Columnas(1, (10 - contador));\n                printf(\"\\n\");\n                Filas(++contador);\n        }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__queue_using_array.0.c", "original_string": "void enqueue(int x)\n{\n    if(rear==n-1)\n    {\n        printf(\"overflow\\n\");\n    }\n    else if(front==-1 && rear==-1)\n    {\n        front=rear=0;\n        printf(\"the inserted element is %d\\n\",x);\n        queue[rear]=x;\n    }\n    else\n    {\n        rear++;\n        printf(\"the inserted element is %d\\n\",x);\n        queue[rear]=x;\n    }\n}"}
{"author": "MartinMarinovich", "file": "MarinovichMartinLABIPP1G-__servicio0.2.c", "original_string": "int listarServicios(eServicio listaDeServicio[], int tamanioServicio)\n{\n    int error = -1;\n    if(listaDeServicio !=NULL && tamanioServicio>0)\n    {\n        system(\"cls\");\n        printf(\"\\n****  LISTADO DE SERVICIOS  ****\\n\");\n        printf(\" Id         Servicio        Precio\\n\");\n        printf(\"----------------------------------\\n\");\n        for(int i = 0 ; i<tamanioServicio; i++)\n        {\n            mostrarServicio(listaDeServicio[i]);\n        }\n        error = 0;\n    }\n    return error;\n}"}
{"author": "2security", "file": "Control-Statements__AnyBaseToAnyBaseConvert.0.c", "original_string": "int main()\n{   \n    char s[20];\n    int base1,base2;\n    printf(\"Enter the number and base:\");\n    scanf(\"%s%d\",s,&base1);\n    printf(\"Enter the base to be converted:\");\n    scanf(\"%d\",&base2);\n    baseconversion(s,base1,base2);\n    return 0;\n}"}
{"author": "haon1026", "file": "linux-programming__sigaction.1.c", "original_string": "void sig_catch(int signo)           \n{\n    if(signo == SIGINT)\n    {\n        printf(\"catch SIGINT!!! %d\\n\", signo);\n        sleep(10);\n    }\n    else if(signo == SIGBUS)\n        printf(\"catch SIGBUS!!! %d\\n\", signo);\n    return;\n}"}
{"author": "ankitraj311", "file": "450_babbar__8_rotate_cyclically_by_1.0.c", "original_string": "void array_print(int arr[], int no)  \n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad10.7.c", "original_string": "int CreateTree(treePointer root, stackPointer head)\n{\n    stackPointer nodeToAdd = (stackPointer)malloc(sizeof(struct stack));\n    if (!nodeToAdd)\n    {\n        printf(\"Neuspjesna alokacija memorije!\\n\");\n        return 1;\n    }\n    nodeToAdd->next = head->next;\n    head->next = nodeToAdd;\n    nodeToAdd->nextTree = root;\n    return 0;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__16_Dowhile.1.c", "original_string": "int main()\n{\n    int contador1 = 0;\n    int contador2 = 7;\n    do\n    {\n    printf(\"\\n\");\n    if(contador1 > 4)\n        Columna(contador2 - 1);\n    else\n        Columna(contador1 - 1);\n    --contador2;\n    ++contador1;\n    }while(contador1 < 8);\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__os.6.c", "original_string": "CLASS* mkscreen(CLASS* os) {\n    CLASS* scrclass = mkosclass(os, \"Screen\");\n    adddec(scrclass, function, \"void\", \"clearScreen\");\n    adddec(scrclass, function, \"void\", \"setColor\");\n    adddec(scrclass, function, \"void\", \"drawPixel\");\n    adddec(scrclass, function, \"void\", \"drawLine\");\n    adddec(scrclass, function, \"void\", \"drawRectangle\");\n    adddec(scrclass, function, \"void\", \"drawCircle\");\n    return scrclass;\n}"}
{"author": "behergue", "file": "Operating_Systems__myFS.6.c", "original_string": "void initializeSuperBlock(MyFileSystem *myFileSystem, int diskSize)\n{\n    myFileSystem->superBlock.diskSizeInBlocks = diskSize / BLOCK_SIZE_BYTES;\n    myFileSystem->superBlock.numOfFreeBlocks = myQuota(myFileSystem);\n    myFileSystem->superBlock.creationTime = time(NULL);\n    myFileSystem->superBlock.blockSize = BLOCK_SIZE_BYTES;\n    myFileSystem->superBlock.maxLenFileName = MAX_LEN_FILE_NAME;\n    myFileSystem->superBlock.maxBlocksPerFile = MAX_BLOCKS_PER_FILE;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__timer_polling.2.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad2-KopiowanieTablic.2.c", "original_string": "void copyArrayPointer(int sourceArray[], int outputArray[], int size){\n    int * pointerSource = sourceArray;\n    int * pointerOutput = outputArray;\n    for(int i = 0; i < size; i++){\n        *pointerOutput = *pointerSource;\n        pointerSource++;\n        pointerOutput++;\n    }\n}"}
{"author": "SugumaranEvil", "file": "Linux_programming__read.0.c", "original_string": "int main()\n{\n   int fd,m_sync,unmap;\n   char *addr;\n   ssize_t rd;\n   char buffer[20];\n   fd = shm_open(\"/posix\", O_RDWR , 0);\n   perror(\"shm_open\");\n   addr = mmap(NULL, 20 , PROT_READ | PROT_WRITE , MAP_SHARED, fd, 0);\n   perror(\"mmap\");\n   printf(\"%s\\n\",addr);\n   shm_unlink(\"/posix\");\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__25_While.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular sen(X) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    while(i <= veces){\n        if(i%2 == 0)\n            Suma_total += Exp(X, (i*2)+1) / Fac((i*2)+1);\n        else\n            Suma_total -= Exp(X, (i*2)+1) / Fac((i*2)+1);\n        ++i;\n    }\n    printf(\"sen(%i) es igual a %lf\", X, (Suma_total + X));\n    return 0;\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__LCS.0.c", "original_string": "void main()\n{\nint i,j,m,n;\nchar x[50];\nchar y[50];\nint c[51][51];\nchar b[51][51];\nprintf(\"Enter the first string\\n\");\nscanf(\"%s\",x);\nprintf(\"Enter the second string\\n\");\nscanf(\"%s\",y);\nm=strlen(x);\nn=strlen(y);\nfor(i=1;i<=m;i++)\n{\nc[i][0]=0;\n}\nfor(j=0;j<=n;j++)\n{\nc[0][j]=0;\n}\nfor(i=1;i<=m;i++)\n{\n    for(j=1;j<=n;j++)\n    {\n        if(x[i-1]==y[j-1])\n        {\n        c[i][j]=c[i-1][j-1]+1;\n        b[i][j]=92;\n        }\n        else if(c[i-1][j]>=c[i][j-1])\n        {\n            c[i][j]=c[i-1][j];\n            b[i][j]='^';\n        }\n        else\n        {\n            c[i][j]=c[i][j-1];\n            b[i][j]='<';   \n        }\n    }\n}\nfor(i=0;i<=m;i++)\n{\n    for(j=0;j<=n;j++)\n    {\n        printf(\"%d \",c[i][j]);\n    }\n    printf(\"\\n\");\n}\nfor(i=1;i<=m;i++)\n{\n    for(j=1;j<=n;j++)\n    {\n        printf(\"%c \",b[i][j]);\n    }\n    printf(\"\\n\");\n}\n}"}
{"author": "earth429", "file": "mulpre__divBy10.2.c", "original_string": "void dispNumber(struct NUMBER *a){\n    int i;\n    if(a->sign == 1){\n        printf(\"+\");\n    } else {\n        printf(\"-\");\n    }\n    for (i = KETA - 1; i >= 0;i--){\n        printf(\"%2d\", a->n[i]);\n    }\n}"}
{"author": "TSN-SHINGENN", "file": "libmddl__main.1.c", "original_string": "int\nmain(int ac, char **av)\n{\n    int a = 12345, b = 987654;\n    int len;\n    char C = 'C';\n    const char *txt=\"chat put acbde\";\n    size_t n;\n    char buf[128];\n    double d[] = {\n        0.0,\n        42.0,\n        1234567.89012345,\n        0.000000000000018,\n        555555.55555555555555555,\n        -888888888888888.8888888,\n        111111111111111111111111.2222222222\n    };\n    mddl_printf_init(putch);\n    for(n=0;n<100;n++) {\n        len = sprintf(buf, \"%% %d %c %d %s %d buf=%p\\n\", a, (int)n, b, txt, a, buf);\n    printf(\"sprintf=%s\",buf);\n    printf(\"len=%llu\\n\", (unsigned long long)len);\n        len = mddl_printf(\"%% %d %c %d %s %d buf=%p\\n\", a, (int)n, b, txt, a, buf);\n    mddl_printf(\"len=%llu\\n\", (unsigned long long)len);\n    len = sprintf(buf, \"%f %f %f\\n\", d[0], d[1], d[2]);\n    printf(\"float sprintf=%s\",buf);\n    printf(\"len=%d\\n\", len);\n        len = mddl_printf(\"%f %f %f\\n\", d[0], d[1], d[2]);\n    printf(\"len=%d\\n\", len);\n    }\n    return 0;\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__tmep.1.c", "original_string": "unsigned int datagram_construction(unsigned char datagram[65535],unsigned char Version,\n                            unsigned char Differentialted_Services,unsigned short Identification,\n                            unsigned short DF, unsigned short MF,\n                            unsigned short Fragment_offset, unsigned char TTL, \n                            unsigned char Protocol,\n                            unsigned char *Source_address, unsigned char *Destination_address,\n                            unsigned char *Option,unsigned int Option_len,\n                            unsigned *payload,unsigned short payload_len){\n    if (payload_len > 65515){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    unsigned char IHL = 5 + Option_len; \n    printf(\"IHL%d\\n\",IHL);\n    unsigned char temp = 0x00;\n    Version = Version << 4;  \n    temp = temp | IHL; \n    temp = temp | Version; \n    memcpy(&datagram[0],&temp,1);\n    memcpy(&datagram[1],&Differentialted_Services,1);\n    unsigned short Total_length = payload_len + IHL*4; \n    memcpy(&datagram[2],&Total_length,2);\n    memcpy(&datagram[4],&Identification,2);\n    unsigned short temp2;\n    short df = DF;\n    df = df << 14;\n    df = df & 0x4000;  \n    short mf = MF;\n    mf = mf << 13;\n    mf = mf & 0x2000; \n    Fragment_offset = Fragment_offset & 0x1FFF; \n    temp2 = df | mf | Fragment_offset;\n    memcpy(&datagram[6],&temp2,2);\n    memcpy(&datagram[8],&TTL,1);\n    memcpy(&datagram[9],&Protocol,1);\n    memcpy(&datagram[12],Source_address,4);\n    memcpy(&datagram[16],Destination_address,4);\n    memcpy(&datagram[20],Option,Option_len*4);\n    unsigned char Header[IHL * 4 - 2]; \n    memcpy(&Header[0],&datagram[0],10);\n    memcpy(&Header[10],&datagram[12],8 + Option_len * 4);\n    unsigned short Header_checksum = CRC16(Header,IHL * 4 - 2);\n    memcpy(&datagram[10],&Header_checksum,2); \n    unsigned char crc16_result[2];\n    memcpy(crc16_result, &Header_checksum, sizeof(Header_checksum));\n    memcpy(&datagram[20 + Option_len*4],payload,payload_len);\n    printf(\"******Send datagrame information******\\n\");\n    printf(\"Source address: \");\n    output_octal(Source_address,4);\n    printf(\"Destinamtion address  : \");\n    output_octal(Destination_address,4);\n    printf(\"payload      : %s\\n\",payload);\n    printf(\"CRC16        : \");\n    output_octal(crc16_result, 2);    \n    printf(\"payload length  : %d\\n\", payload_len);\n    printf(\"Header length   : %d(row*4bytes)\\n\", IHL);\n    printf(\"datagram length : %d\\n\", Total_length);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] datagram send success!\\n\");\n    return Total_length;\n}"}
{"author": "jdes01", "file": "practicassoo__practica2ej2.1.c", "original_string": "int main(int argc, char const * argv[] ){\n    int totalLineas = 0;\n    int * retorno;\n    pthread_t hilos[argc-1];\n    for (int i = 0; i < argc-1; i++){\n        if ( pthread_create( &(hilos[i]), NULL, (void *) cuentaLineas, (void *) argv[i+1] ) != 0){\n            fprintf(stderr, \"Error en la creacion de la hebra \\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n    for (int i = 0; i < argc-1; i++){\n        if ( pthread_join( hilos[i], (void **) &retorno ) != 0){\n            fprintf(stderr, \"Error al hacer join \\n\");\n            exit(EXIT_FAILURE);\n        }\n        printf(\"El numero de lineas del fichero %i es %d \\n\", i + 1, *retorno);\n        totalLineas = totalLineas + *retorno;\n    }\n    printf(\"El numero de lineas totales son %i \\n\", totalLineas);\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__spi.0.c", "original_string": "int main()\n{\n    PINSEL0 |= (1<<8)|(1<<10)|(1<<12);  \n    PINSEL0 &= ~((1<<9)|(1<<11)|(1<<13));\n    IODIR0 |= (1<<7);       \n    S0SPCR = (1<<2)|(1<<3)|(1<<4)|(1<<5);       \n    S0SPCCR = 8;        \n    spi_data(0x0C01);               \n    spi_data(0x090F);               \n    spi_data(0x0AFF);               \n    spi_data(0x0B03);               \n    spi_data(0x010C);               \n    spi_data(0x020B);       \n    spi_data(0x030D);       \n    spi_data(0x040E);       \n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.13.c", "original_string": "void imprimir_alumnos_en_tabla(){\n    system(\"clear\");\n    printf(\"----------------------------------------------\\n\");\n    printf(\"Matricula\\tNombre\\t 1er\\t2o\\t3er\\t Ord\\n\");\n    printf(\"----------------------------------------------\\n\");\n    for (int i = 0; i < siguiente_alumno; i++){\n        imprimir_alumno_por_fila(i);\n    }\n    puts(\"Presione una tecla para continuar...\");\n    fflush(stdin);\n    getchar();\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__test1.5.c", "original_string": "unsigned int crc32cyy(unsigned char *data,int len) {\n    unsigned int crc = 0xFFFFFFFF;\n    int i;\n    for (i=0;i<len;i++) {\n        crc = crc ^ data[i];\n        int j;\n        for (j=7;j>=0;j--) {\n            crc = (crc >> 1) ^ (0xEDB88320 & (-(crc & 1)));\n        }\n    }\n    return ~crc;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q2.9.c", "original_string": "void postorder(node *t)\n{\n    STACK s;\n    node*curr;\n    curr = t;\n    s.tos = -1;\n    do\n    {\n        while (curr != NULL)\n        {\n            if (curr->right != NULL)\n                push(&s, curr->right);\n            push(&s, curr);\n            curr = curr->left;\n        }\n        curr = pop(&s);\n        if (curr->right != NULL && s.s[s.tos] == curr->right)\n        {\n            pop(&s);\n            push(&s, curr);\n            curr = curr->right;\n        }\n        else\n        {\n            printf(\"%d\\t\", curr->data);\n            curr = NULL;\n        }\n    }while (s.tos != -1);\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Delete_At_The_Beginning_Of_A_Single_Linked_List.1.c", "original_string": "void display_node(struct node*temp1)\n{\n    printf(\"The Elements are:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}"}
{"author": "earth429", "file": "mulpre__divide.1.c", "original_string": "int divide(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c, struct NUMBER *d) {\n    struct NUMBER m, n, p, q;\n    clearByZero(c);\n    clearByZero(d);\n    if(isZero(b) != -1){ \n        return -1;\n    }\n    copyNumber(a, &n);\n    while(1){\n        if(numComp(&n, b) != -1){ \n            increment(c, &m);\n            copyNumber(&m, c);\n            sub(&n, b, &m);\n            copyNumber(&m, &n);\n        } else { \n            copyNumber(&n, d);\n            break;\n        }\n    }\n    return 0;\n}"}
{"author": "Theemiss", "file": "simple_shell__memory_mangment.2.c", "original_string": "char *_memcpy(char *dest, char *src, unsigned int n)\n{\n    unsigned int i;\n    for (i = 0; i < n; i++)\n    {\n        dest[i] = src[i];\n    }\n    return (dest);\n}"}
{"author": "dishanp", "file": "DSA__q3.2.c", "original_string": "int main()\n{\n    int n, m;\n    printf(\"Enter number of terms for P1: \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter coefficients according to increasing order of exponents : \");\n    for(int i = 0 ; i < n ; i++)\n        scanf(\"%d\", &A[i]);\n    printf(\"\\nFirst polynomial : \");\n    printPoly(A, n);\n    printf(\"\\nEnter number of terms for P2: \");\n    scanf(\"%d\", &m);\n    int B[m];\n    printf(\"Enter coefficients according to increasing order of exponents : \");\n    for(int i = 0 ; i < m ; i++)\n        scanf(\"%d\", &B[i]);\n    printf(\"\\nSecond polynomial : \");\n    printPoly(B, m);\n    printf(\"\\nSum of P1 and P2 : \");\n    int *sum = add(A, B, n, m);\n}"}
{"author": "2security", "file": "Pointer__10AddTwoMatrix.2.c", "original_string": "int main()\n    {\n        int i,j,m,n;\n        int **mat1,**mat2,**mat3;\n        printf(\"Enter the row & col. of the first matrix \");\n        scanf(\"%d%d\",&r,&c);\n        printf(\"Enter the row & col. of the second matrix \");\n        scanf(\"%d%d\",&m,&n);\n        if((r==m)&&(c==n))\n            {\n                mat1=(int **)malloc(r*sizeof(int *));       \n                mat2=(int **)malloc(r*sizeof(int *));\n                mat3=(int **)malloc(r*sizeof(int *));       \n                for(i=0;i<r;i++)\n                mat1[i]=(int *)malloc(c*sizeof(int));   \n                for(j=0;j<r;j++)\n                mat2[j]=(int *)malloc(c*sizeof(int));\n                for(j=0;j<r;j++)\n                mat3[j]=(int *)malloc(c*sizeof(int));\n                printf(\"\\n Enter the first matrix \");\n                for(i=0;i<r;i++)\n                    {\n                    for(j=0;j<c;j++)\n                    scanf(\"%d\",&mat1[i][j]);\n                    }\n                printf(\"\\n Enter the second matrix\");\n                for(i=0;i<r;i++)\n                    {\n                    for(j=0;j<c;j++)\n                    scanf(\"%d\",&mat2[i][j]);\n                    }\n                Sum(mat1,mat2,mat3);\n                printf(\"\\n The Resultant matrix is \\n\");\n                Display(mat3);\n                free(mat1);\n                free(mat2);\n                free(mat3);\n                }\n        else\n        printf(\"Please enter same row & col of the two matrix ...\");\n    return 0;\n    }"}
{"author": "behergue", "file": "Operating_Systems__my_system.1.c", "original_string": "int system(const char * command){\n    int ret = -1;\n    int pid = fork();\n    if(pid == -1)\n        fprintf(stderr, \"Fallo fork\\n\");\n    else if(pid == 0)\n        execlp(\"/bin/bash\", \"bash\", \"-c\", command, (char*) NULL);\n    else{\n        wait(&ret);\n        ret = WEXITSTATUS(ret);\n    }\n}"}
{"author": "dle2005", "file": "File_Structure__heapsort.6.c", "original_string": "void unpack(const char *recordbuf, Person *p) {\n    sscanf(recordbuf, \"%[^'#']#%[^'#']#%[^'#']#%[^'#']#%[^'#']#%[^'#']#\",\n    p -> sn, p -> name, p -> age, p -> addr, p -> phone, p -> email);\n}"}
{"author": "ria3999", "file": "cbnst__REGULA-FALSI_METHOD.1.c", "original_string": "void main()\n{\n    float a,b,fa,fb,c,fc;\n    printf(\"\\n\\n***INPUT***\\n\\n\");\n    do\n    {\n        printf(\"Enter intervals a and b\");\n        scanf(\"%f%f\",&a,&b);\n        fa=function(a);\n        fb=function(b);\n    }while(fa*fb>0);\n    int i=-1;\n    float d=-1;\n    do\n    {\n        i++;\n        if(i!=0)\n        d=c;\n        fa=function(a);\n        fb=function(b);\n        c=a-((b-a)/(function(b)-function(a)))*function(a);\n        fc=function(c);\n        if(fa*fc>0)\n            a=c;\n        else\n            b=c;\n    }while(d!=c);\n    printf(\"\\n\\n***OUTPUT***\\n\\n\");\n    printf(\"The required root is %f \\n\",c);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedInsertion.5.c", "original_string": "int main(){\n     struct Node*head;\n     struct Node*second;\n     struct Node*third;\n     struct Node*fourth;\n     head = (struct Node *) malloc(sizeof(struct Node));\n     second = (struct Node *) malloc(sizeof(struct Node));\n     third = (struct Node *) malloc(sizeof(struct Node));\n     fourth = (struct Node *) malloc(sizeof(struct Node));\n     head->data=7;\n     head->next=second;\n     second->data=11;\n     second->next=third;\n     third->data=70;\n     third->next=fourth;\n     fourth->data=22;\n     fourth->next=NULL;\n     printf(\"\\nLinked list before insertion\\n\");\n     linkedListTraversal(head);\n     head= insertAfterNode(head, second, 45);\n     printf(\"\\nLinked list after insertion\\n\");\n     linkedListTraversal(head);\n     return 0;\n}"}
{"author": "theuwis", "file": "AdventOfCode2015__main26.0.c", "original_string": "int main(void){\n    int input[NR_ELEMENTS] = {50, 44, 11, 49, 42, 46, 18, 32, 26, 40, 21, 7, 18, 43, 10, 47, 36, 24, 22, 40};\n    int multiplier[NR_ELEMENTS] = {0};\n    int nr_jars_needed[10] = {0};\n    int result = 0, nr_jars = 0;\n    for(int i = 0; i < pow(2, NR_ELEMENTS); i++){\n        for(int j = 0; j < NR_ELEMENTS; j++){\n            multiplier[NR_ELEMENTS - 1 - j] = (i >> (NR_ELEMENTS - 1 -j)) & 1;\n        }\n        for(int k = 0; k < NR_ELEMENTS; k++){\n            result += input[k] * multiplier[k];\n            if(multiplier[k] == 1){\n                nr_jars++;\n            }\n        }\n        if(result == LITERS_TO_STORE){\n            nr_jars_needed[nr_jars]++;\n        }\n        result = 0;\n        nr_jars = 0;\n    }\n    for(int i = 0; i < 10; i++){\n        if(nr_jars_needed[i] > 0){\n            printf(\"answer=%d\\n\", nr_jars_needed[i]);\n            break;\n        }\n    }\n    return EXIT_SUCCESS;\n}"}
{"author": "zjzj-zz", "file": "1s_programing__sankaku.0.c", "original_string": "int main(){\n double a, b, c, d, e, f;\n double z[3], k, o, p, q;\n int i, j;\n printf(\"3\u70b9\u306e\u5ea7\u6a19\u3092\u5165\u529b\u3057\u3066\u4e0b\u3055\u3044\\n\");\n printf(\"1\u3064\u3081\u306e\u5ea7\u6a19:\");\n scanf(\"%lf%lf\", &a, &b);\n printf(\"2\u3064\u3081\u306e\u5ea7\u6a19:\");\n scanf(\"%lf%lf\", &c, &d);\n printf(\"3\u3064\u3081\u306e\u5ea7\u6a19:\");\n scanf(\"%lf%lf\", &e, &f);\n z[0]=dist(a, b, c, d);\n z[1]=dist(c, d, e, f);\n z[2]=dist(e, f, a, b);\n for(i=0; i<3; i++){\n  for(j=0; j<3; j++){\n   if(z[i]<z[j]){\n    k=z[i];\n    z[i]=z[j];\n    z[j]=k;\n   }\n  }\n }\n if(z[0]+z[1]>z[2] && z[1]+z[2]>z[0] && z[2]+z[0]>z[1]){\n  printf(\"3\u3064\u306e\u8fba\u306e\u9577\u3055\u306f\\n\");\n  o=z[0];\n  p=z[1];\n  q=z[2];\n  printf(\"a=%.2f\\nb=%.2f\\nc=%.2f\\n\", o, p, q);\n  printf(\"\u3053\u306e3\u8fba\u3067\u7d50\u3070\u308c\u305f\u56f3\u5f62\u306f\");\n  if(o == p && o == q/sqrt(2)){\n   printf(\"\u76f4\u89d2\u4e09\u89d2\u5f62\u3067\u3059\\n\"); \n   return 0; \n  }else if(sqrt(o*o+p*p) == q){\n   printf(\"\u76f4\u89d2\u4e09\u89d2\u5f62\u3067\u3059\\n\"); \n   return 0; \n  }\n   o*=o;\n   p*=p;\n   q*=q;\n  if(q==o+p){\n   printf(\"\u76f4\u89d2\u4e09\u89d2\u5f62\u3067\u3059\\n\");\n  }else if(q < o+p){\n   printf(\"\u92ed\u89d2\u4e09\u89d2\u5f62\u3067\u3059\\n\");\n  }else if(q > o+p){\n   printf(\"\u920d\u89d2\u4e09\u89d2\u5f62\u3067\u3059\\n\");\n  }\n }\n else{\n  printf(\"\u4e09\u89d2\u5f62\u3067\u306f\u306a\u3044\\n\");\n }\n return 0;\n}"}
{"author": "dishanp", "file": "DSA__q45.0.c", "original_string": "void create(int A[], int n)\n{\n    struct node *t, *last;\n    first = (struct node*)malloc(sizeof(struct node));\n    first->data = A[0];\n    first->next = NULL;\n    last = first;\n    for(int i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q14.2.c", "original_string": "void display(queue *q)\n{\n    printf(\"Cuurent queue: \\n\");\n    int i;\n    for (i=q->front;i<q->rear;i++)\n        printf(\"%d\\t\",q->c[i]);\n    printf(\"\\n\");\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_any_pos_SLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "mehedi9021", "file": "Data_Structure__tree.1.c", "original_string": "struct node * constructTree( int index ) {\n    struct node *temp = NULL;\n    if (index != -1) {\n        temp = (struct node *)malloc( sizeof ( struct node ) );\n        temp->left = constructTree( leftcount[index] );\n        temp->data = array[index];\n        temp->right = constructTree( rightcount[index] );\n    }\n    return temp;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__tree.2.c", "original_string": "void inorder( struct node *root ) {\n    if (root != NULL) {\n        inorder(root->left);\n        printf(\"%c\\t\", root->data);\n        inorder(root->right);\n    }\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_30.1.c", "original_string": "int verificarValorRepetido(int vet1[10], int valorComparar) {\n    for (int i = 0; i < 10; i++) {\n        if (vet1[i] == valorComparar) {\n            return valorComparar;\n        }\n    }\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.20.c", "original_string": "void addfield(SCOPE* s, CLASSVARDEC* v, int* i) {\n    STRINGLIST* currname = v->base->names;\n    while(currname != NULL) {\n        addvar(s, &(s->fields), mkvar(v->base->type, currname->content, v->base->primitive, v->base->debug, fieldseg, *i));\n        currname = currname->next;\n        (*i)++;\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_DLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Search_In_A_Single_Linked_List.1.c", "original_string": "void display_node(struct node*temp1)\n{\n    printf(\"THE ELEMENTS ARE:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->link;\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__fcntl.0.c", "original_string": "int main()\n{\n    int flags = fcntl(STDIN_FILENO, F_GETFL);   \n    if(flags == -1)\n    {\n        perror(\"fcntl error\");\n        exit(1);\n    }\n    flags |= O_NONBLOCK;\n    int ret = fcntl(STDIN_FILENO, F_SETFL, flags);\n    if(ret == -1)\n    {\n        perror(\"fcntl error\");\n        exit(1);\n    }\n    char buf[10];\n    int n;\n    while(1)\n    {\n        n = read(STDIN_FILENO, buf, 10);\n        if(n < 0)\n        {\n            if(errno != EAGAIN)\n            {\n                perror(\"read /dev/tty\");\n                exit(1);\n            }\n            else\n            {\n                write(STDOUT_FILENO, MSG_TRY, strlen(MSG_TRY));\n                sleep(2);\n                continue;\n            }\n        }\n        break;\n    }\n    write(STDOUT_FILENO, buf, n);\n    return 0;\n}"}
{"author": "2security", "file": "Array__Symmetric.2.c", "original_string": "int ** Transpose(int **mat1,int **mat2,int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)\n        mat2[i][j]=mat1[j][i];\n    return mat2;\n    }"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad2-Strcmp.1.c", "original_string": "void getNChars(int numOfChars) {\n    char stringArray[numOfChars];\n    fflush(stdin);\n    printf(\"Podaj znaki.\\n\");\n    for(int i = 0; i < numOfChars; i++) {\n        stringArray[i] = getchar();\n        if (strcmp(&stringArray[i], \" \") == 0 || strcmp(&stringArray[i], \"\\t\") == 0 || strcmp(&stringArray[i], \"\\n\") == 0) {\n            printf(\"\\nNapotkano spacje, tabulator lub znak nowej linii!\\n\");\n            break;\n        }\n    }\n    printf(\"\\nPodane znaki to: \");\n    puts(stringArray);\n}"}
{"author": "theuwis", "file": "AdventOfCode2016__main10.0.c", "original_string": "int main(){\n   for(int i = 0; i < NR_DISCS; i++){\n      for(int j = 0; j < i + 1; j++){\n         if(input[i][0] - 1 > input[i][2]){\n            input[i][2]++;\n         }\n         else{\n            input[i][2] = 0;\n         }\n      }\n   }\n   while(1){\n      for(int i = 0; i < NR_DISCS; i++){\n         if(input[i][0] - 1 > input[i][2]){\n            input[i][2]++;\n            not_zero = true;\n         }\n         else{\n            input[i][2] = 0;\n         }\n      }\n      if(!not_zero){\n         printf(\"answer=%d\\n\", time);\n         break;\n      }\n      else{\n         not_zero = false;\n      }\n      time++;\n   }\n   return EXIT_SUCCESS;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__stack.5.c", "original_string": "int main()\n{\n    PNODE First = NULL;\n    int choice = 1, no = 0;\n    printf(\"Dynamic implementation of stack\\n\");\n    while(choice != 0)\n    {\n        printf(\"\\n 1: Push the element\");\n        printf(\"\\n 2: Pop the elemet\");\n        printf(\"\\n 3: Display the elemets of stack\");\n        printf(\"\\n 4: Count the number of elements of stack\");\n        printf(\"\\n 5: Peep the element\");\n        printf(\"\\n 0: Exit the application\\n\");\n        printf(\"Please enter your choice : \\n\");\n        scanf(\"%d\",&choice);\n        switch (choice)\n        {\n            case 1:\n                printf(\"Enter the element that you want to insert\\n\");\n                scanf(\"%d\",&no);\n                Push(&First, no);\n                break;\n            case 2 :\n                no = Pop(&First);\n                printf(\"Poped element is : %d\\n\",no);\n                break;\n            case 3 :\n                Display(First);\n                break;\n            case 4:\n                printf(\"Number of elements are : %d\\n\",Count(First));\n                break;\n            case 5:\n                printf(\"Peeped element is : %d\\n\",Peep(First));\n                break;\n            case 0:\n                printf(\"Thank you for using the application\\n\");\n                break;\n            default:\n                printf(\"Wrong choice\\n\");\n        } \n    }\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_DLL.9.c", "original_string": "void delete_at_pos()\n{\n    struct node *temp;\n    int pos;\n    int i=1;\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    temp=head;\n    while(i<pos)\n    {\n        temp=temp->next;\n        i++;\n    }\n    if(temp->next==0)\n    {\n        temp->pre->next=0;\n        free(temp);\n    }\n    else\n    {\n        temp->next->pre=temp->pre;\n        temp->pre->next=temp->next;\n        free(temp);\n    }\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad8-NumeralSystems.1.c", "original_string": "void do_binar(int n, int sys){\n    int r;\n    if(sys < 2 || sys > 10){\n        printf(\"Podano system liczbowy spoza zakresu!!!\");\n        return;\n    }\n    r = n % sys;\n    if(n >= sys)\n        do_binar(n / sys, sys);\n    putchar('0' + r);\n    return;\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example51.1.c", "original_string": "int asalKontrol (int x,int y)  \n{                                           \n    if(y==1)\n        return 1;\n    else\n    {\n        if(x%y==0)  \n            return 0;\n        else\n            asalKontrol(x,y-1);    \n    }    \n}"}
{"author": "mehedi9021", "file": "Data_Structure__double_list_create.1.c", "original_string": "void createList(int n)\n{\n    int i, data;\n    struct node *newNode;\n            head = (struct node *)malloc(sizeof(struct node));\n            printf(\"Enter data of 1 node: \");\n            scanf(\"%d\", &data);\n            head->data = data;\n            head->prev = NULL;\n            head->next = NULL;\n            last = head;\n            for(i=2; i<=n; i++)\n            {\n                newNode = (struct node *)malloc(sizeof(struct node));\n                    printf(\"Enter data of %d node: \", i);\n                    scanf(\"%d\", &data);\n                    newNode->data = data;\n                    newNode->prev = last;\n                    newNode->next = NULL;\n                    last->next = newNode;\n                    last = newNode;\n            }\n        printf(\"\\nDOUBLY LINKED LIST CREATED SUCCESSFULLY\\n\");\n    }"}
{"author": "kbtomic", "file": "StrukturePodataka__zad4.5.c", "original_string": "int umnozak(pozicija p, pozicija q, pozicija r)\n{\n    pozicija prvi = p->next;\n    pozicija drugi = q->next;\n    struct polinom P;\n    pozicija s = NULL;\n    s = (pozicija)malloc(sizeof(struct polinom));\n    if (s == NULL)\n    {\n        printf(\"Neuspjesna alokacija memorije!\\n\");\n        return 1;\n    }\n    s->next = NULL;\n    P.next = s;\n    while (prvi != NULL)\n    {\n        drugi = q->next;\n        while (drugi != NULL)\n        {\n            s->koeficijent = prvi->koeficijent * drugi->koeficijent;\n            s->eksponent = prvi->eksponent + drugi->eksponent;\n            zbroj(&P, r, r);\n            drugi = drugi->next;\n        }\n        prvi = prvi->next;\n    }\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q2.2.c", "original_string": "void InsertQ(queue *q, node* n)\n{\n    if (q->rear == MAX)\n        printf(\"Side Full\\n\");\n    else\n        q->c[(q->rear)++]=n;\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad4-StructInStruct.0.c", "original_string": "int main()\n{\n    PERSONINFO persons[] = {\n        \"23232323232\", \"Adam\", \"Rick\", \"Melix\",\n        \"11111111111\", \"Morty\", \"Eric\", \"Willis\",\n        \"88833388822\", \"Tom\", \"George\", \"Brady\"\n    };\n    int counter = 0;\n    int size = sizeof(persons)/sizeof(*persons);\n    while(counter < size){\n        printf(\"%7s, %7s %7s -- %s\\n\", persons[counter].lastName, persons[counter].firstName, persons[counter].middleName, persons[counter].pesel);\n        counter++;\n    }\n    getchar();\n    return 0;\n}"}
{"author": "sdukesameer", "file": "c__selection_sort.3.c", "original_string": "int main(){\n    int len;\n    scanf(\"%d\", &len);   \n    int arr[len];\n    if (len<=0){   \n            printf(\"ERROR: Empty list\\n\");\n            exit(1);\n    }\n    inputArray( arr, len );   \n    selectionSort(arr, len);   \n    printf(\"Sorted: \");\n        printArray(arr,len);   \n    return 0;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__print_memory.0.c", "original_string": "void    print_hex(unsigned char c)\n{\n    char    *radix;\n    radix = \"0123456789abcdef\";\n    write(1, &radix[c / 16], 1);\n    write(1, &radix[c % 16], 1);\n}"}
{"author": "sdukesameer", "file": "dsa__bfs.6.c", "original_string": "int main(){\n    graph g;\n    int f=1,s;\n    input(&g);\n    printf(\"\\n\\' If\");\n    for(int i=0; i<g.n;i++)\n        printf(\" %c=%d\",'A'+i,i+1);\n    printf(\" \\'\\nEnter the initial vertex: \");\n    while(f){\n        scanf(\"%d\",&s);\n        if(s>0 && s<g.n+1)\n            f=0;\n        else\n            printf(\"Invalid input. Try again.\\n\");\n    }\n    bfs(g,s-1);\n    free_graph(&g);\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__ucgen11.0.c", "original_string": "int main ()\n{\n    int i,j;\n    int yildiz;\n    printf(\"l\u00fctfen boyut giriniz\");\n    scanf(\"%d\",&yildiz);\n    if(yildiz<0)\n    {   \n      printf(\"hatal\u0131 giri\u015f yapt\u0131n\u0131z\");\n      return (1);\n    }\n    for(i=0;i<yildiz;i++)\n    {\n      for(j=0;j<=i;j++)\n       printf(\"*\");\n      printf(\"\\n\");\n    }\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__FIFO.2.c", "original_string": "void main()\n{\n    for(i=0;i<3;i++)\n        Queue[i]=-1;    \n    printf(\"\\nEnter the number of pages : \");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter the page : \");\n        scanf(\"%d\",&page);\n        if(isthere(page)==-1)\n        {\n            enqueue(page);\n            PFR=PFR+1;\n        }\n        printf(\"\\nStatus : \");\n        for(j=0;j<3;j++)\n            printf(\"%d\\t\",Queue[j]);\n    }\n    printf(\"\\nPage Fault Rate is : %d\",PFR);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__strcap.0.c", "original_string": "int StrlenCap(char str[])\n{\n    int iCnt = 0, i = 0;\n    if(str == NULL)\n    {\n        return -1;\n    }\n    while(str[i] != '\\0')\n    {\n        if((str[i] >= 'A') && (str[i] <= 'Z'))\n        {\n            iCnt++;\n        }\n        i++;\n    }\n    return iCnt;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q3_merge.4.c", "original_string": "int main(){\n    nodeptr a,b,u,in;\n    int n,m,i,t;\n    init(&a);\n    init(&b);\n    printf(\"\\nEnter number elements of first list\");\n    scanf(\"%d\",&n);\n    printf(\"\\nEnter elements\");\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&t);\n        add(a,t);\n    }\n    printf(\"\\nEnter number elements of second list\");\n    scanf(\"%d\",&m);\n    printf(\"\\nEnter elements\");\n    for(i=0;i<m;i++){\n        scanf(\"%d\",&t);\n        add(b,t);\n    }\n    display(a);\n    display(b);\n    merge(a,b);\n    display(a);\n}"}
{"author": "behergue", "file": "Operating_Systems__myFS.14.c", "original_string": "int updateNode(MyFileSystem *myFileSystem, int numNode, NodeStruct *node)\n{\n    int posNodoI;\n    assert(numNode < MAX_NODES);\n    posNodoI = findNodeByPos(numNode);\n    if(lseek(myFileSystem->fdVirtualDisk, posNodoI, SEEK_SET) == (off_t) - 1) {\n        perror(\"Failed lseek in updateNode\");\n        return -1;\n    }\n    if(write(myFileSystem->fdVirtualDisk, node, sizeof(NodeStruct)) == -1) {\n        perror(\"Failed write in updateNode\");\n    }\n    sync();\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__singlyLL.0.c", "original_string": "nptr reverse(nptr head)\n{\n    if (head -> next == NULL)\n        return head; \n    nptr newList = reverse(head -> next);\n    head -> next = NULL;\n    nptr temp = newList;\n    while(temp -> next != NULL)\n        temp = temp -> next;\n    temp -> next = head;\n    return newList;\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__routing2.3.c", "original_string": "void    get_f(char *line)\n{\n    char    **par;\n    char    **colors;\n    int     cc;\n    int     cw;\n    cw = 0;\n    par = ft_split(line, ' ');\n    cc = 0;\n    colors = ft_split(&par[1][0], ',');\n    while (line[cc])\n    {\n        if (line[cc] == ',')\n            cw++;\n        cc++;\n    }\n    if (cw != 2)\n    {\n        ft_putstr(\"Error:\\n Wrong floor RGB\");\n        exit(0);\n    }\n    cw = c_w(line, ' ');\n    cc = c_w(&par[1][0], ',');\n    freethenipples(par);\n    check_frgb(colors, cc, cw);\n    freethenipples(colors);\n}"}
{"author": "254Odeke", "file": "Operating-Systems_Lab__Deadlock_Prevention_with_Known_Required_Resourses_Simulation.2.c", "original_string": "void show()\n{\nint i,j;\nprintf(\"Process\\t Allocation\\t Max\\t Available\\t\");\nfor(i=0;i<n;i++)\n {\n printf(\"\\nP%d\\t \",i+1);\n for(j=0;j<r;j++)\n {\n printf(\"%d \",alloc[i][j]);\n }\n printf(\"\\t\");\n for(j=0;j<r;j++)\n {\n printf(\"%d \",max[i][j]);\n }\n printf(\"\\t\");\n if(i==0)\n {\n for(j=0;j<r;j++)\n printf(\"%d \",avail[j]);\n }\n }\n}"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__syscalls.6.c", "original_string": "void * _sbrk(int32_t incr)\n{\n    extern char   end; \n    static char * heap_end;\n    char *        prev_heap_end;\n    if (heap_end == 0) {\n        heap_end = & end;\n    }\n    prev_heap_end = heap_end;\n    heap_end += incr;\n    return (void *) prev_heap_end;\n}"}
{"author": "haon1026", "file": "linux-programming__nonblood-mmap-r.1.c", "original_string": "int main()\n{\n    struct student stu;\n    int fd = open(\"temp\", O_RDONLY);\n    if(fd == -1)\n        sys_err(\"open error\");\n    struct student *p = mmap(NULL, sizeof(stu), PROT_READ, MAP_SHARED, fd, 0);\n    if(p == MAP_FAILED)\n        sys_err(\"mmap error\");\n    close(fd);\n    while(1)\n    {\n        printf(\"id = %d, name = %s, age = %d\\n\", p->id, p->name, p->age);\n        sleep(1);\n    }\n    munmap(p, sizeof(stu));\n    return 0;\n}"}
{"author": "2security", "file": "Array__ReverseArray.1.c", "original_string": "void displayarr(int arr[],int len)\n    {\n    int i;\n    for(i=0;i<len;i++)\n        printf(\"%d \",arr[i]);\n    }"}
{"author": "paawankohli", "file": "DSA-LAB__1.0.c", "original_string": "int main()\n{\n    int rowNum;\n    printf(\"Enter no. of rows:\");\n    scanf(\"%d\", &rowNum);\n    int **table = calloc(rowNum, sizeof(int*));\n    int total = 0;\n    for(int i = 0 ; i < rowNum ; i++)\n    {\n        int colSize;\n        printf(\"Enter no. of columns of %dth row: \", i + 1);\n        scanf(\"%d\", &colSize);\n        table[i] = calloc(colSize + 1, sizeof(int));\n        table[i][0] = colSize;  \n        printf(\"Enter %d elements: \", colSize);\n        for(int j = 1 ; j <= table[i][0] ; j++)\n            scanf(\"%d\", &table[i][j]);\n        total += colSize;\n    }\n    int temp[total];\n    int k = 0;\n    for(int i = 1 ; i <= table[rowNum - 1][0] ; i++) \n        temp[k++] = table[rowNum - 1][i];\n    for(int a = 0 ; a < rowNum - 1 ; a++)\n    {\n        int colSize = table[a][0];\n        for(int i = 1 ; i <= colSize ; i++)\n            temp[k++] = table[a][i];\n    }\n    for(int i = 0 ; i < rowNum - 1; i++)\n        table[i][0] = 0;\n    table[rowNum - 1] = malloc((total + 1) * sizeof(int));\n    table[rowNum - 1][0] = total;\n    for(int i = 1; i <= total; i++)\n        table[rowNum - 1][i] = temp[i - 1];\n    for(int i = 0 ; i < rowNum ; i++)\n    {\n        int colSize = table[i][0];\n        if(colSize == 0)\n        {\n            printf(\"NULL\\n\");\n            continue;\n        }\n        for(int j = 0 ; j <= colSize ; j++)\n            printf(\"%d\\t\", table[i][j]);\n        printf(\"\\n\");\n        free(table[i]);\n    }\n    free(table);\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__tersucgen21.0.c", "original_string": "int main ()\n{\n    int i,k,l,yildiz;\n    printf(\"boyut giriniz:\");\n    scanf(\"%d\",&yildiz);\n    if(yildiz<0)\n    {\n        printf(\"hatal\u0131 giri\u015f\");\n        return 1;\n    }\n    for(i=1;i<=yildiz;i++)\n    {\n         for(k=1;k<=yildiz-i;k++)\n             printf(\" \");\n          for(l=1;l<=i;l++)\n              printf(\"*\");\n      printf(\"\\n\");\n     }\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_after_pos_DLL.1.c", "original_string": "void creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__pthread_canceltest.3.c", "original_string": "int main()\n{\n    pthread_t tid;\n    void *retval = NULL;\n    pthread_create(&tid, NULL, thread_fun1, NULL);\n    pthread_join(tid, &retval);\n    printf(\"thread 1 exit code = %d\\n\\n\", (int)retval);\n    pthread_create(&tid, NULL, thread_fun2, NULL);\n    pthread_join(tid, &retval);\n    printf(\"thread 2 exit code = %d\\n\\n\", (int)retval);\n    pthread_create(&tid, NULL, thread_fun3, NULL);\n    sleep(3);\n    pthread_cancel(tid);\n    pthread_join(tid, &retval);\n    printf(\"thread 3 exit code = %d\\n\\n\", (int)retval);     \n    return 0;    \n}"}
{"author": "zjzj-zz", "file": "4s_Numerical__Gauss_Seidel_General.1.c", "original_string": "void Seidel( double x[N], double  y[N], double a[N][N], double b[N]){ \n    for( j = 0; j < N; j++ ){\n        for( k = 0; k < N; k++ ) y[k] = x[k];\n        x[j] = ( (a[j][j] * y[j]) + b[j] );\n        for( k = 0; k < N; k++ ) x[j] -= ( a[j][k] * y[k] );\n        x[j] /= a[j][j];\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__BK.1.c", "original_string": "int main()\n{\n    int seq[10000], n, tam_s; \n    seq[0] = 1;\n    scanf(\"%i\", &n);\n    if (n == 1)\n    {\n        printf(\"%i\\n\", seq[0]);\n    }\n    else\n    {\n        for (int i = 1; i < n; i++)\n        {\n            if (i == (n - 1))\n            {\n                sequencia(seq, true);\n                putchar('\\n');\n            }\n            else\n            {\n                sequencia(seq, false);\n            }\n        }\n    }\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.15.c", "original_string": "void stripvars(ASSEMBLER* a) {\n    STRINGLIST* curln = a->lns;\n    while(curln != NULL) {\n        if(curln->content[0] == '@')\n                handlevarsymbol(a, curln);\n        curln = curln->next;\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q31.3.c", "original_string": "void pop2(stack *s)\n{\n    if (s->tos2 == MAX)\n        printf(\"Underflow! \\n\");\n    else\n        printf(\"%d popped\\n\", s->a[(s->tos2)++]);\n}"}
{"author": "behergue", "file": "Operating_Systems__myFS.13.c", "original_string": "int updateDirectory(MyFileSystem *myFileSystem)\n{\n    if(lseek(myFileSystem->fdVirtualDisk, BLOCK_SIZE_BYTES * DIRECTORY_IDX, SEEK_SET) == (off_t) - 1) {\n        perror(\"Failed lseek in updateDirectory\");\n        return -1;\n    }\n    if(write(myFileSystem->fdVirtualDisk, &(myFileSystem->directory), sizeof(DirectoryStruct)) == -1) {\n        perror(\"Failed write in updateDirectory\");\n        return -1;\n    }\n    sync();\n    return 0;\n}"}
{"author": "0712023", "file": "Arduino-Mood-Light-DIY-kit__Moodlight.2.c", "original_string": "void rgb_set() {\n  int SP1 = RGB.indexOf(' ');\n  int SP2 = RGB.indexOf(' ', SP1 + 1);\n  int SP3 = RGB.indexOf(' ', SP2 + 1);\n  int SP4 = RGB.indexOf(' ', SP3 + 1);\n  String Red = RGB.substring(0, SP1);\n  String Green = RGB.substring(SP1 + 1, SP2);\n  String Blue = RGB.substring(SP2 + 1, SP3);\n  String Bright = RGB.substring(SP3 + 1, SP4);\n  for ( int i = 0; i < NUMPIXELS; i++ ) { \n    pixels.setPixelColor(i, pixels.Color( map(Bright.toInt(), 0, 255, 0, Red.toInt()), map(Bright.toInt(), 0, 255, 0, Green.toInt()), map(Bright.toInt(), 0, 255, 0, Blue.toInt()) ) ); \n    pixels.show(); \n  }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q2.8.c", "original_string": "void preorder(node *t)\n{\n    node* curr;\n    STACK s;\n    s.tos = -1;\n    push(&s, t);\n    while (s.tos != -1)\n    {\n        curr = pop(&s);\n        printf(\"%d\\t\", curr->data);\n        if (curr->right)\n            push(&s, curr->right);\n        if (curr->left)\n            push(&s, curr->left);\n    }\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__receiver0.2.c", "original_string": "int output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n        if(i %9 == 0 && i!=0) printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "theuwis", "file": "AdventOfCode2015__main3.0.c", "original_string": "int main(void){\n    char input[8] = \"hepxcrrq\";\n    bool incr_straight = false, banned_letter = false;\n    int amount_sequence = 0;\n    char first_pair[1];\n    printf(\"%s\\n\", input);\n    while(1){\n        for(int i = 0; i < 5; i++){\n            if((input[i] + 1 == input[i + 1]) && (input[i + 1] + 1 == input[i + 2])){\n                incr_straight = true;\n                break;\n            }\n        }\n        if((strstr(input, \"i\") != NULL) || (strstr(input, \"o\") != NULL) ||\n            (strstr(input, \"l\") != NULL)){\n            banned_letter = true;\n        }\n        for(int i = 0; i < 7; i++){\n            if(input[i] == input[i + 1]){\n                if(amount_sequence == 0){\n                    amount_sequence++;\n                    first_pair[0] = input[i];\n                }\n                else if(input[i] != first_pair[0]){\n                    amount_sequence++;\n                }\n            }\n        }\n        if(incr_straight && !banned_letter && (amount_sequence > 1)){\n            break;\n        }\n        input[7]++;\n        for(int i = 7; i > 0; i--){\n            if(input[i] == '{'){\n                input[i] = 'a';\n                input[i - 1]++;\n            }\n            else{\n                break;\n            }\n        }\n        incr_straight = false;\n        banned_letter = false;\n        amount_sequence = 0;\n    }\n    printf(\"%s\\n\", input);\n    return EXIT_SUCCESS;\n}"}
{"author": "haon1026", "file": "linux-programming__unlink.0.c", "original_string": "int main()\n{\n    int fd = open(\"temp.txt\", O_RDWR|O_CREAT|O_TRUNC, 0644);\n    if(fd < 0)\n    {\n        perror(\"open temp error\");\n        exit(1);\n    }\n    int ret;\n    ret = unlink(\"temp.txt\");       \n    if(ret < 0)\n    {\n        perror(\"unlink error\");\n        exit(1);\n    }\n    char *p1 = \"test of unlink\\n\";\n    char *p2 = \"after write something\\n\";\n    ret = write(fd, p1, strlen(p1));\n    if(ret == -1)\n        perror(\"write error\");\n    printf(\"write ok\\n\");\n    ret = write(fd, p2, strlen(p2));\n    if(ret == -1)\n        perror(\"write error\");\n    printf(\"Enter any key continue\\n\");\n    getchar();\n    close(fd);\n    return 0;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__16_While.0.c", "original_string": "void Columna(int pibote)\n{\n    int j = 1;\n    while(j <= 20)\n    {\n        if(j >= (10 - pibote) && j <= (10 + pibote))\n            printf(\"Z\");\n        else\n            printf(\" \");\n        ++j;\n    }\n}"}
{"author": "augustogunsch", "file": "jack-compiler__io.2.c", "original_string": "char* trimstr(char* str, int len, int end) {\n    int count = len - end;\n    char oldchar = str[count];\n    str[count] = '\\0';\n    char* newstr = (char*)malloc(sizeof(char) * (1 + count));\n    strcpy(newstr, str);\n    str[count] = oldchar;\n    return newstr;\n}"}
{"author": "paawankohli", "file": "CN-Lab__tcpc0.0.c", "original_string": "void main () {\n    struct sockaddr_in seradd;\n    int len = sizeof(seradd);\n    seradd.sin_family = AF_INET;\n    seradd.sin_port = 5555;\n    seradd.sin_addr.s_addr = inet_addr(\"172.16.57.152\");\n    int fd = socket(AF_INET, SOCK_STREAM, 0);\n    printf(\"Socket fd: %d \\n\", fd);\n    if (connect(fd, (struct sockaddr*)&seradd, len) == -1) {\n        printf(\"Connect error! %d\\n\" , errno);\n        exit(0);\n    } else {\n        printf(\"Connected\\n\");\n    }\n    char c = 'a';\n    write(fd, &c, 1);\n    char msg[100];\n    read(fd, msg, 100);\n    printf(\"Server: %s\\n\", msg);\n}"}
{"author": "augustogunsch", "file": "jackc__parser-structure.15.c", "original_string": "VARDEC* parsevardecs(PARSER* p) {\n    VARDEC* head = parsevardec(p);\n    VARDEC* curr = head;\n    VARDEC* nextv;\n    while(nextv = parsevardec(p), nextv != NULL) {\n            curr->next = nextv;\n        curr = nextv;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__25_Dowhile.1.c", "original_string": "double Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    do{\n    Total *= numero;\n    ++i;\n    }while(i < exponente);\n    return Total;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__m_init.1.c", "original_string": "t_m         m_init(int ac, char **av)\n{\n    t_m m;\n    m.debug = 1;\n    m.ac = ac;\n    m.av = av;\n    m.len = ft_strlen(av[1]);\n    m.enemy = 0;\n    m.mate = 0;\n    m.act_x = 0;\n    m.act_y = 0;\n    m.off_x = 0;\n    m.off_y = 0;\n    return (m);\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad5.1.c", "original_string": "float difference(float sourceArray[]){\n    int size = 12;\n    float biggest;\n    float smallest;\n    float diff;\n    for(int i = 0; i < size; i++){\n        if(biggest < sourceArray[i]){\n            biggest = sourceArray[i];\n        }\n        if(smallest > sourceArray[i]){\n            smallest = sourceArray[i];\n        }\n    }\n    diff = biggest - smallest;\n    return diff;\n}"}
{"author": "haon1026", "file": "linux-programming__base.2.c", "original_string": "int Bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    int ret = bind(sockfd, addr, addrlen);\n    if(ret == -1)\n    {\n        sys_err(\"bind() error\");\n    }\n    return ret;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "2lista_de_C__main.0.c", "original_string": "int main()\n{\n    int a;\n    int b;\n    printf(\"Escolha um prato:\\n\\n\");\n    printf(\"---------------------------\\n\");\n    printf(\"1 - Lazanha\\n\");\n    printf(\"2 - Macarronada\\n\");\n    printf(\"3 - Strogonff\\n\");\n    printf(\"4 - Churrasco\\n\");\n    printf(\"5 - Sair\\n\");\n    printf(\"---------------------------\\n\\n\");\n    printf(\"Digite o prato: \");\n    scanf(\"%d\",&a);\n    while(a<=4)\n    {\n        printf(\"Escolha um prato:\\n\\n\");\n    printf(\"---------------------------\\n\");\n    printf(\"1 - Lazanha\\n\");\n    printf(\"2 - Macarronada\\n\");\n    printf(\"3 - Strogonff\\n\");\n    printf(\"4 - Churrasco\\n\");\n    printf(\"5 - Sair\\n\");\n    printf(\"---------------------------\\n\\n\");\n    printf(\"Digite o prato: \");\n    scanf(\"%d\",&a);\n    }\n}"}
{"author": "earth429", "file": "mulpre__divBy10.8.c", "original_string": "int divBy10(struct NUMBER *a, struct NUMBER *b){\n    int i;\n    int remainder; \n    b->sign = a->sign; \n    remainder = a->sign * a->n[0]; \n    for (i = 1; i <= KETA - 2;i++){\n        b->n[i - 1] = a->n[i];\n    }\n    b->n[KETA -1] = 0;\n    return remainder;\n}"}
{"author": "earth429", "file": "mulpre__mulprec1.8.c", "original_string": "int divBy10(struct NUMBER *a, struct NUMBER *b){\n    int i;\n    int remainder; \n    clearByZero(b);\n    b->sign = a->sign; \n    remainder = a->sign * a->n[0]; \n    for (i = 1; i <= KETA - 2;i++){\n        b->n[i - 1] = a->n[i];\n    }\n    b->n[KETA - 1] = 0;\n    return remainder;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__catavento.0.c", "original_string": "void init(){\n     glClearColor(0.0,0.0,0.0,0.0);\n     glEnable(GL_DEPTH_TEST); \n     glMatrixMode(GL_MODELVIEW);\n     glLoadIdentity();\n     glOrtho(-7.0,7.0,-7.0,7.0,-7.0,7.0);\n     glPushMatrix();\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BST.2.c", "original_string": "struct tree* delete(struct tree* root,int tar)\n{\n    if(root!=NULL)\n    {\n        if(tar<root->val)\n        root->left=delete(root->left,tar);\n        else if(tar>root->val)\n        root->right=delete(root->right,tar);\n        else if(tar==root->val)\n        {\n            if(root->left==NULL && root->right==NULL)\n            {\n                root=NULL;\n            }\n            else if(root->left==NULL && root->right!=NULL)\n            {\n                temp=root;\n                root=root->right;\n                free(temp);\n            }\n            else if(root->left!=NULL && root->right==NULL)\n            {\n                temp=root;\n                root=root->left;\n                free(temp);\n            }\n            else\n            {\n                temp=find_max(root->left);\n                root->val=temp->val;\n                root->left=delete(root->left,temp->val);\n            }\n        }\n        return(root);\n    }\n    else\n    {\n        return(root);\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.3.c", "original_string": "void firmwareUpdateInfoReader_explain(char *programDir)\n{\n  char *sep = (strlen(programDir) > 0) ? (separator()) : (\"\");\n  printf(\"Waiting for firmware update info to be entered and saved in '%s%s%s' file\\n(if this file has not been opened automatically already, just open it manually in an editor of your choice)\\n\", programDir, sep, DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n  printf(\"Expected firmware update info format: <new-version>:<checksum-or-signature> (e.g., 1.1:8639e6e80b089338e51fac17d5faa647c4c05368e46af5c42583fb34c0) \\n\");\n}"}
{"author": "MartinMarinovich", "file": "ParcialLaboratorio1GCompleto__cliente.2.c", "original_string": "int listarClientes(eCliente listadoDeClientes[], int tamanio)\n{\n    int error = -1;\n    if(listadoDeClientes !=NULL && tamanio>0)\n    {\n        system(\"cls\");\n        printf(\"\\n****  LISTADO DE CLIENTES  ****\\n\");\n        printf(\" Id             Nombre           Sexo\\n\");\n        printf(\"----------------------------------\\n\");\n        for(int i = 0 ; i<tamanio; i++)\n        {\n            listadoDeClientes[0].idCliente = 1;\n            mostrarCliente(listadoDeClientes[i]);\n        }\n        error = 0;\n    }\n    return error;\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__unique2.2.c", "original_string": "int check_number(int n, int ns[], int i){\n  for(int j = 0; j <= i; j++)\n    if( n == ns[j])\n      return 0;\n  return 1;\n}"}
{"author": "mandarvu", "file": "msc__problem73.1.c", "original_string": "int main() {\n  int source[MAX], target[MAX];\n  printf(\"Enter %d numbers: \", MAX);\n  for (int i = 0; i < MAX; i++)\n    scanf(\"%d\", source + i);\n  printf(\"\\nThe Array is\\n\");\n  for (int i = 0; i < MAX; i++)\n    printf(\"%d\\t\",  *(source + i));\n  reverse_array(source, target);\n  printf(\"\\nThe reversed Array is\\n\");\n  for (int i = 0; i < MAX; i++)\n    printf(\"%d\\t\",  *(target + i));\n  printf(\"\\n\");\n  return 0;\n}"}
{"author": "RafaelFelisbino-hub", "file": "WHILE-exercices__Exercicio4WHILE.0.c", "original_string": "int main()\n{\n    int escolha;\n    float saque, deposito, saldo = 0;\n    setlocale(LC_ALL, \"Portuguese\");\n    system(\"color 17\");\n    printf(\"Digite o que quer fazer: (1)Consulta saldo, (2)saque, (3)dep\u00f3sito, (4)sair:  \");\n    scanf_s(\"%i\", &escolha);\n    while (escolha != 4)\n    {\n        if (escolha == 1)\n        {\n            printf(\"\\nSeu saldo \u00e9:  %.2f\", saldo);\n        }\n        if (escolha == 2)\n        {\n            printf(\"\\nDigite o valor do saque:  \");\n            scanf_s(\"%f\", &saque);\n            if ((saldo - saque) <= 0)\n            {\n                printf(\"Voc\u00ea n\u00e3o possui saldo\");\n            }\n            else\n            {\n                saldo = saldo - saque;\n                printf(\"\\nSeu saldo \u00e9:  %.2f\", saldo);\n            }\n        }\n        if (escolha == 3)\n        {\n            printf(\"\\nDigite o valor a ser depositado:  \");\n            scanf_s(\"%f\", &deposito);\n            saldo = saldo + deposito;\n            printf(\"Seu saldo \u00e9 %.2f reais\", saldo);\n        }\n        printf(\"\\n===============================================================================================\");\n        printf(\"\\n\\nDigite o que quer fazer: (1)Consulta saldo, (2)saque, (3)dep\u00f3sito, (4)sair:  \");\n        scanf_s(\"%i\", &escolha);\n    } \n    system(\"pause\");\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client.3.c", "original_string": "void str_trim_lf(char *arr, int length) {\n    int i;\n    for (i = 0; i < length; i++)\n    {\n        if (arr[i] == '\\n')\n        {\n            arr[i] = '\\0';\n            break;\n        }\n    }\n}"}
{"author": "fikepaci", "file": "monty__tokenize_string.3.c", "original_string": "int get_word_count(char *str, char *delims)\n{\n    int wc = 0, pending = 1, i = 0;\n    while (*(str + i))\n    {\n        if (is_delim(str[i], delims))\n            pending = 1;\n        else if (pending)\n        {\n            pending = 0;\n            wc++;\n        }\n        i++;\n    }\n    return (wc);\n}"}
{"author": "mehedi9021", "file": "C_Programming__separate_odd_even.0.c", "original_string": "int main()\n{\n    int i,n;\n    printf(\"Enter the element of array:\");\n    scanf(\"%d\", &n);\n    int a[n];\n    for(i=0; i<=n-1; i++)\n    {\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\nEven numbers:\");\n    for(i=0; i<=n-1; i++)\n    {\n        if(a[i]%2==0)\n        {\n            printf(\"%d \", a[i]);\n        }\n    }\n    printf(\"\\n\\nOdd numbers:\");\n    for(i=0; i<=n-1; i++)\n    {\n        if(a[i]%2==1)\n        {\n            printf(\"%d \", a[i]);\n        }\n    }\n    return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__51.0.c", "original_string": "int main(void)\n{\n    float vetor[tamanho], aux;\n    int j = tamanho - 1;\n    printf(\"Informe os n\u00fameros do vetor:\\n\");\n    for (int i = 0; i < tamanho; i++)\n    {\n        scanf(\"%f\", &vetor[i]);\n    }\n    for (int i = 0; i < (tamanho / 2); i++)\n    {\n        aux = vetor[i];\n        vetor[i] = vetor[j];\n        vetor[j] = aux;\n        j--;\n    }\n    printf(\"\\nVetor: \");\n    for (int i = 0; i < tamanho; i++)\n    {\n        printf(\"%.2f \", vetor[i]);\n    }\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__receiver0.1.c", "original_string": "int addr_check(unsigned char des_addr[6]){\n    int flag = 1;\n    int i =0;\n    for(i = 0;i<6;i++){\n        if(des_addr[i] != my_addr[i]) flag = 0;\n    }\n    if(flag){\n        printf(\"[INFO] Address check success!\\n\");\n    }else {\n        printf(\"[Error] Address check error!\\n\");\n    }\n    return flag;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSL__tls13_ticket.0.c", "original_string": "bool_t tls13IsTicketValid(TlsContext *context)\n{\n   bool_t valid = FALSE;\n   if(tlsGetHashAlgo(context->ticketHashAlgo) != NULL)\n   {\n      if(context->ticketPskLen > 0)\n      {\n         if(context->entity == TLS_CONNECTION_END_CLIENT)\n         {\n            if(context->ticket != NULL && context->ticketLen > 0)\n            {\n               valid = TRUE;\n            }\n         }\n         else\n         {\n            valid = TRUE;\n         }\n      }\n   }\n   return valid;\n}"}
{"author": "sdukesameer", "file": "dsa__list-ins-seq-sor_acend_decend.1.c", "original_string": "void sequential_insert(node** head, int inp)\n{\n    node* linklist=createnode(inp);\n    linklist->next=*head;\n    *head=linklist;\n    printf(\"%d inserted\\n\",(*head)->data);\n}"}
{"author": "dle2005", "file": "Algorithm__Prim.1.c", "original_string": "void main() {\n    int n = 0;\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"\\n\");\n    int **W = (int **)malloc(sizeof(int *) * (n + 1));\n    for(int i = 0; i <= n; i++)\n        W[i] = (int *)malloc(sizeof(int) * (n + 1));\n    nearest = (int *)malloc(sizeof(int) * (n + 1));\n    distance = (int *)malloc(sizeof(int) * (n + 1));\n    edge *F = (edge *)malloc(sizeof(edge) * n);\n    printf(\"W = \\n\");\n    for(int i = 1; i <= n; i++) \n        for(int j = 1; j <= n; j++) \n            scanf(\"%d\", &W[i][j]);\n    printf(\"\\n\");\n    prim(n, W, F);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__WiFiHelper.4.c", "original_string": "static esp_err_t setMode(wifi_mode_t mode, bool enable)\n{\n  wifi_mode_t currentMode;\n  esp_err_t error = ESP_OK;\n  esp_wifi_get_mode(&currentMode);\n  printf(\"Old wifi mode: %u\\n\", ((uint32_t)((currentMode))));\n  bool isEnabled = (currentMode & mode) != 0;\n  if (isEnabled != enable) \n  {\n    if (enable) \n    {\n      error = esp_wifi_set_mode(((wifi_mode_t)((currentMode | mode))));\n    }\n    else\n    {\n      wifi_mode_t nextMode = ((wifi_mode_t)((currentMode & (~mode))));\n      if (nextMode == WIFI_MODE_NULL) \n      {\n        esp_wifi_set_mode(WIFI_MODE_NULL);\n        error = esp_wifi_stop();\n      }\n      else\n      {\n        error = esp_wifi_set_mode(nextMode);\n      }\n    }\n  }\n  return error;\n}"}
{"author": "augustogunsch", "file": "jackc__io.6.c", "original_string": "bool isdir(char* f) {\n    bool readsmt = false;\n    for(int i = strlen(f)-1; i >= 0; i--) {\n        if(f[i] == '.') {\n            if(readsmt)\n                return false;\n            else\n                continue;\n        }\n        if(f[i] == '/')\n            return 1;\n        readsmt = true;\n    }\n    return true;\n}"}
{"author": "augustogunsch", "file": "jackc__threads.3.c", "original_string": "void* vmtranslateunit(void* input) {\n    COMPILEUNIT* unit = (COMPILEUNIT*)input;\n    if(unit->compiled == NULL) {\n        eprintf(\"Class '%s' is empty; file '%s'\\n\", unit->parsed->name, unit->file->name);\n        exit(1);\n    }\n    char* classname = getclassname(unit->file->name);\n    unit->vmtranslator = mkvmtranslator(classname, unit->compiled);\n    unit->asmlns = translatevm(unit->vmtranslator);\n    free(classname);\n    pthread_exit(NULL);\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__doublylinkedlist.1.c", "original_string": "void delete(int tar)\n{\n    if(start==NULL)\n    printf(\"\\nList is empty\");\n    else\n    {\n        temp=start;\n        q=temp;\n        while(temp->next!=NULL)\n        {\n            if(temp->val==start->val && temp->val==tar)\n            {\n                start=start->next;\n                start->prev=NULL;\n                free(temp);\n                temp=start;\n            }\n            else if(temp->val==tar)\n            {\n                q->next=temp->next;\n                temp->next->prev=q;\n                free(temp);\n                temp=q->next;\n            }\n            q=temp;\n            temp=temp->next;\n        }\n        if(temp->val==tar && temp->next==NULL)\n        {\n            q->next=NULL;\n            temp->prev=NULL;\n            free(temp);\n        }\n    }\n}"}
{"author": "dishanp", "file": "DSA__q45.3.c", "original_string": "int main()\n{\n    int n, m;\n    printf(\"Number of elements : \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n        scanf(\"%d\", &A[i]);\n    create(A, n);\n    remduplicates(first);\n    display(first);\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__PassingStructureToFunction.0.c", "original_string": "void main()\n{\n    printf(\"\\nEnter Book_ID: \");\n    scanf(\"%d\", &b.book_id);\n    printf(\"\\nEnter Book_Price: \");\n    scanf(\"%f\", &b.book_price);\n    printf(\"\\nEnter Book_Name: \");\n    scanf(\"%s\", &b.book_name);\n    displayBookDetails(b);\n}"}
{"author": "254Odeke", "file": "OpeartingSystems__os16.1.c", "original_string": "void assign(){\n    int i;\n    for (i=0;i<no_of_pages;i++){\n        ptable[i].fno = -1;\n        ptable[i].pbit= -1;\n    }\n    for(i=0; i<no_of_frames;i++)\n        ftable[i] = 32555;\n    for (i=0;i<no_of_pages;i++){\n        printf(\"Enter the Frame number where page %d must be placed: \",i);\n        scanf(\"%d\",&frameno);\n        ftable[frameno] = i;\n        if(ptable[i].pbit == -1){\n            ptable[i].fno = frameno;\n            ptable[i].pbit = 1;\n        }\n    }\n    printf(\"\\n\\nPAGE TABLE\\n\\n\");\n    printf(\"PageAddress FrameNo. PresenceBit\\n\\n\");\n    for (i=0;i<no_of_pages;i++)\n        printf(\"%d\\t\\t%d\\t\\t%d\\n\",i,ptable[i].fno,ptable[i].pbit);\n    printf(\"\\n\\nFRAME TABLE\\n\\n\");\n    printf(\"FrameAddress PageNo\\n\\n\");\n    for(i=0;i<no_of_frames;i++)\n        printf(\"%d\\t\\t%d\\n\",i,ftable[i]);\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__functions.1.c", "original_string": "int CountKey(char* lastName)\n{\n    int lengthOfLastName = strlen(lastName);\n    int sum = 0, i = 0;\n    if (lengthOfLastName < LAST_NAME_LENGTH)\n    {\n        for (i = 0; i < lengthOfLastName; i++)\n            sum += lastName[i];\n    }\n    else\n    {\n        for (i = 0; i < LAST_NAME_LENGTH; i++)\n            sum += lastName[i];\n    }\n    return (sum % SIZE_OF_TABLE);\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_11.7.c", "original_string": "void infixToPostfix(char* exp) \n{ \n    int i, k; \n    struct Stack* stack = createStack(strlen(exp));  \n    for (i = 0, k = -1; exp[i]; ++i) \n    { \n        if (isOperand(exp[i])) \n            exp[++k] = exp[i]; \n        else if (exp[i] == '(') \n            push(stack, exp[i]); \n        else if (exp[i] == ')') \n        { \n            while (!isEmpty(stack) && peek(stack) != '(') \n                exp[++k] = pop(stack); \n            if (!isEmpty(stack) && peek(stack) != '(') \n                return;             \n            else\n                pop(stack); \n        } \n        else\n        { \n            while (!isEmpty(stack) && Prec(exp[i]) <= Prec(peek(stack))) \n                exp[++k] = pop(stack); \n            push(stack, exp[i]); \n        } \n    } \n    while (!isEmpty(stack)) \n        exp[++k] = pop(stack); \n    exp[++k] = '\\0'; \n}"}
{"author": "2security", "file": "Control-Statements__AnyBaseToAnyBaseConvert.1.c", "original_string": "void baseconversion(char s[20],int b1,int b2)\n{\n    int count=0,r,digit,i,n=0,b=1;\n    for(i=strlen(s)-1;i>=0;i--)\n        {\n         if(s[i]>='A'&&s[i]<='Z')\n            {\n             digit=s[i]-'0'-7;\n            }\n         else\n            {\n             digit=s[i]-'0';\n            }\n        n=digit*b+n;\n        b=b*b1;\n        }\n    while(n!=0)\n    {\n        r=n%b2;\n        digit='0'+r;\n        if(digit>'9')\n        {\n            digit+=7;\n        }\n         s[count]=digit;\n         count++;\n         n=n/b2;\n    }\n    for(i=count-1;i>=0;i--)\n        {\n        printf(\"%c\",s[i]);\n        }\n    printf(\"\\n\");\n    }"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__routing2.4.c", "original_string": "void    get_c(char *line)\n{\n    char    **par;\n    char    **colors;\n    int     cc;\n    int     cw;\n    cw = 0;\n    par = ft_split(line, ' ');\n    cc = 0;\n    colors = ft_split(&par[1][0], ',');\n    while (line[cc])\n    {\n        if (line[cc] == ',')\n            cw++;\n        cc++;\n    }\n    if (cw != 2)\n    {\n        ft_putstr(\"Error:\\n Wrong ceiling RGB\");\n        exit(0);\n    }\n    cw = c_w(line, ' ');\n    cc = c_w(&par[1][0], ',');\n    freethenipples(par);\n    check_crgb(colors, cc, cw);\n    freethenipples(colors);\n}"}
{"author": "sahadipanjan6", "file": "Programs-in-C__P4.0.c", "original_string": "void main()\n{\n    int n;\n    printf(\"Enter any number:\\n\");\n    scanf(\"%d\", &n);\n    if(isPalindrome(n) == 1)\n        printf(\"%d is a Palindrome...\\n\", n);\n    else\n        printf(\"%d is NOT a Palindrome...\\n\", n);\n}"}
{"author": "earth429", "file": "mulpre__newton_test.1.c", "original_string": "double newton(double x0) {\n    double x; \n    double b; \n    double e; \n    e = 1.e-7;\n    x = x0;\n    b = x0;\n    while(1){\n        b = x; \n        x = b - (f(b) / fdash(b));\n        if(fabs(x - b) < e){ \n            break;\n        }\n    }\n    return x;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__count_one.0.c", "original_string": "int CountOne(int iValue)\n{\n    int iRem = 0;\n    int iCnt = 0;\n    if(iValue < 0)\n    {\n        iValue = -iValue;\n    }\n    while(iValue != 0)\n    {\n        iRem = iValue % 2;\n    if(iRem == 1)\n        {\n            iCnt++;\n        }\n        iValue = iValue / 2;\n    }\n    return iCnt;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.11.c", "original_string": "int delValFromNode(int val, struct btreeNode *myNode) {\n        int pos, flag = 0;\n        if (myNode) {\n                if (val < myNode->val[1]) {\n                        pos = 0;\n                        flag = 0;\n                } else {\n                        for (pos = myNode->count;\n                                (val < myNode->val[pos] && pos > 1); pos--);\n                         if (val == myNode->val[pos]) {\n                                flag = 1;\n                        } else {\n                                flag = 0;\n                        }\n                }\n                if (flag) {\n                        if (myNode->link[pos - 1]) {\n                                copySuccessor(myNode, pos);\n                                flag = delValFromNode(myNode->val[pos], myNode->link[pos]);\n                                if (flag == 0) {\n                                        printf(\"Given data is not present in B-Tree\\n\");\n                                }\n                        } else {\n                                removeVal(myNode, pos);\n                        }\n                } else {\n                        flag = delValFromNode(val, myNode->link[pos]);\n                }\n                if (myNode->link[pos]) {\n                        if (myNode->link[pos]->count < MIN)\n                                adjustNode(myNode, pos);\n                }\n        }\n        return flag;\n  }"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__routing2.0.c", "original_string": "int     str_is_digits(char *c)\n{\n    int i;\n    i = 0;\n    if (!c)\n        return (0);\n    while (c[i])\n    {\n        if (!ft_isdigit(c[i]))\n            return (0);\n        i++;\n    }\n    return (1);\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_21.0.c", "original_string": "int main()\n{\n    int a[10];\n    int b[10];\n    int c[10];\n    int i;\n                printf(\"--------------------------------------\\n\");\n                printf(\"digite um numero para o primeiro vetor\\n\");\n                printf(\"--------------------------------------\\n\\n\");\n    for(i=0;i<10;i++) \n    {\n        printf(\"digite um numero: \");\n        scanf(\"%d\",&a[i]);\n    }\n                printf(\"--------------------------------------\\n\");\n                printf(\"digite um numero para o segundo vetor\\n\");\n                printf(\"--------------------------------------\\n\\n\");\n    for(i=0;i<10;i++) \n    {\n        printf(\"digite um numero: \");\n        scanf(\"%d\",&b[i]);\n    }\n                printf(\"\\n------------------------------------------\\n\");\n    for(i=0;i<10;i++) \n    {\n        c[i] = a[i] - b[i];\n        printf(\"[%d] - [%d] = [%d]\\n\",a[i],b[i],c[i]);\n    }\n                printf(\"\\n------------------------------------------\\n\");\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__queue.0.c", "original_string": "int main()\n{\n    int choice;\n    while(1){\n        printf(\"Enter the choice\\n1. Insertion\\n2. Deletion\\n3. Display\\n4. Exit\\n\");\n        scanf(\"%d\",&choice);\n        switch (choice){\n            case 1:\n                enqueue();\n                break;\n            case 2:\n                dequeue();\n                break;\n            case 3:\n                display();\n                break;\n            case 4:\n                exit(0);\n            default:\n                printf(\"Invalid Choice\\n\");\n        }\n    }\n}"}
{"author": "MartinMarinovich", "file": "ParcialLaboratorio1GCompleto__servicio.3.c", "original_string": "int getIdServicio(eServicio servicios[],int tam_s)\n{\n    int auxId;\n    listarServicios(servicios,tam_s);\n    utn_getNumeroInt(&auxId,\"Ingrese id\",\"Error, ingrese id valido\",2000,2003,4);\n    while(buscarServicios(servicios,tam_s,auxId) == -1)\n    {\n         utn_getNumeroInt(&auxId,\"Ingrese un id valido\",\"Error, ingrese id valido\",2000,2003,4);\n    }\n    return auxId;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__stp_conditions.0.c", "original_string": "bool_t stpRootBridge(StpBridgeContext *context)\n{\n   bool_t res;\n   if(stpCompareBridgeId(&context->designatedRoot, &context->bridgeId) == 0)\n   {\n      res = TRUE;\n   }\n   else\n   {\n      res = FALSE;\n   }\n   return res;\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example40.1.c", "original_string": "int binaryToDecimal(int arr[])\n{\n    int i,j=4,decimalNum=0;\n    for(i=SIZE;i>0;i--)\n    {\n        decimalNum+=pow(2,j)*arr[i];\n        j--;\n    }\n   return decimalNum;\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__server1.1.c", "original_string": "int main() \n{ \n    int sockfd, connfd, len; \n    struct sockaddr_in servaddr, cli; \n    sockfd = socket(AF_INET, SOCK_STREAM, 0); \n    if (sockfd == -1) { \n        printf(\"socket creation failed...\\n\"); \n        exit(0); \n    } \n    else\n        printf(\"Socket successfully created..\\n\"); \n    bzero(&servaddr, sizeof(servaddr)); \n    servaddr.sin_family = AF_INET; \n    servaddr.sin_addr.s_addr = htonl(INADDR_ANY); \n    servaddr.sin_port = htons(PORT); \n    if ((bind(sockfd, (SA*)&servaddr, sizeof(servaddr))) != 0) { \n        printf(\"socket bind failed...\\n\"); \n        exit(0); \n    } \n    else\n        printf(\"Socket successfully binded..\\n\"); \n    if ((listen(sockfd, 5)) != 0) { \n        printf(\"Listen failed...\\n\"); \n        exit(0); \n    } \n    else\n        printf(\"Server listening..\\n\"); \n    len = sizeof(cli); \n    connfd = accept(sockfd, (SA*)&cli, &len); \n    if (connfd < 0) { \n        printf(\"server acccept failed...\\n\"); \n        exit(0); \n    } \n    else\n        printf(\"server acccept the client...\\n\"); \n    comm(connfd); \n    close(sockfd); \n}"}
{"author": "paawankohli", "file": "DSA-LAB__q23.2.c", "original_string": "void dequeueleft(queue *q)\n{\n    if (q->front==q->rear)\n        printf(\"Queue Empty\");\n    else\n        printf(\"\\n%s deleted\", q->c[(q->front)++] );\n}"}
{"author": "augustogunsch", "file": "jackc__io.13.c", "original_string": "char* getouthack(char* input) {\n    char* out;\n    int inplen = strlen(input);\n    if(isdir(input)) {\n        char* name = getname(input, inplen);\n        int sz = (inplen + strlen(name) + 7) * sizeof(char);\n        out = (char*)malloc(sz);\n        sprintf(out, \"%s/%s.hack\", input, name);\n        free(name);\n    }\n    else {\n        out = heapstr(input, inplen);\n        out[inplen-4] = 'h';\n    }\n    return out;\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad4.0.c", "original_string": "int main()\n{\n    int N;\n    printf(\"Podaj dodatnia wartosc liczby 'N': \");\n    scanf(\"%d\", &N);\n    while(N <= 0){\n        printf(\"Podano bledna wartosc\\n\");\n        printf(\"Podaj dodatnia wartosc liczby 'N': \");\n        scanf(\"%d\", &N);\n    }\n    printf(\"N-ty wyraz ciagu to: %.2f\", ciag(N));\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_rtx.3.c", "original_string": "OsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,\n   void *param, size_t stackSize, int_t priority)\n{\n   uint_t i;\n   OsTask *task = NULL;\n   osSuspendAllTasks();\n   for(i = 0; i < OS_PORT_MAX_TASKS; i++)\n   {\n      if(!taskTable[i].tid)\n         break;\n   }\n   if(i < OS_PORT_MAX_TASKS)\n   {\n      taskTable[i].tid = os_tsk_create_ex(taskCode, priority, param);\n      if(taskTable[i].tid != 0)\n         task = &taskTable[i];\n   }\n   osResumeAllTasks();\n   return task;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__brackets.2.c", "original_string": "int     main(int ac, char **av)\n{\n    char    store[500];\n    if (ac > 1)\n    {\n        if (brackets(av[1],store))\n            write(1, \"OK\",2);\n        else\n            write(1, \"Error\",5);\n    }\n    write(1,\"\\n\",1);\n    return(0);\n}"}
{"author": "mehedi9021", "file": "Data_Structure__double_linked_list_create.4.c", "original_string": "void insertAtEnd(int data)\n{\n    struct node * newNode;\n    if(last == NULL)\n    {\n        printf(\"Error, List is empty!\\n\");\n    }\n    else\n    {\n        newNode = (struct node *)malloc(sizeof(struct node));\n        newNode->data = data;\n        newNode->next = NULL;\n        newNode->prev = last;\n        last->next = newNode;\n        last = newNode;\n        printf(\"NODE INSERTED SUCCESSFULLY AT THE END OF LIST\\n\");\n    }\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_dma_ex.1.c", "original_string": "HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\n  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)\n  {\n    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\n    return HAL_ERROR;\n  }\n  if ((NULL == hdma->XferCpltCallback) || (NULL == hdma->XferM1CpltCallback) || (NULL == hdma->XferErrorCallback))\n  {\n    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;\n    return HAL_ERROR;\n  }\n  __HAL_LOCK(hdma);\n  if(HAL_DMA_STATE_READY == hdma->State)\n  {\n    hdma->State = HAL_DMA_STATE_BUSY;\n    hdma->ErrorCode = HAL_DMA_ERROR_NONE;\n    hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;\n    hdma->Instance->M1AR = SecondMemAddress;\n    DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength); \n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_DME_FLAG_INDEX(hdma));\n    __HAL_DMA_CLEAR_FLAG (hdma, __HAL_DMA_GET_FE_FLAG_INDEX(hdma));\n    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;\n    hdma->Instance->FCR |= DMA_IT_FE;\n    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))\n    {\n      hdma->Instance->CR  |= DMA_IT_HT;\n    }\n    __HAL_DMA_ENABLE(hdma); \n  }\n  else\n  {     \n    __HAL_UNLOCK(hdma);   \n    status = HAL_BUSY;\n  }  \n  return status; \n}"}
{"author": "sdukesameer", "file": "dsa__list-ins-rem_even.3.c", "original_string": "void print(node** head)\n{\n    if(*head==NULL)\n        printf(\"\\nSTACK EMPTY\\n\");\n    else\n    {\n        node* h=*head;\n        printf(\"\\n LINK-LIST:\");\n        while(h!=NULL)\n        {\n            printf(\"  %d\",h->data);\n            h=h->next;\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "2security", "file": "Matrix__35SumLowerTriangularMatrix.0.c", "original_string": "int SumLowerTri(int mat[][20],int r)\n    {\n    int i,j,sum=0;\n    for(i=0;i<r;i++) \n        {\n        for(j=0;j<r;j++) \n            {\n            if(i>=j)\n                sum=sum+mat[i][j];\n            }\n        }\n    return sum;\n    }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__pgcd.2.c", "original_string": "void    ft_pgcd(int a, int b)\n{\n    int     cdn;\n    int     i;\n    i = 1;\n    cdn = 0;\n    while (i < a && i < b)\n    {\n        if (a % i == 0 && b % i == 0)\n            cdn = i;\n        i++;\n    }\n    ft_putnbr(cdn);\n}"}
{"author": "sdukesameer", "file": "dsa__pol-add-sub-mul.0.c", "original_string": "void createNode(int c, int p, node** exp)\n{\n    if(c==0)\n        return;\n    node* x=*exp;\n    while(x)\n    {\n        if(x->pow == p)\n        {\n            if(x->coeff < 0 && c < 0)\n                x->coeff=-(x->coeff+c);\n            else\n                x->coeff=x->coeff+c;\n            return;\n        }\n        x=x->next;\n    }\n    node* ret=(node*) malloc(sizeof(node));\n    ret->coeff=c;\n    ret->pow=p;\n    if(*exp==NULL)\n    {\n        ret->next=*exp;\n        *exp=ret;\n    }\n    else\n    {\n            if(p > (*exp)->pow)\n            {\n                ret->next=*exp;\n                *exp=ret;\n            }\n            else\n            {\n                x=*exp;\n                while(x->next!=NULL && x->next->pow > p)\n                    x=x->next;\n                ret->next=x->next;\n                x->next=ret;\n            }\n    }\n}"}
{"author": "2security", "file": "Pointer__10AddTwoMatrix.1.c", "original_string": "int **Sum(int **mat1,int **mat2,int **mat3)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            {\n            mat3[i][j]=mat1[i][j]+mat2[i][j];\n            }\n        }\n    return mat3;\n    }"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad20.1.c", "original_string": "int wypisz(int * array, int n){\n   for(int i = 0; i < n; i++){\n        if(array[i] % 2 == 0) {\n            printf(\"Parzysta liczba %d o indeksie %d\\n\", array[i], i);\n        }\n    }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__packet_error_rate.0.c", "original_string": "void timer_1_init()\n{\n        NRF_TIMER_TX_READY->TASKS_CLEAR = 1;\n        NRF_TIMER_TX_READY->BITMODE = TIMER_BITMODE_BITMODE_32Bit << TIMER_BITMODE_BITMODE_Pos;\n        NRF_TIMER_TX_READY->PRESCALER = 4;\n        NRF_TIMER_TX_READY->SHORTS = TIMER_SHORTS_COMPARE0_CLEAR_Msk << TIMER_SHORTS_COMPARE0_CLEAR_Pos;\n        NRF_TIMER_TX_READY->MODE = TIMER_MODE_MODE_LowPowerCounter << TIMER_MODE_MODE_Pos;\n        NRF_TIMER_TX_READY->CC[TIMER_RELOAD_CC_NUM] = TIMER_RELOAD;\n        NRF_TIMER_TX_READY->TASKS_START = 1;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__B.0.c", "original_string": "double fatorial (int i)\n{\n    double res = 1;\n    for (int j=1; j<i; j++)\n    {\n        res = res*(j+1);\n    }\n    return res;\n}"}
{"author": "sdukesameer", "file": "dsa__list-ins-seq-sor_acend_decend.0.c", "original_string": "node* createnode(int inp)\n{\n    node* newnode=malloc(sizeof(node));\n    newnode->data=inp;\n    newnode->next=NULL;\n    return newnode;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__45_identical_matrix.0.c", "original_string": "int main()\n{\n  int i,j,k,r1,c1,r2,c2, flag = 0;\n  printf(\"Enter Value of r1, c1\\n\");\n  scanf(\"%d%d\",&r1,&c1);\n  int m1[r1][c1], sum = 0;\n  if(r1 == c1)\n  {\n    printf(\"Enter value of Matrix1\\n\");\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        scanf(\"%d\",&m1[i][j]);\n      }\n    }\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        printf(\"%d \",m1[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        if( i == j && m1[i][j] == 1)\n    {\n          flag++;\n    }\n    if( i != j && m1[i][j] == 0)\n    {\n      flag++;\n    }\n      }\n    }  \n  }\n  else\n  {\n    printf(\"Identical Matrix Should be a Square Matrix\\n\");\n  }\n  if(flag == (r1*c1))\n  {\n    printf(\"Matrix is Identical\\n\");\n  }\n  else\n  {\n    printf(\"Matrix is Not Identical\");\n  }\n  printf(\"\\nValue of flag is %d\",flag);\n}"}
{"author": "DanielSalis", "file": "AED1__teste8.3.c", "original_string": "node* findParent(node *aux, int key_parent){\n    if(aux != NULL){\n        node *NovoPai = findParent(aux->left, key_parent);\n        if(NovoPai == NULL) {\n            NovoPai = findParent(aux->right, key_parent);\n        }\n        return NovoPai;\n    }else{\n        return NULL;\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__example.1.c", "original_string": "int main()\n{\n    stack s;\n    char exp[15];\n    printf(\"Enter exp: \");\n    scanf(\"%s\", exp);\n    for(int i = 0 ; exp[i] != '\\0' ; i++)\n    {\n        char token = exp[i];\n        if (token >= '0' && token <= '9')\n            push(&s, token);\n        else\n        {\n            char b = pop(&s);\n            char a = pop(&s);\n            switch(token)\n            {\n                case '+':   push(&s, toInt(a) + toInt(b) + '0');\n                            break;\n                case '-':   push(&s, toInt(a) - toInt(b) + '0');\n                            break;\n                case '/':   push(&s, toInt(a) / toInt(b) + '0');\n                            break;\n                case '*':   push(&s, toInt(a) * toInt(b) + '0');\n                            break;\n            }\n        }\n    }\n    printf(\"Ans = %d \\n\", toInt(pop(&s)));\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_CLL.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.delete the element from the last position\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"delete the element from the last position\\n\");\n            delete_end();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "jose120918", "file": "binary_trees__9-binary_tree_height.0.c", "original_string": "int scale(const binary_tree_t *tree)\n{\n    int ll = 1;\n    int lr = 1;\n    if (tree == NULL)\n    {\n        return (-1);\n    }\n    ll += scale((*tree).left);\n    lr += scale((*tree).right);\n    if (lr > ll)\n    {\n        return (lr);\n    }\n    return (ll);\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BST.4.c", "original_string": "void inorder(struct tree* root)\n{\n    if(root!=NULL)\n    {\n        inorder(root->left);\n        printf(\"\\t%d\",root->val);\n        inorder(root->right);\n    }\n}"}
{"author": "davibernardos", "file": "DB-Projetos__e18.0.c", "original_string": "int main(int argc, char *argv[]) {\n    int player1, player2, optP1, optP2;\n    int mainMenu, playerMenu, modeMenu, novojogo;\n    int totalJogadas, empates, vitoriasP1, vitoriasP2, totalNormal, totalMelhor, totalStartrek, totalDeath, tempVitP1, tempVitP2, especial, tempDeath;\n    float percentP1, percentP2;\n    srand( time(NULL) );\n    totalJogadas=0;\n    totalNormal=0;\n    totalMelhor=0;\n    totalStartrek=0;\n    totalDeath=0;\n    empates=0;\n    vitoriasP1=0;\n    vitoriasP2=0;\n    especial=3;\n    do {\n        system(\"cls\");\n        printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n        printf(\"\\n\\n\\tO que voce quer fazer?\\n\");\n        printf(\"\\t1 - Jogar\\n\");\n        printf(\"\\t2 - Ver Regras\\n\");\n        printf(\"\\t3 - Ver Estatisticas\\n\");\n        printf(\"\\t4 - Sair\\n\\t\");\n        if (totalJogadas > especial ) {\n            printf(\"\\n\\t0 - ESPECIAL DEATHMATCH\\n\");\n        }\n        scanf(\"%d\",&mainMenu);\n        while( (mainMenu>4) || (totalJogadas<especial && mainMenu<1) ){\n            printf(\"\\t-> Opcao invalida!\\n\");\n            printf(\"\\tO que voce quer fazer?\\n\\t\");\n            scanf(\"%d\",&mainMenu);\n        }\n        system(\"cls\");\n        if (mainMenu==1){\n                printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n                printf(\"\\n\\n\\tComo voce quer jogar?\\n\");\n                printf(\"\\t1 - Player VS Player\");\n                printf(\"\\n\\t2 - Player VS Computador\\n\\t\");\n                scanf(\"%d\",&playerMenu);\n                while(playerMenu<1 || playerMenu>2){\n                    printf(\"\\t-> Opcao invalida!\\n\");\n                    printf(\"\\tComo voce quer jogar?\\n\\t\");\n                    scanf(\"%d\",&playerMenu);\n                }\n                system(\"cls\");\n                printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n                printf(\"\\n\\n\\tMODO DE JOGO:\\n\");\n                printf(\"\\t1 - Normal\\n\");\n                printf(\"\\t2 - Melhor de 3\\n\");\n                printf(\"\\t3 - Startreck\\n\\t\");\n                scanf(\"%d\",&modeMenu);\n                while(modeMenu<1 || modeMenu>3){\n                    printf(\"-> Opcao invalida!\\n\");\n                    printf(\"Como voce quer jogar?\\n\\t\");\n                    scanf(\"%d\",&modeMenu);\n                }\n                system(\"cls\");\n                if (modeMenu==1) {\n                    do {\n                        printf(\"Vez do Player 1.\\n\");\n                        printf(\"Escolha uma opcao para jogar:\\n\");\n                        printf(\"\\t1 - Pedra\\n\");\n                        printf(\"\\t2 - Papel\\n\");\n                        printf(\"\\t3 - Tesoura\\n\");\n                        printf(\"Numero: \");\n                        scanf(\"%d\",&optP1);\n                        while( optP1<1 || optP1>3 ){\n                            printf(\"Opcao invalida. Digite novamente: \");\n                            scanf(\"%d\",&optP1);\n                        }\n                        system(\"cls\");\n                        printf(\"Agora o Player 2.\\n\");\n                        printf(\"Escolha uma opcao para jogar:\\n\");\n                        printf(\"\\t1 - Pedra\\n\");\n                        printf(\"\\t2 - Papel\\n\");\n                        printf(\"\\t3 - Tesoura\\n\");\n                        system(\"pause\");\n                        printf(\"Numero: \");\n                        if (playerMenu==1) {\n                            scanf(\"%d\",&optP2);\n                            while( optP2<1 || optP2>3 ){\n                                printf(\"Opcao invalida. Digite novamente: \");\n                                scanf(\"%d\",&optP2);\n                            }\n                        } else {\n                            optP2 = ( rand() % 2 ) + 1;\n                            printf(\"%d\",optP2);\n                        }\n                        totalJogadas++;\n                        totalNormal++;\n                        if (optP1==optP2) {\n                            printf(\"\\nEmpate!\\n\");\n                            empates++;\n                        } else {\n                            if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {\n                                printf(\"\\nPlayer 1 venceu!\\n\");\n                                vitoriasP1++;\n                            } else {\n                                printf(\"\\nPlayer 2 venceu!\\n\");\n                                vitoriasP2++;\n                            }\n                        }\n                        printf(\"\\nDigite 1 para jogar novamente, ou qualquer outro para sair!\");\n                        scanf(\"%d\",&novojogo);\n                        system(\"cls\");\n                }while(novojogo==1);\n                }\n                else {\n                    if (modeMenu==2) {\n                    do {\n                        tempVitP1=0;\n                        tempVitP2=0;\n                            do {\n                                system(\"cls\");\n                                printf(\"P1(%d) VS P2 (%d)\\n\",tempVitP1,tempVitP2);\n                            printf(\"Vez do Player 1.\\n\");\n                            printf(\"Escolha uma opcao para jogar:\\n\");\n                            printf(\"\\t1 - Pedra\\n\");\n                            printf(\"\\t2 - Papel\\n\");\n                            printf(\"\\t3 - Tesoura\\n\");\n                            printf(\"Numero: \");\n                            scanf(\"%d\",&optP1);\n                            while( optP1<1 || optP1>3 ){\n                                printf(\"Opcao invalida. Digite novamente: \");\n                                scanf(\"%d\",&optP1);\n                            }\n                            system(\"cls\");\n                            printf(\"Agora o Player 2.\\n\");\n                            printf(\"Escolha uma opcao para jogar:\\n\");\n                            printf(\"\\t1 - Pedra\\n\");\n                            printf(\"\\t2 - Papel\\n\");\n                            printf(\"\\t3 - Tesoura\\n\");\n                            system(\"pause\");\n                            printf(\"Numero: \");\n                            if (playerMenu==1) {\n                                scanf(\"%d\",&optP2);\n                                while( optP2<1 || optP2>3 ){\n                                    printf(\"Opcao invalida. Digite novamente: \");\n                                    scanf(\"%d\",&optP2);\n                                }\n                            } else {\n                                optP2 = ( rand() % 2 ) + 1;\n                                printf(\"%d\",optP2);\n                            }\n                            if (optP1==optP2) {\n                                printf(\"\\nEmpate!\\n\");\n                                empates++;\n                            } else {\n                                if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {\n                                    printf(\"\\nPlayer 1 venceu a rodada!\\n\");\n                                    tempVitP1++;\n                                } else {\n                                    printf(\"\\nPlayer 2 venceu a rodada!\\n\");\n                                    tempVitP2++;\n                                }\n                            }\n                            system(\"pause\");\n                    }while( tempVitP1<2 && tempVitP2<2 );\n                        totalJogadas++;\n                        totalMelhor++;\n                        system(\"cls\");\n                        if (tempVitP1 > tempVitP2) {\n                            printf(\"\\nPlayer 1 venceu a partida!\\n\");\n                            vitoriasP1++;\n                        } else {\n                            printf(\"\\nPlayer 2 venceu a partida!\\n\");\n                            vitoriasP2++;\n                        }\n                        system(\"pause\");\n                        system(\"cls\");\n                        printf(\"\\nDigite 1 para jogar novamente, ou qualquer outro para sair!\");\n                        scanf(\"%d\",&novojogo);\n                        system(\"cls\");\n                    }while(novojogo==1);\n                    } else {\n                        if (modeMenu==3) {\n                            do {\n                        printf(\"Vez do Player 1.\\n\");\n                        printf(\"Escolha uma opcao para jogar:\\n\");\n                        printf(\"\\t1 - Pedra\\n\");\n                        printf(\"\\t2 - Papel\\n\");\n                        printf(\"\\t3 - Tesoura\\n\");\n                        printf(\"\\t4 - Lagarto\\n\");\n                        printf(\"\\t5 - Spoc\\n\");\n                        printf(\"Numero: \");\n                        scanf(\"%d\",&optP1);\n                        while( optP1<1 || optP1>5 ){\n                            printf(\"Opcao invalida. Digite novamente: \");\n                            scanf(\"%d\",&optP1);\n                        }\n                        system(\"cls\");\n                        printf(\"Agora o Player 2.\\n\");\n                        printf(\"Escolha uma opcao para jogar:\\n\");\n                        printf(\"\\t1 - Pedra\\n\");\n                        printf(\"\\t2 - Papel\\n\");\n                        printf(\"\\t3 - Tesoura\\n\");\n                        printf(\"\\t4 - Lagarto\\n\");\n                        printf(\"\\t5 - Spoc\\n\");\n                        system(\"pause\");\n                        printf(\"Numero: \");\n                        if (playerMenu==1) {\n                            scanf(\"%d\",&optP2);\n                            while( optP2<1 || optP2>5 ){\n                                printf(\"Opcao invalida. Digite novamente: \");\n                                scanf(\"%d\",&optP2);\n                            }\n                        } else {\n                            optP2 = ( rand() % 4 ) + 1;\n                            printf(\"%d\",optP2);\n                        }\n                        totalJogadas++;\n                        totalStartrek++;\n                        if (optP1==optP2) {\n                            printf(\"\\nEmpate!\\n\");\n                            empates++;\n                        } else {\n                            if (\n                                (optP1==PEDRA&&optP2==TESOURA) ||\n                                (optP1==PEDRA&&optP2==LAGARTO) ||\n                                (optP1==LAGARTO&&optP2==PAPEL) ||\n                                (optP1==LAGARTO&&optP2==SPOCK) ||\n                                (optP1==SPOCK&&optP2==PEDRA) ||\n                                (optP1==SPOCK&&optP2==TESOURA) ||\n                                (optP1==TESOURA&&optP2==LAGARTO) ||\n                                (optP1==TESOURA&&optP2==PAPEL) ||\n                                (optP1==PAPEL&&optP2==PEDRA) ||\n                                (optP1==PAPEL&&optP2==SPOCK)\n                            ) {\n                                printf(\"\\nPlayer 1 venceu!\\n\");\n                                vitoriasP1++;\n                            } else {\n                                printf(\"\\nPlayer 2 venceu!\\n\");\n                                vitoriasP2++;\n                            }\n                        }\n                        printf(\"\\nDigite 1 para jogar novamente, ou qualquer outro para sair!!\");\n                        scanf(\"%d\",&novojogo);\n                        system(\"cls\");\n                    }while(novojogo==1);\n                        }\n                    }\n                }\n        }\n        else {\n            if (mainMenu==2) {\n                printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n                printf(\"\\n\\n\\tREGRAS:\\n\");\n                printf(\"\\tNo Jokenpo, os jogadores devem escolher numeros, no qual cada numero representa um simbolo.\\n\");\n                printf(\"\\tEsses simbolos sao comparados para ver quem ganhou, da seguinte forma:\\n\");\n                printf(\"\\t\\t- PEDRA ganha da TESOURA (quebrando-a).\\n\");\n                printf(\"\\t\\t- TESOURA ganha do PAPEL (cortando-o).\\n\");\n                printf(\"\\t\\t- PAPEL ganha da PEDRA (embrulhando-o).\\n\");\n                printf(\"\\tNa variacao Star Trek as regras anteriores permanecem, e outras sao adicionadas:\\n\");\n                printf(\"\\t\\t- PEDRA ganha do LAGARTO (esmagando-o).\\n\");\n                printf(\"\\t\\t- TESOURA ganha do LAGARTO (matando-o).\\n\");\n                printf(\"\\t\\t- PAPEL ganha do SPOCK (cegando-o).\\n\");\n                printf(\"\\t\\t- LAGARTO ganha do PAPEL (comendo-o).\\n\");\n                printf(\"\\t\\t- LAGARTO ganha do SPOCK (envenenando-o).\\n\");\n                printf(\"\\t\\t- SPOCK ganha da PEDRA (vaporizando-a).\\n\");\n                printf(\"\\t\\t- SPOCK ganha da TESOURA (quebrando-a).\\n\\n\");\n                system(\"pause\");\n            } else {\n                if (mainMenu==3) {\n                    printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n                    printf(\"\\n\\n\\tTotal de Jogadas: %d\\n\",totalJogadas);\n                    printf(\"\\t\\tEmpates: %d\\n\",empates);\n                    percentP1=(100.0*vitoriasP1)/totalJogadas;\n                    printf(\"\\t\\tVitorias Player 1: %d(%f%%)\\n\",vitoriasP1,percentP1);\n                    percentP2=(100.0*vitoriasP2)/totalJogadas;\n                    printf(\"\\t\\tVitorias Player 2: %d(%f%%)\\n\",vitoriasP2,percentP2);\n                    printf(\"\\tJogadas no Modo Normal: %d\\n\",totalNormal);\n                    printf(\"\\tJogadas no Modo Melhor de 3: %d\\n\",totalMelhor);\n                    printf(\"\\tJogadas no Modo Star Trek: %d\\n\",totalStartrek);\n                    system(\"pause\");\n                } else if (mainMenu==0) {\n                    do {\n                        tempVitP1=0;\n                        tempDeath=0;\n                            do {\n                            printf(\"\\tDEATMATCH\\n\");\n                            printf(\"\\tEste e o modo especial de Jokenpo. Resista o maximo que puder e veja quantas partidas seguidas voce consegue vencer!\\n\");\n                            system(\"cls\");\n                            printf(\"P1(%d) VS P2 (%d)\\n\",tempVitP1,tempVitP2);\n                            printf(\"Vez do Player 1.\\n\");\n                            printf(\"Escolha uma opcao para jogar:\\n\");\n                            printf(\"\\t1 - Pedra\\n\");\n                            printf(\"\\t2 - Papel\\n\");\n                            printf(\"\\t3 - Tesoura\\n\");\n                            printf(\"Numero: \");\n                            scanf(\"%d\",&optP1);\n                            while( optP1<1 || optP1>3 ){\n                                printf(\"Opcao invalida. Digite novamente: \");\n                                scanf(\"%d\",&optP1);\n                            }\n                            system(\"cls\");\n                            printf(\"Agora o Player 2.\\n\");\n                            printf(\"Escolha uma opcao para jogar:\\n\");\n                            printf(\"\\t1 - Pedra\\n\");\n                            printf(\"\\t2 - Papel\\n\");\n                            printf(\"\\t3 - Tesoura\\n\");\n                            system(\"pause\");\n                            printf(\"Numero: \");\n                            optP2 = ( rand() % 2 ) + 1;\n                            printf(\"%d\",optP2);\n                            if (optP1==optP2) {\n                                printf(\"\\nEmpate!\\n\");\n                                empates++;\n                            } else {\n                                if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {\n                                    printf(\"\\nPlayer 1 venceu a rodada!\\n\");\n                                    tempVitP1=1;\n                                    tempDeath++;\n                                } else {\n                                    printf(\"\\nPlayer 2 venceu a rodada e encerrou a partida!\\n\");\n                                    tempVitP1=2;\n                                }\n                            }\n                            system(\"pause\");\n                    }while( tempVitP1==1 );\n                        totalJogadas++;\n                        totalDeath++;\n                        system(\"cls\");\n                            printf(\"\\nVoce ganhou: %d partidas!\\n\",tempDeath);\n                            vitoriasP1++;\n                        system(\"pause\");\n                        system(\"cls\");\n                        printf(\"\\nDigite 1 para jogar novamente, ou qualquer outro para sair!\");\n                        scanf(\"%d\",&novojogo);\n                        system(\"cls\");\n                    }while(novojogo==1);\n                }\n            }\n        }\n    }while(mainMenu>=1 && mainMenu<=3);\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insertion_sort.1.c", "original_string": "void printarray(int a[],int n)\n{\n    int i;\n    for(i=0;i<n;i++)\n        printf(\"%d\\t\",a[i]);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__DemoFOTAUpdateSelfTest.3.c", "original_string": "void validateFirmwareUpdateReversion(void)\n{\n  printf(\"Validating previous firmware\\n\");\n  if (runRandomSelfTest(SIMULATED_REVERSION_SUCCESS_RATE)) \n  {\n    printf(\"Firmware update successfully reverted\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_REVERSION_SUCCEEDED);\n  }\n  else\n  {\n    printf(\"Firmware update reversion failed\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_REVERSION_FAILED);\n  }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__InsertionAtGiven.2.c", "original_string": "int main(){\n     struct InsertionAtGiven*head,\n     *second,\n     *third,\n     *fourth,\n     *fifth;\n     head = (struct InsertionAtGiven * )malloc(sizeof(struct InsertionAtGiven));\n     second = (struct InsertionAtGiven *)malloc(sizeof(struct InsertionAtGiven));\n     third = (struct InsertionAtGiven *)malloc(sizeof( struct InsertionAtGiven));\n     fourth = (struct InsertionAtGiven *)malloc(sizeof(struct InsertionAtGiven));\n     fifth = (struct InsertionAtGiven *)malloc(sizeof(struct InsertionAtGiven));\n     head->data=100;\n     head->next=second;\n     second->data=200;\n     second->next=third;\n     third->data=300;\n     third->next=fourth;\n     fourth->data=400;\n     fourth->next=NULL;\n     listTravesal(head);\n     head = insertAfterValue(head, 200, 550);\n     listTravesal(head);\n     return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__BinHexConverter0.2.c", "original_string": "size_t convertBinValueToHexString8(uint8_t inputValue, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < 2) \n  {\n    return 0;\n  }\n  outputStr[0] = convertBinValueToHexDigit(((inputValue & 0xF0u) >> 4), upperCase);\n  outputStr[1] = convertBinValueToHexDigit((inputValue & 0x0Fu), upperCase);\n  return 2;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc-a.4.c", "original_string": "void preorder(list *root)\n{\n    if (root != NULL)\n    {\n        printf(\"   %d \\n\", root->key); \n        preorder(root->left);\n        preorder(root->right);\n    }\n}"}
{"author": "2security", "file": "File__7MergeTwoFile.2.c", "original_string": "FILE *openfile(char *path,char *mode)\n    {\n    FILE *fp;\n    fp=fopen(path,mode);\n    if(fp==NULL)\n        {\n        perror(\"File opening error (:\");\n        getch();\n        exit(0);\n        }\n    return fp;\n    }"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__DemoFOTAUpdateWorkflow.5.c", "original_string": "static bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)\n{\n  switch (instance->__currentState)\n  {\n    case DemoFOTAUpdateWorkflowEngine_idle__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          printf(\"Cannot handle firmware over-the-air update request (missing network connection)\\n\");\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_connected__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) != 0) \n          {\n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;\n            instance->updateInfo.version = (*((char **)((arguments[0]))));\n            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) \n            {\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) \n            {\n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) == 0) \n          {\n            printf(\"Ignoring firmware over-the-air update request to version %s as this version is already running\\n\", (*((char **)((arguments[0])))));\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_downloading__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) \n          {\n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            saveState(DemoFOTAUpdateWorkflowEngine_activating__state);\n            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) \n            {\n              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) \n            {\n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_restarting__state:\n    {\n      switch (event)\n      {\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_activating__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            validateFirmwareUpdateActivation();\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n            }\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED) \n          {\n            bool __transitionResult = true;\n            saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n            if (!fotahub_confirmFirmwareUpdate(&instance->updateInfo)) \n            {\n              __transitionResult = false;\n            }\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n            }\n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_FAILED) \n          {\n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            saveState(DemoFOTAUpdateWorkflowEngine_reverting__state);\n            if (!fotahub_revertFirmwareUpdate(&instance->updateInfo)) \n            {\n              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            if (!__transitionResult) \n            {\n              return false;\n            }\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_reverting__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            validateFirmwareUpdateReversion();\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_reverting__state) \n            {\n            }\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n          instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n          DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return true;\n}"}
{"author": "jdes01", "file": "practicassoo__practica1ej7.1.c", "original_string": "int main(){\n    pid_t pid;\n    printf(\"Soy %d el padre de todos\\n\", getpid()); \n    pid = fork();\n    switch(pid){\n        case -1: \n            printf(\"Error al crear el proceso hijo\\n\"); \n            exit(EXIT_FAILURE);\n        case 0:\n            signal(SIGUSR1, tratarSignal);      \n            printf(\"Soy %d el hijo del proceso: %d\\n\", getpid(), getppid()); \n            for (int i = 0; i < 5; i++){      \n                pause();\n            }\n            sleep(10);\n        default: \n            printf(\"Esperando a que acabe mi hijo\\n\");\n            for (int i = 0; i < 5; i++){ \n                sleep(3);\n                kill(pid, SIGUSR1);\n            }\n            sleep(3);\n            kill(pid, SIGKILL);\n    }\n  exit(EXIT_SUCCESS); \n}"}
{"author": "paawankohli", "file": "DSA-LAB__q33.1.c", "original_string": "void enqueueleft(queue *q,char n)\n{\n    if (q->front==0)\n        printf(\"Side Full\\n\");\n    else\n        q->c[--(q->front)]=n;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_any_pos_CLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_c_extended.5.c", "original_string": "uint32_t ble_lbs_c_init(ble_lbs_c_t * p_ble_lbs_c, ble_lbs_c_init_t * p_ble_lbs_c_init)\n{\n    uint32_t      err_code;\n    ble_uuid_t    lbs_uuid;\n    ble_uuid128_t lbs_base_uuid = {LBS_UUID_BASE};\n    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c);\n    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c_init);\n    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c_init->evt_handler);\n    p_ble_lbs_c->peer_lbs_db.button_cccd_handle = BLE_GATT_HANDLE_INVALID;\n    p_ble_lbs_c->peer_lbs_db.button_handle      = BLE_GATT_HANDLE_INVALID;\n    p_ble_lbs_c->peer_lbs_db.led_handle         = BLE_GATT_HANDLE_INVALID;\n    p_ble_lbs_c->peer_lbs_db.led_color_handle   = BLE_GATT_HANDLE_INVALID;\n    p_ble_lbs_c->conn_handle                    = BLE_CONN_HANDLE_INVALID;\n    p_ble_lbs_c->evt_handler                    = p_ble_lbs_c_init->evt_handler;\n    err_code = sd_ble_uuid_vs_add(&lbs_base_uuid, &p_ble_lbs_c->uuid_type);\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n    VERIFY_SUCCESS(err_code);\n    lbs_uuid.type = p_ble_lbs_c->uuid_type;\n    lbs_uuid.uuid = LBS_UUID_SERVICE;\n    return ble_db_discovery_evt_register(&lbs_uuid);\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__LP.3.c", "original_string": "void search(int key,int value)\n{\n    int index=H(key);\n    int i;\n    int ct=0;\n    if(HASH[index]==value)\n    {\n        printf(\"\\nThe value found at index %d \",index);\n        ct++;\n    }\n    else\n    {\n        for(i=index+1;i<10;i++)\n        {\n            if(HASH[i]==value)\n            {\n                printf(\"\\nValue found at index %d \",i);\n                ct++;\n                break;\n            }\n        }\n    }\n    if(ct==0)\n    {\n        printf(\"\\nThe key with that value is not found\");\n    }   \n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__menu.3.c", "original_string": "float promedio(float c1, float c2, float c3, float cf){\n    int potencia = pow(2,3);\n    float prom = (((c1 + c2 + c3) / 3) + (cf)) /2;\n    return prom;\n}"}
{"author": "dishanp", "file": "DSA__q24.1.c", "original_string": "int main()\n{\n   printf(\"Enter 1st distance\\n\");\n   printf(\"Enter Kilometres: \");\n   scanf(\"%d\", &d1.km);\n   printf(\"Enter Metres: \");\n   scanf(\"%f\", &d1.m);\n   printf(\"\\nEnter 2nd distance\\n\");\n   printf(\"Enter Kilometres: \");\n   scanf(\"%d\", &d2.km);\n   printf(\"Enter Metres: \");\n   scanf(\"%f\", &d2.m);\n   result.km = d1.km + d2.km;\n   result.m = d1.m + d2.m;\n   convert(&result);\n   printf(\"\\nSum of distances = %dkm %.1fm\\n\", result.km, result.m);\n   return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__40.0.c", "original_string": "int main(int argc, char **argv)\n{\n    FILE *arq;\n    char aux;\n    qtd_t qtd;\n    bool espaco = false, pontuacao = false, enter = false;\n    qtd.chars = 0;\n    qtd.linhas = 1;\n    qtd.palavras = 0;\n    if (argc < 2)\n    {\n        printf(\"\\nErro! N\u00e3o foram informados arquivos o suficiente\\n\\n\");\n        return 0;\n    }\n    arq = fopen(argv[1], \"r\");\n    if (arq == NULL)\n    {\n        printf(\"\\nErro ao abrir o arquivo.\\n\\n\");\n        return 0;\n    }\n    for (int i = 0; fscanf(arq, \"%c\", &aux) != EOF; i++)\n    {\n        if (aux == '\\n')\n        {\n            qtd.linhas++;\n        }\n        if (i == 0)\n        {\n            if (aux != ' ' && aux != '\\n' && aux != ',' && aux != '.' && aux != ';' && aux != ':' && aux != '?' && aux != '!')\n            {\n                qtd.chars++;\n                qtd.palavras++;\n            }\n        }\n        else\n        {\n            if (aux == ' ')\n            {\n                espaco = true;\n            }\n            else if (aux == ',' || aux == '.' || aux == ';' || aux == ':' || aux == '?' || aux == '!')\n            {\n                pontuacao = true;\n            }\n            else if (aux == '\\n')\n            {\n                enter = true;\n            }\n            else\n            {\n                qtd.chars++;\n            }\n            if ((espaco == true || pontuacao == true || enter == true) &&\\\n                (aux != ' ' && aux != '\\n' && aux != ',' && aux != '.' && aux != ';' && aux != ':' && aux != '?' && aux != '!'))\n                {\n                    qtd.palavras++;\n                    espaco = false;\n                    pontuacao = false;\n                    enter = false;\n                }\n        }\n    }\n    printf(\"\\n%s:\\n\", argv[1]);\n    printf(\"\\t-> chars: %i\\n\", qtd.chars);\n    printf(\"\\t-> palavras: %i\\n\", qtd.palavras);\n    printf(\"\\t-> linhas: %i\\n\", qtd.linhas);\n    return 0;\n}"}
{"author": "deepaliajabsingjadhav", "file": "file__file_student_info.0.c", "original_string": "void FileWrite(char *name)\n{\n    int fd = 0, ret = 0, size = 0, i = 0;\n    struct student sobj;\n    fd = open(name,O_WRONLY);\n    if(fd == -1)\n    {\n        printf(\"Unable to open file\\n\");\n        return ;\n    }\n    printf(\"Enter number of students\");\n    scanf(\"%d\",&size);\n    for(i = 1; i <= size; i++)      \n    {\n        printf(\"Enter roll number\\n\");\n        scanf(\"%d\",&sobj.Rollno);\n        printf(\"Enter Name of student\\n\");\n        scanf(\"%s\",&sobj.Name);\n        printf(\"Enter marks\\n\");\n        scanf(\"%d\",&sobj.Marks);\n        write(fd,&sobj,sizeof(sobj));   \n    }\n    close(fd);\n}"}
{"author": "fikepaci", "file": "monty__tokenize_string.4.c", "original_string": "char *get_next_word(char *str, char *delims)\n{\n    int pending = 0;\n    int i = 0;\n    while (*(str + i))\n    {\n        if (is_delim(str[i], delims))\n            pending = 1;\n        else if (pending)\n            break;\n        i++;\n    }\n    return (str + i);\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Seg.2.c", "original_string": "void add_program(int id,int size)\n{\n    int ct=get_count(),i,ch=1,id1;\n    if(ct>=size)\n    {\n        for(i=0;i<16 && size>0;i++)\n        {\n            if(Mem[i]==0)\n            {\n                Mem[i]=id;\n                size--;\n            }\n        }\n    }\n    else\n    {\n        while(ch==1)\n        {\n            printf(\"\\nIs there any possibility of removing a program : \");\n            scanf(\"%d\",&ch);\n            if(ch==1)\n            {\n                printf(\"\\nEnter id : \");\n                scanf(\"%d\",&id1);\n                rem_program(id1);\n            }\n            else\n            {\n                break;\n            }\n        }\n        ct=get_count();\n        if(ct>=size)\n        {\n            for(i=0;i<16 && size>0;i++)\n            {\n                if(Mem[i]==0)\n                {\n                    Mem[i]=id;\n                    size--;\n                }\n            }\n        }\n        else\n        {\n            printf(\"\\nNot possible\");\n        }\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_nonce.1.c", "original_string": "error_t acmeClientParseNewNonceResponse(AcmeClientContext *context)\n{\n   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))\n      return ERROR_UNEXPECTED_STATUS;\n   if(context->nonce[0] == '\\0')\n      return ERROR_INVALID_RESPONSE;\n   return NO_ERROR;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-central-scanner-with-whitelist__nrf_fstorage.5.c", "original_string": "uint8_t const * nrf_fstorage_rmap(nrf_fstorage_t const * p_fs, uint32_t addr)\n{\n    if ((p_fs == NULL) || (p_fs->p_api == NULL))\n    {\n        return NULL;\n    }\n    return (p_fs->p_api)->rmap(p_fs, addr);\n}"}
{"author": "sdukesameer", "file": "dsa__dll-ins-seq-sor-del-a.2.c", "original_string": "list* search_node(list* head, int n) \n{\n    list* dll=head;\n    while (dll!=NULL)\n    {\n        if(dll->key==n)\n            return dll;\n        dll=dll->next;\n    }\n    return NULL;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc.1.c", "original_string": "node* rec_insertion(node* root, int n)\n{\n    if(root==NULL) return createNode(n);\n    else if(n<root->data) root->left=rec_insertion(root->left,n);\n    else if(n>root->data) root->right=rec_insertion(root->right,n);\n    return root;\n}"}
{"author": "ria3999", "file": "cbnst__BISECTION-METHOD.0.c", "original_string": "void main()\n{\n    float a,b,fa,fb,c,fc;\n    do\n    {\n        printf(\"Enter interval\\n\");\n        scanf(\"%f%f\",&a,&b);\n        fa=function(a);\n        printf(\"Value of fa=%f\\n\",fa);\n        fb=function(b);\n        printf(\"Value of fb=%f\\n\",fb);\n    }while(fa*fb>0);\n    printf(\"next loop\");\n    do\n    {\n        c=(a+b)/2.0;\n        printf(\"c is now=%f\\n\",c);\n        fa=function(a);\n        fb=function(c);\n        printf(\"fb becomes=%f\\n\",fb);\n        if(fa*fb<0)\n            b=c;\n        else\n            a=c;\n        printf(\"fabs=%f\",fabs(fb));\n    }while(fabs(fb)>=0.0001);\n    printf(\"The root is %f\",c);\n}"}
{"author": "sdukesameer", "file": "dsa__pre-eva.1.c", "original_string": "int reverse(int x)\n{\n    int f=0;\n    while(x>0){\n        f=(f*10)+x%10;\n        x=x/10;\n    }\n    return f;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e20.8.c", "original_string": "bool verificarCaptchaLogico(char captcha[7][20],int alternativa){\n    int tipo,numero;\n    tipo=buscaTipo(captcha[alternativa]);\n    numero=captcha[6][0]-48;\n    if (tipo==numero) {\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}"}
{"author": "0712023", "file": "Arduino-Mood-Light-DIY-kit__Chapter2_Sensor.1.c", "original_string": "void loop() {\n  Mode_set();  \n  int poten = analogRead(POTEN_PIN);  \n  if ( Mode == 0 || Mode == 1 || Mode == 2 ) {  \n    for ( int i = 0; i < NUMPIXELS; i++ ) { \n      pixels.setPixelColor(i, pixels.Color( map(poten, 0, 1023, 0, r) , map(poten, 0, 1023, 0, g) , map(poten, 0, 1023, 0, b) ) );  \n      pixels.show(); \n    }\n  }\n  if ( digitalRead(TOUCH_PIN) == 1 ) {  \n    touch_count++;  \n    delay(10);  \n    if ( touch_count >= 100 ) {  \n      if ( r == 0 && g == 0 && b == 0 ) {  \n        r = 1;\n      }\n      else if ( r != 0 || g != 0 || b != 0 ) {  \n        r = 0;\n        g = 0;\n        b = 0;\n        Mode = 0;\n      }\n      touch_count = 0;  \n    }\n    else if ( touch && ( r != 0 || g != 0 || b != 0 ) ) {  \n      Mode++;\n      if ( Mode > Mode_EA ) {\n        cds_RGB = true;\n        Mode = 1;\n      }\n      touch = false;\n    } else;                                                   \n  }\n  else {\n    touch = true;\n    touch_count = 0 ;\n  }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__BinHexConverter0.1.c", "original_string": "uint8_t convertHexDigitToBinValue(char inputChr)\n{\n  if (inputChr >= '0' && inputChr <= '9') \n  {\n    return ((uint8_t)(inputChr - '0'));\n  }\n  else if (inputChr >= 'a' && inputChr <= 'f') {\n    return 10 + ((uint8_t)(inputChr - 'a'));\n  }\n  else if (inputChr >= 'A' && inputChr <= 'F') {\n    return 10 + ((uint8_t)(inputChr - 'A'));\n  }\n  return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__priorityqueue.2.c", "original_string": "void display(queue *q)\n{\n    int i;\n    for (i=q->front;i<q->rear;i++)\n        printf(\"%d\\t\",q->c[i]);\n    printf(\"\\n\");\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zadOsmi.6.c", "original_string": "Position MakeDirectory(Position current, char* name)\n{\n    Position newDirectory;\n    newDirectory = AllocateMemoryForDirectory();\n    strcpy(newDirectory->name, name);\n        if (!current->child)\n        {\n            current->child = newDirectory;\n        }\n        else\n        {\n            Position currentChild = current->child;\n            while (currentChild->sibling)\n                currentChild = currentChild->sibling;\n            currentChild->sibling = newDirectory;\n        }\n        return current;\n}"}
{"author": "0712023", "file": "Arduino-Mood-Light-DIY-kit__Moodlight.6.c", "original_string": "void cds_set() {\n  int cds = analogRead(CDS_PIN);\n  cds_cur = (0.99 * cds_pre) + (0.01 * cds);\n  cds_pre = cds_cur;\n  cds = cds_cur;\n  if ( cds <= cds_1 )\n    cds = cds_1;\n  else if ( cds_2 < cds )\n    cds = cds_2;\n  for (int i = 0; i < NUMPIXELS; i++) {\n    pixels.setPixelColor(i, pixels.Color( map(cds, cds_1, cds_2, 0 , r) , map(cds, cds_1, cds_2, 0 , g) , map(cds, cds_1, cds_2, 0 , b) ) );\n    pixels.show();\n  }\n}"}
{"author": "2security", "file": "Pointer__9Access2DArray.1.c", "original_string": "int main()\n    {\n        int **a,m,n,i,j,item;\n        printf(\"\\n Enter row and column of 2D array:: \");\n        scanf(\"%d%d\",&m,&n);\n        a=(int **)malloc(m*sizeof(int **));\n        for(i=0;i<m;i++)\n            a[i]=(int *)malloc(n*sizeof(int));  \n        printf(\"\\n Enter %d elements of array::\",m*n);\n        for(i=0;i<m;i++)\n        for(j=0;j<n;j++)\n            scanf(\"%d\",(*(a+i)+j));\n        printf(\"\\n The entered 2D-array is::\\n\");\n        Display(a,m,n);\n        return 0;\n    }"}
{"author": "ashlyn2002", "file": "programming-using-c__swap_array.0.c", "original_string": "int main(void) {\n    printf(\"swapping the elements in the array to another array \\n\"); \n    int n=5,i;\n    printf(\"elements in the array  1 are \\n\");\n    int a[5]={15,24,36,14,22};\n    for(i=0;i<n;i++)\n        printf(\"%d \\t\",a[i]);\n    printf(\"\\n\");\n    int temp[5];\n    for(i=0;i<n;i++)\n    {\n        temp[i]=a[i];\n    }\n    printf(\"\\n elements in the array  2 are \\n\");\n    int b[5]={20,16,95,38,45};\n    for(i=0;i<n;i++)\n        printf(\"%d \\t\",b[i]);\n    printf(\"\\n after swapping the array \\n\");\n    printf(\"\\n elements in the array  1 are \\n\");\n    for(i=0;i<n;i++)\n    {\n        a[i]=b[i];\n        printf(\"%d \\t\",a[i]);\n    }\n    printf(\"\\n elements in the array  2 are \\n\");\n    for(i=0;i<n;i++)\n    {\n        b[i]=temp[i];\n        printf(\"%d \\t\",b[i]);\n    }\n    return EXIT_SUCCESS;\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__rwserver.0.c", "original_string": "void main(int argc,char*argv[])\n{\n    int sid,sid1,rval;\n    struct sockaddr_in s,c;\n    struct iovec iov[2];\n    char b1[50],b2[50]; \n    int clen; \n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    sid=socket(AF_INET,SOCK_STREAM,6);\n    if(sid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=bind(sid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)    \n    {\n        perror(\"BIND-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    rval=listen(sid,5);\n    if(rval==-1)\n    {\n        perror(\"LISTEN-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    clen=sizeof(c);\n    sid1=accept(sid,(struct sockaddr*)&c,&clen);\n    if(sid1<0)\n    {\n        printf(\"Connection Failed\");\n    }\n    iov[0].iov_base=b1;  \n    iov[0].iov_len=50;  \n    iov[1].iov_base=b2; \n    iov[1].iov_len=50;  \n    readv(sid1,&iov[0],2);  \n    printf(\"Client Message is %s \\n %s\\n\",b1,b2);  \n    writev(sid1,&iov[0],2); \n    printf(\"Response Sent\\n\");\n    close(sid);\n    close(sid1);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CDLL.4.c", "original_string": "void insert_beg()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    temp=head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    head->pre=newnode;\n    temp->next=newnode;\n    newnode->next=head;\n    newnode->pre=temp;\n    head=newnode;\n}"}
{"author": "ankitraj311", "file": "Socket-thread__test1.0.c", "original_string": "void *myThreadFun(void *vargp) \n{ \n    int *myid = (int *)vargp; \n    static int s = 0; \n    ++s; ++g; \n    printf(\"Thread ID: %u, Static: %d, Global: %d\\n\", *myid, ++s, ++g); \n}"}
{"author": "tadeograch", "file": "sorting_algorithms__100-shell_sort.0.c", "original_string": "void shell_sort(int *array, size_t size)\n{\n    size_t n = 0, i, j;\n    int temp = 0;\n    if (size < 2)\n        return;\n    while (n <= size)\n        n = (n * 3) + 1;\n    while (n > 1)\n    {\n        n = (n - 1) / 3;\n        for (i = 0; i < size - n; i++)\n        {\n            for (j = i + n; j > 0 && j >= n; j -= n)\n            {\n                if (array[j] < array[j - n])\n                {\n                    temp = array[j - n];\n                    array[j - n] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n        print_array(array, size);\n    }\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.10.c", "original_string": "TERM* parsearrayterm(PARSER* p) {\n    TERM* t = mkterm(arrayitem);\n    t->array = (ARRAY*)malloc(sizeof(ARRAY));\n    t->array->name = p->current->token;\n    next(p);\n    checkcontent(p, \"[\");\n    t->array->exp = parseexpression(p);\n    checkcontent(p, \"]\");\n    return t;\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__MergeSort.3.c", "original_string": "void merge(int a[], int p, int q, int r) \n        { \n         int i, j, k; \n         int n1 =q-p+1; \n         int n2 =r-q; \n         count++;\n         int L[n1],R[n2]; \n         count++;\n         for(i=0;i<n1;i++)\n          {\n              count++;\n              count++;\n           L[i]=a[p+i];\n           count++;\n          }\n         for(j=0;j<n2;j++)\n          {\n              count++;\n              count++;\n           R[j]=a[q+1+j];\n           count++;\n          }\n         i=0; \n         j=0; \n         k=p; \n         count++;\n         while(i<n1 && j<n2) \n          {\n              count++;\n           if(L[i] <= R[j]) \n            {\n                count++;\n            a[k]=L[i]; \n            count++;\n            i++; \n            count++;\n            } \n           else \n            {\n                count++;\n            a[k]=R[j];\n            count++;\n            j++; \n            count++;\n            } \n            count++;\n           k++;\n          } \n         while(i<n1) \n          {\n              count++;\n           a[k]=L[i];\n           count++;\n           i++;\n           count++;\n           k++; \n           count++;\n          } \n         while(j<n2) \n          {\n           count++;\n           a[k]=R[j];\n           count++;\n           j++; \n           count++;\n           k++; \n           count++;\n          }\n        }"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica33.4.c", "original_string": "int main(){\n    srand(time(NULL));                  \n    sem_init(&mutex, 0, 1);             \n    sem_init(&full, 0, 0);              \n    sem_init(&empty, 0, n);             \n    pthread_t threadProductor[3];       \n    pthread_t threadConsumidor[3];      \n    for (int i=0; i<3; i++){\n        if(pthread_create(&threadProductor[i], NULL, productor, NULL)){                         \n            printf(\"Error, no se ha podido crear la hebra. Codigo de error %d\\n\", errno);\n            exit(EXIT_FAILURE);\n        }\n    }\n    for (int i=0; i<3; i++){                                                                    \n        if(pthread_create(&threadConsumidor[i], NULL, consumidor, NULL)){\n            printf(\"Error, no se ha podido crear la hebra. Codigo de error %d\\n\", errno);\n            exit(EXIT_FAILURE);\n        }\n    }\n    for (int i=0; i<3; i++){\n        if (pthread_join(threadProductor[i], NULL)){                                            \n            printf(\"Error, no se ha podido recoger la hebra. Codigo de error %d\\n\", errno);\n            exit(EXIT_FAILURE);\n        }\n    }\n    for (int i=0; i<3; i++){\n        if (pthread_join(threadConsumidor[i], NULL)){                                           \n            printf(\"Error, no se ha podido recoger la hebra. Codigo de error %d\\n\", errno);\n            exit(EXIT_FAILURE);\n        }\n    }\n    for(int i=0; i<n; i++){                                     \n        printf(\"Valor %d del buffer: %d\\n\", i+1, v[i]);\n    }\n    exit(EXIT_SUCCESS);                                         \n}"}
{"author": "MFarid94", "file": "Assignment4__Exercise8.1.c", "original_string": "int main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n    int arrayA[SIZE];\n    int arrayB[SIZE];\n    int *ptrA = arrayA;\n    int *ptrB = arrayB;\n    int i;\n    printf(\"Enter elements of first array: \");\n    for(i=0 ; i<SIZE ; i++){\n        scanf(\"%d\",ptrA);\n        ptrA++;\n    }\n    printf(\"Enter elements of second array: \");\n    for(i=0 ; i<SIZE ; i++){\n        scanf(\"%d\",ptrB);\n        ptrB++;\n    }\n    ptrA = arrayA;\n    ptrB = arrayB;\n    printf(\"\\n\");\n    printf(\"Array elements before swapping\\n\");\n    printf(\"Elements of first array:\\n\");\n    for(i=0 ; i<SIZE ; i++){\n        printf(\"ArrayA[%d] = %d\\n\",i,*ptrA);\n        ptrA++;\n    }\n    printf(\"\\n\");\n    printf(\"Elements of second array:\\n\");\n    for(i=0 ; i<SIZE ; i++){\n        printf(\"ArrayB[%d] = %d\\n\",i,*ptrB);\n        ptrB++;\n    }\n    Swap(arrayA,arrayB);\n    ptrA = arrayA;\n    ptrB = arrayB;\n    printf(\"\\n\");\n    printf(\"Array elements after swapping\\n\");\n    printf(\"Elements of first array:\\n\");\n    for(i=0 ; i<SIZE ; i++){\n        printf(\"ArrayA[%d] = %d\\n\",i,*ptrA);\n        ptrA++;\n    }\n    printf(\"\\n\");\n    printf(\"Elements of second array:\\n\");\n    for(i=0 ; i<SIZE ; i++){\n        printf(\"ArrayB[%d] = %d\\n\",i,*ptrB);\n        ptrB++;\n    }\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Linked.3.c", "original_string": "void display()\n{\n    int i;\n    printf(\"\\nDisk is : \"); \n    for(i=0;i<16;i++)\n    {\n        printf(\"\\n%d\\t%d\",disk[i].id,disk[i].next_index);\n    }\n}"}
{"author": "paawankohli", "file": "CN-Lab__tcps.0.c", "original_string": "void main () {\n    struct sockaddr_in cliadd, seradd;\n    int sockaddr_len = sizeof(seradd);\n    seradd.sin_family = AF_INET;\n    seradd.sin_port = 1326;\n    seradd.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    int serverfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (serverfd == -1) {\n        printf(\"Can't create socket\\n\");\n        exit(0);\n    }\n    if (bind(serverfd, (struct sockaddr*) &seradd, sockaddr_len) == -1) {\n        printf(\"Can't bind\\n\");\n        exit(0);\n    }\n    if (listen(serverfd, 10) == -1) {\n        printf(\"Can't listen\\n\");\n        exit(0);\n    }\n    printf(\"Waiting for connection!\\n\");\n    int clientfd = accept(serverfd, (struct sockaddr*)&cliadd, &sockaddr_len);\n    printf(\"Connection established!\\n\");\n    printf(\"IP: %s\\n\", inet_ntoa(cliadd.sin_addr));\n    printf(\"Port: %d\\n\", cliadd.sin_port);\n    int mat[100][100];\n    int i = 0;\n    while (1) {\n        int arr[100];\n        read(clientfd, arr, 100 * 4) / 4;\n        int size = arr[0];\n        if (size == 0) {\n            break;\n        }\n        for (int j = 0 ; j <= size ; j++) {\n            mat[i][j] = arr[j];\n        }\n        i++;\n        printf(\"Got line %d\\n\", 1);\n    }\n    for (int ii = 0 ; ii < i ; ii++) {\n        int size = mat[ii][0];\n        for (int j = 1 ; j <= size ; j++) {\n            printf(\"%d \", mat[ii][j]);\n        }\n        printf(\"\\n\");\n    }\n    close(clientfd);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__adc_sw_cntl.1.c", "original_string": "void adc_pot(void)\n{\n    int res,done = 1;\n    ADCR = (1<<0)|(4<<8)|(1<<21)|(1<<24); \n    while(!(ADDR & (done<<31)));\n    res = ADDR & (0x3FF<<6);   \n    res = res>>6;       \n}"}
{"author": "jose120918", "file": "sorting_algorithms__1-main.0.c", "original_string": "listint_t *create_listint(const int *array, size_t size)\n{\n    listint_t *list;\n    listint_t *node;\n    int *tmp;\n    list = NULL;\n    while (size--)\n    {\n        node = malloc(sizeof(*node));\n        if (!node)\n            return (NULL);\n        tmp = (int *)&node->n;\n        *tmp = array[size];\n        node->next = list;\n        node->prev = NULL;\n        list = node;\n        if (list->next)\n            list->next->prev = list;\n    }\n    return (list);\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example13.1.c", "original_string": "int faktoriyel(int num)\n{\n    int res=0;\n    if(num <= 0)\n        printf(\"\\nerror !\\n\");\n    else if (num==1)\n        return num;\n    else\n    {\n        res=num*faktoriyel(num-1);  \n    }   \n   return -1; \n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es21.0.c", "original_string": "void somma_armonica(int n, double* h)\n{\n    if(n == 1)\n    {\n        *h = 1.0 + *h;\n    } else {       \n        *h =  *h + (1.0/n);\n        somma_armonica(n-1,h);     \n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_DLL.8.c", "original_string": "void delete_end()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    else if(head->next==0)\n    {\n        head=0;\n        free(head);\n    }\n    else\n    {\n        temp=head;\n        while(temp->next!=0)\n        {\n            temp=temp->next;\n        }\n        temp->pre->next=0;\n        free(temp);\n    }\n}"}
{"author": "MFarid94", "file": "Assignment1__Exercise9.0.c", "original_string": "int main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);            \n    setvbuf(stderr , NULL , _IONBF , 0);\n    int grade;                                      \n    printf(\"Enter student's grade in percentage: \");\n    scanf(\"%d\",&grade);                             \n    if(grade >= 85 && grade <=100){\n        printf(\"Student's grade is Excellent\");\n    }\n    else if(grade < 85 && grade >= 75){\n        printf(\"Student's grade is Very good\");\n    }\n    else if(grade < 75 && grade >= 65){\n        printf(\"Student's grade is Good\");\n    }\n    else if(grade < 65 && grade >= 50){\n        printf(\"Student's grade is Passed\");\n    }\n    else if(grade < 50 && grade >= 0){\n        printf(\"Student's grade is Failed\");\n    }\n    else{\n        printf(\"Invalid input\");\n    }\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__row_cols.2.c", "original_string": "void cols(void)\n{\n    int val;\n    IODIR1 = IODIR1 & ~COLS;        \n    IODIR1 = IODIR1 | ROWS;         \n    val = IOPIN1 & COLS;        \n    val = val >> 17;\n    switch(val)\n    {\n        case 0x0E:  lcd_str(\"C1\");  delay(200); break;\n        case 0x0D:  lcd_str(\"C2\");  delay(200); break;\n        case 0x0B:  lcd_str(\"C3\");  delay(200); break;\n        case 0x07:  lcd_str(\"C4\");  delay(200); break;\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.19.c", "original_string": "char* lookctable(TABLE* t, bool cond, char* token, const char* fieldname) {\n    char* out = (char*)malloc(t->instsize);\n    if(!cond) {\n        int targsize = t->instsize - 1;\n        for(int i = 0; i < targsize; i++)\n            out[i] = '0';\n        out[t->instsize-1] = '\\0';\n        return out;\n    }\n    for(int i = 0; i < t->size; i++)\n        if(strcmp(t->table[2*i], token) == 0) {\n            strcpy(out, t->table[(2*i)+1]);\n            return out;\n        }\n    return NULL;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CLL.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.insert the element at the beginning position \\n\");\n    printf(\"5.insert the element at the last position \\n\");\n    printf(\"6.insert the element at any position \\n\");\n    printf(\"7.delete the element from the beginning position\\n\");\n    printf(\"8.delete the element from the last position\\n\");\n    printf(\"9.delete the element from any position\\n\");\n    printf(\"10.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=11)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"insert the element at the beginning position \\n\");\n            insert_beg();\n            break;\n            case 5:printf(\"insert the element at the last position \\n\");\n            insert_end();\n            break;\n            case 6:printf(\"insert the element at any position \\n\");\n            insert_at_pos();\n            break;\n            case 7:printf(\"delete the element from the beginning position\\n\");\n            delete_beg();\n            break;\n            case 8:printf(\"delete the element from the last position\\n\");\n            delete_end();\n            break;\n            case 9:printf(\"delete the element from any position\\n\");\n            delete_at_pos();\n            break;\n            case 10:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__unique2.3.c", "original_string": "int valid_array(int ns[], int x){\n  int sum;\n  sum = 0;\n  for(int i = 0; i < 9; i++)\n    sum += ns[i];\n  return (sum == x)? 1 : 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSL__tls13_client_misc.0.c", "original_string": "bool_t tls13IsHelloRetryRequest(const TlsServerHello *message, size_t length)\n{\n   bool_t res;\n   res = FALSE;\n   if(length >= sizeof(TlsServerHello))\n   {\n      if(!osMemcmp(&message->random, tls13HelloRetryRequestRandom,\n         sizeof(tls13HelloRetryRequestRandom)))\n      {\n         res = TRUE;\n      }\n   }\n   return res;\n}"}
{"author": "2security", "file": "Pointer__7ReverseArray.2.c", "original_string": "int main()\n    {\n        int *a,m,i;\n        printf(\"\\n Enter size of array1:: \");\n        scanf(\"%d\",&m);\n        a=(int *)malloc(m*sizeof(int *));\n        printf(\"\\n Enter %d elements of array::\",m);\n        for(i=0;i<m;i++)\n            scanf(\"%d\",&a[i]);\n        printf(\"\\n Before reverse\");\n        printf(\"\\n Array:\");\n        Display(a,m);\n        Reverse(a,m);  \n        printf(\"\\n After reverse\");\n        printf(\"\\n Array:\");\n        Display(Reverse(a,m),m);\n        return 0;\n    }"}
{"author": "davibernardos", "file": "DB-PJ__e19.1.c", "original_string": "logico validarCaptcha ( char captchaLido[6], char captchaGerado [6]) {\n    int contador, contIguais;\n    contIguais=0;\n    for (contador=0; contador<6; contador++) {\n        if( captchaLido[contador] == captchaGerado[contador]) {\n            contIguais++;\n        } else {\n            contIguais = 0;\n            break;\n        }\n    }\n    if ( contIguais == 6) {\n        return TRUE;\n    } else {\n        if(contIguais == 0) {\n            return FALSE;\n        }\n    }\n}"}
{"author": "kbtomic", "file": "Seminarski-StrukturePodataka__Travels.0.c", "original_string": "islandPointer TravelToLeftIsland(int* currentAmountOfCoins, int* numberOfFoundClues, islandPointer start, islandPointer currentIsland, stackPointer stackHead, int* flagForGameOver)\n{\n    islandPointer parentIsland = currentIsland;\n    if (HaveEnoughCoins(*currentAmountOfCoins, currentIsland->leftNext->coins))\n    {\n        *currentAmountOfCoins = SpendCoins(*currentAmountOfCoins, currentIsland->leftNext->coins);\n        currentIsland = currentIsland->leftNext;\n        PushStack(currentIsland, stackHead);\n        printf(\"%s\\n\", currentIsland->description);\n        if (isClueIsland(currentIsland))\n        {\n            printf(\"Trag je: %c\\n\", currentIsland->clue);\n            *numberOfFoundClues += 1;\n        }\n        else if (isDeathlyIsland(currentIsland, start))\n        {\n            if (HaveEnoughCoins(*currentAmountOfCoins, COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE))\n            {\n                char choice = RespawnPrint(*currentAmountOfCoins);\n                system(\"cls\");\n                if (tolower(choice) == 'd')\n                {\n                    *currentAmountOfCoins = SpendCoins(*currentAmountOfCoins, COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE);\n                    PrintCurrentPath(currentIsland, stackHead);\n                    printf(\"Status coina: %d\\n\", *currentAmountOfCoins);\n                    printf(\"Uskrsnuo si!\\n\");\n                    currentIsland = TravelToPrevIsland(parentIsland, currentIsland, stackHead);\n                }\n                else\n                {\n                    currentIsland = TravelToStartIsland(start, currentIsland, stackHead);\n                    *flagForGameOver = 1;\n                }\n            }\n            else\n            {\n                currentIsland = TravelToStartIsland(start, currentIsland, stackHead);\n                *flagForGameOver = 1;\n            }\n        }\n        else\n        {\n            PrintCurrentPath(currentIsland, stackHead);\n            currentIsland = TravelToPrevIsland(parentIsland, currentIsland, stackHead);\n        }\n    }\n    else \n    {\n        printf(\"Nazalost presiromasan si za daljnja putovanja :(!\\n\");\n        *flagForGameOver = 1;\n    }\n    return currentIsland;\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__TowerOfHanoi.0.c", "original_string": "void TOH(int n,char A,char B,char C)\n{\nif(n==1)\n{\ncount++;\nprintf(\"\\nMove %c to %c\",A,B);\ncount++;\n}\nelse\n{\nTOH(n-1,A,C,B);\ncount++;\nprintf(\"\\nMove %c to %c\",A,B);\ncount++;\nTOH(n-1,C,B,A);\ncount++;\n}\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__OptimizedBubbleSort.1.c", "original_string": "int bubbleSortOptimized(int a[], int n)            \n{\n    int i,j,temp,flag=0;                           \n    for(i=0;i<n;i++)                               \n    {\n        for(j=0;j<n-i-1;j++)\n        {\n            if(a[j] > a[j+1])\n            {\n                temp = a[j];\n                a[j] = a[j+1];\n                a[j+1] = temp;\n                flag += 1;\n            }\n        }\n        if(flag == 0)\n        {\n            break;\n        }\n    }\n    printf(\"Sorted array is:\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d \\n\",a[i]);\n    }\n}"}
{"author": "earth429", "file": "mulpre__newton_practice.0.c", "original_string": "int main(int argc, char *argv)\n{\n    double x;\n    double x0;\n    int i;\n    for (i = -5; i <= 5;i++){\n        x0 = (double)i;\n        x = newton(x0);\n        printf(\"x0 = %10.6lf, x = %10.6lf\\n\", x0, x); \n        printf(\"f(x) = %10.6lf\\n\", f(x));\n    }\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_embos.13.c", "original_string": "bool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   bool_t ret;\n   if(timeout == 0)\n   {\n      ret = OS_EVENT_Get(event);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      OS_EVENT_Wait(event);\n      ret = TRUE;\n   }\n   else\n   {\n      ret = !OS_EVENT_WaitTimed(event, OS_MS_TO_SYSTICKS(timeout));\n   }\n   return ret;\n}"}
{"author": "sdukesameer", "file": "dsa__post-eva.0.c", "original_string": "stack* createStack(unsigned int x)\n{\n    stack* ret=(stack*) malloc(sizeof(stack));\n    ret->top=-1;\n    ret->size=x;\n    ret->arr=(float*) malloc(x * sizeof(float));\n    return ret;\n}"}
{"author": "ria3999", "file": "cbnst__QUADRATIC_EQUATION.0.c", "original_string": "void main()\n{\n    float a,b,c,d,x1,x2,realpart,imaginarypart;\n    printf(\"\\n\\n***INPUT***\\n\\n\");\n    printf(\"enter coefficients a,b and c \\n\");\n    scanf(\"%f%f%f\",&a,&b,&c);\n    d=b*b-4*a*c;\n    printf(\"\\n\\n***OUTPUT***\\n\\n\");\n    if(d>0)\n    {\n        x1=(-b+sqrt(d))/(2*a);\n        x2=(-b-sqrt(d))/(2*a);\n        printf(\"root1 is %f and root2 is %f\",x1,x2);\n    }\n    else if(d==0)\n    {\n        x2=(-b)/(2*a);\n        x1=x2;\n        printf(\"equal roots are %f and %f\",x1,x2);\n    }\n    else\n    {\n        realpart=-b/(2*a);\n        imaginarypart=sqrt(-d)/(2*a);\n        printf(\"root1=%f+i%f & root2=%f-i%f\",realpart,imaginarypart,realpart,imaginarypart);\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__list-push-pop-del-rec_rev-count.3.c", "original_string": "void delete(node** head, int key)\n{\n    if(*head==NULL)\n        printf(\"CAN'T DELETE, STACK EMPTY\\n\");\n    else\n    {\n        int c=0,f=0;\n        node* prev;\n        node* cur=*head;\n        while(cur != NULL)\n        {\n            c++;\n            if(c==1)\n            {    if (cur->data==key)\n                {\n                    *head=cur->next;\n                    free(cur);\n                    cur=*head;\n                    f=1;c=0;\n                }\n                else\n                {\n                    prev=cur;\n                    cur=cur->next;\n                }\n            }\n            else\n            {\n                if(cur->data==key)\n                {\n                    prev->next=cur->next;\n                    free(cur);\n                    cur=prev->next;\n                    f=1;\n                }\n                else\n                {\n                    prev=cur;\n                    cur=cur->next;\n                }\n            }\n        }\n        if(f==0)\n            printf(\"NO MATCH FOUND\\n\");\n        else\n            printf(\"Match found!\\nAll matching elements deleted successfully.\\n\");\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__dfs.5.c", "original_string": "void dfs(graph g, int x){\n    stack s;\n    initialiseStack(&s,g.n);\n    int visited[g.n],i,f,t;\n    for(i=0;i<g.n;i++)\n        visited[i]=0;\n    printf(\"\\nFollowing is the DFS Traversal (starting from %c): \\n\",'A'+x);\n    visited[x]=1;\n    printf(\"%c\\t\",'A'+x);\n    push(&s,x);\n    while(s.top!=-1){\n        f=peek(&s);\n        t=1;\n        for(i=0; i<g.n; i++)\n            if(g.arr[f][i])\n                if(!visited[i]){\n                    visited[i]=1;\n                    printf(\"%c\\t\",'A'+i);\n                    push(&s,i);\n                    t=0;\n                    break;\n                }\n        if(t)\n            pop(&s);\n    }\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es21.1.c", "original_string": "int main(void) \n{\n    int n;\n    double risultato;\n    printf(\"Inserisci n: \");\n    scanf(\"%d\", &n);\n    somma_armonica(n, &risultato);\n    printf(\"Risultato = %lf\", risultato);\n    return 0;\n}"}
{"author": "Dhruvik-Chevli", "file": "PPLab__q40.0.c", "original_string": "int main(int argc, char* argv[])\n{\n    int rank,size;\n    int res;\n    int s;\n    MPI_Init(&argc,&argv);\n    MPI_Comm_size(MPI_COMM_WORLD,&size);\n    MPI_Comm_rank(MPI_COMM_WORLD,&rank);\n    char st[100];\n    char st1[100];\n    char* a=(char*)malloc(sizeof(char)*100);\n    char* b=(char*)malloc(100*sizeof(char));\n    char* c=(char*)malloc(199*sizeof(char));\n    char* fst=(char*)malloc(sizeof(char)*200);\n    if(rank==0)\n    {\n        scanf(\"%s\",st);\n        int k=strlen(st);\n        if(k%size!=0)\n        {\n            printf(\"String length should be divisible by the number of processes.\");\n            return 0;\n        }\n        s=k/size;\n        scanf(\"%s\",st1);\n    }\n    MPI_Bcast(&s,1,MPI_INT,0,MPI_COMM_WORLD);\n    MPI_Scatter(st,s,MPI_CHAR,a,s,MPI_CHAR,0,MPI_COMM_WORLD);\n    res=0;\n    MPI_Scatter(st1,s,MPI_CHAR,b,s,MPI_CHAR,0,MPI_COMM_WORLD);\n    for(int i=0;i<s;i++)\n    {\n        c[i*2]=a[i];\n        c[i*2+1]=b[i];\n    }\n    MPI_Gather(c,2*s,MPI_CHAR,fst,2*s,MPI_CHAR,0,MPI_COMM_WORLD);\n    if(rank==0)\n    {\n        printf(\"%s\\n\",fst);\n    }   \n    MPI_Finalize();\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BST.7.c", "original_string": "void main()\n{\n    int ch;\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter value to insert:\");\n                scanf(\"%d\",&value);\n                root=insert(root,value);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter the value to delete:\");\n                scanf(\"%d\",&value);\n                root=delete(root,value);\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the value to search:\");\n                scanf(\"%d\",&value);\n                root=search(root,value);\n                break;\n            }\n            case 4:\n            {\n                inorder(root);\n                break;\n            }\n            case 5:\n            {\n                preorder(root);\n                break;\n            }\n            case 6:\n            {\n                postorder(root);\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__list-ins-seq-sor_acend_decend.5.c", "original_string": "int main()\n{\n    int ch;\n    while(1)\n    {\n        printf(\"\\n1. SORTED ORDER\\n\");\n        printf(\"2. SEQUENTIAL ORDER\\n\");\n        printf(\"3. EXIT PROGRAM\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int x;\n            while(1)\n            {\n                printf(\"\\n1. ASCENDING ORDER\\n\");\n                printf(\"2. DESCENDING ORDER\\n\");\n                printf(\"3. EXIT\\n\");\n                printf(\"Enter choice: \");\n                scanf(\"%d\",&x);\n                if(x==1)\n                {\n                    int n;\n                    node* head=NULL;\n                    printf(\"\\n\\t ASCENDING ORDER\\n\");\n                    while(1)\n                    {\n                        printf(\"\\n1. INSERT\\n\");\n                        printf(\"2. PRINT\\n\");\n                        printf(\"3. EXIT\\n\");\n                        printf(\"Enter choice: \");\n                        scanf(\"%d\",&n);\n                        if (n==1)\n                        {\n                            int inp;\n                            printf(\"Enter the element: \");\n                            scanf(\"%d\",&inp);\n                            sorted_insert_asc(&head,inp);;\n                        }\n                        else if (n==2)\n                        {\n                            print(&head);\n                        }\n                        else if (n==3)\n                        {\n                            printf(\"Exitting, Thank you.\\n\");\n                            break;\n                        }\n                        else\n                            printf(\"INVALID CHOICE, TRY AGAIN\\n\");\n                    }\n                }\n                else if(x==2)\n                {\n                    int n;\n                    node* head=NULL;\n                    printf(\"\\n\\t DESCENDING ORDER\\n\");\n                    while(1)\n                    {\n                        printf(\"\\n1. INSERT\\n\");\n                        printf(\"2. PRINT\\n\");\n                        printf(\"3. EXIT\\n\");\n                        printf(\"Enter choice: \");\n                        scanf(\"%d\",&n);\n                        if (n==1)\n                        {\n                            int inp;\n                            printf(\"Enter the element: \");\n                            scanf(\"%d\",&inp);\n                            sorted_insert_dec(&head,inp);;\n                        }\n                        else if (n==2)\n                        {\n                            print(&head);\n                        }\n                        else if (n==3)\n                        {\n                            printf(\"Exitting, Thank you.\\n\");\n                            break;\n                        }\n                        else\n                            printf(\"INVALID CHOICE, TRY AGAIN\\n\");\n                    }\n                }\n                else if(x==3)\n                {\n                    printf(\"Exitting, Thank you.\\n\");\n                    break;\n                }\n                else\n                {\n                    printf(\"INVALID CHOICE, TRY AGAIN\\n\");\n                }\n            }\n        }\n        else if(ch==2)\n        {\n            int n;\n            node* head=NULL;\n            while(1)\n            {\n                printf(\"\\n1. INSERT\\n\");\n                printf(\"2. PRINT\\n\");\n                printf(\"3. EXIT\\n\");\n                printf(\"Enter choice: \");\n                scanf(\"%d\",&n);\n                if(n==1)\n                {\n                    int inp;\n                    printf(\"Enter the element: \");\n                    scanf(\"%d\",&inp);\n                    sequential_insert(&head,inp);\n                }\n                else if(n==2)\n                    print(&head);\n                else if(n==3)\n                {\n                    printf(\"Exitting, Thank you.\\n\");\n                    break;\n                }\n                else\n                    printf(\"INVALID CHOICE, TRY AGAIN!\\n\");\n            }\n        }\n        else if(ch==3)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n                break;\n        }\n        else\n            printf(\"SORRY, INVALID CHOICE, TRY AGAIN!\\n\");\n    }\n    return 0;\n}"}
{"author": "qtgeo1248", "file": "ProjectEuler__ans4.2.c", "original_string": "bool is_palin(size_t i, size_t num_digits) {\n    if (num_digits < 2) return true;\n    return i % 10 == i / power(10, num_digits - 1)\n        && is_palin((i % power(10, num_digits - 1)) / 10, num_digits - 2);\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise17.0.c", "original_string": "int * Swap(int a_size,int *a,int b_size,int *b)\n{\n    int temp;\n    int i;\n    for(i=0;i<b_size;i++)\n    {\n        temp = a[i];\n        a[i] = b[i];\n        b[i] = temp;\n    }\n    return a;\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__BubbleSort.1.c", "original_string": "void getdata(int x[50],int n)\n      {\n        int k;\n        printf(\"enter the value for sorting\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        } \n       }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__80.0.c", "original_string": "int main(int argc, char **argv)\n{\n    FILE *arq_1, *arq_2;\n    char aux, *texto;\n    if (argc < 3)\n    {\n        printf(\"\\nErro! N\u00e3o foram informados aquivos o suficiente.\\n\\n\");\n        return 0;\n    }\n    arq_1 = fopen(argv[1], \"r\");\n    arq_2 = fopen(argv[2], \"w\");\n    if (arq_1 == NULL || arq_2 == NULL)\n    {\n        printf(\"\\nErro ao abrir algum arquivo.\\n\\n\");\n        return 0;\n    }\n    int i = 0;\n    while (fscanf(arq_1, \"%c\", &aux) != EOF)\n    {\n        i++;\n    }\n    rewind(arq_1);\n    texto = malloc(i+1 * sizeof(char));\n    for (int j = 0; j < i; j++)\n    {\n        fscanf(arq_1, \"%c\", texto + j);\n    }\n    texto[i] = '\\0';\n    for (int j = 0; j < i; j++)\n    {\n        if (texto[j] == '/' && texto[j+1] == '/')\n        {\n            int k = j;\n            while (texto[k] != '\\n' && texto[k] != '\\0')\n            {\n                texto[k] = ' ';\n                k++;\n            }\n        }\n    }\n    fprintf(arq_2, \"%s\", texto);\n    fclose(arq_1);\n    fclose(arq_2);\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q4_poly.2.c", "original_string": "void show(struct Node *node) \n{ \n    while(node->next != NULL) \n    { \n        printf(\"%dx^%d\", node->coeff, node->pow); \n        node = node->next; \n        if(node->next != NULL) \n            printf(\" + \"); \n    }\n    printf(\"\\n\"); \n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__rounting_utils1.0.c", "original_string": "int     all_params(void)\n{\n    if (g_width != 0 && g_height != 0 && g_we != NULL && g_no != NULL\n        && g_no != NULL && g_ea != NULL && g_fr != -1 &&\n        g_fr != -1 && g_fg != -1 && g_fb != -1 && g_cr != -1 &&\n        g_cg != -1 && g_cb != -1)\n        return (1);\n    return (0);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insertion_sort.2.c", "original_string": "int main(void) {\n    printf(\"sorting the elements in the array \\n\"); \n    printf(\"insertion sort \\n \");\n    int a[5]={90,64,11,24,5};\n    int n=5;\n    printf(\"the elements in the array are :\\n \");\n    printarray(a,n);\n    printf(\"\\n after sorting elements in the array are :\\n\");\n    insertion(a,n);\n    printarray(a,n);\n    return EXIT_SUCCESS;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__os.7.c", "original_string": "CLASS* mkkeyboard(CLASS* os) {\n    CLASS* kbdclass = mkosclass(os, \"Keyboard\");\n    adddec(kbdclass, function, \"char\", \"keyPressed\");\n    adddec(kbdclass, function, \"char\", \"readChar\");\n    adddec(kbdclass, function, \"String\", \"readLine\");\n    adddec(kbdclass, function, \"int\", \"readInt\");\n    return kbdclass;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_DLL.4.c", "original_string": "void delete_end()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    else if(head->next==0)\n    {\n        head=0;\n        free(head);\n    }\n    else\n    {\n        temp=head;\n        while(temp->next!=0)\n        {\n            temp=temp->next;\n        }\n        temp->pre->next=0;\n        free(temp);\n    }\n}"}
{"author": "HakNinja", "file": "C-Basic__33strv.0.c", "original_string": "void main()\n {\n  char st[100],ch;\n  printf(\"Enter string:\");\n  gets(st);\n  int i,n,j;\n  n=strlen(st);\n  i=0;\n  j=n-1;\n  while(i<j) \n   { \n    ch=st[i];\n    st[i]=st[j];\n    st[j]=ch;\n    j--;\n    i++;\n    }\n  printf(\"Reverse of the string:\");\n  puts(st);\n  }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_7.3.c", "original_string": "void pop(struct stack* stk,FILE* fp2){\n    if(StackEmpty(stk))\n    {\n        fprintf(fp2, \"%d\\n\", -1);\n        return;\n    }\n    stk->top--;\n    fprintf(fp2,\"%d\\n\",stk->A[stk->top+1]);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__display_the_DCLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n}"}
{"author": "sahadipanjan6", "file": "Programs-in-C__Perfect_Numbers_Within_Range.1.c", "original_string": "int isPerfect(int number)\n{\n    int i = 0;\n    int sum_factors = 0;\n    for(i=1; i<number; i++)\n    {\n        if(number%i == 0)\n            sum_factors += i;\n    }\n    if(sum_factors == number)\n        return 1;\n    return 0;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler.5.c", "original_string": "void DeleteLast(PPNODE Head, PPNODE Tail)\n{\n    if(*Head == NULL && *Tail == NULL)  \n    {\n        return;\n    }\n    if(*Head == *Tail)  \n    {\n        free(*Head);\n        *Head = NULL;\n        *Tail = NULL;\n    }\n    else    \n    {\n        *Tail  = (*Tail )->prev;\n        free((*Tail)->next);      \n        (*Head)->prev = *Tail;\n        (*Tail)->next = *Head;\n    }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-central-scanner-with-whitelist__nrf_fstorage.1.c", "original_string": "ret_code_t nrf_fstorage_uninit(nrf_fstorage_t * p_fs,\n                               void           * p_param)\n{\n    ret_code_t rc;\n    NRF_FSTORAGE_PARAM_CHECK(p_fs,        NRF_ERROR_NULL);\n    NRF_FSTORAGE_PARAM_CHECK(p_fs->p_api, NRF_ERROR_INVALID_STATE);\n    rc = (p_fs->p_api)->uninit(p_fs, p_param);\n    p_fs->p_api        = NULL;\n    p_fs->p_flash_info = NULL;\n    return rc;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__linear_search.1.c", "original_string": "void printarray(int a[],int n)\n{\n    int i;\n    for(i=0;i<n;i++)\n        printf(\"%d \\t\",a[i]);\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_7.2.c", "original_string": "void push(struct stack* stk, int elem,FILE* fp2){\n    if(StackOverflow(stk))\n    {\n        fprintf(fp2, \"%d\\n\", 999);\n        return;\n    }\n    stk->top++;\n    stk->A[stk->top]=elem;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader0.5.c", "original_string": "static bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"r\");\n  if (updateInfoFile == NULL) \n  {\n    return false;\n  }\n  memset(updateInfoString, 0, updateInfoStringSize);\n  while (isWhitespace(updateInfoString))\n  {\n    if (fgets(updateInfoString, ((int32_t) updateInfoStringSize), updateInfoFile) == NULL) \n    {\n      fclose(updateInfoFile);\n      return false;\n    }\n  }\n  fclose(updateInfoFile);\n  return true;\n}"}
{"author": "sdukesameer", "file": "dsa__bfs-a.3.c", "original_string": "int dequeue(que* q){\n    int ret=q->items[0];\n    for(int i=0; i<q->end; i++)\n        q->items[i]=q->items[i+1];\n    q->end--;\n    return ret;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_24.0.c", "original_string": "int main()\n{\n    float maior_tam_aluno = 0;\n    int num_maior_aluno = 0;\n    float menor_tam_aluno = 100000;\n    int num_menor_aluno = 0;\n    int num_aluno[3];\n    float altura_aluno[3];\n    int i;\n    int j = 0;\n    for(i = 0; i <3; i++){\n            printf(\"Digite o numero do aluno %d: \",i);\n            scanf(\"%d\",&num_aluno[i]);\n            printf(\"Digite a altura do aluno %d: \",j);\n            scanf(\"%f\",&altura_aluno[i]);\n        }\n            for(j = 0; j <3; j++){\n            if(altura_aluno[j] > maior_tam_aluno){\n                maior_tam_aluno = altura_aluno[j];\n                num_maior_aluno = num_aluno[j];\n            }\n            if(altura_aluno[j] < menor_tam_aluno){\n                menor_tam_aluno = altura_aluno[j];\n                num_menor_aluno = num_aluno[j];\n            }\n    }\n    printf(\"\\n O maior aluno eh: %d %.2f \\n\",num_maior_aluno, maior_tam_aluno);\n    printf(\"\\n O menor aluno eh: %d %.2f \\n\",num_menor_aluno, menor_tam_aluno);\n    system(\"PAUSE\");\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc-a.14.c", "original_string": "int main() \n{ \n    int ch;\n    list* root=NULL;\n    while(1)\n    {\n        printf(\"\\n\");\n        printf(\"1. Insertion Using Recursive Function \\n\");\n        printf(\"2. Insertion Using Iterative Function \\n\");\n        printf(\"3. In-order Traversal  using a Recursive Function \\n\");\n        printf(\"4. Pre-order Traversal  using a Recursive Function \\n\");\n        printf(\"5. Post-order Traversal  using a Recursive Function \\n\");\n        printf(\"6. Determine the height of the Binary Search Tree \\n\");\n        printf(\"7. Construct the Binary Search Tree which is mirror image of the given Binary Search Tree \\n\");\n        printf(\"8. Count the total number of nodes of the Binary Search Tree \\n\");\n        printf(\"9. Count the total number of leaf nodes of the Binary Search Tree \\n\");\n        printf(\"10. Count the total number of internal nodes of the Binary Search Tree \\n\");\n        printf(\"11. Find maximum and minimum elements in the Binary Search Tree \\n\");\n        printf(\"12. Deallocate the memory space occupied by Binary Search Tree \\n\");\n        printf(\"13. Exit Program \\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            root=rec_insert(root,n);\n            printf(\"%d inserted in Binary Tree\\n\",n);\n        }\n        else if(ch==2)\n        {\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            root=insert(root,n);\n            printf(\"%d inserted in Binary Tree\\n\",n);\n        }\n        else if(ch==3)\n        {\n            printf(\"\\nIN-ORDER\\n\");\n            inorder(root);\n        }\n        else if(ch==4)\n        {\n            printf(\"\\nPRE-ORDER\\n\");\n            preorder(root);\n        }\n        else if(ch==5)\n        {\n            printf(\"\\nPOST-ORDER\\n\");\n            postorder(root);\n        }\n        else if (ch==6)\n        {\n            printf(\"Height of tree= %d\\n\",rec_height(root));\n        }\n        else if (ch==7)\n        {\n            mirror_ins(root);\n            printf(\"Mirror of tree constructed\\n\");\n        }\n        else if (ch==8)\n        {\n            printf(\"Total number of nodes= %d\\n\",rec_count(root));\n        }\n        else if (ch==9)   \n        {\n            printf(\"Number of leaf nodes= %d\\n\",leafcount(root));\n        }\n        else if (ch==10)\n        {\n            printf(\"Number of internal nodes= %d\\n\",InternalNodeCount(root));\n        }\n        else if (ch==11)\n        {\n            printf(\"Maximum= %d\\n\",findmax(root));\n            printf(\"Minimum= %d\\n\",findmin(root));\n        }\n        else if (ch==12)\n        {\n            deleteTree(root);\n            root=NULL;\n        }\n        else if (ch==13)\n        {\n            printf(\"Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid Choice.\\n\");\n    }\n    return 0; \n}"}
{"author": "mandarvu", "file": "msc__problem60.0.c", "original_string": "int main() {\n    int x = 2, y, z = 4;\n    printf(\"x = %d\\nz = %d\\n\", x,z);\n    printf(\"a) y = x++ + ++x => \");\n    y = x++ + ++x;\n    printf(\"%d\\n\", y);\n    x = 2;\n    printf(\"b) y = ++x + ++x => \");\n    y = ++x + ++x;\n    printf(\"%d\\n\", y);\n    x = 2;\n    printf(\"c) y = ++x + ++x + ++x => \");\n    y = ++x + ++x + ++x; \n    printf(\"%d\\n\", y);\n    x = 2;\n    printf(\"d) y = x>z = \");\n    y = x > z;\n    printf(\"%d\\n\", y);\n    printf(\"e) y = x>z?x:z = \");\n    y = x > z ? x : z;\n    printf(\"%d\\n\", y);\n    return 0;\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Reverse_Of_A_Single_Linked_List.1.c", "original_string": "void display_node(struct node*temp1)\n{\n    printf(\"THE ELEMENTS ARE:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e62.0.c", "original_string": "void cabecalho()\n{\n    printf(\"\\t____________________________________________________________\\n\");\n    printf(\"\\n\");\n    printf(\"\\t| Ingresso++ - Meu sistema de gestao de venda de ingressos |\\n\");\n    printf(\"\\n\");\n    printf(\"\\t____________________________________________________________\\n\");\n    printf(\"\\n\");\n}"}
{"author": "sdukesameer", "file": "dsa__stk-by-array.3.c", "original_string": "void peek(stack* stk)\n{\n    if(stk->top==-1)\n        printf(\"SORRY, STACK EMPTY!\\n\");\n    else\n        printf(\"Top element is %d\\n\",stk->arr[stk->top]);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q12.0.c", "original_string": "void strrev(char *str)\n{\n    int i = strlen(str) - 1, j = 0;\n    char ch;\n    while (i > j)\n    {\n        ch = str[i];\n        str[i] = str[j];\n        str[j] = ch;\n        i--;  j++;\n    }\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_27.0.c", "original_string": "int main()\n{\n    int vetor[5];\n    int primos[5];\n    int i,j;\n    int c = 0;\n    int t = 0;\n        for(i = 0; i < 5; i++){\n            printf(\"Digite um numero %d: \",i+1);\n            scanf(\"%d\",&vetor[i]);\n        }\n        for(i= 0; i < 5; i++){\n            c = 0;\n            for(j =2; j < vetor[i]; j++){\n                if(vetor[i]%j == 0){\n                    c=1;\n                    break;\n                }\n            }\n        if(c == 0){\n            primos[t] = vetor[i];\n            t++;\n        }\n    }\n    printf(\"\\n \\n Numeros primos do array : \\n \\n\");\n    for(i =0; i < t; i++){\n        printf(\"\\n %d \\n\",primos[i]);\n    }\n    system(\"PAUSE\");\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q4.2.c", "original_string": "node* copy(node *t)\n{\n    node *p;\n    if (t == NULL)\n        return NULL;\n    p = (node*)malloc(sizeof(node));\n    p->data = t->data;\n    p->left = copy(t->left);\n    p->right = copy(t->right);\n    return p;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__infixToPostfix.7.c", "original_string": "char*infixToPostfix(char* infix){\n     struct stack *sp = (struct stack *)malloc(sizeof(struct stack));\n     sp->size = 100;\n     sp->top = -1;\n     sp->arr = (char*)malloc(sp->size * sizeof(char));\n     char *postfix = (char *)malloc((strlen(infix)+1)* sizeof(char));\n     int i = 0;\n     int j = 0;\n     while(infix[i]!='\\0'){\n          if(!isOperator(infix[i])){\n               postfix[j]=infix[i];\n               j++;\n               i++;\n          }\n          else{\n               if(precedence(infix[i])> precedence(stackTop(sp))){\n                    push(sp, infix[i]);\n                    i++;\n               }\n               else\n               {\n                    postfix[j]=pop(sp);\n                    j++;\n               }\n          }\n          while(!isEmpty(sp)){\n               postfix[j]=pop(sp);\n               j++;\n          }\n          postfix[j]='\\0';\n          return postfix;\n     }\n}"}
{"author": "deessee0", "file": "Appunti-C__terzo0.1.c", "original_string": "int main(void) {\n    int dim_a = 7;\n    int *a = malloc(sizeof(int)*dim_a);\n    for(int i=0; i<dim_a; i++)\n    {\n        printf(\"a[%d]=\", i);\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\n\");\n    rimuoviDuplicati(a, &dim_a);\n    for(int i=0; i<dim_a; i++)\n    {\n        printf(\"a[%d]=\", i);\n        scanf(\"%d\", &a[i]);\n    }\n    free(a);\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__HeapSort.1.c", "original_string": "void RestoreHeapDown(int HEAP[],int index,int n)\n{\n    int val=HEAP[index];\n    int j=index*2;\n    while(j<=n)\n    {\n        if(j<n && HEAP[j]<HEAP[j+1])\n        j++;\n        if(HEAP[j]<HEAP[j/2])\n        break;\n        else\n        {\n            HEAP[j/2]=HEAP[j];\n            j=j*2;\n        }\n        HEAP[j/2]=val;\n    }\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__27_no_happy_no_2.0.c", "original_string": "int main()\n{\n  int i,j,k,x,y,no,sum=0;\n  printf(\"Enter the number to find out happy or not\");\n  scanf(\"%d\",&no);\n  while( sum != 1)\n  {\n    sum = 0;\n    while(no>0)\n    {\n      i = no % 10;\n      sum = sum + (i*i);\n      no = no / 10;\n    }\n    no = sum ;\n    printf(\"sum is %d\", sum);\n  }\n  if( sum == 1)\n  {\n    printf(\"Happy number\");\n  }\n  else\n  {\n    printf(\"Not Happy number\");\n  }\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes2.7.c", "original_string": "float minimo(float *c){\n    float min = c[0];\n    for (int i = 1; i < MAX_CALIFICACIONES; i++){\n        if (min > c[i]){\n            min = c[i];\n        }\n    }\n    return min;\n}"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__3-1.4.c", "original_string": "void change(int a[], int b, int c){\n  int aux = a[b];\n  a[b] = a[c];\n  a[c] = aux;\n}"}
{"author": "HakNinja", "file": "C-Basic__12grade.0.c", "original_string": "void main()\n {\n  float m1,m2,m3,m4,m5,per;\n  printf(\"Enter marks of five subject=\");\n  scanf(\"%f%f%f%f%f\",&m1,&m2,&m3,&m4,&m5);\n  per=(m1+m2+m3+m4+m5)/5;\n  printf(\"percentage=%f\\n\",per);\n  if(per<=100&&per>=85)\n   {\n    printf(\"Grade=A\");\n    }\n  else if(per<85&&per>=75)\n   {\n    printf(\"Grade=B\");\n    }\n  else if(per<75&&per>=55)\n   {\n    printf(\"Grade=C\");\n    }\n  else if(per<55&&per>=40)\n   {\n    printf(\"Grade=D\");\n    }\n  else\n   {\n    printf(\"FAIL\");\n    }\n  }"}
{"author": "augustogunsch", "file": "jackc__vm-translator.8.c", "original_string": "char* dotat(VMTRANSLATOR* t, char* name, char* n) {\n    int sz = sizeof(char) * (strlen(name) + strlen(n) + 3);\n    char* atstr = (char*)malloc(sz);\n    sprintf(atstr, \"@%s.%s\", name, n);\n    togarbage(t, atstr);\n    return atstr;\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad70.0.c", "original_string": "int main()\n{\n    int workHours;\n    float brutto;\n    float podatek;\n    printf(\"Podaj liczb\\251 przepracowanych godzin w tygodniu: \");\n    scanf(\"%d\", &workHours);\n    if(workHours >= 40) {\n        brutto = 40 * BASICHOUR + (workHours - 40) * BASICHOUR * OVERTIME;\n    } else {\n        brutto = workHours * BASICHOUR;\n    }\n    if (brutto <= 1200) {\n        podatek = brutto * TAX1;\n    } else if (brutto > 1200 && brutto <= 1800) {\n        podatek = 1200 * TAX1 + (brutto - 1200) * TAX2;\n    } else {\n        podatek = 1200 * TAX1 + (600) * TAX2 + (brutto - 1800) * TAX3;\n    }\n    printf(\"\\nWynagrodzenie brutto: %.2fz\\210\\n\", brutto);\n    printf(\"Podatek: %.2fz\\210\\n\", podatek);\n    printf(\"Wynagrodzenie netto: %.2fz\\210\\n\", brutto - podatek);\n    getchar();\n    return 0;\n}"}
{"author": "RafaelFelisbino-hub", "file": "FUNCOES-exercices__Exercicio4FUNCAO.0.c", "original_string": "int main() \n{\n    float volumeEsfera, equacao, PI, y, N;\n    printf(\"Digite o numero para o cubo:  \");\n    scanf_s(\"%f\", &N);\n    printf(\"Digite o valor de PI:  \");\n    scanf_s(\"%f\", &PI);\n    volumeEsfera = 4 * PI * cubo(N) / 3;\n    printf(\"O volume da esfera e:  %.2f\\n\\n\", volumeEsfera);\n    N = 0;\n    printf(\"Digite o valor de X para a equacao:  \");\n    scanf_s(\"%f\", &N);\n    printf(\"Digite o valor de Y para a equacao:  \");\n    scanf_s(\"%f\", &y);\n    equacao = cubo(N) + cubo(y) + 2;\n    printf(\"O resultado da equacao e: %.2f\\n\", equacao);\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Insert_At_Any_Position_In_Single_Linked_List.2.c", "original_string": "void insert_at_N_position(struct node*head1, struct node*temp1)\n{\n    int pos,i;\n    printf(\"\\nAt what position you want to insert?\\n\");\n    scanf(\"%d\",&pos);\n    struct node*tempo;\n    tempo = (struct node*) malloc (sizeof(struct node));\n    printf(\"Enter the data:\");\n    scanf(\"%d\",&tempo->data);\n    if(pos == 0)\n    {\n        printf(\"After Insertion, the List is:\\n\");\n        while(temp1!=NULL)\n        {\n            printf(\"%d\\t\",temp1->data);\n            temp1 = temp1->ptr;\n        }\n        printf(\"\\nSORRY!!! NO ADDITIONAL NODE IS INSERTED :(\");\n        return;\n    }\n    if(pos == 1)\n    {\n        tempo->ptr = temp1;\n        head1 = temp1 = tempo;\n        printf(\"After Insertion, The List is:\\n\");\n        while(temp1!=NULL)\n        {\n            printf(\"%d\\t\",temp1->data);\n            temp1 = temp1->ptr;\n        }\n        return;\n    }\n    for(i=1;i<pos-1;i++)\n    {\n        temp1 = temp1->ptr;\n    }\n    tempo->ptr = temp1->ptr;\n    temp1->ptr = tempo;\n    temp1 = head1;\n    printf(\"After Insertion, The List is:\\n\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__shell_client_misc.3.c", "original_string": "error_t shellClientEstablishConnection(ShellClientContext *context)\n{\n   error_t error;\n   if(context->sshConnection.state < SSH_CONN_STATE_OPEN)\n   {\n      error = shellClientProcessEvents(context);\n   }\n   else if(context->sshConnection.state == SSH_CONN_STATE_OPEN)\n   {\n      shellClientChangeState(context, SHELL_CLIENT_STATE_CONNECTED);\n      error = NO_ERROR;\n   }\n   else\n   {\n      error = ERROR_WRONG_STATE;\n   }\n   return error;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__tokenizer.11.c", "original_string": "bool isidentifier(STRING* tk) {\n    if(isdigit(tk->str[0]))\n        return false;\n    int count = tk->count - 1;\n    for(int i = 0; i < count; i++)\n        if(!isalnum(tk->str[i]) && tk->str[i] != '_')\n            return false;\n    return true;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_01.0.c", "original_string": "int* read(int n)\n{\n      int *arr;\n      arr = (int*) malloc(n* sizeof(int));\n      int i;\n      for(i=0;i<n;i++)\n       fscanf(F1,\"%d\",&arr[i]);\n      return arr;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__ssh_server.7.c", "original_string": "error_t sshServerUnloadAllHostKeys(SshServerContext *context)\n{\n   error_t error;\n   if(!context->running)\n   {\n      error = sshUnloadAllHostKeys(&context->sshContext);\n   }\n   else\n   {\n      error = ERROR_WRONG_STATE;\n   }\n   return error;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedInsertion.2.c", "original_string": "struct Node * insertAtIndex(struct Node *head, int data, int index){\n     struct Node * ptr = (struct Node *) malloc(sizeof(struct Node));\n     struct Node * p = head;\n     int i = 0;\n     while (i!=index-1)\n     {\n          p = p->next;\n          i++;\n     }\n     ptr->data = data;\n     ptr->next = p->next;\n     p->next = ptr;\n     return head;\n}"}
{"author": "zjzj-zz", "file": "1s_programing__jishojun.1.c", "original_string": "int strcmp(char *str1, char *str2){\n int r, i, a, b, c;\n char *ptr;\n for(ptr = str1; *ptr != '\\0'; ptr++){\n  a +=1;\n }\n for(ptr = str2; *ptr != '\\0'; ptr++){\n  b +=1;\n }\n if(a>b){\n  c=a;\n }else{\n  c=b;\n }\n for(i=0; i<=c; i++){\n  if(str1[i] != str2[i]){\n   if(str1[i] < str2[i]){\n    r = -1;\n    break;\n   }\n   else{\n    r = 1;\n    break;\n   }\n  }\n r = 0;\n }\n return r;\n}"}
{"author": "Dhruvik-Chevli", "file": "PPLab__q1.1.c", "original_string": "int main(int argc,char* argv[]){\n    int rank,size,*a=NULL,c;\n    long res,*b=NULL;\n    MPI_Init(&argc,&argv);\n    MPI_Comm_size(MPI_COMM_WORLD,&size);\n    MPI_Comm_rank(MPI_COMM_WORLD,&rank);\n    a=(int*)malloc(size*sizeof(int));\n    b=(long*)malloc(size*sizeof(long));\n    if(rank==0){\n        printf(\"Enter %d numbers.\\n\",size);\n        for(int i=0;i<size;i++)\n            scanf(\"%d\",&a[i]);\n    }\n    MPI_Scatter(a,1,MPI_INT,&c,1,MPI_INT,0,MPI_COMM_WORLD);\n    res=fact(c);\n    printf(\"Process[%d]: Factorial of %d is %ld\\n\",rank,c,res);\n    MPI_Gather(&res,1,MPI_LONG,b,1,MPI_LONG,0,MPI_COMM_WORLD);\n    if(rank==0){\n        res=0;\n        for(int i=0;i<size;i++) res+=b[i];\n        printf(\"Process[%d]: The sum of all factorials is %ld\\n\",rank,res);\n    }\n    MPI_Finalize();\n    return 0;\n}"}
{"author": "2security", "file": "Array__RemoveDuplicates.2.c", "original_string": "void displayarr(int arr[],int len)\n    {\n    int i;\n    for(i=0;i<len;i++)\n        printf(\"%d \",arr[i]);\n    }"}
{"author": "augustogunsch", "file": "jackc__vm-translator.14.c", "original_string": "char* mklab(VMTRANSLATOR* t) {\n    int sz = (t->classnamelen + strlen(t->currln->tokens[1]) + 4) * sizeof(char);\n    char* lab = (char*)malloc(sz);\n    sprintf(lab, \"(%s$%s)\", t->classname, t->currln->tokens[1]);\n    togarbage(t, lab);\n    return lab;\n}"}
{"author": "mandarvu", "file": "msc__problem8.0.c", "original_string": "int main()\n{\n  int rows, cols;\n  int x, y;\n  printf(\"Enter matrix dimension(row * col): \");\n  scanf(\"%d %d\",&rows, &cols);\n  int mm[rows][cols];\n  printf(\"Give values in the %d * %d matrix row-wise.\\n\", rows, cols);\n  for (int ii = 0; ii < rows; ii++)\n  {\n    for (int jj = 0; jj < cols; jj++)\n    {\n      scanf(\"%d\",&mm[ii][jj]);\n    }\n  }\n  printf(\"\\nThe array is\\n\");\n  for (int ii = 0; ii < rows; ii++)\n  {\n    for (int jj = 0; jj < cols; jj++)\n    {\n      printf(\"%d\\t\",mm[ii][jj]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"Enter (row * col) of element needed: \");\n  scanf(\"%d %d\",&x, &y);\n  if (x > rows || y > cols)\n    printf(\"Array index out of range\\n\");\n  else\n    printf(\"Value at %d * %d in the given array is: %d\\n\",x, y, mm[x - 1][y - 1]);\n  return 0;\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__101-cocktail_sort_list.1.c", "original_string": "void cocktail_sort_list(listint_t **list)\n{\n    listint_t *current;\n    int flag = 1;\n    if (list == NULL || *list == NULL || (*list)->next == NULL)\n        return;\n    current = *list;\n    while (flag > 0)\n    {\n        flag = 0;\n        while (current->next != NULL)\n        {\n            if (current->n > current->next->n)\n            {\n                swap_func(list, current);\n                print_list(*list);\n                flag = 1;\n            }\n            else\n                current = current->next;\n        }\n        if (flag == 0)\n            break;\n        flag = 0;\n        while (current->prev != NULL)\n        {\n            if (current->n < current->prev->n)\n            {\n                swap_func(list, current->prev);\n                print_list(*list);\n                flag = 1;\n            }\n            else\n                current = current->prev;\n        }\n    }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_08.7.c", "original_string": "int main(int argc, char* argv[]) {\n        int num; char s;int size;\n        int* arr;\n        F1 = fopen(argv[1], \"r\");\n        F2 = fopen(argv[2], \"w\");\n        while(1)\n        {\n        fscanf(F1 ,\"%c %d\",&s, &num);\n        if(s == 'r')\n        {\n                size = num;\n                arr = read(num);\n        }\n        else if(s == 's')\n        {\n            int nm1 = check_digit_array(arr, 6);\n            if(nm1 != 0)\n            {\n                radix_sort(arr, size);\n        display(arr, size);\n            }\n        }\n        else if(s == 'd')\n        {\n                display(arr, size);\n                fprintf(F2, \"\\n\");\n        }\n        else if(s == 't')\n                return 0;\n        }\n        return 0;\n}"}
{"author": "dishanp", "file": "Data-Structures-And-Algorithms__q20.0.c", "original_string": "void ngerearrange(int *arr, int n)\n{\n    int i, j;\n    for (i=0; i<n; i++)\n    {\n        for (j = i+1; j<n; j++)\n        {\n            if (*(arr + i) < *(arr + j))\n            {\n                *(arr + i) = *(arr + j);\n                break;\n            }\n        }\n    }\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica2-4.1.c", "original_string": "void * aumentaVariableGlobal(){\n    for (int i = 0; i < 1000; i++)\n    {\n        variableGlobal++;\n        printf(\"%i\\n\", variableGlobal);\n    }\n    printf(\"la hebra ha aumentado %i veces\\n\", variableGlobal);\n    pthread_exit(NULL); \n}"}
{"author": "mehedi9021", "file": "Data_Structure__stack.4.c", "original_string": "int push(int data) {\n   if(!isfull()) {\n      top = top + 1;\n      stack[top] = data;\n   } else {\n      printf(\"Could not insert data, Stack is full.\\n\");\n   }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__binarySearchTree.5.c", "original_string": "struct Node*verify(struct Node*root, int value){\n     if(root==NULL){\n          printf(\"\\nThe Tree maybe Empty or value is not present...\\n\");\n          return root;\n     }\n     else if(value<root->data){\n          root->left= verify(root->left, value);\n     }\n     else if(value>root->data)\n     {\n          root->right= verify(root->right, value);\n     }\n     else if(root->data==value){\n          printf(\"\\nThe value you mentioned is present in this tree..(value: %d)\\n\", root->data);\n     }\n     else{\n          printf(\"\\nValue you entered is no present..\\n\");\n     }\n     return root;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__carro.4.c", "original_string": "void tecladoEspecial(int tecla, int x, int y)\n{\n  switch (tecla)\n  {\n  case GLUT_KEY_RIGHT:\n    tx += 0.05;\n    theta -= 8.0;\n    break;\n  case GLUT_KEY_LEFT:\n    tx -= 0.05;\n    theta += 8.0;\n    break;\n  case GLUT_KEY_UP:\n    ty += 0.05;\n    break;\n  case GLUT_KEY_DOWN:\n    ty -= 0.05;\n    break;\n  default:\n    break;\n  }\n  glutPostRedisplay();\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Orthogonal_Matrix_Or_Not.0.c", "original_string": "void main()\n{\n    int i, j, k, temp, sum = 0;\n    int rows = R;\n    int columns = C;\n    int input_matrix[R][C];\n    int transposed_matrix[R][C];\n    int product_matrix[R][C];\n    printf(\"\\nEnter the matrix elements...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &input_matrix[i][j]);\n        }\n    }\n    printf(\"\\nOriginal Matrix is as follows:- \\n\");\n    display(input_matrix);\n    temp = rows;\n    rows = columns;\n    columns = rows;\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {   \n            transposed_matrix[i][j] = input_matrix[j][i];\n        }\n    }\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            for(k=0; k<R; k++)\n            {\n                sum += input_matrix[i][k] * transposed_matrix[k][j];\n            }\n            product_matrix[i][j] = sum;\n            sum = 0;\n        }\n    }\n    if(check_Identity_Matrix(product_matrix) == 0)\n        printf(\"\\nInput Matrix is orthogonal...\\n\");\n    else\n        printf(\"\\nInput Matrix is NOT orthogonal...\\n\");\n}"}
{"author": "Theemiss", "file": "simple_shell__shell.0.c", "original_string": "int check_builtin(char **cmd)\n{\n    bul_t fun[] = {\n        {\"cd\", NULL},\n        {\"help\", NULL},\n        {\"echo\", NULL},\n        {\"history\", NULL},\n        {NULL, NULL}\n    };\n    int i = 0;\n        if (*cmd == NULL)\n    {\n        return (-1);\n    }\n    while ((fun + i)->command)\n    {\n        if (_strcmp(cmd[0], (fun + i)->command) == 0)\n            return (0);\n        i++;\n    }\n    return (-1);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_any_pos_CLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d\",temp->data);\n    printf(\"\\n\");\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__taylor.0.c", "original_string": "int main()\n{\n    int n, q;\n    double a[7], x[100], xf;\n    scanf(\"%i\", &n); \n    getchar();\n    for (int i = 0; i <= n; i++)\n    {\n        scanf(\"%lf\", &a[i]); \n        getchar();\n    }\n    scanf(\"%i\", &q); \n    for (int i = 0; i < q; i++)\n    {\n        scanf(\"%lf\", &x[i]); \n        getchar();\n    }\n    putchar('\\n');\n    for (int i = 0; i < q; i++)\n    {\n        xf = f_de_x(n, a, x[i]); \n        vetor_taylor(n, a, x[i], xf); \n        putchar('\\n');\n    }\n    return 0;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__reverse_single_linked_list.1.c", "original_string": "void reverse()\n{\n    struct node* current, *prev, *temp;\n    current=head;\n    prev =NULL;\n    while(temp!=NULL)\n    {\n        temp=current->next;\n        current->next=prev;\n        prev=current;\n        current=temp;\n    }\n    head=prev;\n}"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio3.1.c", "original_string": "void *func2(void *arg){\n    printf(\"\\nHe entrado en la func2\\n\");\n        if (pthread_mutex_init(&my_lock2, NULL) != 0) { \n            printf(\"\\nThread 2 mutex init has failed\\n\"); \n            return 1;\n        }\n        pthread_mutex_lock(&my_lock2);\n        printf(\"Soy el mutex thread 2 y voy a introducir en aux todos 2\\n\");\n        for(int i = 0; i < 100; i++){\n            aux[i]=2;\n        }\n        printf(\"Thread 2:   El nuevo valor de aux es:\\n\");\n        for(int i = 0; i<100 ;i++){\n            printf(\"%d, \",aux[i]);\n        }\n        pthread_mutex_unlock(&my_lock2);\n    pthread_exit(NULL);\n}"}
{"author": "Oryx-Embedded", "file": "Common__date_time.7.c", "original_string": "uint8_t computeDayOfWeek(uint16_t y, uint8_t m, uint8_t d)\n{\n   uint_t h;\n   uint_t j;\n   uint_t k;\n   if(m <= 2)\n   {\n      m += 12;\n      y -= 1;\n   }\n   j = y / 100;\n   k = y % 100;\n   h = d + (26 * (m + 1) / 10) + k + (k / 4) + (5 * j) + (j / 4);\n   return ((h + 5) % 7) + 1;\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad101.0.c", "original_string": "int main()\n{\n    int endProgram = 0;\n    while(!endProgram) {\n        int userCategory;\n        float userIncome;\n        float userTax;\n        int userChoice;\n        int valueOK = 0;\n        while(!valueOK) {\n            printf(\"********************************************************************\\n\");\n            printf(\"Wybierz odpowiednia opcje:\\n\");\n            printf(\"1) Stan wolny\\t\\t\\t2) Glowa rodziny\\n\");\n            printf(\"3) Malzenstwo, wspolnie\\t\\t4) Malzenstwo, osobno\\n\");\n            printf(\"5) wyjscie\\n\");\n            printf(\"********************************************************************\\n\");\n            userChoice = getchar();\n            switch (userChoice) {\n                case '1' : {\n                    userCategory = FREE;\n                    printf(\"Wybrano [Stan wolny]\\n\");\n                    valueOK = 1;\n                    break;\n                }\n                case '2' : {\n                    userCategory = HEAD;\n                    printf(\"Wybrano [Glowa rodziny]\\n\");\n                    valueOK = 1;\n                    break;\n                }\n                case '3' : {\n                    userCategory = MARRIEDT;\n                    printf(\"Wybrano [Malzenstwo, wspolnie]\\n\");\n                    valueOK = 1;\n                    break;\n                }\n                case '4' : {\n                    userCategory = MARRIEDS;\n                    printf(\"Wybrano [Malzenstwo, osobno]\\n\");\n                    valueOK = 1;\n                    break;\n                }\n                case '5' : {\n                    valueOK = 1;\n                    endProgram = 1;\n                    break;\n                }\n                default : fflush(stdin);\n            }\n        }\n        if (!endProgram) {\n            printf(\"Podaj dochod podlegajacy opodatkowaniu: \");\n            scanf(\"%f\", &userIncome);\n            if(userIncome <= userCategory){\n                userTax = TAX1 * userIncome;\n            } else {\n                userTax = TAX1 * userCategory + (userIncome - userCategory) * TAX2;\n            }\n            printf(\"Wysokosc naleznego podatku: %.2f$\\n\\n\", userTax);\n            getchar();\n        }\n    }\n    return 0;\n}"}
{"author": "ankitraj311", "file": "450_babbar__7_intersection_array_Geek_usorted_array.2.c", "original_string": "int remove_repeat(int arr[], int size_arr) \n{\n  for(int i = 0; i<size_arr; i++)\n  {\n    for(int j = i+1; j<size_arr;j++)\n    { \n      if(arr[i] == arr[j])\n      {\n        for(int k = j; k<size_arr; k++)\n    {\n          arr[k] = arr[k+1];\n    }\n    size_arr--;\n      }\n    }\n  }\n  return size_arr;\n}"}
{"author": "earth429", "file": "mulpre__lcm.1.c", "original_string": "int lcm(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    struct NUMBER tmp, tmp2;\n    gcd(a, b, c);\n    if(isZero(c) != -1){ \n        return 0;\n    }\n    divide(a, c, &tmp, &tmp2);\n    dispNumberZeroSuppress(&tmp);\n    dispNumberZeroSuppress(b);\n    multiple(&tmp, b, c);\n    return 0;\n}"}
{"author": "kalpa96", "file": "Struct__comple.2.c", "original_string": "struct complex subtract(struct complex n1, struct complex n2) {\n    struct complex temp1;\n    temp1.real = n1.real - n2.real;\n    temp1.imag = n1.imag - n2.imag;\n    return (temp1);\n}"}
{"author": "flora0110", "file": "hw01git__2-1tqueue.9.c", "original_string": "void path(int ***d,char ***maze,char*** road,int fr,int fc,int fh){\n    int row=fr;\n    int col=fc;\n    int hei=fh;\n    int i,j,k,nr,nc,nh;\n    road[hei][row][col]='*';\n    while(maze[hei][row][col]!='S'){\n        if ((d[hei][row+1][col]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei][row+1][col]==d[hei][row][col]-3 && maze[hei][row][col]=='T')){\n            row++;\n        }\n        else if ((d[hei][row-1][col]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei][row-1][col]==d[hei][row][col]-3 && maze[hei][row][col]=='T')){\n            row--;\n        }\n        else if ((d[hei][row][col+1]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei][row][col+1]==d[hei][row][col]-3 && maze[hei][row][col]=='T')){\n            col++;\n        }\n        else if ((d[hei][row][col-1]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei][row][col-1]==d[hei][row][col]-3 && maze[hei][row][col]=='T')){\n            col--;\n        }\n        else if(maze[hei-1][row][col]=='U' &&((d[hei-1][row][col]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei-1][row][col]==d[hei][row][col]-3 && maze[hei][row][col]=='T'))){\n            hei--;\n        }\n        else if(maze[hei+1][row][col]=='U' &&((d[hei+1][row][col]==d[hei][row][col]-1&& maze[hei][row][col]!='T') || (d[hei+1][row][col]==d[hei][row][col]-3 && maze[hei][row][col]=='T'))){\n            hei++;\n        }\n        road[hei][row][col]='*';\n    }\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es5.0.c", "original_string": "void rimuovi(int a[], int *dim){\n  for(int i=0; i<*dim; i++){\n    for(int j=i+1; j<*dim; j++){\n      if(a[i]==a[j]){\n        for(int k=j; k<*dim-1; k++){\n          a[k] = a[k+1];\n        }\n        *dim -=1;\n        j--;\n      }\n    }\n  }\n}"}
{"author": "theuwis", "file": "AdventOfCode2016__main9.0.c", "original_string": "int main(void){\n    parse_instructions();\n    max_instr = curr_instr;\n    curr_instr = 0;\n    while(curr_instr < max_instr){\n        switch(instr[curr_instr].cmd){\n            case 0 :\n                regs[instr[curr_instr].y] = regs[instr[curr_instr].x];\n                curr_instr++;\n                break;\n            case 1 :\n                regs[instr[curr_instr].y] = instr[curr_instr].x;\n                curr_instr++;\n                break;\n            case 2 :\n                regs[instr[curr_instr].x]++;\n                curr_instr++;\n                break;\n            case 3 :\n                regs[instr[curr_instr].x]--;\n                curr_instr++;\n                break;\n            case 4 :\n                if(regs[instr[curr_instr].x] != 0){\n                    curr_instr += instr[curr_instr].y;\n                }\n                else{\n                    curr_instr++;\n                }\n                break;\n            case 5:\n                if(instr[curr_instr].x != 0){\n                    curr_instr += instr[curr_instr].y;\n                }\n                else{\n                    curr_instr++;\n                }\n                break;\n            default :\n                printf(\"Not a valid instruction!\\n\");\n                exit(EXIT_FAILURE);\n        }\n    }\n    printf(\"ans=%d\\n\", regs[0]);\n    return EXIT_SUCCESS;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e92.7.c", "original_string": "int main(int argc, char *argv[]) {\n    float pagamento, troco, restante;\n    int menu, contOpera, contSelec;\n    contSelec = 0;\n    contShow = 0;\n    contOpera = 0;\n    while(contOpera <= 0)\n    {\n        printf(\"Iniciando cadastro de eventos \\n\\n\");   \n        printf(\"Informe a opcao desejada:\\n\");\n        printf(\"Digite 1 para cadastrar um evento \\n\");\n        printf(\"Digite 2 iniciar vendas \\n\");\n        scanf(\"%d\", &menu);\n        switch(menu)\n        {\n            case 1:\n            {\n                cadastrarEvento(show);\n                contShow++;\n                system(\"cls\");\n                break;\n            }\n            case 2:\n            {\n                printf(\"Iniciando operacao de vendas\\n\");\n                contOpera++;\n                break;\n            }\n            default:\n            {\n                printf(\"Informe uma opcao valida\\n\");\n                break;\n            }       \n        }   \n        if(contShow >= 10)\n        {\n            printf(\"Limite de eventos atingido, prosseguindo para venda de ingressos.\\n\");\n            contOpera++;\n        }\n    }\n    while(contOpera <= 1)\n    {\n        do{\n        printf(\"Escolha o codigo do evento que deseja participar: \\n\");\n        listarEventos(show);\n        scanf(\"%d\", &contSelec);\n        if(show[contSelec].disponiveis <= 0)\n        {\n            printf(\"Ingressos para este evento estao esgotados, retornando para a selecao. \\n\");\n        }\n        }while(show[contSelec].disponiveis <= 0);\n        printf(\"Informe a opcao desejada:\\n\");\n        printf(\"Digite 1 para comprar um ingresso inteiro. \\n\");\n        printf(\"Digite 2 para comprar meia entrada. \\n\");\n        printf(\"Digite 3 para mudar o evento selecionado. \\n\");\n        printf(\"Digite 4 para fechar as operacoes. \\n\");\n        scanf(\"%d\", &menu);\n        switch(menu)\n        {\n            case 1:\n            {\n                printf(\"Escolha a forma de pagamento: \\n\");\n                printf(\"Pressione 1 para pagamento em dinheiro com desconto ou 2 para pagamento em cartao.\\n\");\n                scanf(\"%d\", &menu);\n                switch(menu)\n                {\n                    case 1:\n                    {\n                        printf(\"Valor a ser pago: %g\\n\", (show[contSelec].valorIngresso * 0.9));            \n                        printf(\"Informe o valor do pagamento: \");\n                        do\n                        {\n                            scanf(\"%g\", &pagamento);\n                            if(pagamento < (show[contSelec].valorIngresso * 0.9))\n                            {\n                                restante = (show[contSelec].valorIngresso * 0.9) - pagamento;\n                                printf(\"Valor inserido insufuciente, faltou %g, insira o valor correto para prosseguir.\\n\", restante);  \n                            }\n                        }while(pagamento < (show[contSelec].valorIngresso * 0.9));\n                        troco = pagarDinheiroInt(contSelec, pagamento, show);\n                        printf(\"Seu troco e de: %g\\n\", troco);                      \n                        break;\n                    }\n                    case 2:\n                    {\n                        pagarCartaoInt;\n                        break;\n                    }\n                }\n                system(\"cls\");\n                break;\n            }\n            case 2:\n            {\n                if(show[contSelec].meia <= show[contSelec].cadeiras * 0.4)\n                {\n                    printf(\"Escolha a forma de pagamento: \\n\");\n                    printf(\"Pressione 1 para pagamento em dinheiro com desconto ou 2 para pagamento em cartao.\\n\");\n                    scanf(\"%d\", &menu);\n                    switch(menu)\n                    {\n                        case 1:\n                        {   \n                            printf(\"Valor a ser pago: %g\\n\", (show[contSelec].valorIngresso * 0.9 / 2) );           \n                            printf(\"Informe o valor do pagamento: \");\n                            do\n                            {\n                                scanf(\"%g\", &pagamento);\n                                if(pagamento < ((show[contSelec].valorIngresso * 0.9 / 2)))\n                                {\n                                    restante = ((show[contSelec].valorIngresso * 0.9 / 2) ) - pagamento;\n                                    printf(\"Valor inserido insufuciente, faltou %g, insira o valor correto para prosseguir.\\n\", restante);  \n                                }\n                            }while(pagamento < ((show[contSelec].valorIngresso * 0.9 / 2) ));\n                            troco = pagarDinheiroMeia(contSelec, pagamento, show);\n                            printf(\"Seu troco e de: %g \\n\", troco); \n                            break;\n                        }\n                        case 2:\n                        {\n                            pagarCartaoMeia;\n                            printf(\"O pagamento foi efetuado com sucesso.\\n\");\n                            break;\n                        }\n                    }\n                }\n                else\n                {\n                    printf(\"Ingressos para este evento estao esgotados. \\n\");\n                }\n                system(\"cls\");\n                break;              \n            }\n            case 3:\n            {\n                printf(\"Retornando para a selecao. \\n\");    \n                system(\"cls\");          \n                break;\n            }\n            case 4:\n            {\n                printf(\"Encerrando operacao de vendas. \\n\");\n                contOpera++;\n                break;\n            }\n            default:\n            {\n                printf(\"Informe uma opcao valida. \\n\");\n                break;\n            }\n        }\n    }\n    printf(\"Operacao de vendas encerradas.\\n\");\n    informarDados(show);\n    return 0;\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__Frecuency_of_Numbers_In_Array.0.c", "original_string": "int main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    int a[50], b[50];\n    printf(\"The elements are\\n\");\n    int i,j;\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n        b[i] = -1;\n    }\n    for(i=0;i<n;i++)\n    {\n        int count = 1;\n        for(j=i+1;j<n;j++)\n        {\n            if(a[i] == a[j])\n            {\n                count++;\n                b[j] = 0;\n            }\n        }\n        if(b[i]!=0)\n        {\n            b[i] = count;\n        }\n    }\n    printf(\"Frequencies are:\\n\");\n    for(i=0;i<n;i++)\n    {\n        if(b[i]!=0)\n        {\n            printf(\"%d occurence is : %d\\n\", a[i],b[i]);\n        }\n    }\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_cmsis_rtos2.24.c", "original_string": "void osFreeMem(void *p)\n{\n   if(p != NULL)\n   {\n      TRACE_DEBUG(\"Freeing memory at 0x%08X\\r\\n\", (uint_t) p);\n      osSuspendAllTasks();\n      free(p);\n      osResumeAllTasks();\n   }\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-structure.2.c", "original_string": "int getobjsize(CLASS* c) {\n    CLASSVARDEC* curr = c->vardecs;\n    int count = 0;\n    while(curr != NULL) {\n        if(curr->type == field)\n            count += countstrs(curr->base->names);\n        curr = curr->next;\n    }\n    return count;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__BI-1.0.c", "original_string": "int main()\n{\n    char str[1001], aux[1002], aux2[1002];\n    int tam, tam2, tam3, busca;\n    scanf(\"%1001[^\\n]s\", str);\n    tam = strlen(str);\n    for (int i = 1; i < tam; i++)\n    {\n        for (int j = 0; j <= i; j++)\n        {\n            aux[j] = str[j];\n        }\n        tam2 = strlen(aux);\n        for (int j = 0; j < tam2; j++)\n        {\n            if ((int) aux[j] != (int) str[j])\n                aux[j] = '\\0';\n        }\n        tam2 = strlen(aux);\n        printf(\"%s %i\\n\", aux, tam2);\n        for (int j = tam2 - 2; j > 0; j--)\n        {\n            for (int k = 0; aux[j + k] != '\\0'; k++)\n            {\n                for (int l = k; (l <= j + k)&&(str[l + tam2] != '\\0'); l++)\n                {\n                    printf(\"%c %c\\n\", aux[l], str[l + j]);\n                }\n                putchar('\\n');\n            }\n        }\n        for (int j = tam2 - 1; j <= 0; j--)\n        {\n            aux[j] = '\\0';\n        } \n    }\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__count_the_elem_in_LL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    int count=0;\n    temp=head;\n    while(temp!=0)\n    {\n        count++;\n        temp=temp->next;\n    }\n    printf(\"the number of element in linked list is %d\", count);\n    printf(\"\\n\");\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise22.0.c", "original_string": "int removeDuplicates(int arr_old[], int n_old, int arr_new[], int *n_new)\n{\n    int i=0;\n    if (n_old==0)\n        return ERROR;\n    for (i=0 ; i<n_old-1 ; i++)\n    {\n        if (arr_old[i] != arr_old[i+1])\n        {\n            arr_new[*n_new] = arr_old[i];\n            (*n_new)++;\n        }\n    }\n    arr_new[*n_new] = arr_old[i];\n    (*n_new)++;\n    return SUCCESS;\n}"}
{"author": "sdukesameer", "file": "dsa__Md_Sameer_13000119114.13.c", "original_string": "void display_tree(list* root, int n){\n    if (root==NULL){\n        for (int i = 0; i < n-2; i++)\n            printf(\" \");\n        printf(\"NULL\\n\");\n    }\n    else{\n        display_tree(root->right,n+5);\n        for (int i = 0; i < n+2; i++)\n            printf(\" \");\n        printf(\"/\\n\");\n        for (int i = 0; i < n; i++)\n            printf(\" \");\n        printf(\"%d\\n\",root->key);\n        for (int i = 0; i < n+2; i++)\n            printf(\" \");\n        printf(\"\\\\\\n\");\n        display_tree(root->left,n+5);\n    }\n}"}
{"author": "DanielSalis", "file": "AED1__teste8.2.c", "original_string": "node* search(node* root, int key){\n    if(root == NULL){\n        return NULL;\n    }\n    if (root->key == key)\n       return root;\n    if (root->key > key)\n       return search (root->left, key);\n    else\n       return search (root->right, key);\n}"}
{"author": "sdukesameer", "file": "dsa__bfs-a.6.c", "original_string": "int main(){\n    gph g;\n    int f=1,s;\n    input(&g);\n    printf(\"\\n\\' If\");\n    for(int i=0; i<g.n;i++)\n        printf(\" %c=%d\",'A'+i,i+1);\n    printf(\" \\'\\nEnter the initial vertex: \");\n    while(f){\n        scanf(\"%d\",&s);\n        if(s>0 && s<g.n+1)\n            f=0;\n        else\n            printf(\"Invalid input.\\n\");\n    }\n    bfs(g,s-1);\n    free_graph(&g);\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_2.1.c", "original_string": "void push(int ele)\n{\n    if(isFull())\n    {\n        printf(\"Stack is Full \\n\");\n    }\n    else\n    {\n        top++;\n        stack[top] = ele;\n        printf(\"%d pushed \\n\", ele);\n    }\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example4_1.0.c", "original_string": "int main (void)\n{\n    int i,binary[SIZE];\n    printf(\"%s\\n\",\"onluk tabana d\u00f6n\u00fc\u015ft\u00fcrmek istedi\u011finiz binary de\u011ferini giriniz:\");\n    for(i=0;i<SIZE;i++)\n        scanf(\"%d\",&binary[i]);\n    printf(\"binary say\u0131:\");\n    for(i=0;i<SIZE;i++)\n        printf(\"%d\",binary[i]);\n    printf(\"\\n onluk bi\u00e7im:%d\",tabanDonusumu(binary));\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es41.1.c", "original_string": "void stampa_vettore(int a[], int dim)\n{\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        printf(\"%d\\n\", a[i]);\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__BD.0.c", "original_string": "int main()\n{\n    char t[1002], p[102];\n    int tamt, tamp, busca;\n    fgets(t, 1002, stdin);\n    fgets(p, 102, stdin);\n    for (int i = 0; t[i] != '\\0'; i++)\n    {\n        if (t[i] == '\\n')\n        {\n            t[i] = '\\0';\n        }\n    }\n    for (int i = 0; p[i] != '\\0'; i++)\n    {\n        if (p[i] == '\\n')\n        {\n            p[i] = '\\0';\n        }\n    }\n    tamt = strlen(t);\n    tamp = strlen(p);\n    for (int i = 0; i <= (tamt - tamp); i++)\n    {\n        if (t[i] == p[0])\n        {\n            busca = true;\n            for (int k = 0; k < tamp; k++)\n            {\n                if (t[i+k] != p[k])\n                {\n                    busca = false;\n                    break;\n                }\n            }\n            if (busca == true)\n            {\n                printf (\"%i \", i);\n            }\n        }\n    }\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_05.0.c", "original_string": "int* read(int n)\n{\n        flag++;\n        int i;\n        int s = sizeof(int);\n        int* arr1= (int*)malloc(s * n);\n        for(i = 0; i<n; i++)\n        {\n                fscanf(F1, \"%d\", (arr1+i));\n        }\n        return arr1;\n}"}
{"author": "ankitraj311", "file": "450_babbar__6_union_array_Geek_usorted_array.0.c", "original_string": "void array_print(int arr[], int no)  \n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-2new0.2.c", "original_string": "int*** make3darrint(int rows, int cols,int hei){\n    int ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__BA.2.c", "original_string": "void main()\n{\n    int i,j,pr;\n    printf(\"\\nEnter the available resources  : \");\n    for(i=0;i<m;i++)\n        scanf(\"%d\",&available[i]);\n    printf(\"\\nEnter maximum : \");   \n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nfor process %d : \",i);\n        for(j=0;j<m;j++)\n        {\n            scanf(\"%d\",&max[i][j]);\n        }\n    }\n    printf(\"\\nEnter allocation : \");    \n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nfor process %d : \",i);\n        for(j=0;j<m;j++)\n        {\n            scanf(\"%d\",&allocation[i][j]);\n        }\n    }\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<m;j++)\n        {\n            need[i][j]=max[i][j]-allocation[i][j];\n        }\n    }\n    printf(\"\\nenter the process to take request : \");\n    scanf(\"%d\",&pr);\n    printf(\"\\nEnter request : \");\n    for(j=0;j<m;j++)\n    {\n        scanf(\"%d\",&request[pr][j]);\n    }\n    resource_request(pr);\n}"}
{"author": "mehedi9021", "file": "Data_Structure__create_list_with_function.0.c", "original_string": "int main()\n    {\n        int n,data;\n        printf(\"Enter the number of list:\");\n        scanf(\"%d\", &n);\n        createlist(n);\n        printf(\"\\nDisplay\\n\");\n        displaylist();\n        return 0;\n    }"}
{"author": "kalpa96", "file": "c-programing__power.1.c", "original_string": "int po(int n1, int n2){\n    int i,sum=0;\n    if(n1>n2){  \n        for(i=n2;i<=n1;i++){\n            sum = sum + i*i;\n    }\n        printf(\"sum = %d\",sum);\n    }\n    else{\n        for(i=n1;i<=n2;i++){\n            sum= sum + i*i;         \n        }\n        printf(\"sum = %d\",sum);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__dequeue.0.c", "original_string": "void enqueueright(queue *q,int n)\n{\n    if (q->rear==20)\n        printf(\"Side Full\\n\");\n    else\n        q->c[(q->rear)++]=n;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__double_linked_list_create.2.c", "original_string": "void displayListFromFirst()\n{\n    struct node * temp;\n        temp = head;\n        printf(\"\\n\\nDATA IN THE LIST From First:\\n\");\n        while(temp != NULL)\n        {\n            printf(\"DATA = %d\\n\", temp->data);\n            temp = temp->next;\n        }\n    }"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__utils.4.c", "original_string": "char    *ft_strjoi(char *s1, char *s2)\n{\n    char    *str;\n    int     i;\n    int     j;\n    if (!s2)\n        return (s1);\n    if (!s1)\n        return (s2);\n    str = (char*)malloc(ft_strlen(s1) + ft_strlen(s2) + 2);\n    i = -1;\n    while (s1[++i])\n    {\n        str[i] = s1[i];\n    }\n    j = -1;\n    while (s2[++j])\n    {\n        str[i] = s2[j];\n        i++;\n    }\n    str[i] = '\\n';\n    str[i + 1] = '\\0';\n    free(s1);\n    return (str);\n}"}
{"author": "dishanp", "file": "DSA__q43.0.c", "original_string": "void ngerearrange( int *arr, int n)\n{\n    int i, j;\n    for (i=0; i<n; i++)\n    {\n        for (j = i+1; j<n; j++)\n        {\n            if (*(arr + i) < *(arr + j))\n            {\n                *(arr + i) = *(arr + j);\n                break;\n            }\n        }\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__list-push-pop-del-rec_rev-count.1.c", "original_string": "node* push(node* head, int data)\n{\n    if(head==NULL)\n        return createNode(head,data);\n    else\n        head->next=push(head->next,data);\n    return head;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__13_basic_employee_bonus.0.c", "original_string": "int main()\n{\n  int salary;\n  float bonus;\n  char gender;\n  printf(\"Enter the Gender\");\n  scanf(\"%c\",&gender);\n  printf(\"Enter Salary\");\n  scanf(\"%d\",&salary);\n  if(gender == 'M' || gender == 'm')\n  {\n    if(salary > 10000)\n    {\n      bonus = (salary * .05);\n    }\n    else\n    {\n      bonus = (salary * .07);\n    }\n  }\n  if(gender == 'F' || gender == 'f')\n  {\n    if(salary > 10000)\n    {\n      bonus = (float)(salary * .10);\n    }\n    else\n    {\n      bonus = (float)(salary * .12);\n    }\n  }\n  salary = salary + bonus;\n  printf(\"Salary is %d\", salary);\n}"}
{"author": "2security", "file": "Matrix__40CheckSymmetricMatrix.2.c", "original_string": "int main()\n    {\n    int i,j,r,c,mat1[20][20],mat2[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    printf(\"\\n Enter the matrix \\n\");\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)                \n    scanf(\"%d\",&mat1[i][j]);\n    if(IsSymmetric(mat1,Transpose(mat1,mat2,r,c),r,c))\n        printf(\"\\nSymmetric matrix\");\n    else\n        printf(\"\\nMatrix is not Symmetric matrix\");\n    return 0;\n    }"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__routing2.4.c", "original_string": "void    get_c(char *line)\n{\n    char    **par;\n    char    **colors;\n    int     cc;\n    int     cw;\n    cw = 0;\n    par = ft_split(line, ' ');\n    cc = 0;\n    colors = ft_split(&par[1][0], ',');\n    while (line[cc])\n    {\n        if (line[cc] == ',')\n            cw++;\n        cc++;\n    }\n    if (cw != 2)\n    {\n        ft_putstr(\"Error:\\n Wrong ceiling RGB\");\n        exit(0);\n    }\n    cw = c_w(line, ' ');\n    cc = c_w(&par[1][0], ',');\n    freethenipples(par);\n    check_crgb(colors, cc, cw);\n    freethenipples(colors);\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__LP.4.c", "original_string": "void display()\n{\n    int i;\n    for(i=0;i<10;i++)\n    {\n        if(HASH[i]!=-1)\n        printf(\"\\nkey : %d\\tvalue : %d\",i,HASH[i]);\n    }\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__28_union_array.0.c", "original_string": "int main()\n{\n  int a = 0, i=0,j=0,k=0,len_array1=0,len_array2=0,temp=0, total_count = 0;\n  printf(\"Enter Length of array1 and array2\");\n  scanf(\"%d%d\",&len_array1,&len_array2);\n  int array1[len_array1],array2[len_array2],array3[len_array1+len_array2];\n  total_count = len_array1+len_array2;\n  printf(\"Enter Element of Array1\\n\");\n  for(i=0; i<len_array1; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  printf(\"Enter Element of Array2\\n\");\n  for(i=0; i<len_array2; i++)\n  {\n    scanf(\"%d\",&array2[i]);\n  }\n  for(i=0;i<len_array1;i++)\n  {\n    array3[j] = array1[i];\n    j++;\n  }\n  for(i=0;i<len_array2;i++)\n  {\n    array3[j] = array2[i];\n    j++;\n  }\n  for(i=0;i<total_count;i++)\n  {\n    for(j=i+1; j<len_array1+len_array2;j++)\n    {\n      if(array3[i] > array3[j])\n      {\n        temp = array3[i];\n    array3[i] = array3[j];\n    array3[j] = temp;\n      }\n    }\n  }\n  for(i=0;i<total_count;i++)\n  {\n    for(j=i+1; j<total_count;)\n    {\n      if(array3[i] == array3[j])\n      {\n        for(k=j;k<total_count;k++)\n    {\n          array3[k] = array3[k+1];\n    }\n        total_count--;\n      }\n      else\n      {\n        j++;\n      }\n    }\n  }\n  printf(\"\\nArray After Union, value of k is %d\\n\",k);\n  for(i=0; i<total_count; i++)\n  {\n    printf(\"%d \",array3[i]);\n  }\n}"}
{"author": "augustogunsch", "file": "jack-compiler__io.0.c", "original_string": "char* strtail(char* str, int len, int count) {\n    int index = len - count;\n    if (index <= 0) return str;\n    return str + (sizeof(char) * (index));\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__ft_prime_sum.5.c", "original_string": "int     main(int ac, char **av)\n{\n    if (ac == 2)\n        ft_putnbr(ft_add_prime_sum(ft_atoi(av[1])));\n    else if (ac != 2 || ft_atoi(av[1]) < 0)\n        write(1, \"0\", 1);\n    write(1, \"\\n\", 1);\n    return (0);\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Paging.5.c", "original_string": "void main()\n{\n    int ch,id,size,i;\n    for(i=0;i<16;i++)\n        Mem[i]=0;\n    while(1)\n    {\n        printf(\"\\nEnter choice : \");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1: \n            {\n                printf(\"\\nEnter program id : \");\n                scanf(\"%d\",&id);\n                printf(\"\\nEnter the size in terms of pages : \");\n                scanf(\"%d\",&size);\n                add_program(id,size);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter program id : \");\n                scanf(\"%d\",&id);\n                rem_program(id);\n                break;\n            }\n            case 3:\n            {\n                display_table();\n                break;\n            }\n            case 4:\n            {   \n                display_Mem();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_5.3.c", "original_string": "void addafter()\n{\n    struct node* temp, * p;\n    int key, i = 1;\n    printf(\"Enter location : \");\n    scanf(\"%d\", &key);\n    len = length();\n    if(key > len)\n    {\n        printf(\"Unable to insert\\n\");\n        printf(\"The list is having only %d nodes.\\n\", len);\n    }\n    else\n    {\n        p = root;\n        while(i < key)\n        {\n            p = p->link;\n            i++;\n        }\n        temp = (struct node*)malloc(sizeof(struct node));\n        printf(\"Enter a node to insert : \");\n        scanf(\"%d\", &temp->data);\n        printf(\"%d inserted.\\n\", temp->data);\n        temp->link = p->link;\n        p->link = temp;\n    }\n}"}
{"author": "RafaelFelisbino-hub", "file": "MATRIZ-exercices__Exercicio18MATRIZ.0.c", "original_string": "int main() \n{\n    char nomesProdutos[5][100], nomeCaro[100], loja[4][20] = {\"Adidas\",\"Nike\",\"Cervejaria\",\"Cachoeiras\"};\n    float lojaProduto[4][5], matrizImpostos[4][5], maisCaro = 0;\n    int i, j;\n    for (i = 0; i < 5; i++)\n    {\n        printf(\"Digite os nomes dos produtos [%d]:  \", i);\n        scanf_s(\"%[^\\n]s\", &nomesProdutos[i], 100);\n        getchar();\n    }\n    for (i = 0; i < 4; i++)\n        for (j = 0; j < 5; j++) \n        {\n            printf(\"Digite o preco dos produtos [%s] loja [%s] produto:  \", loja[i], nomesProdutos[j]);\n            scanf_s(\"%f\", &lojaProduto[i][j]);\n        }\n    for (i = 0; i < 4; i++)\n        for (j = 0; j < 5; j++)\n        {\n            if (lojaProduto[i][j] <= 50) \n                matrizImpostos[i][j] = lojaProduto[i][j] * 5 / 100 + lojaProduto[i][j];\n            if(lojaProduto[i][j] > 50 && lojaProduto[i][j] <= 100)\n                matrizImpostos[i][j] = lojaProduto[i][j] * 10 / 100 + lojaProduto[i][j];\n            if (lojaProduto[i][j] > 100)\n                matrizImpostos[i][j] = lojaProduto[i][j] * 20 / 100 + lojaProduto[i][j];\n        }\n    for (i = 3; i < 4; i++)\n        for (j = 0; j < 5; j++) \n        {\n            if (matrizImpostos[i][j] > maisCaro) \n            {\n                maisCaro = matrizImpostos[i][j];\n                nomeCaro[99] = strcpy_s(nomeCaro, 99, nomesProdutos[i]);\n            }\n        }\n    for (i = 0; i < 4; i++)\n        for (j = 0; j < 5; j++)\n        {\n            printf(\"A matriz com os impostos [%d][%d]:  %.2f\\n\", i, j, matrizImpostos[i][j]);\n        }\n    printf(\"O produto mais caro da 3 linha e %s com o valor de %.0f\\n\", nomeCaro, maisCaro);\n    system(\"pause\");\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b0.0.c", "original_string": "int main() {\n    char *filename = \"Passwords.txt\";\n    FILE *f = fopen(filename, \"r\");\n    char *line = NULL;\n    size_t n = 0;\n    size_t valids = 0;\n    while (getline(&line, &n, f) != -1) {\n        char *str = strchr(line, ':');\n        char *pass = calloc(sizeof(char), strlen(str) - 2);\n        strcpy(pass, &str[2]);\n        int i = strtol(line, &line, 10);\n        line++;\n        int j = strtol(line, &line, 10);\n        char c = line[1];\n        if ((pass[i - 1] == c || pass[j - 1] == c) && pass[i - 1] != pass[j - 1])\n            valids++;\n        free(pass);\n    }\n    printf(\"Answer: %zu\\n\", valids);\n    fclose(f);\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-statements.7.c", "original_string": "STATEMENT* parsedo(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, dostatement);\n    s->dostatement = parsesubroutcall(p);\n    checkcontent(p, \";\");\n    return s;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_certificate.2.c", "original_string": "error_t acmeClientParseDownloadCertResponse(AcmeClientContext *context,\n   char_t *buffer, size_t size, size_t *length)\n{\n   error_t error;\n   size_t n;\n   error = NO_ERROR;\n   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))\n      return ERROR_UNEXPECTED_STATUS;\n   if(context->nonce[0] == '\\0')\n      return ERROR_INVALID_RESPONSE;\n   if(osStrcasecmp(context->contentType, \"application/pem-certificate-chain\"))\n      return ERROR_INVALID_RESPONSE;\n   if(context->bufferLen >= ACME_CLIENT_BUFFER_SIZE)\n      return ERROR_RESPONSE_TOO_LARGE;\n   error = pemImportCertificate(context->buffer, context->bufferLen, NULL,\n      &n, NULL);\n   if(error)\n      return ERROR_INVALID_RESPONSE;\n   if(context->bufferLen > size)\n      return ERROR_BUFFER_OVERFLOW;\n   osMemcpy(buffer, context->buffer, context->bufferLen);\n   *length = context->bufferLen;\n   return error;\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__map_manager.3.c", "original_string": "void        map_errors(char **map)\n{\n    int i;\n    int j;\n    i = 0;\n    j = 0;\n    while (++i <= g_map_height)\n    {\n        while (++j <= g_map_width)\n        {\n            if (map[i][j] != '1' && map[i][j] != '0' && map[i][j] != '2'\n            && map[i][j] != 'N' && map[i][j] != 'W' && map[i][j] != 'E'\n            && map[i][j] != 'S' && map[i][j] != ' ')\n                error_redirect(0);\n            else if (map[i][j] != ' ' && map[i][j] != '1')\n            {\n                if (map[i][j + 1] == ' ' || map[i][j - 1] == ' '\n                || map[i + 1][j] == ' ' || map[i - 1][j] == ' ')\n                    error_redirect(1);\n                if ((map[i][j] == 'N' || map[i][j] == 'S' ||\n                map[i][j] == 'E' || map[i][j] == 'W') && !g_peeinit)\n                    player_init(map[i][j], j - 1, i - 1);\n            }\n        }\n        j = 0;\n    }\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-2new.7.c", "original_string": "void dfs(char*** maze,char*** mark,char*** road,int row,int col,int hei,int count){\n    int i,j,k;\n    if(count>=(min+5)){\n        return;\n    }\n    else{\n        int i;\n        int nh,nr,nc;\n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            nh = hei+move[i].hei;\n            if(mark[nh][nr][nc]!='X'){\n                mark[nh][nr][nc]='X';\n                road[nh][nr][nc]='*';\n                if(maze[nh][nr][nc]=='T'){\n                    dfs(maze,mark,road,nr,nc,nh,count+3);\n                }\n                else{\n                    dfs(maze,mark,road,nr,nc,nh,count+1);\n                }\n                mark[nh][nr][nc]=maze[nh][nr][nc];\n                road[nh][nr][nc]=maze[nh][nr][nc];\n            }\n        }\n        if(maze[hei][row][col]=='U'){\n            if(mark[hei+1][row][col]!='X'){\n                mark[hei+1][row][col]='X';\n                road[hei+1][row][col]='*';\n                if(maze[hei+1][row][col]=='T'){\n                    dfs(maze,mark,road,row,col,hei+1,count+3);\n                }\n                else if(maze[hei+1][row][col]=='F'){\n                    pathnum++;\n                }\n                else{\n                    dfs(maze,mark,road,row,col,hei+1,count+1);\n                }\n                mark[hei+1][row][col]=maze[hei+1][row][col];\n                road[hei+1][row][col]=maze[hei+1][row][col];\n            }\n        }\n        else if(maze[hei][row][col]=='D' && hei>0){\n            if(mark[hei-1][row][col]!='X'){\n                mark[hei-1][row][col]='X';\n                road[hei-1][row][col]='*';\n                if(mark[hei-1][row][col]='T'){\n                    dfs(maze,mark,road,row,col,hei-1,count+3);\n                }\n                else{\n                    dfs(maze,mark,road,row,col,hei-1,count+1);\n                }\n                mark[hei-1][row][col]=maze[hei-1][row][col];\n                road[hei-1][row][col]=maze[hei-1][row][col];\n            }\n        }\n    }\n}"}
{"author": "2security", "file": "Matrix__32CheckUpperTriangularMatrix.0.c", "original_string": "int checkUpperTri(int mat[][20],int r)\n    {\n    int i,j,flag=1;\n    for(i=1;i<r;i++) \n        for(j=0;j<i;j++) \n            if(mat[i][j]!= 0) \n                return 0;\n        return 1;\n    }"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__OPR.3.c", "original_string": "void main()\n{\n    int PFR=0,j,i;\n    for(i=0;i<3;i++)\n        Queue[i]=-1;\n    printf(\"\\nEnter the  number of pages : \");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter page : \");\n        scanf(\"%d\",&page[i]);\n    }\n    for(i=0;i<n;i++)\n    {\n        if(isthere(page[i])==-1)\n        {\n            enqueue(page[i],i);\n            PFR=PFR+1;\n        }\n        printf(\"\\nStatus : \");\n        for(j=0;j<3;j++)\n            printf(\"%d\\t\",Queue[j]);\n    }\n    printf(\"\\nPage Fault Rate is : %d\",PFR);\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Two.0.c", "original_string": "int isthere(int d,char name)\n{\n    int flag=-1;\n    temp=dir[d];\n    while(temp!=NULL)\n    {\n        if(temp->file==name)\n        {\n            flag=1;\n            break;\n        }\n        temp=temp->next;\n    }\n    return(flag);\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__goal_server.5.c", "original_string": "void send_message(char *s, int uid){\n    pthread_mutex_lock(&clients_mutex);\n    for(int i=0; i<MAX_CLIENTS; ++i){\n        if(clients[i]){\n            if(clients[i]->uid != uid){\n                if(write(clients[i]->sockfd, s, strlen(s)) < 0){\n                    perror(\"ERROR: write to descriptor failed\");\n                    break;\n                }\n            }\n        }\n    }\n    pthread_mutex_unlock(&clients_mutex);\n}"}
{"author": "augustogunsch", "file": "jack-compiler__tokenizer.3.c", "original_string": "TOKEN* appendtokenraw(TOKEN* curitem, STRING* token, int definedat, TOKENTYPE type) {\n    curitem->token = (char*)malloc(sizeof(char)*token->count);\n    strcpy(curitem->token, token->str);\n    curitem->definedat = definedat;\n    curitem->type = type;\n    TOKEN* nextitem = mktoken();\n    curitem->next = nextitem;\n    token->count = 0;\n    return nextitem;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__tokenizer.0.c", "original_string": "STRING* mkstring(int size) {\n    STRING* str = (STRING*)malloc(sizeof(STRING));\n    str->size = sizeof(char) * size; \n    str->str = (char*)malloc(str->size);\n    str->count = 0;\n    return str;\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_5.9.c", "original_string": "int search(int value)\n{\n    struct node *p = root;\n    while(p != NULL)\n    {\n        if(p->data == value)\n        {\n            return 1;\n        }\n        else\n        {\n            p = p->link;\n        }\n    }\n    return 0;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_08.6.c", "original_string": "void radix_sort(int arr[], int n) {\n    int m = getMax(arr, n);\n    int exp;\n    for (exp = 1; m / exp > 0; exp *= 10)\n        countSort(arr, n, exp);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__DemoFOTAUpdateWorkflow.4.c", "original_string": "static void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution)\n{\n  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;\n  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;\n  instance->updateInfo.version = NULL;\n  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;\n  if (!postponeInitialExecution) \n  {\n    instance->__currentState = loadState();\n    switch (instance->__currentState)\n    {\n      case DemoFOTAUpdateWorkflowEngine_connected__state:\n      {\n        DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n        break;\n      }\n      case DemoFOTAUpdateWorkflowEngine_restarting__state:\n      {\n        DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n  }\n}"}
{"author": "MFarid94", "file": "Assignment-2__Exercise17.0.c", "original_string": "int MaximumValue(int l, int r){\n        int max_value = 0;\n        int result = 0;\n        for(int i = l ; i<=r ;i++){\n            for(int j = i ; j<=r ;j++){\n                result = i^j;\n                if(result > max_value){\n                    max_value = result;\n                }\n            }\n        }\n        return max_value;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__extr_intr.4.c", "original_string": "void delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "2security", "file": "Matrix__40CheckSymmetricMatrix.0.c", "original_string": "int IsSymmetric(int mat1[][20],int mat2[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            {\n            if(mat1[i][j]!=mat2[i][j])\n                return 0;\n            }\n        }\n    return 1;\n    }"}
{"author": "2security", "file": "Array__Orthogonal.1.c", "original_string": "int ** Transpose(int **mat1,int **mat2,int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)\n        mat2[i][j]=mat1[j][i];\n    return mat2;\n    }"}
{"author": "2security", "file": "Array__SumArray.0.c", "original_string": "int main()\n    {\n    int *arr,i,n,sum=0;\n    printf(\"Enter how many numbers you want to store into array\");\n    scanf(\"%d\",&n);\n    arr=(int *)malloc((n)*sizeof(int *));   \n    printf(\"Enter %d elements\",n);\n    for(i=0;i<n;i++)\n    scanf(\"%d\",&arr[i]);\n    for(i=0;i<n;i++)\n        sum=sum+arr[i];\n    printf(\"Sum of the array=%d\",sum);\n    return 0;\n    }"}
{"author": "kbtomic", "file": "StrukturePodataka__zad4.2.c", "original_string": "int unosDrugi(pozicija p)\n{\n    FILE* fp = NULL;\n    fp = fopen(\"pol2.txt\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"Neuspjesno otvaranje datoteke!\\n\");\n        return 1;\n    }\n    while (!feof(fp))\n    {\n        pozicija q = NULL;\n        q = (pozicija)malloc(sizeof(struct polinom));\n        if (q == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        pozicija pret, temp;\n        temp = p->next;\n        pret = p;\n        fscanf(fp, \"%d %d\", &q->koeficijent, &q->eksponent);\n        while (temp != NULL && temp->eksponent < q->eksponent)\n        {\n            pret = temp;\n            temp = temp->next;\n        }\n        pret->next = q;\n        if (temp != NULL)\n            q->next = temp;\n        else\n            q->next = NULL;\n    }\n    return 0;\n    return 0;\n}"}
{"author": "earth429", "file": "mulpre__mulprec.18.c", "original_string": "int decrement(struct NUMBER *a, struct NUMBER *b) {\n    struct NUMBER one;\n    int r;\n    setInt(&one, 1);\n    r = sub(a, &one, b);\n    return r;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q4_poly.3.c", "original_string": "int main() \n{ \n    struct Node *poly1 = NULL, *poly2 = NULL, *poly = NULL; \n    int n , m, coeff, power;\n    printf(\"Enter no. of terms in the first polynomial: \");\n    scanf(\"%d\", &n);\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter coeff and power of x : \");\n        scanf(\"%d %d\", &coeff, &power);\n        create_node(coeff, power, &poly1); \n    }\n    printf(\"Enter no. of terms in the second polynomial: \");\n    scanf(\"%d\", &m);\n    for(int i = 0 ; i < m ; i++)\n    {\n        printf(\"Enter coeff and power of x : \");\n        scanf(\"%d %d\", &coeff, &power);\n        create_node(coeff, power, &poly2); \n    }\n    printf(\"1st Number: \");     show(poly1); \n    printf(\"2nd Number: \");     show(poly2); \n    poly = (struct Node *)malloc(sizeof(struct Node)); \n    polyadd(poly1, poly2, poly); \n    printf(\"Added polynomial: \"); show(poly); \n    return 0; \n}"}
{"author": "shengelenge", "file": "wstep-do-programowania__zad30.1.c", "original_string": "int main()\n{\n    unsigned int n;\n    printf(\"Podaj liczbe naturlana: \");\n    scanf(\"%d\", &n);\n    if (czy_pierwsza(n))\n        printf(\"Liczba %u jest pierwsza.\\n\", n);\n    else\n        printf(\"Liczba %u nie jest pierwsza.\\n\", n);\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__timer_2MR.0.c", "original_string": "int main()\n{\n    int count=0;\n    IODIR1 = IODIR1 | (0xFF<<17);       \n    T0PR = 14;                                          \n    T0MR0 = 2000000;                                \n    T0MR1 = 4000000;                                \n    T0MCR   = (1<<0)|(1<<3)|(1<<4);     \n    T0TCR   = (1<<0);                                   \n    while(1)\n    {\n        count++;\n        if(T0IR & (1<<0))                           \n        {\n            IOSET1 = (0xFF<<17);\n            T0IR = 1<<0;                                \n        }\n        if(T0IR & (1<<1))                           \n        {\n            IOCLR1 = (0xFF<<17);\n            T0IR = 1<<1;                                \n        }\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_any_pos_DLL.3.c", "original_string": "int count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n    return c;\n}"}
{"author": "254Odeke", "file": "Operating-Systems_Lab__Short_Job_First_CPU_Scheduling_Simulation.0.c", "original_string": "void main(){\nint et[20],at[10],n,i,j,temp,st[10],ft[10],wt[10],ta[10]; int totwt=0,totta=0;\nfloat awt,ata;\nchar pn[10][10],t[10]; \nprintf(\"Enter the number of process:\"); scanf(\"%d\",&n);\nfor(i=0;i<n;i++)\n{\nprintf(\"Enter process name, arrival time & execution time:\"); \nscanf(\"%s%d%d\",pn[i],&at[i],&et[i]);\n}\nfor(i=0;i<n;i++)\nfor(j=0;j<n;j++)\n{\nif(et[i]<et[j])\n{\ntemp=at[i];\nat[i]=at[j];\nat[j]=temp;\ntemp=et[i];\net[i]=et[j];\net[j]=temp;\nstrcpy(t,pn[i]);\nstrcpy(pn[i],pn[j]);\nstrcpy(pn[j],t);\n}\n}\nfor(i=0;i<n;i++)\n{\nif(i==0)\nst[i]=at[i]; else st[i]=ft[i-1];\nwt[i]=st[i]-at[i];ft[i]=st[i]+et[i];ta[i]=ft[i]-at[i];totwt+=wt[i]; totta+=ta[i];\n}\nawt=(float)totwt/n;\nata=(float)totta/n;\nprintf(\"\\nPname\\tarrivaltime\\texecutiontime\\twaitingtime\\ttatime\");\nfor(i=0;i<n;i++)\nprintf(\"\\n%s\\t%5d\\t\\t%5d\\t\\t%5d\\t\\t%5d\",pn[i],at[i],et[i],wt[i],ta[i]); \nprintf(\"\\nAverage waiting time is:%f\",awt);\nprintf(\"\\nAverage turnaroundtime is:%f\",ata); getch();\n}"}
{"author": "mehedi9021", "file": "Data_Structure__queue_with_linkedlist.0.c", "original_string": "void Enqueue(int x) {\n    struct Node* temp =\n        (struct Node*)malloc(sizeof(struct Node));\n    temp->data =x;\n    temp->next = NULL;\n    if(front == NULL && rear == NULL){\n        front = rear = temp;\n        return;\n    }\n    rear->next = temp;\n    rear = temp;\n}"}
{"author": "2security", "file": "Matrix__23AddMatrix.1.c", "original_string": "void AddMat(int mat1[][20],int mat2[][20],int r,int c)\n    {\n    int i,j,temp[20][20];\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            temp[i][j]=mat1[i][j]+mat2[i][j];\n        }\n    displayMat(temp,r,c);\n    }"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc.10.c", "original_string": "int count_internalnodes(node* root)\n{\n    if(root == NULL || (root->left == NULL && root->right == NULL))\n        return 0;\n    else\n        return 1 + count_internalnodes(root->left)+count_internalnodes(root->right);\n}"}
{"author": "fikepaci", "file": "sorting_algorithms__2-selection_sort.1.c", "original_string": "void selection_sort(int *array, size_t size)\n{\n    unsigned int i, j, min;\n    if (array == NULL || size < 2)\n        return;\n    for (i = 0; i < size; i++)\n    {\n        min = i;\n        for (j = i + 1; j < size; j++)\n        {\n            if (array[min] > array[j])\n                min = j;\n        }\n        if (min != i)\n        {\n            _swap(&array[i], &array[min]);\n            print_array(array, size);\n        }\n    }\n}"}
{"author": "ankitraj311", "file": "450_babbar__2_max_min_in_array.2.c", "original_string": "int main()\n{\n  int arr[100],no,j=0,temp=0,mid=0,max = 0, min = 0;\n  printf(\"Enter length of array\");\n  scanf(\"%d\",&no);\n  for(int i = 0; i<no; i++)\n  {\n    scanf(\"%d\",&arr[i]);\n  }\n  printf(\"Array is :- \");\n  array_print(arr,no);\n  min = arr[0];\n  max = arr[0];\n  max_min_array(arr,max,min,no);  \n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_SLL.9.c", "original_string": "void delete_at_pos()\n{\n    struct node *temp,*nextnode;\n    int pos;\n    printf(\"enter the position to delete the element =\");\n    scanf(\"%d\",&pos);\n    int i=1;\n    int leg=count();\n    if(pos>leg)\n    {\n        printf(\"invalid position\\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        nextnode=temp->next;\n        temp->next=nextnode->next;\n        free(nextnode);\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__double_list_create.3.c", "original_string": "void displayListFromEnd()\n{\n    struct node * temp;\n        temp = last;\n        printf(\"\\n\\nDATA IN THE LIST From End:\\n\");\n        while(temp != NULL)\n        {\n            printf(\"DATA = %d\\n\", temp->data);\n            temp = temp->prev;\n        }\n}"}
{"author": "0712023", "file": "Basis-and-Practice-in-Programming_SKKU__2-stage1.0.c", "original_string": "void main() {\n    char input[512] = \"3 * x ^ 1 + 5 * x ^ 1 + 12 * x ^ 13 + 1 * x ^ 0 + 4 * x ^ 2 + 7 * x ^ 2\";\n  strcat(input,\" +\");\n  int coeff[40]= {};\n  int *pc;\n  pc = coeff;\n  int indice[40]={};\n  int *pi;\n  pi = indice;\n  int cnt_c = 0;\n  int *pnt_c;\n  pnt_c = &cnt_c;\n  int cnt_i = 0;\n  int *pnt_i;\n  pnt_i = &cnt_i;\n  int plus =0;\n  int *pplus;\n  pplus = &plus;\n  int cnt = 0;\n    int *pnt = &cnt;\n  for(int i = 0; i<512; i++){\n    if(input[i] == '+'){\n      *pplus+=1;\n    }\n    if(input[i+1]==' ' && input[i+2] == '*'){\n      if(input[i-1]>47 && input[i-1] < 58){\n        *(pc+*pnt_c) = (input[i-1]-48)*10+input[i]-48;\n      } else{\n        *(pc+*pnt_c) = input[i]-48;\n      }\n            *pnt_c+=1;\n    }\n    if(input[i+1]==' ' && input[i+2] == '+'){\n      if(input[i-1]>47 && input[i-1] < 58){\n        *(pi+*pnt_i) = (input[i-1]-48)*10+input[i]-48;\n      } else {\n        *(pi+*pnt_i) = input[i]-48;\n      }\n      *pnt_i+=1;\n    }\n  }\n  for(int i = 0; i<*pplus; i++){\n    for(int j = 0;j<*pplus-1;j++){\n      if(indice[j]<indice[j+1]){\n        char tmp1;\n        tmp1 = indice[j];\n        indice[j] = indice[j+1];\n        indice[j+1] = tmp1;\n        char tmp2;\n        tmp2 = coeff[j];\n        coeff[j] = coeff[j+1];\n        coeff[j+1] = tmp2;\n      }\n    }\n  }\n  for(int k = 0; k<*pplus;k++){\n        for(int i = 0; i< *pplus-1; i++){\n            if(indice[i] == indice[i+1]){\n        coeff[i] += coeff[i+1];\n                *pnt+=1;\n        for(int j = i+1; j< *pplus-1 ; j++){\n                    char tmp;\n                    tmp = coeff[j];\n                    coeff[j] = coeff[j+1];\n                    coeff[j+1] = tmp;\n                }\n        coeff[*pplus-1] = 0;\n                for(int j = i+1; j< *pplus-1 ; j++){\n                    char tmp;\n                    tmp = indice[j];\n                    indice[j] = indice[j+1];\n                    indice[j+1] = tmp;\n                }\n        indice[*pplus-1] = 0;\n            }\n        }\n    }\n  *pnt =0 ;\n  for(int i = 0; i<40; i++){\n    if(coeff[i]==0){\n      break;\n    }\n    *pnt+=1;\n  }\n  char result[512] = {};\n  for(int i =0; i<*pnt-1;i++){\n    char tmp[100] = {};\n    sprintf(tmp,\"%d * x ^ %d + \", coeff[i], indice[i]);\n    strcat(result,tmp);\n  }\n  char tmp[50] ={};\n  sprintf(tmp,\"%d * x ^ %d\", coeff[*pnt-1], indice[*pnt-1]);\n  strcat(result, tmp);\n  printf(\"%s\\n\", result);\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_putnbr.0.c", "original_string": "void ft_putnbr(int numero){\n    int negativo = 0;\n    if(numero < 0){\n        numero = numero*(-1);\n        negativo = 1;\n    }\n    else\n        negativo = 0;\n    int longitud_N = 0; \n    for(int  i = numero; i > 0; i= i/10){\n        ++longitud_N; \n    }\n    if(negativo)\n        longitud_N++;\n    char string_intermedio[11] = \" \"; \n    for(int i = numero; i > 0; i = i/10){ \n        string_intermedio[longitud_N-1] = (i%10)+48;\n        --longitud_N;\n    }\n    if(negativo)\n        string_intermedio[0] = '-';\n    printf(\"%s\", string_intermedio); \n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica3-1.2.c", "original_string": "void * suministro(){\n    int modelo=(rand()%4)+1; \n    int cantidad=(rand()%10)+1; \n    printf(\"stock: %i %i %i %i %i \\n\",camisetas[0], camisetas[1], camisetas[2], camisetas[3], camisetas[4]);\n    printf(\"se va a suministrar el modelo %i %i veces \\n\",modelo,cantidad);\n    pthread_mutex_lock(&mutex_acceso);\n        camisetas[modelo-1] = camisetas[modelo-1] + cantidad;\n    pthread_mutex_unlock(&mutex_acceso);\n    printf(\"stock: %i %i %i %i %i \\n\",camisetas[0], camisetas[1], camisetas[2], camisetas[3], camisetas[4]);\n    pthread_exit(NULL); \n}"}
{"author": "earth429", "file": "mulpre__divBy10.4.c", "original_string": "void copyNumber(struct NUMBER *a, struct NUMBER *b){\n    int i;\n    b->sign = a->sign;\n    for (i = 0; i < KETA;i++){\n        b->n[i] = a->n[i];\n    }\n}"}
{"author": "Theemiss", "file": "simple_shell__bulltin.0.c", "original_string": "void  exit_bul(char **cmd, char *input, char **argv, int c)\n{\n    int statue, i = 0;\n    if (cmd[1] == NULL)\n    {\n        free(input);\n        free(cmd);\n        exit(EXIT_SUCCESS);\n    }\n    while (cmd[1][i])\n    {\n        if (_isalpha(cmd[1][i++]) != 0)\n        {\n            _prerror(argv, c, cmd);\n            break;\n        }\n        else\n        {\n            statue = _atoi(cmd[1]);\n            free(input);\n            free(cmd);\n            exit(statue);\n        }\n    }\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__flor.0.c", "original_string": "void circulo()\n{\n  int i;\n  float angulo = 0.0;\n  glBegin(GL_POLYGON);\n  for (i = 0; i <= 50; i++)\n  {\n    angulo = 2 * M_PI * i / 50.0;\n    glVertex2f(0.15 * cos(angulo), 0.15 * sin(angulo));\n  }\n  glEnd();\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__24_Dowhile.1.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular ln(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    do{\n        if(i%2 == 0)\n            Suma_total += Exp(X-1, i+1) / (i+1);\n        else\n            Suma_total -= Exp(X-1, i+1) / (i +1);\n        ++i;\n    }while(i <= veces);\n    printf(\"ln(%i) es igual a %lf\", X, (Suma_total + (X - 1)));\n    return 0;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__10_Mover.1.c", "original_string": "void mostrar(int X_1, int X_2, int contador)\n{\n    if(X_1 != 41){\n        if(contador <= 80){\n            if(contador == X_1)\n                printf(\"X\");\n            else if(contador == X_2)\n                printf(\"X\");\n            else\n                printf(\" \");\n            mostrar(X_1,X_2, ++contador);\n        }else{\n            sleep(0.4);\n            system(\"cls\");\n            mostrar(++X_1, --X_2, 1);\n        }\n    }   \n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_07.2.c", "original_string": "int findMax_digits(int a[],int n)\n{\n  int i,digits=0,num;\n  int max=0;\n  int level=1;\n  for(i=1;i<n;i++)\n   {\n     if(a[i]>a[max])\n       max=i;\n   }\n  num=a[max];\n  if(num==0)\n   return 0;\n  while(num>=level)\n   {\n     digits++;\n     level*=2;\n   }\n  return digits;\n}"}
{"author": "sdukesameer", "file": "dsa__list-ins-seq-sor.1.c", "original_string": "void sequential_insert(node** head, int inp)\n{\n    node* linklist=createnode(inp);\n    linklist->next=*head;\n    *head=linklist;\n    printf(\"%d inserted\\n\",(*head)->data);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__ssh_server_misc.0.c", "original_string": "void sshServerTick(SshServerContext *context)\n{\n   error_t error;\n   uint_t i;\n   systime_t time;\n   SshConnection *connection;\n   time = osGetSystemTime();\n   for(i = 0; i < context->sshContext.numConnections; i++)\n   {\n      connection = &context->sshContext.connections[i];\n      if(connection->state != SSH_CONN_STATE_CLOSED)\n      {\n         if(timeCompare(time, connection->timestamp + SSH_SERVER_TIMEOUT) >= 0)\n         {\n            TRACE_INFO(\"SSH server: Closing inactive connection...\\r\\n\");\n            error = sshSendDisconnect(connection, SSH_DISCONNECT_BY_APPLICATION,\n               \"Session idle timeout\");\n            if(error)\n            {\n               sshCloseConnection(connection);\n            }\n         }\n      }\n   }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-central-scanner-with-whitelist__nrf_fstorage.6.c", "original_string": "uint8_t * nrf_fstorage_wmap(nrf_fstorage_t const * p_fs, uint32_t addr)\n{\n    if ((p_fs == NULL) || (p_fs->p_api == NULL))\n    {\n        return NULL;\n    }\n    return (p_fs->p_api)->wmap(p_fs, addr);\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__sender0.1.c", "original_string": "void output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n    }\n    printf(\"\\n\");\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__DemoFOTAUpdateWorkflow.2.c", "original_string": "void fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)\n{\n  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_7_b.0.c", "original_string": "int main()\n{\n    int one[8] = {5, 6, 8, 8, 10, -2, 0, 121};\n    int two[8] = {2, 1, 3, -4, 10, 21, 2, 233};\n    int three[8];\n    unsigned int naturalNumber = 8;\n    printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n    biggerElement(naturalNumber, one, two, three);\n    printf(\"\\nElementy tablicy3: \");\n    for(int i = 0; i < (sizeof(three)/sizeof(three[0])); i++){\n        printf(\"%d \", three[i]);\n    }\n    getchar();;\n    return 0;\n}"}
{"author": "ankitraj311", "file": "450_babbar__6_union_array_Geek_usorted_array.3.c", "original_string": "void union_array(int arr1[], int arr2[], int size_arr1, int size_arr2)\n{\n  int total_size = size_arr1+size_arr2, arr3[total_size], index_val = 0, k = 0i, last_count = 0;\n  for(int i = 0; i<size_arr1; i++)\n  {\n    arr3[k] = arr1[i];\n    k++;\n  }\n  for(int i = 0; i<size_arr2; i++)\n  {\n    int val = ispresent(arr1,size_arr1,arr2,i); \n    if(val == 0)\n    {\n      arr3[k] = arr2[i];\n      k++;\n    }\n  }\n  printf(\"Array after Union :-\");\n  array_print(arr3,k);\n}"}
{"author": "2security", "file": "Star__HollowDiamondStar.0.c", "original_string": "int main()\n    {\n        int n,i,j,k;\n        printf(\"Enter no of rows\");\n        scanf(\"%d\",&n);\n        for(i=1;i<=n;i++)\n            {\n                for(j=n;j>=i;j--)\n                    printf(\"*\");\n                for(j=2;j<2*i;j++)\n                    printf(\" \");\n                for(j=1;j<=n-i+1;j++)\n                    printf(\"*\");\n                printf(\"\\n\");\n            }\n        for(i=1;i<=n;i++)\n        {\n            for(j=1;j<=i;j++)\n                printf(\"*\");\n            for(j=1;j<=2*n-2*i;j++)\n                printf(\" \");\n            for(j=1;j<=i;j++)\n                printf(\"*\");\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n    return 0;\n    }"}
{"author": "mehedi9021", "file": "Data_Structure__enter_value_to_node.3.c", "original_string": "int main()\n{\n    int n;\n    printf(\"Enter the total number of nodes: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    printf(\"display:\\n\");\n    print();\n    return 0;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e90.0.c", "original_string": "char * gercaptcha (char captcha [6]) {\n    int cont;\n    for (cont = 0; cont < 6; cont ++)\n    {\n        if (cont== 0 || cont==3|| cont ==5)\n        {\n            captcha [cont] = 65 + (rand() % 26);\n        }else {\n            if (cont==1 || cont == 2|| cont==4)\n            {\n                captcha [cont] = 48 + (rand() % 10);\n            }\n        }\n    }\n    return captcha;\n}"}
{"author": "dishanp", "file": "DSA__q3.0.c", "original_string": "void printPoly(int poly[], int n)\n{\n    for (int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d\", poly[i]);\n        if (i != 0)\n            printf(\"x^%d\", i) ;\n        if (i != n-1)\n            printf(\" + \");\n    }\n    printf(\"\\n\");\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_05.1.c", "original_string": "void display(int arr2[], int n)\n{   \n        int i;\n        for(i = 0; i<n; i++)\n        {\n                fprintf(F2, \"%d \", arr2[i]);\n        }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__ssh_server.11.c", "original_string": "void sshServerDeinit(SshServerContext *context)\n{\n   if(context != NULL)\n   {\n      socketClose(context->socket);\n      sshDeinit(&context->sshContext);\n      osMemset(context, 0, sizeof(SshServerContext));\n   }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_CLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the list is %d\\n\",c);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__stack.1.c", "original_string": "int Pop(PPNODE Head)        \n{\n    int no = 0;\n    PNODE temp = *Head;\n    if(*Head == NULL)\n    {\n        printf(\"Stack is empty\\n\");\n        return -1;\n    }\n    else\n    {\n        no = (*Head)->data;         \n        *Head = (*Head)->next;\n        free(temp);\n        return no;\n    }\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__sum999.2.c", "original_string": "void *productofnum(void *arra)\n{\n    float product=1;\n    int *arr=(int *)arra;\n    for(i=0;i<n;i++)\n    {\n        product=arr[i]*product;\n        printf(\"%f\\t\",product);\n    }\n    printf(\"the product is %f\\n\",product);\n}"}
{"author": "sdukesameer", "file": "dsa__list-ins-seq-sor.2.c", "original_string": "void sorted_insert(node** head, int inp)\n{\n    node* newnode=createnode(inp);\n    if(*head==NULL||newnode->data < (*head)->data)\n    {\n        newnode->next=*head;\n        *head=newnode;\n        printf(\"%d inserted\\n\",(*head)->data);\n    }\n    else\n    {\n        node* temp=*head;\n        while(temp->next!=NULL&&temp->next->data < newnode->data)\n            temp=temp->next;\n        newnode->next=temp->next;\n        temp->next=newnode;\n        printf(\"%d inserted\\n\",temp->next->data);\n    }\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad6.2.c", "original_string": "int red(pozicija p)\n{\n    char c;\n    while (1) {\n        printf(\"Unesi N za unos novog elementa reda, M za micanje postojeceg elementa reda, I za ispis elemenata reda, X za izlaz\\n\");\n        scanf(\" %c\", &c);\n        if (c == 'N')\n            pushR(p);\n        else if (c == 'M')\n            pop(p);\n        else if (c == 'I')\n            ispis(p->next);\n        else if (c == 'X')\n            break;\n        else\n            printf(\"Nisi unio ispravno slovo!\\n\");\n    }\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__iterative_traversals.2.c", "original_string": "void iterative_preorder(nptr root)\n{\n    stack s; s.top = -1;\n    nptr cur;\n    push(&s, root);\n    while (!IsEmpty(s)) \n    {\n        cur = Pop(s);\n        printf(\"%d\", cur->data);\n        if (cur -> rchild) \n            push(&s, cur -> rchild);\n        if (cur -> lchild) \n            push(&s, cur -> lchild);\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader0.4.c", "original_string": "static void openFirmwareUpdateInfoFileInVSCode(void)\n{\n  char vsCodePath[260 + 1] = \"\";\n  char *os = getenv(\"OS\");\n  if (os != NULL && strcmp(os, \"Windows_NT\") == 0) \n  {\n    snprintf(vsCodePath, sizeof(vsCodePath), \"C:\\\\Users\\\\%s\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\bin\\\\code\", getenv(\"USERNAME\"));\n  }\n  else\n  {\n    snprintf(vsCodePath, sizeof(vsCodePath), \"/usr/bin/code\");\n  }\n  if (access(vsCodePath, F_OK) != -1) \n  {\n    char openCommand[260 + 1] = \"\";\n    snprintf(openCommand, sizeof(openCommand), \"code %s\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n    system(openCommand);\n  }\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__catavento.3.c", "original_string": "void display()\n{\n    glMatrixMode(GL_MODELVIEW);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glLoadIdentity();\n    glTranslatef(0.0, 0.0, -9.0);\n    glPopMatrix();\n    glPushMatrix();\n    desenhaCentro();\n    desenhaFolhas();\n    glutSwapBuffers();\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.21.c", "original_string": "void assemble(ASSEMBLER* a) {\n    STRINGLIST* currln = a->lns;\n    while(currln != NULL) {\n        if(currln->content[0] == '@')\n            transa(currln);\n        else\n            transb(currln);\n        currln = currln->next;\n    }\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica3-3a.0.c", "original_string": "int main(){\n    srand(time(NULL));                  \n    sem_init(&mutex, 0, 1);             \n    sem_init(&full, 0, 0);              \n    sem_init(&empty, 0, n);           \n    pthread_t threadProductor;        \n    pthread_t threadConsumidor;        \n    if(pthread_create(&threadProductor, NULL, productor, NULL)){ printf(\"Error %d\\n\", errno); exit(EXIT_FAILURE); }\n    if(pthread_create(&threadConsumidor, NULL, consumidor, NULL )){ printf(\"Error %d\\n\", errno); exit(EXIT_FAILURE); }\n    if (pthread_join(threadProductor, NULL)){ printf(\"Error %d\\n\", errno); exit(EXIT_FAILURE); }\n    if (pthread_join(threadConsumidor, NULL)){ printf(\"Error %d\\n\", errno); exit(EXIT_FAILURE); }\n    for(int i=0; i<n; i++){ printf(\"Valor %d del buffer: %d\\n\", i+1, v[i]); }\n    exit(EXIT_SUCCESS);                                        \n}"}
{"author": "augustogunsch", "file": "jackc__assembler.11.c", "original_string": "SYMBOL* readlabel(ASSEMBLER* a, STRINGLIST* ln, int count) {\n    int i = 1;\n    char c;\n    while(true) {\n        c = ln->content[i];\n        if(c == ')') \n            break;\n        i++;\n    }\n    int size = i * sizeof(char);\n    char* name = (char*)malloc(size);\n    snprintf(name, size, \"%s\", ln->content+sizeof(char));\n    SYMBOL* l = (SYMBOL*)malloc(sizeof(SYMBOL));\n    l->name = name;\n    l->value = count;\n    return l;\n}"}
{"author": "dle2005", "file": "Algorithm__Floyd_v2.3.c", "original_string": "void main() {\n    int n = 5; \n    int **W = init_matrix(n + 1); \n    int **D = init_matrix(n + 1); \n    int **P = init_matrix(n + 1);\n    for(int i = 1; i <= n; i++) \n        for(int j = 1; j <= n; j++)\n            scanf(\"%d\", &W[i][j]);\n    floyd2(n, W, D, P); \n    printf(\"\\n\");\n    for(int i = 1; i <= n; i++) { \n        for(int j = 1; j <= n; j++)\n            printf(\"%d \", D[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    for(int i = 1; i <= n; i++) { \n        for(int j = 1; j <= n; j++)\n            printf(\"%d \", P[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    for(int i = 1; i <= n; i++) { \n        for(int j = 1; j <= n; j++) {\n            if(P[i][j] != 0) {\n                printf(\"Path v%d ~ v%d: v%d -> \", i, j, i); \n                path(i, j, P);\n                printf(\"v%d\\n\", j);\n            }\n        }\n    }\n}"}
{"author": "dishanp", "file": "DSA__q62.1.c", "original_string": "void rowsort(int **mat, int m, int n)\n{\n    for (int i = 0 ; i < m ; i++)\n    {\n        for (int j = 0 ; j < n - 1 ; j++)\n        {\n            for (int k = j + 1 ; k < n ; k++)\n            {\n                if (mat[i][j] > mat[i][k])\n                swap(&mat[i][j], &mat[i][k]);\n            }\n        }\n    }\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__sum_999_server.0.c", "original_string": "int main()\n{\n    key_t key;\n    int array[10],i,n;\n    int shmid;\n    struct Memory *shmptr;\n    key = ftok(\".\", 'x');\n    printf(\"key:%d\\n\",key);\n    shmid = shmget(key, sizeof(struct Memory), IPC_CREAT | 0666);\n     if (shmid < 0) {\n          printf(\"*** shmget error (server) ***\\n\");\n          exit(1);\n     }\n     shmptr=(struct Memory*)shmat(shmid,NULL,0);\n     if ((int) shmptr == -1) {\n          printf(\"*** shmat error (server) ***\\n\");\n          exit(1);\n     }\n     printf(\"enter the array elements less than 10 numbers and use 999 to stop the number\\n\");\n     while(array[i]!=999)\n    {\n    for(i=0;i<SIZE;i++)\n    {\n        scanf(\"%d\",&array[i]);\n        n=i;\n        if(array[i]==999)\n        break;\n    }\n    }\n    float product=1,sum=0;\n    for(i=0;i<n;i++)\n    {\n        sum+=array[i];\n        product*=array[i];\n    }\n    shmptr->status  = NOT_READY;\n    shmptr->arr[0]=sum;\n    shmptr->arr[1]=product;\n    shmptr->arr[2]=sum/n;\n     shmptr->status=FILLED;\n     printf(\"please start the client in another window\\n\");\n     while (shmptr->status != TAKEN)\n          sleep(1);\n    shmdt((void *) shmptr);\n    printf(\"back to server and shared memory detached\\n\");\n     shmctl(shmid, IPC_RMID, NULL);\n     exit(0);\n}"}
{"author": "MartinMarinovich", "file": "ParcialLaboratorio1GCompleto__servicio.4.c", "original_string": "int buscarServicios(eServicio servicios[],int tam_s,int idServicio)\n{\n    int indice=-1;\n    for(int i=0;i<tam_s;i++)\n    {\n        if(servicios[i].idServicio ==idServicio)\n        {\n            indice=i;\n            break;\n        }\n    }\n        return indice;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__longadd.1.c", "original_string": "void insert(nptr list,int x)\n{\n    nptr temp = createNode();\n    temp->ele = x;\n    temp-> llink = list;\n    temp-> rlink = list -> rlink;\n    list -> rlink = temp;\n    (temp -> rlink) -> llink = temp;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Single.1.c", "original_string": "void add_file(char name)\n{\n    struct dir* p=(struct dir*)malloc(sizeof(struct dir));\n    p->file=name;\n    p->next=NULL;\n    if(isthere(name)==-1)\n    {\n        if(start==NULL)\n            start=p;\n        else\n        {\n            temp=start;\n            while(temp->next!=NULL)\n                temp=temp->next;\n            temp->next=p;\n        }\n    }\n    else\n        printf(\"\\nFile already exists\");\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__4.6.c", "original_string": "int main()\n{\n    rect_t retangulo_1, retangulo_2;\n    int escolha;\n    do\n    {\n        do\n        {\n            printf(\"\\n\\t(1) Calcular a \u00e1rea de um ret\u00e2ngulo\\n\");\n            printf(\"\\t(2) Verificar interse\u00e7\u00e3o de retangulos\\n\");\n            printf(\"\\t(3) Verificar se um ret\u00e2ngulo est\u00e1 contido em um outro\\n\");\n            printf(\"\\t(4) Calcular a \u00e1rea da interse\u00e7\u00e3o entre dois retangulos\\n\");\n            printf(\"\\t(5) Sair\\n\");\n            printf(\"\\n\\tDigite sua escolha: \");\n            scanf(\"%i\", &escolha);\n            getchar();\n            if (escolha < 1 || escolha > 5) system(\"clear\");\n        } while (escolha < 1 || escolha > 5);\n        switch (escolha)\n        {\n            case 1:\n                le_retangulo(&retangulo_1);\n                printf(\"\\n\u00c1rea = %lf\\n\", area(retangulo_1));\n                break;\n            case 2:\n                le_retangulos(&retangulo_1, &retangulo_2);\n                if ((intersecao(retangulo_1, retangulo_2) || intersecao(retangulo_2, retangulo_1)) == true)\n                {\n                    printf(\"\\nOs ret\u00e2ngulos dados se intersectam!\\n\");\n                }\n                else printf(\"\\nOs ret\u00e2ngulos dados n\u00e3o se intersectam!\\n\");\n                break;\n            case 3:\n                le_retangulos(&retangulo_1, &retangulo_2);\n                switch (contido(retangulo_1, retangulo_2))\n                {\n                    case 1:\n                        printf(\"\\nO ret\u00e2ngulo 1 est\u00e1 contido no ret\u00e2ngulo 2\\n\");\n                        break;\n                    case 2:\n                        printf(\"\\nO ret\u00e2ngulo 2 est\u00e1 contido no ret\u00e2ngulo 1\\n\");\n                        break;\n                    case 3:\n                        printf(\"\\nOs ret\u00e2ngulos s\u00e3o identicos\\n\");\n                        break;\n                    case 0:\n                        printf(\"\\nNenhum ret\u00e2ngulo est\u00e1 contido no outro\\n\");\n                        break;\n                }\n                break;\n            case 4:\n                le_retangulos(&retangulo_1, &retangulo_2);\n                if ((intersecao(retangulo_1, retangulo_2) || intersecao(retangulo_2, retangulo_1)) == false)\n                {\n                    printf(\"\\nOs ret\u00e2ngulos dados n\u00e3o se intersectam!\\n\");\n                }\n                else\n                {\n                    printf(\"\\n\u00c1rea da interse\u00e7\u00e3o = %lf\\n\", intersecao_area(retangulo_1, retangulo_2));\n                }\n                break;\n            case 5:\n                return 0;\n        }\n        printf(\"\\nPressione ENTER para continuar: \");\n        getchar();\n        system(\"clear\");\n    } while (escolha != 5);\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__pwm_double.1.c", "original_string": "void delay(int ct)\n{\n    for(int i=0;i<ct;i++)\n    {\n        for(int j=0;j<6000;j++)\n        {\n        }\n    }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__str_capitalizer.2.c", "original_string": "int     main(int ac,char **av)\n{\n    int     i;\n    int     i2;\n    i = 0;\n    if (ac > 1)\n    {\n        while (i < ac)  \n        {\n            i++;\n            i2 = 0;\n            while (av[i][i2])\n            {\n                if (tolowerr(av[i][i2], av[i][i2 + 1]))\n                    av[i][i2] += 32;\n                else if (toupperr(av[i][i2] , av[i][i2 + 1]))\n                    av[i][i2] -= 32;\n                write(1, &av[i][i2], 1);\n                i2++;\n            }\n            i++;\n            write(1, \"\\n\", 1);\n        }\n    }\n    else\n        write(1, \"\\n\",1);\n    return(0);\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_sys_bios.14.c", "original_string": "bool_t osCreateSemaphore(OsSemaphore *semaphore, uint_t count)\n{\n   Semaphore_Params semaphoreParams;\n   Semaphore_Params_init(&semaphoreParams);\n   semaphoreParams.mode = Semaphore_Mode_COUNTING;\n   semaphore->handle = Semaphore_create(count, &semaphoreParams, NULL);\n   if(semaphore->handle != NULL)\n      return TRUE;\n   else\n      return FALSE;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e30.2.c", "original_string": "int main(int argc, char *argv[]) {\n    char captchaDigitado[CAPTCHA], captchaSistema[CAPTCHA], *atribuicao;\n    int comparaDigitado;\n    do{\n        atribuicao = gerarCaptcha(captchaSistema);\n        printf(\"%s\", atribuicao);\n        printf(\"\\nDigite o captcha para provar q nao e um robo\\n\");\n        gets(captchaDigitado);\n        comparaDigitado = confirmacaoCaptcha(atribuicao, captchaDigitado);\n        if(comparaDigitado == 0){\n            printf(\"\\nSao iguais!! Voce nao e um robo\\n\");\n        }\n        else if(comparaDigitado < 0 || comparaDigitado > 0){\n            printf(\"\\nCaptcha errado, um novo sera redefinido\\n\");\n        }\n    }while(comparaDigitado < 0 || comparaDigitado > 0);\n    return 0;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__22_Dowhile.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Senh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    do{\n        Suma_total += Exp(X,(i*2)+1) / Fac((i*2)+1);\n        ++i;\n    }while(i <= veces);\n    printf(\"senh(%i) es igual a %lf\", X, (Suma_total + X));\n    return 0;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_37.0.c", "original_string": "void ordenarVetorCrescente() {\n    for (int i = 0; i <= 5; i++) {\n        int menorValorPosicao = buscarMenorValor(i);\n        int valorPosicaoAnterior = vetor[i];\n        vetor[i] = menorValorPosicao;\n        vetor[posicaoReporNumero] = valorPosicaoAnterior;\n    }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__dequeue1.3.c", "original_string": "void dequeueR()\n{\n    if((front==-1 && rear==-1) || front>rear)\n    printf(\"queue is empty\");\n    else\n    {\n        printf(\"The value popped is %d\",queue[rear]);\n        rear=rear-1;\n    }\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__1000-sort_deck.2.c", "original_string": "void quicksort(deck_node_t **deck, int lo, int hi)\n{\n    int p;\n    if (lo < hi)\n    {\n        p = partition(deck, lo, hi);\n        quicksort(deck, lo, p - 1);\n        quicksort(deck, p + 1, hi);\n    }\n}"}
{"author": "augustogunsch", "file": "jack-compiler__io.4.c", "original_string": "char* getfullname(char* fname, int fnamelen, char* dirname, int dirlen) {\n    int sz = sizeof(char)*(fnamelen+dirlen+2);\n    char* fullname = (char*)malloc(sz);\n    sprintf(fullname, \"%s/%s\", dirname, fname);\n    return fullname;\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__map_manager.4.c", "original_string": "void        error_redirect(int error)\n{\n    if (error == 0)\n        ft_putstr(\"Error:\\nmap has an unknown character\\n\");\n    else if (error == 1)\n        ft_putstr(\"Error:\\nthe map isnt closed\");\n    exit(0);\n}"}
{"author": "Mr-JoE1", "file": "C-Tasks-for-newbies__main17.0.c", "original_string": "int main()\n{\n    int binary;\n    printf(\"Enter Number In Binary Form : \");\n    scanf(\"%d\" , &binary);\n    printf(\"\\nNumber = %d\\n\" , BinaryToDecimal( binary ) );\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__sftp_server_directory.4.c", "original_string": "error_t sftpServerCloseDir(SftpServerSession *session,\n   const SshBinaryString *handle)\n{\n   error_t error;\n   SftpFileObject *fileObject;\n   fileObject = sftpServerFindDir(session, handle);\n   if(fileObject != NULL)\n   {\n      fsCloseDir(fileObject->dir);\n      fileObject->dir = NULL;\n      fileObject->type = SSH_FILEXFER_TYPE_INVALID;\n      error = NO_ERROR;\n   }\n   else\n   {\n      error = ERROR_INVALID_HANDLE;\n   }\n   return error;\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__23.3.c", "original_string": "void sorting(int a[],int n)\n{\n    int i,j,t;\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<n-i-1;j++)\n        {\n            if(a[j]>a[j+1])\n            {\n                t=a[j];\n                a[j]=a[j+1];\n                a[j+1]=t;\n            }\n        }\n    }\n    for(i=0;i<n;i++)\n    printf(\"\\n%d\",a[i]);\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client.0.c", "original_string": "int main()\n{\n    int sockfd, fdmax, i;\n    struct sockaddr_in server_addr;\n    fd_set master;\n    fd_set read_fds;\n    char name[32];\n    char new_entry_message[42];\n    printf(\"Please enter your name: \");\n    fgets(name, 32, stdin);\n    str_trim_lf(name, strlen(name));\n    if (strlen(name) > 32 || strlen(name) < 2)\n    {\n        printf(\"Name must be less than 30 and more than 2 characters.\\n\");\n        return EXIT_FAILURE;\n    }\n    connect_request(&sockfd, &server_addr);\n    strcpy(new_entry_message, name);\n    strcat(new_entry_message, \" joined!\");\n    send(sockfd, new_entry_message, 32, 0);\n    FD_ZERO(&master);\n    FD_ZERO(&read_fds);\n    FD_SET(0, &master);\n    FD_SET(sockfd, &master);\n    printf(\"\\n--------------------- WELCOME TO THE CHATROOM ---------------------\\n\");\n    fdmax = sockfd;\n    while (1)\n    {\n        read_fds = master;\n        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)\n        {\n            perror(\"select\");\n            exit(4);\n        }\n        for (i = 0; i <= fdmax; i++)\n            if (FD_ISSET(i, &read_fds))\n               send_recv(i, sockfd, name, &master);\n    }\n    printf(\"Bye\\n\");\n    close(sockfd);\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__lcd_func.5.c", "original_string": "void lcd_str1(char str[])\n{\n    int i,count=0;\n    for(i=0;str[i]!='\\0';++i)\n        {\n            lcd_data(str[i]);\n            if(count == 16)\n            {\n                lcd_cmd(0xC0);\n            }\n            count++;\n        }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__drv_ws2812.6.c", "original_string": "uint32_t drv_ws2812_rectangle_draw(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint32_t color)\n{\n    uint32_t err_code;\n    for(int h = y; h < (y + height); h++)\n    {\n        for(int w = x; w < (x + width); w++)\n        {\n            err_code = drv_ws2812_pixel_draw(w, h, color);\n            if(err_code) return err_code;\n        }\n    }\n    return NRF_SUCCESS;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sort_Array_Descending.0.c", "original_string": "void main()\n{\n    int i = 0;\n    int size = 0;\n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n    printf(\"\\nArray after Sorting is as follows:- \\n\");\n    sorting(input_array, size);\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes2.3.c", "original_string": "void modificar_alumno(){\n    system(\"clear\");\n    puts(\"\\tMenu para cambio de nombre...\");\n    int posicion = posicion_alumno();\n    estudiante estudiante_seleccionado = lista_estudiantes[posicion];\n    printf(\"El nombre del alumno es: %s\\n\", estudiante_seleccionado.nombre);\n    printf(\"Ingresa el nuevo nombre: \");\n    fflush(stdin);\n    fgets(estudiante_seleccionado.nombre, 60, stdin);\n    lista_estudiantes[posicion] = estudiante_seleccionado;\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_print_combn.8.c", "original_string": "void comb7(int *numeros,int a,int b,int c, int d,int e,int f,int g)\n{\n  while(a<=3)\n       {\n        while(b<=4)\n            {\n                while(c<=5)\n                    {\n                        while(d<=6)\n                            {\n                              while(e<=7)\n                                  {\n                                    while(f<=8)\n                                         {\n                                          while(g<=9)\n                                              {\n                                                printf(\"%i%i%i%i%i%i%i, \",numeros[a],numeros[b],numeros[c],numeros[d],numeros[e],numeros[f],numeros[g]);\n                                                g=g+1;\n                                              }\n                                          f=f+1;\n                                          g=f+1;\n                                         }\n                                    e=e+1;\n                                    f=e+1;\n                                    g=f+1;\n                                  }\n                              d=d+1;\n                              e=d+1;\n                              f=e+1;\n                              g=f+1;\n                            } \n                        c=c+1;\n                        d=c+1;\n                        e=d+1;\n                        f=e+1;\n                        g=f+1;\n                    }\n                b=b+1;\n                c=b+1;\n                d=c+1;\n                e=d+1;\n                f=e+1;\n                g=f+1;\n            }\n        a=a+1;\n        b=a+1;\n        c=b+1;\n        d=c+1;\n        e=d+1;\n        f=e+1;\n        g=f+1;\n       }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__DemoFOTAUpdateWorkflow.3.c", "original_string": "void fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)\n{\n  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;\n  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_5.5.c", "original_string": "void del()\n{\n    struct node* temp;\n    int key;\n    printf(\"Enter the key : \");\n    scanf(\"%d\", &key);\n    if(key > length())\n    {\n        printf(\"Invalid Location\\n\");\n    }\n    else if(key == 1)\n    {\n        temp = root;\n        root = temp->link;\n        temp->link = NULL;\n        free(temp);\n    }\n    else\n    {\n        struct node* p = root, *q;\n        int i = 1;\n        while(i < key - 1)\n        {\n            p = p->link;\n            i++;\n        }\n        q = p->link;\n        p->link = q->link;\n        q->link = NULL;\n        free(q);\n    }\n}"}
{"author": "254Odeke", "file": "Operating-Systems_Lab__Page_Replacement_Alg_LRU_Simulation.0.c", "original_string": "void main(){\nint g=0,a[5],b[20],p=0,q=0,m=0,h,k,i,q1=1,j,u,n; char f='F';\nprintf(\"Enter the number of pages:\"); scanf(\"%d\",&n);\nprintf(\"Enter %d Page Numbers:\",n); for(i=0;i<n;i++)\nscanf(\"%d\",&b[i]);\nfor(i=0;i<n;i++)\n{if(p==0)\n{\nif(q>=3)\nq=0;\na[q]=b[i];\nq++;\nif(q1<3)\n{\nq1=q;\n}\n}\nprintf(\"\\n%d\",b[i]);\nprintf(\"\\t\");\nfor(h=0;h<q1;h++)\nprintf(\"%d\",a[h]);\nif((p==0)&&(q<=3))\n{\nprintf(\"-->%c\",f);m++;\n}\np=0;\ng=0;\nif(q1==3)\n{\nfor(k=0;k<q1;k++)\n54;\n{\nif(b[i+1]==a[k])\np=1;\n}\nfor(j=0;j<q1;j++)\n{\nu=0;\nk=i;while(k>=(i-1)&&(k>=0))\n{\nif(b[k]==a[j])\nu++;k--;\n}\nif(u==0)\nq=j;\n}\n}\nelse\n{\nfor(k=0;k<q;k++)\n{\nif(b[i+1]==a[k])\np=1;\n}\n}\n}\nprintf(\"\\nNo of faults:%d\",m); getch();\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b3.1.c", "original_string": "int main() {\n    char *filename = \"Seats.txt\";\n    FILE *f = fopen(filename, \"r\");\n    bool *seats = calloc(sizeof(bool), 128 * 8);\n    char *seat = NULL; size_t n = 0;\n    while (getline(&seat, &n, f) != -1) {\n        size_t low = 0; size_t high = 127;\n        for (int i = 0; i < 7; i++) {\n            if (seat[i] == 'F') high -= (high - low + 1) / 2;\n            else low += (high - low + 1) / 2;\n        }\n        size_t row = low;\n        low = 0; high = 7;\n        for (int i = 7; i < 10; i++) {\n            if (seat[i] == 'L') high -= (high - low + 1) / 2;\n            else low += (high - low + 1) / 2;\n        }\n        size_t col = low;\n        size_t id = row * 8 + col;\n        seats[id] = true;\n    }\n    printf(\"Answer: %zu\\n\", find_empty(seats));\n    free(seat);\n    free(seats);\n    fclose(f);\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_SLL.10.c", "original_string": "void reverse()\n{\n    struct node *nextnode,*prenode,*currentnode;\n    prenode=0;\n    currentnode=nextnode=head;\n    while(nextnode!=0)\n    {\n        nextnode=nextnode->next;\n        currentnode->next=prenode;\n        prenode=currentnode;\n        currentnode=nextnode;\n    }\n    head=prenode;\n}"}
{"author": "0712023", "file": "Arduino-Mood-Light-DIY-kit__Chapter2_Sensor.5.c", "original_string": "void ultra_set() {\n  static long dis_pre;\n  digitalWrite(TRIG_PIN, HIGH);\n  delayMicroseconds(10);\n  digitalWrite(TRIG_PIN, LOW);\n  long duration = pulseIn(ECHO_PIN, HIGH);\n  long distance = ((float)(340 * duration) / 1000) / 2 ;\n  delay(50);\n  if ( distance > 2000 )\n    distance = dis_pre;\n  if ( distance < dis_1 )\n    distance = dis_1;\n  else if ( distance > dis_3 )\n    distance = dis_3;\n  dis_pre = distance;\n  if ( dis_1 <= distance && distance <= dis_2 ) {\n    for (int i = 0; i < NUMPIXELS; i++) {\n      pixels.setPixelColor(i, pixels.Color( 255 - map(distance, dis_1, dis_2, 0, 255) , map(distance, dis_1, dis_2, 0, 255) , 0) );\n      pixels.show();\n    }\n  }\n  else if ( dis_2 <= distance && distance <= dis_3 ) {\n    for (int i = 0; i < NUMPIXELS; i++) {\n      pixels.setPixelColor(i, pixels.Color( 0 , 255 - map(distance, dis_2, dis_3, 0, 255) , map(distance, dis_2, dis_3, 0, 255) ) );\n      pixels.show();\n    }\n  }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLLcircular.3.c", "original_string": "nptr deleteLeft(nptr head)\n{\n    if(head == NULL)\n        return head;\n    if(head -> left == head && head -> right == head)\n    {\n        printf(\"%d deleted\\n\", head -> data);\n        free(head);\n        return NULL;\n    }\n    nptr temp = head;\n    head = head -> right;\n    head -> left = temp -> left;\n    printf(\"%d deleted\\n\", temp -> data);\n    free(temp);\n    return head;\n}"}
{"author": "dle2005", "file": "Algorithm__Dijkstra_v2.1.c", "original_string": "int main() {\n    int num_of_Vertex;\n    printf(\"-----input-----\\n\");\n    printf(\"num of Vertex = \");\n    scanf(\"%d\", &num_of_Vertex);\n    edge F[num_of_Vertex];\n    number **W = (int **)malloc(sizeof(int) * num_of_Vertex);\n    for(int i = 0; i < num_of_Vertex; i++)\n        W[i] = (int *)malloc(sizeof(int) * num_of_Vertex);\n    printf(\"insert weight graph\\n\");\n    for(int i = 0; i < num_of_Vertex; i++)\n        for(int j = 0; j < num_of_Vertex; j++)\n            scanf(\"%d\", &W[i][j]);\n    dijkstra(num_of_Vertex, W, F);\n    printf(\"\\n-----output-----\\n\");\n    for(int i = 1; i < num_of_Vertex; i++) \n        printf(\"1 -> %d, length = %d, touch = %d\\n\",\n                F[i].j + 1, F[i].length, F[i].touch);\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_03.1.c", "original_string": "void display(int arr2[], int n)\n{\n        int i;\n        for(i = 0; i<n; i++)\n        {\n                fprintf(F2, \"%d \", arr2[i]);\n        }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_10.6.c", "original_string": "int main()\n{\n    char sel;\n    int p;\n    FILE* fp1;\n    FILE* fp2;\n    fp1=fopen(\"input.txt\",\"r\"); \n    fp2=fopen(\"output.txt\",\"w\");    \n    char exp[10000];        \n    while(1)    \n    {\n        int i=0;\n        fscanf(fp1,\"%c\",&sel);\n        if(sel=='e')\n        {\n            fgetc(fp1);\n            fscanf(fp1,\"%[^\\n]\",exp);\n            i=strlen(exp);\n            fgetc(fp1);\n            struct stack* stk=(struct stack*)malloc(sizeof(struct stack));\n            stk->A=(char*)malloc(i);\n            stk->top=-1;\n            stk->cap=i;\n            p=checkParantheses(exp,stk);\n            if(p==0)\n            {\n                fprintf(fp2, \"NO\\n\");\n            }\n            else\n                fprintf(fp2,\"YES\\n\");\n        }\n        else if(sel=='s')\n            break;\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__pwm_single.0.c", "original_string": "int main()\n{\n    PINSEL0 |= (1<<17);\n    PINSEL0 &= ~(1<<16);  \n    PWMPR = 14;\n    PWMMR0 = 10000;\n    PWMLER = 1<<0;\n    PWMMCR = (1<<1);   \n    PWMPCR &= ~(1<<4);  \n    PWMPCR = (1<<12);\n    PWMTCR = (1<<0)|(1<<3);  \n        while(1)\n        {\n            PWMMR4 = 2500;   \n            PWMLER = 1<<4;\n            delay(500);\n            PWMMR4 = 5000;   \n            PWMLER = 1<<4;\n            delay(500);\n            PWMMR4 = 7500;   \n            PWMLER = 1<<4;\n            delay(500);\n            PWMMR4 = 10000;   \n            PWMLER = 1<<4;\n            delay(500);\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_end_DCLL.4.c", "original_string": "void insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    temp=head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    temp->next=newnode;\n    newnode->pre=temp;\n    newnode->next=head;\n    head->pre=newnode;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.0.c", "original_string": "bool isop(TOKEN* t) {\n    for(int i = 0; i < operators.size; i++)\n        if(!strcmp(t->token, operators.items[i]))\n            return true;\n    return false;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__ssh_exchange_hash.4.c", "original_string": "error_t sshVerifyExchangeHashSignature(SshConnection *connection,\n   const SshBinaryString *serverHostKey, const SshBinaryString *signature)\n{\n   error_t error;\n   SshString serverHostKeyAlgo;\n   error = sshFinalizeExchangeHash(connection, connection->h,\n      &connection->hLen);\n   if(!error)\n   {\n      if(!connection->newKeysSent)\n      {\n         osMemcpy(connection->sessionId, connection->h, connection->hLen);\n         connection->sessionIdLen = connection->hLen;\n      }\n      serverHostKeyAlgo.value = connection->serverHostKeyAlgo;\n      serverHostKeyAlgo.length = osStrlen(connection->serverHostKeyAlgo);\n      error = sshVerifySignature(connection, &serverHostKeyAlgo, serverHostKey,\n         connection->h, connection->hLen, signature);\n   }\n   return error;\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__BubbleSort.3.c", "original_string": "void bubble_sort(int a[50],int n)\n    {\n       int i,j,temp;\n       count++;\n       for(i=1;i<n;i++)\n       {\n           count++;\n           count++;\n           for(j=0;j<n-i;j++)\n           {\n               count++;\n               count++;\n               if(a[j]>a[j+1])\n               {\n                   count++;\n                   temp=a[j];\n                   count++;\n                   a[j]=a[j+1];\n                   count++;\n                   a[j+1]=temp;\n                   count++;\n               }\n           }\n       }\n    }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Transpose_Matrix.0.c", "original_string": "void main()\n{\n    int i, j = 0;\n    int input_matrix[R][C];\n    printf(\"\\nEnter the matrix elements...\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &input_matrix[i][j]);\n        }\n    }\n    printf(\"\\nOriginal Matrix is as follows:- \\n\");\n    display(input_matrix);\n    transpose_and_display(input_matrix);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSL__tls_ticket.5.c", "original_string": "bool_t tlsCompareTicketKeyName(const uint8_t *ticket, size_t ticketLen,\n   const TlsTicketEncryptionState *state)\n{\n   bool_t res;\n   res = FALSE;\n   if(state->valid)\n   {\n      if(ticketLen >= TLS_TICKET_KEY_NAME_SIZE)\n      {\n         if(osMemcmp(ticket, state->keyName, TLS_TICKET_KEY_NAME_SIZE) == 0)\n         {\n            res = TRUE;\n         }\n      }\n   }\n   return res;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__os.0.c", "original_string": "CLASS* mkosclass(CLASS* os, const char* name) {\n    CLASS* c = (CLASS*)malloc(sizeof(CLASS));\n    c->name = ezheapstr(name);\n    c->subroutdecs = NULL;\n    c->next = os;\n    return c;\n}"}
{"author": "dishanp", "file": "DSA__q63.3.c", "original_string": "void frequency(struct node *p)\n{\n    struct node *q;\n    int c = 0, counter;\n    while(p)\n    {\n        counter = 0;\n        q = p->next;\n        while(q)\n        {\n            if(p->data == q->data)\n            counter++;\n            q = q->next;\n        }\n        if(counter == 0)\n        {\n            insert(head, c, p->data);\n            c++;\n        }\n        p = p->next;\n    }\n    struct node_freq *r = head;\n    while(r)\n    {\n        p = first;\n        while(p)\n        {\n            if(r->data == p->data)\n                r->freq++;\n            p = p ->next;\n        }\n        r = r->next;\n    }\n    display_freq(head);\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__loop_matriz.0.c", "original_string": "int main()\n{\n    int linha = 1, coluna = 1;\n    char a = 'a';\n    printf(\"\\n\");\n    for (int m = 0; m < mlinhas; m++)\n    {\n        for (int n = 0; n < ncolunas; n++)\n        {\n            if (coluna == 1)\n            {\n                printf(\"| \");\n            }\n            printf(\"%c%i%i  \", a, linha, coluna);\n            if (coluna == ncolunas)\n            {\n                printf(\"|\");\n            }\n            coluna++;\n        }\n        printf(\"\\n\");\n        linha++, coluna = 1;\n    }\n    printf(\"\\n\");\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.6.c", "original_string": "char* mkpointerind(VMTRANSLATOR* t) {\n    if(t->currln->tokens[2][0] == 0)\n        return mkstr(t, \"@THIS\");\n    else\n        return mkstr(t, \"@THAT\");\n}"}
{"author": "dishanp", "file": "DSA__q13.0.c", "original_string": "int mindist(int *arr, int n, int x, int y)\n{\n    int d = 100;\n    for(int i = 0 ; i < n ; i++)\n    {\n        if(x == *(arr + i))\n        {\n            for(int j = i ; j < n ; j++)\n            {\n                if(y == *(arr + j) && d > (j - i))\n                {\n                    d = j - i ;\n                }\n            }\n        }\n    }\n    return d;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sort_Array_Descending.2.c", "original_string": "void sorting(int array[MAX], int length)\n{\n    int i, j, temp = 0;\n    int size = length;\n    for(i=0; i<length; i++)\n    {\n        for(j=i+1; j<length; j++)\n        {\n            if(array[i] < array[j])\n            {\n                temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    }\n    display(array, size);\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__test.1.c", "original_string": "static void init_crc_table(void)\n{\n    unsigned int c;\n    unsigned int i, j;\n    for (i = 0; i < 256; i++) {\n        c = (unsigned int)i;\n        for (j = 0; j < 8; j++) {\n            if (c & 1)\n                c = 0xedb88320L ^ (c >> 1);\n            else\n                c = c >> 1;\n        }\n        crc_table[i] = c;\n    }\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Selection_Sort.1.c", "original_string": "void display(int array[MAX], int length)\n{\n    int i = 0;\n    for(i=0; i<length; i++)\n        printf(\"%d\\t\", array[i]);\n    printf(\"\\n\");\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Linear_Search.2.c", "original_string": "int linear_search(int array[MAX], int length, int key)\n{\n    int i, index = -1;\n    int size = length;\n    for(i=0; i<size; i++)\n    {\n        if(array[i] == key)\n        {\n            index = i;\n            break;\n        }\n        else\n            continue;\n    }\n    return index;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__pgcd.1.c", "original_string": "void    ft_putnbr(int nb)\n{\n    if (nb < 0)\n        nb *= -1;\n    if (nb > 9)\n    {\n        ft_putnbr(nb / 10);\n        ft_putnbr(nb % 10);\n    }\n    else\n        ft_putchar(nb + 48);\n}"}
{"author": "2security", "file": "Array__Orthogonal.2.c", "original_string": "int ** MultiMat(int **mat1,int **mat2,int **temp,int r,int c,int n)\n    {\n    int i,j,k;\n        for(i=0;i<r;i++)\n            {\n            for(j=0;j<n;j++)\n                {\n                temp[i][j]=0;\n                for(k=0;k<c;k++)\n                    temp[i][j]+=mat1[i][k]*mat2[k][j];\n                }\n            }\n        return temp;\n        }"}
{"author": "sdukesameer", "file": "dsa__bfs-a.4.c", "original_string": "void bfs(gph g, int s){\n    que q;\n    initialiseQueue(&q,g.n);\n    int visited[g.n],i,f;\n    for(i=0;i<g.n;i++)\n        visited[i]=0;\n    visited[s]=1;\n    enqueue(&q,s);\n    printf(\"\\nFollowing is the BFS Traversal (starting from %c): \\n\",'A'+s);\n    while(q.end!=-1){\n        f=dequeue(&q);\n        printf(\"%c\\t\",'A'+f);\n        for (i = 0; i < g.n; i++)\n            if(g.mat[f][i])\n                if(!visited[i]){\n                    visited[i]=1;\n                    enqueue(&q,i);\n                }\n    }\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__44_Trace_of_Matrix.0.c", "original_string": "int main()\n{\n  int i,j,k,r1,c1,r2,c2, flag = 0;\n  printf(\"Enter Value of r1, c1\\n\");\n  scanf(\"%d%d\",&r1,&c1);\n  int m1[r1][c1], sum = 0;\n  printf(\"Enter value of Matrix1\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      scanf(\"%d\",&m1[i][j]);\n    }\n  }\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      printf(\"%d \",m1[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for(i=0; i<r1; i++)\n  {\n    sum = sum + m1[i][i];\n  }\n  printf(\"Value of Trace is %d \",sum); \n}"}
{"author": "theuwis", "file": "AdventOfCode2016__main26.0.c", "original_string": "int main(void){\n    long total_len = 0;\n    int count = 0, multiplier_len = 0;\n    int chars = 0, times = 0;\n    while(input[count] != '\\0'){\n        if(input[count] == '('){\n            count++;\n            while(input[count] != 'x'){\n                chars = chars * 10 + (input[count] - '0'); \n                multiplier_len++;\n                count++;\n            }\n                count++;\n            while(input[count] != ')'){\n                times = times * 10 + (input[count] - '0'); \n                multiplier_len++;\n                count++;\n            }\n            multiplier_len += 3;\n            for(int i = 0; i < compression_list_index; i++){\n                if(compression_list[i][0] != 0){\n                    compression_list[i][0] -= multiplier_len;\n                }\n            }\n            compression_list[compression_list_index][0] = chars;\n            compression_list[compression_list_index][1] = times;\n            compression_list_index++;\n            chars = 0; \n            times = 0;\n            multiplier_len = 0;\n        }\n        else{\n            int total_multiplier = 1;\n            for(int i = 0; i < compression_list_index; i++){\n                if(compression_list[i][0] != 0){\n                    total_multiplier *= compression_list[i][1];\n                    compression_list[i][0] -= 1;\n                }\n            }\n            total_len += total_multiplier;\n        }\n        count++;\n    }\n    printf(\"answer=%ld\\n\", total_len);\n    return EXIT_SUCCESS;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_DLL.1.c", "original_string": "void creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "TSN-SHINGENN", "file": "mbmcs__mbmcs_LIMITED_MOTION_2STATE_SWITCH.4.c", "original_string": "void mbmcs_limited_motion_2state_switch_irq_enable(const mbmcs_limited_motion_2state_switch_t *self_p, bool is_true)\n{\n    uint32_t reg32 = LMSW_OP_STAT_REG(self_p->base_addr);\n    if(is_true== true ) {\n    reg32 |= LMSW_OP_INTR_ENABLE_MASK;\n    } else {\n    reg32 &= ~LMSW_OP_INTR_ENABLE_MASK;\n    }\n    LMSW_OP_STAT_REG(self_p->base_addr) = reg32;\n    return;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__create_single_linked_list.2.c", "original_string": "void displaylist()\n    {\n        struct node*temp;\n        temp=head;\n        while(temp!=NULL)\n        {\n            printf(\"%d\\n\", temp->data);\n            temp=temp->next;\n        }\n    }"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__DemoFOTAUpdateWorkflowFilePersistence.0.c", "original_string": "void saveState(int16_t state)\n{\n  FILE *file = fopen(DEMO_PRODUCT_UPDATE_STATE_FILE_NAME, \"wb\");\n  if (file == NULL) \n  {\n    printf(\"Failed to open %s for writing\\n\", DEMO_PRODUCT_UPDATE_STATE_FILE_NAME);\n    return;\n  }\n  if (fwrite(&state, sizeof(state), 1, file) != 1) \n  {\n    printf(\"Failed to write statemachine state %hi to %s\\n\", state, DEMO_PRODUCT_UPDATE_STATE_FILE_NAME);\n    fclose(file);\n    return;\n  }\n  fclose(file);\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sum_Rows_Columns_Matrix.3.c", "original_string": "void display(int matrix[R][C])\n{\n    int i, j = 0;\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "dishanp", "file": "DSA__q15.2.c", "original_string": "void delete(struct node *p, int key)\n{\n    int index = 1;\n    struct node *q = NULL;\n    if(first->data == key)\n    {\n        printf(\"\\nKey found at node : %d\\n\\n\", index);\n    }\n    else\n    {\n        while(p->data != key)\n        {\n            q = p;\n            p = p->next;\n            index++;\n            if(p->next ==NULL && p->data != key)\n            {\n                printf(\"\\nKey is not present in list\\n\");\n            }\n        }\n        printf(\"Key found at node : %d\\n\", index);\n        q->next = p->next;\n        p->next = first;\n        first = p;\n        printf(\"Key moved to head\\n\\nNew list : \");\n        display(first);\n    }\n}"}
{"author": "revathy16296", "file": "rtos_lab_asssignment_1__9_string_cmp.2.c", "original_string": "void choice_zero(char b[SIZE])\n{\n        char r[4]=\"MCIS\";\n        if (strncmp(b,r,4)==0)\n        {printf(\"the value is matching with MCIS\\n\");}\n        else{\n        printf(\"the  string is not matching with MCIS\\n\");\n        printf(\"the length of given string is %d\",n-3);}\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_DCLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n}"}
{"author": "tadeograch", "file": "sorting_algorithms__103-merge_sort.3.c", "original_string": "void CopyArray(int A[], int iBegin, int iEnd, int B[])\n{\n    int k;\n    for (k = iBegin; k < iEnd; k++)\n        B[k] = A[k];\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q14.1.c", "original_string": "int dequeue(queue *q)\n{\n    if (q->front==q->rear)\n    {\n        printf(\"Queue Empty\");\n        return -1;\n    }\n    else\n        return q->c[--(q->rear)];\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__goal_client.1.c", "original_string": "void str_trim_lf (char* arr, int length) {\n  int i;\n  for (i = 0; i < length; i++) { \n    if (arr[i] == '\\n') {\n      arr[i] = '\\0';\n      break;\n    }\n  }\n}"}
{"author": "haon1026", "file": "linux-programming__deadlock2.1.c", "original_string": "void* fun2(void *arg)\n{\n    pthread_mutex_lock(&mutex2);\n    printf(\"val2 = %d\\n\", val2);\n    sleep(1);\n    pthread_mutex_lock(&mutex1);\n    val1 = 200;\n    printf(\"val1 = %d\\n\", val1);\n    pthread_mutex_unlock(&mutex1);\n    pthread_mutex_unlock(&mutex2);\n    return NULL;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_client_misc.2.c", "original_string": "error_t scpClientEstablishConnection(ScpClientContext *context)\n{\n   error_t error;\n   if(context->sshConnection.state < SSH_CONN_STATE_OPEN)\n   {\n      error = scpClientProcessEvents(context);\n   }\n   else if(context->sshConnection.state == SSH_CONN_STATE_OPEN)\n   {\n      scpClientChangeState(context, SCP_CLIENT_STATE_CONNECTED);\n      error = NO_ERROR;\n   }\n   else\n   {\n      error = ERROR_WRONG_STATE;\n   }\n   return error;\n}"}
{"author": "dishanp", "file": "DSA__q4.2.c", "original_string": "int main()\n{\n    int n, m;\n    printf(\"Enter number of terms for P1: \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter coefficients according to increasing order of exponents : \");\n    for(int i = 0 ; i < n ; i++)\n        scanf(\"%d\", &A[i]);\n    printf(\"\\nFirst polynomial : \");\n    printPoly(A, n);\n    printf(\"\\nEnter number of terms for P2: \");\n    scanf(\"%d\", &m);\n    int B[m];\n    printf(\"Enter coefficients according to increasing order of exponents : \");\n    for(int i = 0 ; i < m ; i++)\n        scanf(\"%d\", &B[i]);\n    printf(\"\\nSecond polynomial : \");\n    printPoly(B, m);\n    printf(\"\\nProduct : \");\n    int *prod = multiply(A, B, n, m);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__7_Suma_factorial.1.c", "original_string": "int main()\n{\n    int numero = 0;\n    printf(\"Programa calcula la suma de 0 hasta un numero N ingresado por el usuario\\nIngresa un numero:\");\n    scanf(\"%i\",&numero);\n    if(numero == 0)\n        printf(\"La suma de los factoriales de 0 es 1\");\n    else\n        printf(\"La suma de los factoriales de %i es %i\",numero,Suma(numero,0));\n    return 0;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__circularLinkedList.0.c", "original_string": "void linkedListTraversal(struct Node *head)\n{\n     struct Node *ptr = head;\n     do\n     {\n          printf(\"Element is : %d\\n\", ptr->data);\n          ptr = ptr->next;\n     } while (ptr != head);\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Indexed.0.c", "original_string": "int ispossible()\n{\n    int i,ct=0;\n    for(i=1;i<16;i++)\n    {\n        if(disk[i]==0)\n            ct++;\n    }\n    return(ct);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__onlyRow.2.c", "original_string": "void col_key(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(COL);  \n        IODIR1 = IODIR1 | (ROW);  \n        val = (IOPIN1 & COL); \n        val = val >> 21;\n        switch(val)\n        {\n            case 0x0E: \n                lcd_str(\"C1\");\n                delay(500);\n                break;\n            case 0x0D:\n                lcd_str(\"C2\");\n                delay(500);\n                break;\n            case 0x0B:\n                lcd_str(\"C3\");\n                delay(500);\n                break;\n            case 0x07:\n                lcd_str(\"C4\");\n                delay(500);\n                break;\n            default:\n                delay(1000);\n                lcd_cmd(0x01);\n        }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e18.0.c", "original_string": "int main(int argc, char *argv[]) {\n    int player1, player2, optP1, optP2;\n    int mainMenu, playerMenu, modeMenu, novojogo;\n    int totalJogadas, empates, vitoriasP1, vitoriasP2, totalNormal, totalMelhor, totalStartrek, totalDeath, tempVitP1, tempVitP2, especial, tempDeath;\n    float percentP1, percentP2;\n    srand( time(NULL) );\n    totalJogadas=0;\n    totalNormal=0;\n    totalMelhor=0;\n    totalStartrek=0;\n    totalDeath=0;\n    empates=0;\n    vitoriasP1=0;\n    vitoriasP2=0;\n    especial=3;\n    do {\n        system(\"cls\");\n        printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n        printf(\"\\n\\n\\tO que voce quer fazer?\\n\");\n        printf(\"\\t1 - Jogar\\n\");\n        printf(\"\\t2 - Ver Regras\\n\");\n        printf(\"\\t3 - Ver Estatisticas\\n\");\n        printf(\"\\t4 - Sair\\n\\t\");\n        if (totalJogadas > especial ) {\n            printf(\"\\n\\t0 - ESPECIAL DEATHMATCH\\n\");\n        }\n        scanf(\"%d\",&mainMenu);\n        while( (mainMenu>4) || (totalJogadas<especial && mainMenu<1) ){\n            printf(\"\\t-> Opcao invalida!\\n\");\n            printf(\"\\tO que voce quer fazer?\\n\\t\");\n            scanf(\"%d\",&mainMenu);\n        }\n        system(\"cls\");\n        if (mainMenu==1){\n                printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n                printf(\"\\n\\n\\tComo voce quer jogar?\\n\");\n                printf(\"\\t1 - Player VS Player\");\n                printf(\"\\n\\t2 - Player VS Computador\\n\\t\");\n                scanf(\"%d\",&playerMenu);\n                while(playerMenu<1 || playerMenu>2){\n                    printf(\"\\t-> Opcao invalida!\\n\");\n                    printf(\"\\tComo voce quer jogar?\\n\\t\");\n                    scanf(\"%d\",&playerMenu);\n                }\n                system(\"cls\");\n                printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n                printf(\"\\n\\n\\tMODO DE JOGO:\\n\");\n                printf(\"\\t1 - Normal\\n\");\n                printf(\"\\t2 - Melhor de 3\\n\");\n                printf(\"\\t3 - Startreck\\n\\t\");\n                scanf(\"%d\",&modeMenu);\n                while(modeMenu<1 || modeMenu>3){\n                    printf(\"-> Opcao invalida!\\n\");\n                    printf(\"Como voce quer jogar?\\n\\t\");\n                    scanf(\"%d\",&modeMenu);\n                }\n                system(\"cls\");\n                if (modeMenu==1) {\n                    do {\n                        printf(\"Vez do Player 1.\\n\");\n                        printf(\"Escolha uma opcao para jogar:\\n\");\n                        printf(\"\\t1 - Pedra\\n\");\n                        printf(\"\\t2 - Papel\\n\");\n                        printf(\"\\t3 - Tesoura\\n\");\n                        printf(\"Numero: \");\n                        scanf(\"%d\",&optP1);\n                        while( optP1<1 || optP1>3 ){\n                            printf(\"Opcao invalida. Digite novamente: \");\n                            scanf(\"%d\",&optP1);\n                        }\n                        system(\"cls\");\n                        printf(\"Agora o Player 2.\\n\");\n                        printf(\"Escolha uma opcao para jogar:\\n\");\n                        printf(\"\\t1 - Pedra\\n\");\n                        printf(\"\\t2 - Papel\\n\");\n                        printf(\"\\t3 - Tesoura\\n\");\n                        system(\"pause\");\n                        printf(\"Numero: \");\n                        if (playerMenu==1) {\n                            scanf(\"%d\",&optP2);\n                            while( optP2<1 || optP2>3 ){\n                                printf(\"Opcao invalida. Digite novamente: \");\n                                scanf(\"%d\",&optP2);\n                            }\n                        } else {\n                            optP2 = ( rand() % 2 ) + 1;\n                            printf(\"%d\",optP2);\n                        }\n                        totalJogadas++;\n                        totalNormal++;\n                        if (optP1==optP2) {\n                            printf(\"\\nEmpate!\\n\");\n                            empates++;\n                        } else {\n                            if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {\n                                printf(\"\\nPlayer 1 venceu!\\n\");\n                                vitoriasP1++;\n                            } else {\n                                printf(\"\\nPlayer 2 venceu!\\n\");\n                                vitoriasP2++;\n                            }\n                        }\n                        printf(\"\\nDigite 1 para jogar novamente, ou qualquer outro para sair!\");\n                        scanf(\"%d\",&novojogo);\n                        system(\"cls\");\n                }while(novojogo==1);\n                }\n                else {\n                    if (modeMenu==2) {\n                    do {\n                        tempVitP1=0;\n                        tempVitP2=0;\n                            do {\n                                system(\"cls\");\n                                printf(\"P1(%d) VS P2 (%d)\\n\",tempVitP1,tempVitP2);\n                            printf(\"Vez do Player 1.\\n\");\n                            printf(\"Escolha uma opcao para jogar:\\n\");\n                            printf(\"\\t1 - Pedra\\n\");\n                            printf(\"\\t2 - Papel\\n\");\n                            printf(\"\\t3 - Tesoura\\n\");\n                            printf(\"Numero: \");\n                            scanf(\"%d\",&optP1);\n                            while( optP1<1 || optP1>3 ){\n                                printf(\"Opcao invalida. Digite novamente: \");\n                                scanf(\"%d\",&optP1);\n                            }\n                            system(\"cls\");\n                            printf(\"Agora o Player 2.\\n\");\n                            printf(\"Escolha uma opcao para jogar:\\n\");\n                            printf(\"\\t1 - Pedra\\n\");\n                            printf(\"\\t2 - Papel\\n\");\n                            printf(\"\\t3 - Tesoura\\n\");\n                            system(\"pause\");\n                            printf(\"Numero: \");\n                            if (playerMenu==1) {\n                                scanf(\"%d\",&optP2);\n                                while( optP2<1 || optP2>3 ){\n                                    printf(\"Opcao invalida. Digite novamente: \");\n                                    scanf(\"%d\",&optP2);\n                                }\n                            } else {\n                                optP2 = ( rand() % 2 ) + 1;\n                                printf(\"%d\",optP2);\n                            }\n                            if (optP1==optP2) {\n                                printf(\"\\nEmpate!\\n\");\n                                empates++;\n                            } else {\n                                if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {\n                                    printf(\"\\nPlayer 1 venceu a rodada!\\n\");\n                                    tempVitP1++;\n                                } else {\n                                    printf(\"\\nPlayer 2 venceu a rodada!\\n\");\n                                    tempVitP2++;\n                                }\n                            }\n                            system(\"pause\");\n                    }while( tempVitP1<2 && tempVitP2<2 );\n                        totalJogadas++;\n                        totalMelhor++;\n                        system(\"cls\");\n                        if (tempVitP1 > tempVitP2) {\n                            printf(\"\\nPlayer 1 venceu a partida!\\n\");\n                            vitoriasP1++;\n                        } else {\n                            printf(\"\\nPlayer 2 venceu a partida!\\n\");\n                            vitoriasP2++;\n                        }\n                        system(\"pause\");\n                        system(\"cls\");\n                        printf(\"\\nDigite 1 para jogar novamente, ou qualquer outro para sair!\");\n                        scanf(\"%d\",&novojogo);\n                        system(\"cls\");\n                    }while(novojogo==1);\n                    } else {\n                        if (modeMenu==3) {\n                            do {\n                        printf(\"Vez do Player 1.\\n\");\n                        printf(\"Escolha uma opcao para jogar:\\n\");\n                        printf(\"\\t1 - Pedra\\n\");\n                        printf(\"\\t2 - Papel\\n\");\n                        printf(\"\\t3 - Tesoura\\n\");\n                        printf(\"\\t4 - Lagarto\\n\");\n                        printf(\"\\t5 - Spoc\\n\");\n                        printf(\"Numero: \");\n                        scanf(\"%d\",&optP1);\n                        while( optP1<1 || optP1>5 ){\n                            printf(\"Opcao invalida. Digite novamente: \");\n                            scanf(\"%d\",&optP1);\n                        }\n                        system(\"cls\");\n                        printf(\"Agora o Player 2.\\n\");\n                        printf(\"Escolha uma opcao para jogar:\\n\");\n                        printf(\"\\t1 - Pedra\\n\");\n                        printf(\"\\t2 - Papel\\n\");\n                        printf(\"\\t3 - Tesoura\\n\");\n                        printf(\"\\t4 - Lagarto\\n\");\n                        printf(\"\\t5 - Spoc\\n\");\n                        system(\"pause\");\n                        printf(\"Numero: \");\n                        if (playerMenu==1) {\n                            scanf(\"%d\",&optP2);\n                            while( optP2<1 || optP2>5 ){\n                                printf(\"Opcao invalida. Digite novamente: \");\n                                scanf(\"%d\",&optP2);\n                            }\n                        } else {\n                            optP2 = ( rand() % 4 ) + 1;\n                            printf(\"%d\",optP2);\n                        }\n                        totalJogadas++;\n                        totalStartrek++;\n                        if (optP1==optP2) {\n                            printf(\"\\nEmpate!\\n\");\n                            empates++;\n                        } else {\n                            if (\n                                (optP1==PEDRA&&optP2==TESOURA) ||\n                                (optP1==PEDRA&&optP2==LAGARTO) ||\n                                (optP1==LAGARTO&&optP2==PAPEL) ||\n                                (optP1==LAGARTO&&optP2==SPOCK) ||\n                                (optP1==SPOCK&&optP2==PEDRA) ||\n                                (optP1==SPOCK&&optP2==TESOURA) ||\n                                (optP1==TESOURA&&optP2==LAGARTO) ||\n                                (optP1==TESOURA&&optP2==PAPEL) ||\n                                (optP1==PAPEL&&optP2==PEDRA) ||\n                                (optP1==PAPEL&&optP2==SPOCK)\n                            ) {\n                                printf(\"\\nPlayer 1 venceu!\\n\");\n                                vitoriasP1++;\n                            } else {\n                                printf(\"\\nPlayer 2 venceu!\\n\");\n                                vitoriasP2++;\n                            }\n                        }\n                        printf(\"\\nDigite 1 para jogar novamente, ou qualquer outro para sair!!\");\n                        scanf(\"%d\",&novojogo);\n                        system(\"cls\");\n                    }while(novojogo==1);\n                        }\n                    }\n                }\n        }\n        else {\n            if (mainMenu==2) {\n                printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n                printf(\"\\n\\n\\tREGRAS:\\n\");\n                printf(\"\\tNo Jokenpo, os jogadores devem escolher numeros, no qual cada numero representa um simbolo.\\n\");\n                printf(\"\\tEsses simbolos sao comparados para ver quem ganhou, da seguinte forma:\\n\");\n                printf(\"\\t\\t- PEDRA ganha da TESOURA (quebrando-a).\\n\");\n                printf(\"\\t\\t- TESOURA ganha do PAPEL (cortando-o).\\n\");\n                printf(\"\\t\\t- PAPEL ganha da PEDRA (embrulhando-o).\\n\");\n                printf(\"\\tNa variacao Star Trek as regras anteriores permanecem, e outras sao adicionadas:\\n\");\n                printf(\"\\t\\t- PEDRA ganha do LAGARTO (esmagando-o).\\n\");\n                printf(\"\\t\\t- TESOURA ganha do LAGARTO (matando-o).\\n\");\n                printf(\"\\t\\t- PAPEL ganha do SPOCK (cegando-o).\\n\");\n                printf(\"\\t\\t- LAGARTO ganha do PAPEL (comendo-o).\\n\");\n                printf(\"\\t\\t- LAGARTO ganha do SPOCK (envenenando-o).\\n\");\n                printf(\"\\t\\t- SPOCK ganha da PEDRA (vaporizando-a).\\n\");\n                printf(\"\\t\\t- SPOCK ganha da TESOURA (quebrando-a).\\n\\n\");\n                system(\"pause\");\n            } else {\n                if (mainMenu==3) {\n                    printf(\"\\n     ___ _______ ___   _ _______ __    _ _______ _______ \\n    |   |       |   | | |       |  |  | |       |       |\\n    |   |   _   |   |_| |    ___|   |_| |    _  |   _   |\\n    |   |  | |  |      _|   |___|       |   |_| |  | |  |\\n ___|   |  |_|  |     |_|    ___|  _    |    ___|  |_|  |\\n|       |       |    _  |   |___| | |   |   |   |       |\\n|_______|_______|___| |_|_______|_|  |__|___|   |_______|\");\n                    printf(\"\\n\\n\\tTotal de Jogadas: %d\\n\",totalJogadas);\n                    printf(\"\\t\\tEmpates: %d\\n\",empates);\n                    percentP1=(100.0*vitoriasP1)/totalJogadas;\n                    printf(\"\\t\\tVitorias Player 1: %d(%f%%)\\n\",vitoriasP1,percentP1);\n                    percentP2=(100.0*vitoriasP2)/totalJogadas;\n                    printf(\"\\t\\tVitorias Player 2: %d(%f%%)\\n\",vitoriasP2,percentP2);\n                    printf(\"\\tJogadas no Modo Normal: %d\\n\",totalNormal);\n                    printf(\"\\tJogadas no Modo Melhor de 3: %d\\n\",totalMelhor);\n                    printf(\"\\tJogadas no Modo Star Trek: %d\\n\",totalStartrek);\n                    system(\"pause\");\n                } else if (mainMenu==0) {\n                    do {\n                        tempVitP1=0;\n                        tempDeath=0;\n                            do {\n                            printf(\"\\tDEATMATCH\\n\");\n                            printf(\"\\tEste e o modo especial de Jokenpo. Resista o maximo que puder e veja quantas partidas seguidas voce consegue vencer!\\n\");\n                            system(\"cls\");\n                            printf(\"P1(%d) VS P2 (%d)\\n\",tempVitP1,tempVitP2);\n                            printf(\"Vez do Player 1.\\n\");\n                            printf(\"Escolha uma opcao para jogar:\\n\");\n                            printf(\"\\t1 - Pedra\\n\");\n                            printf(\"\\t2 - Papel\\n\");\n                            printf(\"\\t3 - Tesoura\\n\");\n                            printf(\"Numero: \");\n                            scanf(\"%d\",&optP1);\n                            while( optP1<1 || optP1>3 ){\n                                printf(\"Opcao invalida. Digite novamente: \");\n                                scanf(\"%d\",&optP1);\n                            }\n                            system(\"cls\");\n                            printf(\"Agora o Player 2.\\n\");\n                            printf(\"Escolha uma opcao para jogar:\\n\");\n                            printf(\"\\t1 - Pedra\\n\");\n                            printf(\"\\t2 - Papel\\n\");\n                            printf(\"\\t3 - Tesoura\\n\");\n                            system(\"pause\");\n                            printf(\"Numero: \");\n                            optP2 = ( rand() % 2 ) + 1;\n                            printf(\"%d\",optP2);\n                            if (optP1==optP2) {\n                                printf(\"\\nEmpate!\\n\");\n                                empates++;\n                            } else {\n                                if ( (optP1==PEDRA&&optP2==TESOURA) || (optP1==PAPEL&&optP2==PEDRA) || (optP1==TESOURA&&optP2==PAPEL) ) {\n                                    printf(\"\\nPlayer 1 venceu a rodada!\\n\");\n                                    tempVitP1=1;\n                                    tempDeath++;\n                                } else {\n                                    printf(\"\\nPlayer 2 venceu a rodada e encerrou a partida!\\n\");\n                                    tempVitP1=2;\n                                }\n                            }\n                            system(\"pause\");\n                    }while( tempVitP1==1 );\n                        totalJogadas++;\n                        totalDeath++;\n                        system(\"cls\");\n                            printf(\"\\nVoce ganhou: %d partidas!\\n\",tempDeath);\n                            vitoriasP1++;\n                        system(\"pause\");\n                        system(\"cls\");\n                        printf(\"\\nDigite 1 para jogar novamente, ou qualquer outro para sair!\");\n                        scanf(\"%d\",&novojogo);\n                        system(\"cls\");\n                    }while(novojogo==1);\n                }\n            }\n        }\n    }while(mainMenu>=1 && mainMenu<=3);\n    return 0;\n}"}
{"author": "behergue", "file": "Operating_Systems__myFS.12.c", "original_string": "int updateBitmap(MyFileSystem *myFileSystem)\n{\n    if(lseek(myFileSystem->fdVirtualDisk, BLOCK_SIZE_BYTES * BITMAP_IDX, SEEK_SET) == (off_t) - 1) {\n        perror(\"Failed lseek in updateBitmap\");\n        return -1;\n    }\n    if(write(myFileSystem->fdVirtualDisk,\n             myFileSystem->bitMap, sizeof(BIT) * NUM_BITS) == -1) {\n        perror(\"Failed write in updateBitmap\");\n        return -1;\n    }\n    sync();\n    return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__7.0.c", "original_string": "long int ackermann(int m, int n)\n{\n    if (m == 0) return n+1;\n    else if (n == 0) return ackermann(m-1, 1);\n    else return ackermann(m-1, ackermann(m, n-1));\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.21.c", "original_string": "void addclassvardec(SCOPE* s, CLASSVARDEC* v, int* i) {\n    if(v->type == stat)\n        addstaticvar(s, v);\n    else {\n        addfield(s, v, i);\n    }\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example31.0.c", "original_string": "int main()\n{\n    int n,i=1,c;\n    printf(\"serinin gitmesini istedi\u011finiz n de\u011ferini giriniz:\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Fibonacci dizisi\\n\");\n    for(c=1;c<=n;c++) \n    {\n        printf(\"%d\\n\",fibonacci(i));    \n        i++;       \n    }\n return 0;   \n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__ledAssign2.1.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__channel_survey.6.c", "original_string": "static void process_channel_survey_report(ble_gap_evt_qos_channel_survey_report_t * p_report)\n{\n        for (uint8_t i = 0; i < BLE_GAP_CHANNEL_COUNT; i++)\n        {\n                float energy_sample = p_report->channel_energy[i];\n                if (energy_sample == BLE_GAP_POWER_LEVEL_INVALID)\n                {\n                        continue;\n                }\n                if (m_num_channel_survey_reports_received == 0)\n                {\n                        m_average_ch_energy[i].ch_energy = energy_sample;\n                }\n                else\n                {\n                        m_average_ch_energy[i].ch_energy =  (m_num_channel_survey_reports_received * m_average_ch_energy[i].ch_energy + energy_sample)\n                                                           / (m_num_channel_survey_reports_received + 1);\n                }\n        }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e160.2.c", "original_string": "int main(int argc, char *argv[]) \n{\n    char captcha[6];\n    char vetor[6];\n    int * retorno, * comparacao, cont;\n    int iguais;\n    printf(\"Verificacao de Seguranca.\\n\\n\");\n    retorno = gerarCaptcha(captcha);\n    printf(\"%s\\n\", retorno);\n    printf(\"\\nEscreva os 6 caracteres que voce ve acima: \\n\");\n    gets(vetor);\n    comparacao = compararCaptcha(captcha, vetor, iguais);\n    printf(\"\", comparacao);\n    iguais = 0;\n    if(comparacao == 6)\n        printf(\"\\nOs caracteres sao iguais!\\n\");\n    else\n    {\n        printf(\"\\nOs caracteres sao diferentes. Tente novamente.\\n\");\n        while(comparacao != 6)\n        {\n            retorno = gerarCaptcha(captcha);\n            printf(\"%s\\n\", retorno);\n            printf(\"\\nEscreva os 6 caracteres que voce ve acima: \\n\");\n            gets(vetor);\n            for(cont = 0; cont < 6; cont++)\n            {\n                if(captcha[cont] == vetor[cont])\n                iguais++;\n            }\n            comparacao = iguais;\n            if(comparacao == 6)\n            {\n                printf(\"\\nOs caracteres sao iguais!\\n\");\n                break;\n            }\n            else\n            {\n                printf(\"\\nOs caracteres sao diferentes. Tente novamente.\\n\");\n            }\n        }\n    }\n    return 0;\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__QuickSort.2.c", "original_string": "void putdata(int x[50], int n)\n       {\n        int k;\n        for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n         }\n          printf(\"\\n\");\n        }"}
{"author": "deepaliajabsingjadhav", "file": "file__read_file.0.c", "original_string": "int main()\n{\n    char name[20] = {'\\0'};\n    char arr[50] = {'\\0'};\n    int fd = 0;     \n    int ret = 0, length = 0;\n    char temp;\n    printf(\"Enter file name\\n\");\n    scanf(\"%s\",name);\n    fd = open(name,O_RDWR); \n    if(fd == -1)\n    {\n        printf(\"Unable to open file\\n\");\n    }\n    else\n    {\n        printf(\"File succesfully opened with fd %d\\n\",fd);\n    }\n    ret = read(fd,arr,10);\n    if(ret == -1)\n    {\n        printf(\"Unable to read from the file\\n\");\n    }\n    else\n    {\n        printf(\"Data succesfully read\\n\");\n    }\n    printf(\"Data from file is : %s\\n\",arr);\n    close(fd);\n    return 0;\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__ArmstrongOfNwithoutPow.0.c", "original_string": "int main()\n{\n    int n;\n    int count = 0;\n    printf(\"enter a number:\");\n    scanf(\"%d\",&n);\n    int temp = n;\n    while(temp!=0)\n    {\n        count++;\n        temp/=10;\n    }\n    printf(\"count:%d\\n\",count);\n    int rem = 0, sum = 0;\n    int t = n;\n    int i;\n    while(t!=0)\n    {\n        int mul=1;\n        rem = t%10;\n        for(i=1;i<=count;i++)\n        {\n            mul = mul*rem;\n        }\n        printf(\"Power of %d is : %d\\n\",rem,mul);\n        sum = sum+mul;\n        t = t/10;   \n    }\n    if(sum == n)\n    {\n        printf(\"ARMSTRONG NUMBER\");\n    }\n    else\n    printf(\"NOT ARMSTRONG NUMBER\");\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.22.c", "original_string": "void pushpopcommon(VMTRANSLATOR* t, TEMPLATE* tp) {\n    tp->items[0] = switchsegment(t);\n    tp->items[1] = mkstr(t, \"D=M\");\n    tp->items[2] = at(t, t->currln->tokens[2]);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CDLL.3.c", "original_string": "int count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n    return c;\n}"}
{"author": "flora0110", "file": "hw03git__4108056029_1-1.3.c", "original_string": "imfor find(int a,int b,int l,int r,node* ptr){\n    imfor im;\n    if(a==l && b==r){\n        im.sum=ptr->sum;\n        im.ls=ptr->ls;\n        im.rs=ptr->rs;\n        im.max=ptr->max;\n        return im;\n    }\n    int m=(l+r)/2;\n    if(b<=m){\n        im = find(a,b,l,m,ptr->left);\n        return im;\n    }\n    if(a>m){\n        im = find(a,b,m+1,r,ptr->right);\n        return im;\n    }\n    else{\n        imfor leftim=find(a,m,l,m,ptr->left);\n        imfor rightim=find(m+1,b,m+1,r,ptr->right);\n        im.sum=leftim.sum+rightim.sum;\n        im.ls=max(leftim.ls,leftim.sum+rightim.ls);\n        im.rs=max(rightim.rs,rightim.sum+leftim.rs);\n        im.max=max(max(rightim.max,leftim.max),leftim.rs+rightim.ls);\n        return im;\n    }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__frequency_character.1.c", "original_string": "int main()\n{\n    char arr[30];\n    char cValue = '\\0';\n    int iRet = 0;\n    printf(\"Please enter the string\\n\");\n    scanf(\"%[^'\\n']s\",arr);\n    printf(\"Please enter the character to calculate the frequency\\n\");\n    scanf(\" %c\",&cValue);       \n    iRet = Frequency(arr,cValue);\n    printf(\"Total Frequency is %d\\n\",iRet);\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__shell_server.2.c", "original_string": "error_t shellServerStart(ShellServerContext *context)\n{\n   error_t error;\n   uint_t i;\n   OsTask *task;\n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n   TRACE_INFO(\"Starting shell server...\\r\\n\");\n   if(context->running)\n      return ERROR_ALREADY_RUNNING;\n   error = sshServerRegisterChannelRequestCallback(context->sshServerContext,\n      shellServerChannelRequestCallback, context);\n   if(error)\n      return error;\n   for(i = 0; i < context->numSessions; i++)\n   {\n      task = osCreateTask(\"Shell Session\", shellServerTask,\n         &context->sessions[i], SHELL_SERVER_STACK_SIZE,\n         SHELL_SERVER_PRIORITY);\n      if(task == NULL)\n         return ERROR_OUT_OF_RESOURCES;\n   }\n   return NO_ERROR;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__matrices_dinamicas.1.c", "original_string": "void leer_temperaturas(float **t, int f, int c){\n    for (int i = 0; i < f; i++){\n        for (int j = 0; j < c; j++){\n            printf(\"Ingrese la temperatura %d del dia %d:\", j+1, i+1);\n            scanf(\"%f\", &t[i][j]);\n        }\n    }\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__functions.3.c", "original_string": "position AllocateMemoryForStudent(char* firstName, char* lastName, char* registrationNumber)\n{\n    position newStudent = NULL;\n    newStudent = (position)malloc(sizeof(ListElement));\n    if (!newStudent)\n    {\n        printf(\"Problem with memory allocation!\\n\");\n        return newStudent;\n    }\n    newStudent->next = NULL;\n    strcpy(newStudent->firstName, firstName);\n    strcpy(newStudent->lastName, lastName);\n    strcpy(newStudent->registrationNumber, registrationNumber);\n    return newStudent;\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example30.1.c", "original_string": "void okuYaz (void)\n{\n    int num[SIZE], i;\n    printf(\"%s\",\"okul numaran\u0131z\u0131 giriniz:\");\n    for(i=0;i<SIZE;i++)\n        scanf(\"%d\",&num[i]);\n    printf(\"%s\\n\",\"okul numaran\u0131z:\");\n    for(i=0;i<SIZE;i++)\n        printf(\"%d\",num[i]);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__queue_using_linked_list.4.c", "original_string": "int main()\n{\n    printf(\"queue using the linked list\\n\");\n    enqueue(17);\n    enqueue(34);\n    enqueue(55);\n    dequeue();\n    enqueue(20);\n    display();\n    peek();\n    dequeue();\n    enqueue(45);\n    peek();\n    display();\n}"}
{"author": "sahadipanjan6", "file": "Programs-in-C__Perfect_Number.1.c", "original_string": "int isPerfect(int number)\n{\n    int i = 0;\n    int sum_factors = 0;\n    for(i=1; i<number; i++)\n    {\n        if(number%i == 0)\n            sum_factors += i;\n    }\n    if(sum_factors == number)\n        return 1;\n    return 0;\n}"}
{"author": "earth429", "file": "mulpre__mulprec.14.c", "original_string": "int numComp(struct NUMBER *a, struct NUMBER *b) {\n    int sa = getSign(a);\n    int sb = getSign(b);\n    int i;\n    if(sa > sb){ \n        return 1;\n    }\n    if(sa < sb){ \n        return -1;\n    }\n    if(sa == 1 && sb == 1){ \n        for (i = KETA - 1; i >= 0;i--){\n            if(a->n[i] > b->n[i]){ \n                return 1;\n            } else if(a->n[i] < b->n[i]){\n                return -1;\n            }\n        }\n        return 0; \n    }\n    if(sa == -1 && sb == -1){ \n        for (i = KETA - 1; i >= 0;i--){\n            if(a->n[i] > b->n[i]){ \n                return -1;\n            } else if(a->n[i] < b->n[i]){\n                return 1;\n            }\n        }\n        return 0; \n    }\n    return 100;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__orderedLL.3.c", "original_string": "int main()\n{\n    nptr head = NULL;\n    int ch, ele;\n    printf(\"0. Exit      1. Insert      2. Display\\n\");\n    do\n    {\n        printf(\"Command: \");\n        scanf(\"%d\", &ch);\n        switch(ch)\n        {\n            case 1: printf(\"Element: \");\n                    scanf(\"%d\", &ele);\n                    insert(head, ele);\n                    break;\n            case 2: display(head);\n        }\n    }while(ch != 0);\n}"}
{"author": "augustogunsch", "file": "jackc__parser-tree.5.c", "original_string": "void freeexpression(TERM* e) {\n    if(e->type == arrayitem)\n        freearray(e->array);\n    else if(e->type == innerexpression || e->type == unaryopterm)\n        freeexpression(e->expression);\n    else if(e->type == subroutcall)\n        freesubroutcall(e->call);\n    TERM* next = e->next;\n    free(e);\n    if(next != NULL)\n        freeexpression(next);\n}"}
{"author": "ankitraj311", "file": "450_babbar__2_max_min_in_array_GEEk.0.c", "original_string": "struct pair max_min_array(int arr[], int no)\n{\n  struct pair minmax;\n  if( no == 1)\n  {\n    minmax.max = arr[0];\n    minmax.min = arr[0];\n    return minmax;\n  }\n  if(arr[0] > arr[1])\n  {\n    minmax.max = arr[0];\n    minmax.min = arr[1];\n  }\n  else\n  {\n    minmax.max = arr[1];\n    minmax.min = arr[0];\n  }\n  for(int i = 0; i<no; i++)\n  {\n    if(arr[i] < minmax.min)\n      minmax.min = arr[i];\n    else if(arr[i] > minmax.max)\n      minmax.max = arr[i];\n  }\n  return minmax;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__lcd.0.c", "original_string": "int main()\n{\n        int num = 8,res,quotient,remainder;     \n        res = 66 + 33;\n        lcd_config();   \n        quotient = res/10;\n        remainder = res%10;\n        lcd_data(quotient + 0x30);\n        lcd_data(remainder + 0x30);\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__HeapSort.1.c", "original_string": "void getdata(int x[100],int n)\n    {\n        int k;\n        printf(\"enter the value  for sorting\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        } \n    }"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__62.0.c", "original_string": "int main()\n{\n    char frase[50], esarf[50];\n    int tam_frase, i = 0, i1, j = 0, k = 0;\n    printf(\"\\nInforme uma frase quanlquer:\\n\");\n    scanf(\"%[^\\n]s\", frase);\n    tam_frase = strlen(frase);\n    i1 = tam_frase - 1;\n    strcpy(esarf, frase);\n    for (int i = 0; i < tam_frase; i++)\n    {\n        esarf[i] = frase[(tam_frase - 1) - i];\n    }\n    while (j != (tam_frase + 1))\n    {\n        while ((j <= tam_frase) && (frase[j] != ' '))\n        {\n            j++;\n        }\n        for (int j1 = j; j1 < tam_frase; j1++)\n        {\n            frase[j1] = frase[j1 + 1];\n        }\n    }\n    while (k != (tam_frase + 1))\n    {\n        while ((k <= tam_frase) && (esarf[k] != ' '))\n        {\n            k++;\n        }\n        for (int k1 = k; k1 < tam_frase; k1++)\n        {\n            esarf[k1] = esarf[k1 + 1];\n        }\n    }\n    for (int m = 0; frase[m]; m++)\n    {\n        frase[m] = tolower(frase[m]);\n    }\n    for (int n = 0; esarf[n]; n++)\n    {\n        esarf[n] = tolower(esarf[n]);\n    }\n    if (strcmp(frase, esarf) == 0)\n    {\n        printf(\"\\nA Frase \u00e9 um pal\u00edndromo.\\n\\n\");\n    }\n    else\n    {\n        printf(\"\\nA Frase n\u00e3o \u00e9 um pal\u00edndromo.\\n\\n\");\n    }\n    return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__BH.0.c", "original_string": "int main()\n{\n    char str[1001];\n    int num[1001], aux, aux0, qtd = 1;\n    fgets(str, 1001, stdin);\n    for (int i = 0; str[i] != '\\0'; i++)\n    {\n        if (str[i] == '\\n')\n        {\n            str[i] = '\\0';\n        }\n    }\n    for (int i = 0; str[i] != '\\0';)\n    {\n        aux = atoi(&str[i]);\n        aux0 = aux;\n        while (aux0 >= 10)\n        {\n            aux0 /= 10;\n            qtd++;\n        }\n        if ((aux != 0) && (str[i + qtd] != '\\0'))\n        {\n            for (int j = 0; j < (aux - 1); j++)\n            {\n                printf(\"%c\", str[i + qtd]);\n            }\n        }\n        else\n        {\n            printf(\"%c\", str[i]);\n        }\n        i += qtd;\n        qtd = 1;\n    }\n    putchar('\\n');\n    return 0;\n}"}
{"author": "haon1026", "file": "linux-programming__base.1.c", "original_string": "int Socket(int domain, int type, int protocol)\n{\n    int sockfd = socket(domain, type, protocol);\n    if(sockfd == -1)\n    {\n        sys_err(\"socket() error\");\n    }\n    return sockfd;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad10.0.c", "original_string": "int main()\n{\n    stackPointer head = (stackPointer)malloc(sizeof(struct stack));\n    head->next = NULL;\n    treePointer root = NULL;\n    char readFile[MAX_NAME_OF_FILE] = \"postfix.txt\";\n    char writeFile[MAX_NAME_OF_FILE] = \"infix.txt\";\n    root = ReadFromFile(readFile, root, head);\n    WriteInFile(writeFile, root);\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__post-eva.6.c", "original_string": "float evaluatePostfix(char exp[])\n{\n    stack* stk=createStack(strlen(exp));\n    int i=0;\n    float f=0,s=0,t=0;\n    while (exp[i]!='\\0')\n    {\n        if((exp[i]==',' && exp[i+1]==',') || (exp[i]==' ' && exp[i+1]==' '))\n            i++;\n        else if((exp[i]==',' && exp[i+1]==' ') || (exp[i]==' ' && exp[i+1]==','))\n        {\n            printf(\"Invalid operator or operand encountered.\\n\");\n            return 0;\n        }\n        else if((int)exp[i]>47 && (int)exp[i]<58)\n            t=(t*10)+c2i(exp[i]);\n        else if(exp[i]==',' || exp[i]==' ')\n        {\n            push(stk,t);\n            t=0;\n        }\n        else if(isOperator(exp[i]))\n        {\n            if(stk->top-2<-1)\n            {\n                printf(\"Underflow, not enough operands.\\n\");\n                return 0;\n            }\n            s=pop(stk);\n            f=pop(stk);\n            push(stk,operation(f,exp[i],s));\n            if(i+1<stk->size)\n                i++;\n        }\n        else\n        {\n            printf(\"Invalid operator or operand encountered.\\n\");\n            return 0;\n        }\n        i++;\n    }\n    if(stk->top!=0)\n    {\n        printf(\"Overflow, too may operands.\\n\");\n        return 0;\n    }\n    return stk->arr[stk->top];\n}"}
{"author": "zjzj-zz", "file": "4s_Numerical__Dichotomy.2.c", "original_string": "void dichotomy(double x[2] ){ \n    double c;\n    while(1){\n        c = (x[0] + x[1]) / 2;\n        if(f(c)*f(x[0]) < 0) x[1] = c;\n        else x[0] = c;\n        if(fabs(x[0]-x[1])<0.0000000001){\n            printf(\"x = %.10lf\\n\",c);\n            exit(1);\n        }\n    }\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__sum.0.c", "original_string": "int main()\n{\n    int pid,fd[2];\n    pipe(fd);\n    printf(\"enter the 10 values to be calculated\\n\");\n    for(i=0;i<SI;i++)\n    {\n        scanf(\"%d\",&array[i]);\n    }\n    pid=fork();\n    if (pid==0)\n    {\n        printf(\"inside child-----\\n\");\n        close(fd[0]);\n        float product,sum;\n        sum=sum_of_num();\n        printf(\"the sum is %f\\n\",sum);\n        write(fd[1],&sum,sizeof(sum));\n        product=product_of_num();\n        printf(\"the product is %f\\n\",product);\nclose(fd[1]);       \n    }\n    else\n    {\n        wait(NULL);\n        printf(\"-----inside parent process------\\n\");\n        close(fd[1]);\n        float avg=0,sum;\n        read(fd[0],&sum,sizeof(sum));\n        printf(\"\\tthe sum is %f\\n\",sum);\n        avg=sum/SI;\n        printf(\"\\tthe average is %f\\n\",avg);\n    }\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__sftp_server.1.c", "original_string": "error_t sftpServerInit(SftpServerContext *context,\n   const SftpServerSettings *settings)\n{\n   uint_t i;\n   TRACE_INFO(\"Initializing SFTP server...\\r\\n\");\n   if(context == NULL || settings == NULL)\n      return ERROR_INVALID_PARAMETER;\n   if(settings->sessions == NULL || settings->numSessions < 1 ||\n      settings->numSessions > SFTP_SERVER_MAX_SESSIONS)\n   {\n      return ERROR_INVALID_PARAMETER;\n   }\n   if(settings->fileObjects == NULL || settings->numFileObjects < 1)\n   {\n      return ERROR_INVALID_PARAMETER;\n   }\n   if(settings->rootDir == NULL ||\n      osStrlen(settings->rootDir) > SFTP_SERVER_MAX_ROOT_DIR_LEN)\n   {\n      return ERROR_INVALID_PARAMETER;\n   }\n   osMemset(context, 0, sizeof(SftpServerContext));\n   context->sshServerContext = settings->sshServerContext;\n   context->numSessions = settings->numSessions;\n   context->sessions = settings->sessions;\n   context->numFileObjects = settings->numFileObjects;\n   context->fileObjects = settings->fileObjects;\n   context->checkUserCallback = settings->checkUserCallback;\n   context->getFilePermCallback = settings->getFilePermCallback;\n   osStrcpy(context->rootDir, settings->rootDir);\n   pathCanonicalize(context->rootDir);\n   pathRemoveSlash(context->rootDir);\n   for(i = 0; i < context->numSessions; i++)\n   {\n      osMemset(&context->sessions[i], 0, sizeof(SftpServerSession));\n   }\n   for(i = 0; i < context->numFileObjects; i++)\n   {\n      osMemset(&context->fileObjects[i], 0, sizeof(SftpFileObject));\n   }\n   if(!osCreateEvent(&context->event))\n   {\n      sftpServerDeinit(context);\n   }\n   return NO_ERROR;\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__raycasting.1.c", "original_string": "void        cast_rays(void)\n{\n    int     strip_id;\n    float   angle;\n    strip_id = 0;\n    angle = g_player.rotation_angle - (g_player.fov / 2);\n    while (strip_id < g_width)\n    {\n        normalangle(angle);\n        cast_ray(50, (float)angle);\n        angle += g_player.fov / g_width;\n        strip_id++;\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__search_an_element_by_key.1.c", "original_string": "void search(int key)\n{\n    while (head != NULL)\n    {    if(head->data==key)\n        {\n            printf(\"key Data found\\n\");\n            return;\n       }\n        head = head->next;\n    }\n    printf(\"Key Data not found\\n\");\n}"}
{"author": "2security", "file": "Matrix__34SumUpperTriangularMatrix.0.c", "original_string": "int SumUpperTri(int mat[][20],int r)\n    {\n    int i,j,sum=0;\n    for(i=0;i<r;i++) \n        {\n        for(j=0;j<r;j++) \n            {\n            if(i<=j)\n                sum=sum+mat[i][j];\n            }\n        }\n    return sum;\n    }"}
{"author": "augustogunsch", "file": "jackc__parser-expressions.6.c", "original_string": "TERM* parsekeyword(PARSER* p) {\n    TERM* t = mkterm(keywordconstant);\n    if(!existsinarray(&keywordconstants, p->current->token))\n        unexpected(p);\n    t->string = p->current->token;\n    next(p);\n    return t;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es22.3.c", "original_string": "int main(void) {\n    int dim, indice;\n    int i = 0;\n    printf(\"Inserire dimensione array: \"); \n    scanf(\"%d\", &dim);\n    int a[dim];\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\n\");\n    indice = minimo(a, dim);\n    printf(\"-------------------------------\\n\");\n    printf(\"L'indice minore \u00e8: %d\\n\", indice);\n    scambia(a,dim, 0, indice);\n    printf(\"\\nQuesto \u00e8 l'array con il valore minimo in testa:\\n\");\n    stampa_vettore(a, dim);\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__longadd.3.c", "original_string": "nptr add(nptr num1, nptr num2)\n{\n    nptr sum = createNode();\n    nptr n1 = num1 -> llink;\n    nptr n2 = num2 -> llink;\n    int cin = 0;\n    int s = 0;\n    while(n1 != num1 && n2 != num2)\n    {\n        s = (n1 -> ele) + (n2 -> ele) + cin;\n        if(s >= 10)\n        { \n            cin = 1;\n            insert(sum, s - 10);\n        }\n        else\n        {\n            cin = 0;\n            insert(sum, s);\n        }\n        n1 = n1 -> llink;\n        n2 = n2 -> llink;\n    }\n    while(n1 != num1)\n    {\n        s = (n1 -> ele) + cin;\n        if(s > 9)\n        { \n            cin = 1; \n            insert(sum, s - 10);\n        }\n        else \n        {\n            cin = 0; \n            insert(sum, s);\n        }\n        n1 = n1 -> llink;\n    }\n    while(n2 != num2)\n    {\n        s = (n2 -> ele) + cin;\n        if(s > 9)\n        { \n            cin = 1; \n            insert(sum, s - 10);\n        }\n        else \n        {\n            cin = 0; \n            insert(sum, s);\n        }\n        n2 = n2 -> llink;\n    }\n    return sum;\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__receiver3.1.c", "original_string": "int addr_check(unsigned char des_addr[6]){\n    int flag = 1;\n    int i =0;\n    for(i = 0;i<6;i++){\n        if(des_addr[i] != my_addr[i]) flag = 0;\n    }\n    if(flag){\n        printf(\"[INFO] Address check success!\\n\");\n    }else {\n        printf(\"[Error] Address check error!\\n\");\n    }\n    return flag;\n}"}
{"author": "qtgeo1248", "file": "ProjectEuler__ans0.0.c", "original_string": "int main() {\n    char *filename = \"num.txt\";\n    FILE *f = fopen(filename, \"r\");\n    char *line = NULL; size_t len = 0; char *thing = NULL;\n    getline(&line, &len, f);\n    size_t max = strtol(line, &thing, 10);\n    size_t *primes = calloc(sizeof(size_t), max / 4);\n    size_t num = 0;\n    for (size_t test = 2; test < max; test++) {\n        bool isPrime = true;\n        for (size_t i = 0; i < num; i++) {\n            if (test % primes[i] == 0)\n                isPrime = false;\n        }\n        if (isPrime) {\n            primes[num] = test;\n            num++;\n        }\n    }\n    size_t sum = 0;\n    for (size_t i = 0; i < num; i++)\n        sum += primes[i];\n    printf(\"Answer: %zu\\n\", sum);\n    free(primes);\n    fclose(f);\n    free(line);\n    return 0;\n}"}
{"author": "kbtomic", "file": "Seminarski-StrukturePodataka__ShuffleIslands.0.c", "original_string": "int Shuffle(islandPointer startIsland, int numberOfIslands)\n{\n    islandPointer islandToChange = startIsland->next;\n    islandPointer start = startIsland;\n    islandPointer prevOfIslandToChange = startIsland;\n    while(islandToChange->next)\n    {\n        prevOfIslandToChange = startIsland;\n        islandToChange = startIsland->next;\n        int randomIndex = GenerateRandom(start->next->index, numberOfIslands);\n        islandPointer changeWithMe = start;\n        islandPointer prevOfChangeWithMe = changeWithMe;\n        islandPointer nextOfChangeWithMe = changeWithMe->next;\n        while (changeWithMe->index != randomIndex)\n        {\n            prevOfChangeWithMe = changeWithMe;\n            changeWithMe = changeWithMe->next;\n            nextOfChangeWithMe = changeWithMe->next;\n        }\n        if (islandToChange->index != randomIndex)\n        {\n            if (islandToChange->next == changeWithMe)\n            {\n                prevOfIslandToChange->next = changeWithMe;\n                prevOfChangeWithMe->next = changeWithMe->next;\n                changeWithMe->next = islandToChange;\n                islandToChange->next = nextOfChangeWithMe;\n            }\n            else if (changeWithMe->next == islandToChange)\n            {\n                prevOfChangeWithMe->next = islandToChange;\n                prevOfIslandToChange->next = islandToChange->next;\n                changeWithMe->next = islandToChange->next;\n                islandToChange->next = changeWithMe;\n            }\n            else \n            {\n                prevOfIslandToChange->next = changeWithMe;\n                prevOfChangeWithMe->next = islandToChange;\n                changeWithMe->next = islandToChange->next;\n                islandToChange->next = nextOfChangeWithMe;\n            }\n        }\n        startIsland = startIsland->next;\n        if (!startIsland->next)\n            break;\n    }\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__stk-push-pop.2.c", "original_string": "void push(stack* stk, int n)\n{\n    if(is_full(stk))\n        printf(\"OVERFLOW!\\n\");\n    else\n    {\n        stk->arr[++stk->top]=n;\n        printf(\"%d pushed to stack.\\n\",stk->arr[stk->top]);\n    }\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_3_2_4.1.c", "original_string": "int change(int * x, int * y){\n    if(*y < *x){\n        int temp = *x;\n        *x = *y;\n        *y = temp;\n    }\n    return 0;\n}"}
{"author": "Dhruvik-Chevli", "file": "DAALab__bst.1.c", "original_string": "void inorder(struct Node* root)\n{\n    if(!root)\n        return;\n    inorder(root->left);\n    printf(\"%d \",root->data);\n    inorder(root->right);\n    return;\n}"}
{"author": "2security", "file": "Matrix__38CheckIdentityMatrix.0.c", "original_string": "int checkIdentity(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            {\n            if((i!=j)&&(mat[i][j]!=0))\n                return 0;\n            else if((i==j)&&(mat[i][j])!=1)\n                return 0;\n            }\n        }\n    return 1;\n    }"}
{"author": "0712023", "file": "Basis-and-Practice-in-Programming_SKKU__stage5.2.c", "original_string": "void main(){\n  int x, y, xg, yg;\n  scanf(\"%d %d\", &x, &y);\n    scanf(\"%d %d\", &xg, &yg);\n  pos = x*8+y;\n  goal = xg*8+yg;\n  for(int i = 0 ; i< 136; i++){\n        char ch = getchar();\n    if(ch != ' '){\n      map[(i-i/17)/2] = ch;\n    }\n    }\n  map[goal] = 'G';\n  int turn = 0;\n    scanf(\"%d\", &turn);\n    int cnt = 0;\n    char *cmd = (char*) calloc(turn, sizeof(char));\n    while(cnt < turn){\n    char input[7] = \"\";\n    gets(input);\n    if(strncmp(input, \"WIND\", 4) == 0){\n            cmd[cnt-1]='\\0';\n      strcat(cmd, &input[5]);\n    } else if(strncmp(input, \"CMD\", 3) == 0){\n      cnt+=1;\n      strcat(cmd, &input[4]);\n    }\n  }\n  map[pos] = 'P';\n  for(int i=0; i<64; i++) {\n        printf(\"%c \", map[i]);\n    if(i%8==7){\n      printf(\"\\n\");\n    }\n  }\n  printf(\"\\n\");\n  for(int k = 0; k<turn; k++){\n    map[pos] = 'W';\n    check_stuck();\n    tail_func(cmd[k]);\n    map[pos] = 'P';\n    for(int i=0; i<64; i++) {\n        printf(\"%c \", map[i]);\n      if(i%8==7){\n        printf(\"\\n\");\n      }\n    }\n    printf(\"\\n\");\n    if(pos == goal){\n            exit(0);\n    }\n  }\n  free(cmd);\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zadOsmi.2.c", "original_string": "int PushStack(Position current, StackPosition stackHead)\n{\n    StackPosition newStackElement;\n    StackPosition tempStackElement = stackHead;\n    if (newStackElement = AllocateMemoryForStack()) \n    {\n        while (tempStackElement->next)\n            tempStackElement = tempStackElement->next;\n        newStackElement->next = tempStackElement->next;\n        tempStackElement->next = newStackElement;\n        newStackElement->data = current;\n        return 0;\n    }\n    else\n        return 1;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_08.0.c", "original_string": "int main()\n{\n    int vetor[6];\n    for(int i=0; i<6; i++){\n        printf(\"digite os valores do vetor: \\n\");\n        scanf(\"%d\",&vetor[i]);\n    }\n       printf(\"\\nRESULTADO\\n\");\n        for(int i=5; i>=0; i--){\n        printf(\"%d \",vetor[i]);\n        }\n    return 0;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ili9341_ext.13.c", "original_string": "static void ili9341_rotation_set(nrf_lcd_rotation_t rotation)\n{\n    write_command(ILI9341_MADCTL);\n    switch (rotation) {\n        case NRF_LCD_ROTATE_0:\n            write_data(ILI9341_MADCTL_MX | ILI9341_MADCTL_BGR);\n            break;\n        case NRF_LCD_ROTATE_90:\n            write_data(ILI9341_MADCTL_MV | ILI9341_MADCTL_BGR);\n            break;\n        case NRF_LCD_ROTATE_180:\n            write_data(ILI9341_MADCTL_MY | ILI9341_MADCTL_BGR);\n            break;\n        case NRF_LCD_ROTATE_270:\n            write_data(ILI9341_MADCTL_MX | ILI9341_MADCTL_MY | ILI9341_MADCTL_MV | ILI9341_MADCTL_BGR);\n            break;\n        default:\n            break;\n    }\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-tree.10.c", "original_string": "void freestatements(STATEMENT* s) {\n    if(s->type == letstatement)\n        freelet(s->letstatement);\n    else if(s->type == ifstatement)\n        freeif(s->ifstatement);\n    else if(s->type == whilestatement)\n        freecond(s->whilestatement);\n    else if(s->type == dostatement)\n        freesubroutcall(s->dostatement);\n    else if(s->retstatement != NULL)\n        freeexpression(s->retstatement);\n    free(s->debug);\n    STATEMENT* next = s->next;\n    free(s);\n    if(next != NULL)\n        freestatements(next);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListDelete.2.c", "original_string": "struct Node * deleteInBetween(struct Node * head, int index){\n     struct Node *p =head;\n     struct Node *q = head->next;\n     for (int i=0; i<index-1; i++){\n          p= p->next;\n          q=q->next;\n     }\n     p->next=q->next;\n     free(q);\n     return head;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__drv_ws2812.1.c", "original_string": "static uint32_t pwm_init(void)\n{\n    nrfx_pwm_config_t pwm_config = NRFX_PWM_DEFAULT_CONFIG;\n    pwm_config.output_pins[0] = NRFX_PWM_PIN_NOT_USED; \n    pwm_config.output_pins[1] = WS2812_PIN; \n    pwm_config.output_pins[2] = NRFX_PWM_PIN_NOT_USED;\n    pwm_config.output_pins[3] = NRFX_PWM_PIN_NOT_USED;\n    pwm_config.load_mode    = NRF_PWM_LOAD_INDIVIDUAL;\n    pwm_config.top_value    = 20; \n    pwm_config.base_clock   = NRF_PWM_CLK_16MHz;\n    return nrfx_pwm_init(&m_pwm0, &pwm_config, pwm_handler);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_SLL.8.c", "original_string": "void delete_end()\n{\n    struct node *temp,*nextnode;\n    temp=head;\n    while(temp->next!=0)\n    {\n        nextnode=temp;\n        temp=temp->next;\n    }\n    if(temp==head)\n    {\n        head=0;\n        free(temp);\n    }\n    else\n    {\n        nextnode->next=0;\n        free(temp);\n    }\n}"}
{"author": "dishanp", "file": "DSA__q25.2.c", "original_string": "int main()\n{\n    int n, key;\n    printf(\"Number of elements : \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n    {\n        scanf(\"%d\", &A[i]);\n    }\n    create(A, n);\n    printf(\"Enter key : \");\n    scanf(\"%d\", &key);\n    count_key(first, key);\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__62_split_string_for_given_character.0.c", "original_string": "int main()\n{\nint i = 0, j = 0, k = 0;\nchar str1[100] = {0},str_sub[100][100] = {0},c;\nprintf(\"Enter a string\\n\");\nscanf(\"%[^\\n]s\",str1);\nprintf(\"Enter character From where you want to Split\\n\");\nscanf(\" %c\",&c);\nwhile(str1[k] != '\\0')\n{\n  j = 0;\n  while(str1[k] != c && str1[k] != '\\0')\n  {\n    str_sub[i][j] = str1[k];\n    j++;\n    k++;\n  }\n  str_sub[i][j] = '\\0';\n  i++;\n  if(str1 != '\\0')\n  {\n    k++;\n  }\n}\nint len = i;\nprintf(\"Words after Splitting are:\\n\");\nfor(i=0; i<len; i++)\n{\n  printf(\"%s\\n\",str_sub[i]);\n}\n}"}
{"author": "sdukesameer", "file": "dsa__Md_Sameer_13000119114.3.c", "original_string": "list* insert(list* node, int key){\n    if (node == NULL)\n    return newNode(key); \n    if (key < node->key) \n        node->left = insert(node->left, key);\n    else if (key > node->key) \n        node->right = insert(node->right, key); \n    return node;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__double_insert_at_any_position.3.c", "original_string": "void insertAtN(int data, int position)\n{\n    int i;\n    struct node * newNode, *temp;\n        temp = head;\n        i=1;\n        while(i<position-1 && temp!=NULL)\n        {\n            temp = temp->next;\n            i++;\n        }\n            newNode = (struct node *)malloc(sizeof(struct node));\n            newNode->data = data;\n            newNode->next = temp->next;\n            newNode->prev = temp;\n                temp->next->prev = newNode;\n            temp->next = newNode;\n    }"}
{"author": "2security", "file": "File__4Append.0.c", "original_string": "int main()\n    {\n        FILE *fptr;\n        char str[100];\n        int n;\n        fptr=fopen(\"File4.txt\",\"a\");\n        if(fptr==NULL)\n            {\n                perror(\"File openning error(:\");\n                getch();\n                exit(0);\n            }\n        printf(\"\\n Enter contents to append in file4::\");\n        fflush(stdin);\n        fgets(str,100,stdin);   \n        fputs(str,fptr);\n        printf(\"\\n Successfully append into file...\");\n        fclose(fptr);\n        return 0;\n    }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__biggest_pal.3.c", "original_string": "int         main(int ac, char **av)\n{\n    if (ac == 2)\n    {\n        pal(av[1]);\n    }\n    ft_putstr(\"\\n\");\n    return (0);\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad6.1.c", "original_string": "int stog(pozicija p)\n{\n    char c;\n    while (1) {\n        printf(\"Unesi N za unos novog elementa stoga, M za micanje postojeceg elementa stoga, I za ispis elemenata stoga, X za izlaz\\n\");\n        scanf(\" %c\", &c);\n        if (c == 'N')\n            push(p);\n        else if (c == 'M')\n            pop(p);\n        else if (c == 'I')\n            ispis(p->next);\n        else if (c == 'X')\n            break;\n        else\n            printf(\"Nisi unio ispravno slovo!\\n\");\n    }\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__i2c_read.0.c", "original_string": "int main()\n{\n    lcd_config();\n    i2c_config();\n    i2c_start();\n    i2c_data(0xA0);     \n    i2c_data(0x00);     \n    i2c_data('A');\n    i2c_data('B');\n    i2c_data('C');\n    i2c_stop();\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad5.2.c", "original_string": "int presjek(pozicija p, pozicija q, pozicija r)\n{\n    while (p->next != NULL && q->next != NULL) \n    {\n        if (p->next->el == q->next->el)\n        {\n            pozicija s = NULL;\n            s = (pozicija)malloc(sizeof(struct lista));\n            if (s == NULL)\n            {\n                printf(\"Neuspjesna alokacija memorije!\\n\");\n                return 1;\n            }\n            s->next = NULL;\n            s->el = p->next->el;\n            p = p->next;\n            q = q->next;\n            r->next = s;\n            r = s;\n        }\n        else if (p->next->el < q->next->el) \n            p = p->next;\n        else\n            q = q->next;\n    }\n    return 0;\n}"}
{"author": "revathy16296", "file": "rtos_lab_asssignment_1__3_com_999.1.c", "original_string": "int sum_of_num(int array[],int n)\n{\n    int sum=0;\n    for(i=1;i<n;i++)\n    {\n        sum+=array[i];\n    }\n    return sum;\n}"}
{"author": "behergue", "file": "Computer_Structure__leds2.8.c", "original_string": "void leds_display( unsigned int leds_status )\n{\n    status = leds_status;\n    if( status & LED1 )\n    {\n        portB_write(BIT_LED1, LOW);\n    }\n    else\n    {\n        portB_write(BIT_LED1, HIGH);\n    }\n    if( status & LED2 )\n    {\n        portB_write(BIT_LED2, LOW);\n    }\n    else\n    {\n        portB_write(BIT_LED2, HIGH);\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server.0.c", "original_string": "void scpServerGetDefaultSettings(ScpServerSettings *settings)\n{\n   settings->sshServerContext = NULL;\n   settings->numSessions = 0;\n   settings->sessions = NULL;\n   settings->rootDir = NULL;\n   settings->checkUserCallback = NULL;\n   settings->getFilePermCallback = NULL;\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__tree.0.c", "original_string": "int main(){\n    add_element();\n    add_element();\n    add_element();\n    add_element();\n    add_element();\n    add_element();\n    printf(\"Inorder\\n\");\n    inorder(root);\n    printf(\"preorder\\n\");\n    preorder(root);\n    printf(\"postorder\\n\");\n    postorder(root);\n    printf(\"Inorder_1\\n\");\n    inorder_1(root);\n    printf(\"preorder_1\\n\");\n    preorder_1(root);\n    printf(\"postorder_1\\n\");\n    postorder_1(root);\n    return 0;\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__tmep0.1.c", "original_string": "unsigned int datagram_construction(unsigned char datagram[65535],unsigned char Version,\n                            unsigned char Differentialted_Services,unsigned short Identification,\n                            unsigned short DF, unsigned short MF,\n                            unsigned short Fragment_offset, unsigned char TTL, \n                            unsigned char Protocol,\n                            unsigned char *Source_address, unsigned char *Destination_address,\n                            unsigned char *Option,unsigned int Option_len,\n                            unsigned *payload,unsigned short payload_len){\n    if (payload_len > 65515){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    unsigned char IHL = 5 + Option_len; \n    printf(\"IHL%d\\n\",IHL);\n    unsigned char temp = 0x00;\n    Version = Version << 4;  \n    temp = temp | IHL; \n    temp = temp | Version; \n    memcpy(&datagram[0],&temp,1);\n    memcpy(&datagram[1],&Differentialted_Services,1);\n    unsigned short Total_length = payload_len + IHL*4; \n    memcpy(&datagram[2],&Total_length,2);\n    memcpy(&datagram[4],&Identification,2);\n    unsigned short temp2;\n    short df = DF;\n    df = df << 14;\n    df = df & 0x4000;  \n    short mf = MF;\n    mf = mf << 13;\n    mf = mf & 0x2000; \n    Fragment_offset = Fragment_offset & 0x1FFF; \n    temp2 = df | mf | Fragment_offset;\n    memcpy(&datagram[6],&temp2,2);\n    memcpy(&datagram[8],&TTL,1);\n    memcpy(&datagram[9],&Protocol,1);\n    memcpy(&datagram[12],Source_address,4);\n    memcpy(&datagram[16],Destination_address,4);\n    memcpy(&datagram[20],Option,Option_len*4);\n    unsigned char Header[IHL * 4 - 2]; \n    memcpy(&Header[0],&datagram[0],10);\n    memcpy(&Header[10],&datagram[12],8 + Option_len * 4);\n    unsigned short Header_checksum = CRC16(Header,IHL * 4 - 2);\n    memcpy(&datagram[10],&Header_checksum,2); \n    unsigned char crc16_result[2];\n    memcpy(crc16_result, &Header_checksum, sizeof(Header_checksum));\n    memcpy(&datagram[20 + Option_len*4],payload,payload_len);\n    printf(\"******Send datagrame information******\\n\");\n    printf(\"Source address: \");\n    output_octal(Source_address,4);\n    printf(\"Destinamtion address  : \");\n    output_octal(Destination_address,4);\n    printf(\"payload      : %s\\n\",payload);\n    printf(\"CRC16        : \");\n    output_octal(crc16_result, 2);    \n    printf(\"payload length  : %d\\n\", payload_len);\n    printf(\"Header length   : %d(row*4bytes)\\n\", IHL);\n    printf(\"datagram length : %d\\n\", Total_length);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] datagram send success!\\n\");\n    return Total_length;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__7_Suma_factorial.2.c", "original_string": "int Suma(int numero, int Sumatoria)\n{\n    if(numero >= 1){\n        Sumatoria += factorial(numero);\n        Suma(--numero, Sumatoria);  \n    }else{\n        return Sumatoria + 1;\n    }\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__ImprovisedBubbleSort.3.c", "original_string": "void improvised_bubble_sort(int a[50],int n)\n    {\n       int i,j,temp,flag=1;\n       count++;\n       for(i=1;i<n && flag;i++)\n       {\n           count++;\n           count++;\n           flag=0;\n           for(j=0;j<n-i;j++)\n           {\n               count++;\n               count++;\n               if(a[j]>a[j+1])\n               {\n                   count++;\n                   temp=a[j];\n                   count++;\n                   a[j]=a[j+1];\n                   count++;\n                   a[j+1]=temp;\n                   count++;\n                   flag=1;\n                   count++;\n               }\n           }\n       }\n    }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__11.1.c", "original_string": "int main()\n{\n    double a;\n    int n;\n    printf(\"\\nFun\u00e7\u00e3o exponencial (a^n):\\n\");\n    printf(\"\\t -> (real) a: \");\n    scanf(\"%lf\", &a);\n    getchar();\n    printf(\"\\t -> (int) n: \");\n    scanf(\"%i\", &n);\n    printf(\"\\n%lf^%i = %lf\\n\\n\", a, n, exponencial(a,n));\n    return 0;\n}"}
{"author": "HakNinja", "file": "C-Advance__3str2.0.c", "original_string": "int main()\n{int i,n,s;\n    struct student x[100];\n    printf(\"Enter number of students:\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter Details:\\n\");\n    for(i=0;i<n;i++)\n    {\n    printf(\"Enter roll number:\");\n    scanf(\"%d\",&x[i].rno);\n    printf(\"Enter name of student:\");\n    scanf(\"%s\",x[i].name);\n    printf(\"Percentage:\");\n    scanf(\"%f\",&x[i].per);\n    }\n    printf(\"\\n---------------------------------\\n\");\n    printf(\"Roll_no top be search:\");\n    scanf(\"%d\",&s);\n    for(i=0;i<n;i++)\n    {if(s==x[i].rno)\n    {\n    printf(\"\\nRoll number:%d\\n\",x[i].rno);\n    printf(\"\\nName:%s\\n\",x[i].name);\n    printf(\"Percentage:%f\\n\",x[i].per);\n    } \n    }  \n    return(0);\n}"}
{"author": "0712023", "file": "Arduino-Mood-Light-DIY-kit__Moodlight.7.c", "original_string": "void ultra_set() {\n  static long dis_pre;\n  digitalWrite(TRIG_PIN, HIGH);\n  delayMicroseconds(10);\n  digitalWrite(TRIG_PIN, LOW);\n  long duration = pulseIn(ECHO_PIN, HIGH);\n  long distance = ((float)(340 * duration) / 1000) / 2 ;\n  if ( distance > 2000 )\n    distance = dis_pre;\n  if ( distance < dis_1 )\n    distance = dis_1;\n  else if ( distance > dis_3 )\n    distance = dis_3;\n  dis_pre = distance;\n  if ( dis_1 <= distance && distance <= dis_2 ) {\n    for (int i = 0; i < NUMPIXELS; i++) {\n      pixels.setPixelColor(i, pixels.Color( 255 - map(distance, dis_1, dis_2, 0, 255) , map(distance, dis_1, dis_2, 0, 255) , 0) );\n      pixels.show();\n    }\n  }\n  else if ( dis_2 <= distance && distance <= dis_3 ) {\n    for (int i = 0; i < NUMPIXELS; i++) {\n      pixels.setPixelColor(i, pixels.Color( 0 , 255 - map(distance, dis_2, dis_3, 0, 255) , map(distance, dis_2, dis_3, 0, 255) ) );\n      pixels.show();\n    }\n  }\n}"}
{"author": "Dhruvik-Chevli", "file": "DAALab__bst.2.c", "original_string": "void preorder(struct Node* root)\n{\n    if(!root)\n        return;\n    printf(\"%d \",root->data);\n    preorder(root->left);\n    preorder(root->right);\n    return;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__37_find_frequency_of_no_in_array.0.c", "original_string": "int main()\n{\n  int i,j,k,no=0,max=0;\n  printf(\"Enter Length of array\\n\");\n  scanf(\"%d\",&no);\n  int *a = (int*)(malloc(no * sizeof(int)));\n  printf(\"Enter Array numbers\\n\");\n  for(i=0; i<no; i++)\n  {\n   scanf(\"%d\",&a[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",a[i]);\n  }\n  max = a[0];\n  for(i=0; i<no; i++)\n  {\n    if(max < a[i])\n    { \n      max = a[i];\n    }\n  }\n  printf(\"Value of Max is %d\",max);\n  max+=1;\n  int b[max];\n  a = (int*)(realloc(a,max * sizeof(int)));\n  for(i=0; i<max; i++)\n  {\n    b[i] = 0;\n    if(i>=no)\n    {\n      a[i] = 0;\n    }\n  }\n  for(i=0; i<=max; i++)\n  {\n    if(a[i] != 0)\n    {\n      b[a[i]] = b[a[i]] + 1;\n    }\n  }\n  printf(\"Numbers Repeated odd numbers of Times\\n\");\n  for(i=0; i<max; i++)\n  {\n    if(b[i] != 0)\n    {\n      printf(\"%d is repeated %d times\\n\",i,b[i]);\n    }\n  }\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__functions.6.c", "original_string": "int FindStudent(char* lastName, char* firstName, pointerHash hashTable)\n{\n    int hashKey = CountKey(lastName);\n    position currentStudent = hashTable->hashList[hashKey];\n    int isFound = 0;\n    while (currentStudent && !isFound)\n    {\n        if (strcmp(currentStudent->lastName, lastName) == 0 && strcmp(currentStudent->firstName, firstName) == 0)\n        {\n            printf(\"Registration number for %s %s is:%s\\n\", currentStudent->firstName, currentStudent->lastName, currentStudent->registrationNumber);\n            isFound = 1;\n        }\n        currentStudent = currentStudent->next;\n    }\n    if (!isFound)\n    {\n        printf(\"Student does not exist!\\n\");\n    }\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__n-rooks_castle-a.1.c", "original_string": "int safe(int arr[N][N], int row, int col){\n    for (int i = 0; i < row; i++)\n        if(arr[row][i])\n            return 0;\n    for (int i = 0; i < col; i++)\n        if(arr[row][i])\n            return 0;\n    return 1;\n}"}
{"author": "sdukesameer", "file": "dsa__n-rooks_castle.3.c", "original_string": "int main(){\n    int n=1;\n    while(n){\n        printf(\"Enter valid N i.e no of rows and columns: \");\n        scanf(\"%d\",&N);\n        if(N>0)\n            n=0;\n    }\n    int arr[N][N];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            arr[i][j]=0;\n    rooks(arr,0);\n    return 0;\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-2new.6.c", "original_string": "int bfs(char*** maze,int*** d,int sr,int sc,int sh){\n    rear=-1;front=-1;\n    int arrive=0;\n    element position;\n    position.row = sr;\n    position.col = sc;\n    position.hei = sh;\n    addq(position);\n    int i,j,k;\n    for(i=0;i<n/2+1;i++){\n        for(j=0;j<n+2;j++){\n            for(k=0;k<n+2;k++){\n                d[i][j][k]=MAX;\n            }\n        }\n    }\n    d[sh][sr][sc]=0;\n    int nr,nc,nh;\n    int row,col,hei;\n    while(rear!=front){\n        position = deleteq();\n        row = position.row;\n        col = position.col;\n        hei = position.hei;\n        if(maze[hei][row][col]=='F'){\n            if(min>d[hei][row][col]){\n                min = d[hei][row][col];\n            }\n            min = d[hei][row][col];\n            arrive=1;\n        }\n        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='D'){\n            int upanddown=-1;\n            if(maze[hei][row][col]=='U'){\n                upanddown=1;\n            }\n            nr = row;\n            nc = col;\n            nh = hei+upanddown;\n            if(nh>=0){\n                if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){\n                    d[nh][nr][nc]=d[hei][row][col]+1;\n                    if(maze[nh][nr][nc]=='T'){\n                        d[nh][nr][nc]=d[nh][nr][nc]+2;\n                    }\n                    element nextposition;\n                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                    addq(nextposition);\n                }\n            }\n        }\n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            nh = hei+move[i].hei;\n            if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){\n                d[nh][nr][nc]=d[hei][row][col]+1;\n                if(maze[nh][nr][nc]=='T'){\n                    d[nh][nr][nc]=d[nh][nr][nc]+2;\n                }\n                element nextposition;\n                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                addq(nextposition);\n            }\n        }\n    }\n    return arrive;\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad8.0.c", "original_string": "int main()\n{\n    float number1, number2;\n    int endProgram = 0;\n    while(!endProgram){\n        printf(\"Podaj pierwsz\\245 liczb\\251: \");\n        if(scanf(\"%f\", &number1) == 1) {\n            printf(\"Podaj drug\\245 liczb\\251: \");\n            if(scanf(\"%f\", &number2) == 1) {\n                wynik(number1, number2);\n            } else {\n            printf(\"Podano b\\210\\251dne dane. Zako\\344czenie pracy programu!\\n\");\n            endProgram = 1;\n            }\n        } else {\n            printf(\"Podano b\\210\\251dne dane. Zako\\344czenie pracy programu!\\n\");\n            endProgram = 1;\n        }\n    }\n    getchar();\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_last_CLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d\",temp->data);\n    printf(\"\\n\");\n}"}
{"author": "paawankohli", "file": "DSA-LAB__toh.1.c", "original_string": "int main()\n{\n    int plates;\n    char source = 'A', destin = 'C', aux = 'B';\n    printf(\"Enter number of plates on A:\");\n    scanf(\"%d\", &plates);\n    printf(\"No. of moves: %d \\n\", move(plates, source, destin, aux));\n}"}
{"author": "haon1026", "file": "linux-programming__2mult_thread_server.1.c", "original_string": "int main()\n{\n    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in serv_addr;\n    bzero(&serv_addr, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9999);\n    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    Bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n    Listen(serv_sock, 128);\n    printf(\"Accepting client connect...\\n\");\n    struct clnt_info c_info[256];\n    int i = 0;\n    int clnt_sock;\n    struct sockaddr_in clnt_addr;\n    socklen_t clnt_addr_len;\n    pthread_t tid;\n    while(1)\n    {\n        clnt_addr_len = sizeof(clnt_addr);\n        clnt_sock = Accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_len);\n        c_info[i].clnt_addr = clnt_addr;\n        c_info[i].clnt_sock = clnt_sock;\n        pthread_create(&tid, NULL, do_work, (void*)&c_info[i]);     \n        pthread_detach(tid);            \n        i++;\n    }\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__cll-ins-sor-seq-del.5.c", "original_string": "void print(node* head)\n{\n    node* temp=head;\n    do\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    while(temp!=head);\n}"}
{"author": "ria3999", "file": "cbnst__RANGE_KUTTA_METHOD.1.c", "original_string": "int main()\n{\n    int i,n;\n    float x0,y0,h,xn,k1,k2,k3,k4,x,y,k;\n    printf(\"\\n\\n***INPUT***\\n\\n\");\n    printf(\"Enter x0,y0,h,xn:\\n\");\n    scanf(\"%f%f%f%f\",&x0,&y0,&h,&xn);\n    n=(xn-x0)/h;\n    x=x0;\n    y=y0;\n    for(i=0;i<=n;i++)\n    {\n        k1=h*func(x,y);\n        k2=h*func(x+(h/2),y+(k1/2));\n        k3=h*func(x+(h/2),y+(k2/2));\n        k4=h*func(x+h,y+k3);\n        k=(k1+2*(k2+k3)+k4)/6.0;\n        x=x+h;\n        y=y+k;\n    }\n    printf(\"\\n\\n***OUTPUT***\\n\\n\");\n    printf(\"Result is:\\n\");\n    printf(\"x=%f y=%f\",x,y);\n    return 0;\n}"}
{"author": "ankitraj311", "file": "450_babbar__6_union_array_SELF_unsorted_array.0.c", "original_string": "void array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__palhaco.2.c", "original_string": "void desenhaChapeu(){\n    glPushMatrix();\n        glColor3f(0.0,1.0,0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glRotatef(30.0, 0.0, 0.0, 1.0);\n        glRotatef(-90.0, 1.0, 0.0, 0.0);\n        glTranslatef(0.0, 0.0, 2.0);\n        glutWireCone(2.0,4.0,20,20);\n        glutWireTorus(0.2, 2.2, 10, 25);\n    glPopMatrix();\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__10.0.c", "original_string": "int main()\n{\n    int n, qtd = 2, idade, maior, menor;\n    printf(\"\\nInforme a quantidade de idades: \");\n    scanf(\"%i\", &n);\n    printf(\"\\nInforme a 1\u00aa idade: \");\n    scanf(\"%i\", &idade);\n    maior = idade;\n    menor = idade;\n    for (int i = 0; i < (n - 1); i++)\n    {\n        printf(\"\\nInforme a %i\u00aa idade: \", qtd);\n        scanf(\"%i\", &idade);\n        qtd++;\n        if (idade > maior)\n        {\n            maior = idade;\n        }\n        else if (idade < menor)\n        {\n            menor = idade;\n        }\n    }\n    printf(\"\\nMaior idade: %i\", maior);\n    printf(\"\\nMenor idade: %i\\n\\n\", menor);\n    return 0;\n}"}
{"author": "rgautam320", "file": "Data-Structure__main14.0.c", "original_string": "int main()\n{\n    int arr[10][10], i,j,k, arr2[10][10],arr3[10][10], sum=0;\n    printf(\"Read first 3x3 matrix\\n\");\n    for(i = 0; i<3; i++)\n    {\n        for(j = 0; j<3; j++)\n        {\n            printf(\"Element - [%d],[%d] : \", i, j);\n            scanf(\"%d\", &arr[i][j]);\n        }\n    }\n    printf(\"The first matrix is : \\n\");\n    for(i = 0; i<3; i++)\n    {\n        printf(\"\\n\");\n        for(j = 0; j<3; j++)\n        {\n            printf(\"%d \", arr[i][j]);\n        }\n    }\n    printf(\"Read second 3x3 matrix\\n\");\n    for(i = 0; i<3; i++)\n    {\n        for(j = 0; j<3; j++)\n        {\n            printf(\"Element - [%d],[%d] : \", i, j);\n            scanf(\"%d\", &arr2[i][j]);\n        }\n    }\n    printf(\"The second matrix is : \\n\");\n    for(i = 0; i<3; i++)\n    {\n        printf(\"\\n\");\n        for(j = 0; j<3; j++)\n        {\n            printf(\"%d \", arr2[i][j]);\n        }\n    }\n    printf(\"\\n\");\n    for(i = 0; i<=2; i++)\n    {\n        for(j=0; j<=2; j++)\n        {\n            for(k = 0; k<=2; k++)\n            {\n                sum = sum + arr[i][k] * arr2[k][j];\n            }\n            arr3[i][j] = sum;\n            sum  = 0;\n        }\n    }\n    printf(\"The result is : \\n\");\n    for(i = 0; i<3; i++)\n    {\n        for(j=0; j<3; j++)\n        {\n            printf(\"%d \\t\", arr3[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_CLL.4.c", "original_string": "void delete_beg()\n{\n    struct node *temp,*firstnode;\n    temp =head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    firstnode=head;\n    head=head->next;\n    temp->next=firstnode->next;\n    free(firstnode);\n}"}
{"author": "kbtomic", "file": "Seminarski-StrukturePodataka__Stack.0.c", "original_string": "islandPointer PopStack(stackPointer stackHead)\n{\n    stackPointer tempStackElement = stackHead->next, prev = stackHead->next;\n    if (!tempStackElement->next)\n        return NULL;\n    while (tempStackElement->next)\n    {\n        prev = tempStackElement;\n        tempStackElement = tempStackElement->next;\n    }\n    islandPointer island = tempStackElement->data;\n    prev->next = tempStackElement->next;\n    free(tempStackElement);\n    return island;\n}"}
{"author": "2security", "file": "Pointer__7ReverseArray.0.c", "original_string": "void Display(int *a,int n)\n    {\n        int i;\n        for(i=0;i<n;i++)\n            printf(\"%d \",*(a+i));\n    }"}
{"author": "kbtomic", "file": "StrukturePodataka__zad6.0.c", "original_string": "int main()\n{\n    srand(time(NULL));\n    struct cvor HeadS;\n    HeadS.next = NULL;\n    struct cvor HeadR;\n    HeadR.next = NULL;\n    char c;\n    while (1) {\n        printf(\"Unesi 1 za implementaciju stoga, a 2 za implementaciju reda, 0 za izlaz iz programa\\n\");\n        scanf(\" %c\", &c);\n        if (c == '1')\n            stog(&HeadS);\n        else if (c == '2')\n            red(&HeadR);\n        else if (c == '0')\n            break;\n        else\n            printf(\"Nisi unio ispravni broj!\\n\");\n    }\n    return 0;\n}"}
{"author": "theuwis", "file": "AdventOfCode2015__main4.0.c", "original_string": "int main(){\n   for(int reindeer = 0; reindeer < 9; reindeer++){\n      distance = 0;\n      time_flown = data[reindeer][1];\n      time_rested = 0;\n      for(int time = 0; time < TOTAL_TIME; time++){\n         if(time_flown > 0){\n            distance += data[reindeer][0];\n            time_flown--;\n         }\n         else if(time_flown == 0){\n            time_rested++;\n            if(time_rested == data[reindeer][2]){\n               time_flown = data[reindeer][1];\n               time_rested = 0;\n            }\n         }\n      }\n      distances[reindeer] = distance;\n   }\n   distance = 0;\n   for(int reindeer = 0; reindeer < 9; reindeer++){\n      if(distances[reindeer] > distance){\n         distance = distances[reindeer];\n      }\n   }\n   printf(\"winner=%d\\n\", distance);\n   return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__32.0.c", "original_string": "int main()\n{\n    char frase[200], termo[200];\n    int i = 0, tam_frase, tam_termo, busca = false, indice;\n    puts(\"\\nInforme uma frase:\");\n    scanf(\"%[^\\n]s\", frase);\n    getchar();\n    puts(\"\\nInforme um termo:\");\n    scanf(\"%[^\\n]s\", termo);\n    tam_frase = strlen(frase);\n    tam_termo = strlen(termo);\n    if (tam_frase >= tam_termo)\n    {\n        for (int i = 0; i < tam_frase; i++)\n        {\n            if ((frase[i] == termo[0]) && (busca == false))\n            {\n                busca = true;\n                indice = i;\n                for (int j = 0; j < tam_termo; j++)\n                {\n                    if ((frase[i + j] != termo[j]) && (busca == true))\n                    {\n                        busca = false;\n                    }\n                }\n            }\n        }\n    }\n    if (busca == true)\n    {\n        printf(\"\\nTermo encontrado, iniciando-se na posi\u00e7\u00e3o %i\\n\\n\", indice + 1);\n    }\n    else if (busca == false)\n    {\n        puts(\"\\nTermo n\u00e3o encontrado na frase\\n\");\n    }\n    return 0;\n}"}
{"author": "ankitraj311", "file": "Socket-thread__socket_tcp_client.0.c", "original_string": "int main()\n{\n      char server_response[256];\n      int network_socket;\n      network_socket = socket(AF_INET,SOCK_STREAM,0); \n      struct sockaddr_in server_address;\n      server_address.sin_family = AF_INET;         \n      server_address.sin_port = htons(9000);       \n      server_address.sin_addr.s_addr = INADDR_ANY; \n      int connection_status;\n      connection_status = connect(network_socket, (struct sockaddr*)&server_address, sizeof(server_address)); \n      if(connection_status == -1)\n        printf(\"Error occur during creating the connection.\\n\");\n      recv(network_socket, &server_response, sizeof(server_response),0);\n      if(connection_status != -1)\n        printf(\"%s\",server_response);\n      close(network_socket);\n      return 0;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__tab_mlt.2.c", "original_string": "int     ft_atoi(char *str)\n{\n    int     i;\n    int     sign;\n    int     res;\n    sign = -1;\n    res = 0;\n    if (str[0] == '-')\n        sign *= -1;\n    i = 0;\n    while (str[i])\n    {\n        res = res * 10 + (str[i] - 48);\n        i++;\n    }\n    return (res * sign);\n}"}
{"author": "andi-s0106", "file": "binary_trees__13-binary_tree_nodes.0.c", "original_string": "size_t binary_tree_nodes(const binary_tree_t *tree)\n{\n    size_t nodes;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    nodes = 0;\n    nodes = count_nodes(tree, nodes);\n    return (nodes);\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_08.2.c", "original_string": "int check_digit(int n)\n{\n    int count=0;\n    if(n==0)\n        return 1;\n    while(n>0)\n    {\n        n=n/10;\n        count++;\n    }\n    return count;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_pos_DCLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}"}
{"author": "paawankohli", "file": "DSA-LAB__queueOfInt.0.c", "original_string": "void insertq(que* pq, int item)\n{\n    if ((pq->front == 0 && pq->rear == size - 1) || (pq->front == pq->rear + 1))\n    {\n        printf(\"queue is full\");\n        return;\n    }\n    else if (pq->rear ==  -1)\n    {\n        pq->rear++;\n        pq->front++;\n    }\n    else if (pq->rear == size - 1 && pq->front > 0)\n    {\n        pq->rear = 0;\n    }\n    else\n    {\n        pq->rear++;\n    }\n    pq->queue[pq->rear] = item;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__priorityqueue.1.c", "original_string": "int dequeue(queue *q)\n{\n    if (q->front==q->rear)\n    {\n        printf(\"Queue Empty\");\n        return -1;\n    }\n    else\n        return q->c[--(q->rear)];\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__st.1.c", "original_string": "int     ft_to_upper(char c, char d)\n{\n    if (c == ' ' || c == '\\t')\n    {\n        if (d >= 'a' && d <= 'z')\n            return (1);\n    }\n    return (0);\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__HeapSort.3.c", "original_string": "void max_heapify(int a[100],int n,int i)\n    {\n        int temp;\n        int largest=i;\n        int left=2*i+1;\n        int right=2*i+2;\n        count++;\n        if(left<n && a[left]>a[largest])\n        {\n            count++;\n            largest=left;\n            count++;\n        }\n        count++;\n        if(right<n && a[right]>a[largest])\n        {\n            count++;\n            largest=right;\n            count++;\n        }\n        count++;\n        if(largest!=i)\n        {\n            count++;\n            temp=a[i];\n            count++;\n            a[i]=a[largest];\n            count++;\n            a[largest]=temp;\n            count++;\n            max_heapify(a,n,largest);\n            count++;\n        }\n    }"}
{"author": "Sowmyamithra", "file": "Data-Structures__DFS.2.c", "original_string": "void main()\n{\n    int graph[10][10],n,i,j,ct,v,x,vertices[10],visited[10]={1,1,1,1,1,1,1,1,1,1};\n    printf(\"\\nEnter the number of vertices of G:\");\n    scanf(\"%d\",&n);\n    printf(\"\\nEnter the adjacency matrix of graph\");\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<n;j++)\n        {\n            scanf(\"%d\",&graph[i][j]);\n        }\n    }\n    printf(\"\\nThe adjacency matrix of given graph:\\n\");\n    {\n        for(i=0;i<n;i++)\n        {\n            for(j=0;j<n;j++)\n            {\n                printf(\"\\t%d\",graph[i][j]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    printf(\"\\nEnter the starting vertex:\");\n    scanf(\"%d\",&v);\n    push(v);\n    ct=0;\n    while(top>=0)\n    {\n        vertices[ct]=pop(); \n        visited[v]=3;\n        v=vertices[ct];\n        ct++;\n        for(i=0;i<n;i++)\n        {\n            if(graph[v][i]==1 && visited[i]==1)\n            {\n                push(i);\n                visited[i]=2;   \n            }\n        }\n    }       \n    printf(\"\\nThe graph is:\\n\");\n    for(i=0;i<ct;i++)\n    {\n        printf(\"\\t%d\",vertices[i]);\n    }\n}"}
{"author": "RafaelFelisbino-hub", "file": "WHILE-exercices__Exercicio3WHILE.0.c", "original_string": "int main(void)\n{\n    int n, i = 0, primo = 0;\n    setlocale(LC_ALL, \"Portuguese\");\n    system(\"color 17\");\n    printf(\"Digite o valor de N:  \");\n    scanf_s(\"%i\", &n);\n    while (i <= n)\n    {\n        i++;\n        if (n % i == 0)\n        {\n            primo ++;\n        }                       \n    }\n    if (primo == 2)\n    {\n        printf(\"%i \u00e9 um n\u00famero primo\\n\", n);\n    }\n    else\n    {\n        printf(\"%i n\u00e3o \u00e9 um n\u00famero primo\\n\\n\", n);\n    }\n    system(\"pause\");\n}"}
{"author": "augustogunsch", "file": "jack-compiler__util.4.c", "original_string": "char* itoa(int i) {\n    int size = sizeof(char)*(countplaces(i)+1);\n    char* a = (char*)malloc(size);\n    snprintf(a, size, \"%i\", i);\n    return a;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__DAG1.1.c", "original_string": "void add_file(char dir,char file)\n{\n    int i,flag=-1;\n    struct graph* p=(struct graph*)malloc(sizeof(struct graph));\n    p->name=file;\n    p->id=2;\n    p->parent=dir;\n    p->next=NULL;\n    for(i=0;i<pos;i++)\n    {\n        temp=G[i];\n        q=temp->next;\n        while(temp!=NULL)\n        {\n            if(temp->name==dir && temp->id==1)\n            {\n                p->next=temp->next;\n                temp->next=p;\n                flag=1;\n                break;\n            }\n            else\n            {\n                q=temp;\n                temp=temp->next;\n            }\n        }\n        if(flag==1)\n            break;\n    }\n}"}
{"author": "254Odeke", "file": "OpeartingSystems__os16.0.c", "original_string": "void info(){\n    printf(\"Enter the Size of Physical memory: \");\n    scanf(\"%d\",&pmsize);\n    printf(\"Enter the size of Logical memory: \");\n    scanf(\"%d\",&lmsize);\n    printf(\"Enter the partition size: \");\n    scanf(\"%d\",&psize);\n    no_of_frames=pmsize/psize;\n    no_of_pages=lmsize/psize;\n    printf(\"The physical memory is divided into %d no.of frames\\n\",no_of_frames);\n    printf(\"The Logical memory is divided into %d no.of pages\\n\",no_of_pages);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q30.1.c", "original_string": "int main()\n{\n    int m, n, p, q;\n    printf(\"Enter dimensions of first array:\");\n    scanf(\"%d %d\", &m, &n);\n    int **arr1 = calloc(m, sizeof(int*));\n    for(int i = 0 ; i < m ; i++)\n        arr1[i] = calloc(n, sizeof(int));\n    for(int i = 0 ; i < m; i++)\n        for(int j = 0; j < n; j++)\n            scanf(\"%d\", &arr1[i][j]);\n    printf(\"Enter dimensions of second array:\");\n    scanf(\"%d %d\", &p, &q);\n    int **arr2 = calloc(p, sizeof(int*));\n    for(int i = 0 ; i < p ; i++)\n        arr2[i] = calloc(q, sizeof(int));\n    for(int i = 0 ; i < p; i++)\n        for(int j = 0; j < q; j++)\n            scanf(\"%d\", &arr2[i][j]);\n    if(n != p)\n    {\n        printf(\"Invalid Order\");\n        return 0;\n    }\n    else if (n == p)\n    {\n        int **product = calloc(m, sizeof(int*));\n        for(int i = 0 ; i < m ; i++)\n            product[i] = calloc(q, sizeof(int));\n        multiply(arr1, arr2, m, n, p, q, product);\n        printf(\"Product: \\n\");\n        for(int i = 0 ; i < m ; i++)\n        {\n            for(int j = 0; j < q ; j++)\n                printf(\"%d \\t\", product[i][j]);\n            printf(\"\\n\");\n        }\n    }\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__udpdaytimeclient.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    struct sockaddr_in s,c; \n    int rval,sockid,slen;\n    char m1[20],m2[20];\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP-Address Port#\\n\",argv[0]);\n        exit(1);\n    }\n    sockid=socket(PF_INET,SOCK_DGRAM,17);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=PF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    c.sin_port=htons(5080);\n    printf(\"\\nEnter the request message : \");\n    scanf(\"%s\",m1);\n    slen=sizeof(s);\n    rval=sendto(sockid,m1,sizeof(m1),0,(struct sockaddr*)&s,slen);\n    if(rval==-1)\n    {\n        perror(\"MSG-SEND-ERR:\");\n        exit(1);\n    }\n    printf(\"\\nMessage sent successfully\\n\");\n    strncpy(m2,\" \",20);\n    rval=recvfrom(sockid,m2,sizeof(m2),0,(struct sockaddr*)&s,&slen);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n        exit(1);\n    }\n    printf(\"\\nServer Response is : %s\\n\",m2);\n    close(sockid);\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sum_Rows_Columns_Matrix.0.c", "original_string": "void main()\n{\n    int i, j = 0;\n    int input_matrix[R][C];\n    printf(\"\\nEnter the matrix elements...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &input_matrix[i][j]);\n        }\n    }\n    printf(\"\\nInput Matrix is as follows:- \\n\");\n    display(input_matrix);\n    find_Sum_Of_Rows(input_matrix);\n    find_Sum_Of_Columns(input_matrix);\n}"}
{"author": "tadeograch", "file": "sorting_algorithms__103-merge_sort.0.c", "original_string": "void merge_sort(int *array, size_t size)\n{\n    int n = (int)size;\n    int *brray;\n    if (size < 2)\n        return;\n    brray = malloc(sizeof(int) * size);\n    CopyArray(array, 0, n, brray);\n    TopDownSplitMerge(brray, 0, n, array);\n    free(brray);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__count_the_elem_in_DCLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n}"}
{"author": "augustogunsch", "file": "jack-compiler__util.7.c", "original_string": "STRINGLIST* initstrlist(const char** strs, int count) {\n    STRINGLIST* strlist = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n    STRINGLIST* curr = strlist;\n    for(int i = 0; i < count-1; i++) {\n        curr->content = ezheapstr(strs[i]);\n        curr->next = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n        curr = curr->next;\n    }\n    curr->content = ezheapstr(strs[count-1]);\n    curr->next = NULL;\n    return strlist;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__poly.5.c", "original_string": "int main()\n{\n    nptr poly1  = NULL, poly2 = NULL, poly3 = NULL;\n    int n, m;\n    int coeff, exp;\n    printf(\"Enter terms in poly1: \"); \n    scanf(\"%d\", &n);\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter coeff and exp: \"); \n        scanf(\"%d %d\", &coeff, &exp);\n        poly1 = insert(poly1, coeff, exp);\n    }\n    printf(\"Enter terms in poly2: \"); \n    scanf(\"%d\", &m);\n    for(int i = 0 ; i < m ; i++)\n    {\n        printf(\"Enter coeff and exp: \"); \n        scanf(\"%d %d\", &coeff, &exp);\n        poly2 = insert(poly2, coeff, exp);\n    }\n    printf(\"\\n\");\n    display(poly1);\n    display(poly2);\n    printf(\"\\n\");\n    display(poly3 = add(poly1, poly2));\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__catavento.5.c", "original_string": "void rotacoes(int key, int x, int y){\n     switch (key){\n        case GLUT_KEY_RIGHT :\n            opcao = 3;\n            velocidade = velocidade + 0.0001;\n            break ;\n        case GLUT_KEY_LEFT :\n            opcao = 4;\n            velocidade = velocidade - 0.0001;\n            break ;\n        default:\n           break;\n     }\n    glutPostRedisplay();\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__QuickSort.2.c", "original_string": "void main()\n{\n    int n,i;\n    printf(\"\\nEnter the number of elements in the array:\");\n    scanf(\"%d\",&n);\n    printf(\"\\nEnter the elements of the array:\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&ARR[i]);\n    }\n    QuickSort(ARR,0,n-1);\n    printf(\"\\nThe sorted array is:\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\t%d\",ARR[i]);\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__WiFiStationDrv0.2.c", "original_string": "static esp_err_t wifiEventHandlerCallback(void *ctx, system_event_t *event)\n{\n  switch (event->event_id)\n  {\n    case SYSTEM_EVENT_STA_GOT_IP:\n    {\n      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);\n      break;\n    }\n    case SYSTEM_EVENT_STA_LOST_IP:\n    case SYSTEM_EVENT_STA_DISCONNECTED:\n    case SYSTEM_EVENT_STA_STOP:\n    case SYSTEM_EVENT_STA_DHCP_TIMEOUT:\n    {\n      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_DISCONNECTED);\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return ESP_OK;\n}"}
{"author": "254Odeke", "file": "Operating-Systems_Lab__Virtual_to_Physical_Address_Conversion_Simulation.1.c", "original_string": "void assign(){\n    int i;\n    for (i=0;i<no_of_pages;i++){\n        ptable[i].fno = -1;\n        ptable[i].pbit= -1;\n    }\n    for(i=0; i<no_of_frames;i++)\n        ftable[i] = 32555;\n    for (i=0;i<no_of_pages;i++){\n        printf(\"Enter the Frame number where page %d must be placed: \",i);\n        scanf(\"%d\",&frameno);\n        ftable[frameno] = i;\n        if(ptable[i].pbit == -1){\n            ptable[i].fno = frameno;\n            ptable[i].pbit = 1;\n        }\n    }\n    printf(\"\\n\\nPAGE TABLE\\n\\n\");\n    printf(\"PageAddress FrameNo. PresenceBit\\n\\n\");\n    for (i=0;i<no_of_pages;i++)\n        printf(\"%d\\t\\t%d\\t\\t%d\\n\",i,ptable[i].fno,ptable[i].pbit);\n    printf(\"\\n\\nFRAME TABLE\\n\\n\");\n    printf(\"FrameAddress PageNo\\n\\n\");\n    for(i=0;i<no_of_frames;i++)\n        printf(\"%d\\t\\t%d\\n\",i,ftable[i]);\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__23.2.c", "original_string": "void sumaverage(int ar[],int n)\n{\n    int i,sum=0;\n    float avg;\n    for(i=0;i<n;i++)\n        sum=sum+ ar[i];\n        avg=(float)sum/n;\n    printf(\"%d%f\",sum,avg);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__24_While.1.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular ln(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    while(i <= veces){\n        if(i%2 == 0)\n            Suma_total += Exp(X-1, i+1) / (i+1);\n        else\n            Suma_total -= Exp(X-1, i+1) / (i +1);\n        ++i;\n    }\n    printf(\"ln(%i) es igual a %lf\", X, (Suma_total + (X - 1)));\n    return 0;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es32.1.c", "original_string": "void delta_minimo(int a[], int n, int dim)\n{\n    int differenza[dim];\n    int risultato;\n    for(int i = 0; i<dim; i++)\n    {\n        if(abs(a[i]) > n)\n        {\n            differenza[i] = abs(a[i]) - n;\n        }   else   {\n            differenza[i] = n - abs(a[i]);\n        }         \n    }\n    risultato = minimo(differenza, dim); \n    printf(\"----------------------------\\nIntero in valore assoluto pi\u00f9 vicino a quello fornito: %d\", a[risultato]);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_DCLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}"}
{"author": "qtgeo1248", "file": "ProjectEuler__ans8.0.c", "original_string": "int main() {\n    char *filename = \"num.txt\";\n    FILE *f = fopen(filename, \"r\");\n    size_t num_ints = 0;\n    for (char c = fgetc(f); c != EOF; c = fgetc(f)) {\n        if (isdigit(c))\n            num_ints++;\n    }\n    fclose(f);\n    size_t *digits = calloc(sizeof(size_t), num_ints);\n    f = fopen(filename, \"r\");\n    for (size_t i = 0; i < num_ints; i++) {\n        char c = fgetc(f);\n        if (!isdigit(c))\n            c = fgetc(f);\n        digits[i] = c - '0';\n    }\n    size_t max_prod = 0;\n    for (size_t i = 0; i < num_ints - 12; i++) {\n        size_t tmp_prod = digits[i] * digits[i + 1] * digits[i + 2] * digits[i + 3]\n                        * digits[i + 4] * digits[i + 5] * digits[i + 6] * digits[i + 7]\n                        * digits[i + 8] * digits[i + 9] * digits[i + 10]\n                        * digits[i + 11] * digits[i + 12];\n        if (tmp_prod > max_prod)\n            max_prod = tmp_prod;\n    }\n    printf(\"Answer: %zu\\n\", max_prod);\n    free(digits);\n    fclose(f);\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BST.0.c", "original_string": "struct tree* find_max(struct tree* root)\n{\n    if(root==NULL || root->right==NULL)\n    return(root);\n    else\n    return(find_max(root->right));  \n}"}
{"author": "augustogunsch", "file": "jack-compiler__io.3.c", "original_string": "char* getname(char* f, int len) {\n    int startind = 0;\n    int endind = len - 1;\n    bool readsmt = false;\n    for(int i = endind; i >= 0; i--) {\n        if(f[i] == '/') {\n            if(!readsmt) {\n                endind = i-1;\n                f[i] = '\\0';\n                continue;\n            }\n            startind = i+1;\n            break;\n        }\n        readsmt = true;\n    }\n    int sz = sizeof(char)*(endind - startind + 2);\n    char* startstr = strhead(f, startind);\n    char* retstr = (char*)malloc(sz);\n    snprintf(retstr, sz, \"%s\", startstr);\n    return retstr;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__bridge_mib_impl_tp.5.c", "original_string": "error_t bridgeMibGetDot1dTpPortEntry(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, MibVariant *value, size_t *valueLen)\n{\n   error_t error;\n   size_t n;\n   uint16_t dot1dTpPort;\n   n = object->oidLen;\n   error = mibDecodePort(oid, oidLen, &n, &dot1dTpPort);\n   if(error)\n      return error;\n   if(n != oidLen)\n      return ERROR_INSTANCE_NOT_FOUND;\n   if(bridgeMibGetPortIndex(dot1dTpPort) == 0)\n      return ERROR_INSTANCE_NOT_FOUND;\n   if(!strcmp(object->name, \"dot1dTpPort\"))\n   {\n      value->integer = dot1dTpPort;\n   }\n   else if(!strcmp(object->name, \"dot1dTpPortMaxInfo\"))\n   {\n      value->integer = ETH_MTU;\n   }\n   else if(!strcmp(object->name, \"dot1dTpPortInFrames\"))\n   {\n      value->counter32 = 0;\n   }\n   else if(!strcmp(object->name, \"dot1dTpPortOutFrames\"))\n   {\n      value->counter32 = 0;\n   }\n   else if(!strcmp(object->name, \"dot1dTpPortInDiscards\"))\n   {\n      value->counter32 = 0;\n   }\n   else\n   {\n      error = ERROR_OBJECT_NOT_FOUND;\n   }\n   return error;\n}"}
{"author": "Dhruvik-Chevli", "file": "DAALab__consgcd.1.c", "original_string": "int main()\n{\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    printf(\"%d\\n\",GCD(a,b));\n    return 0;\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__tcpechoconcurrentserver.0.c", "original_string": "void main(int argc,char*argv[])\n{\n    int sid,sid1,rval,itr,i,pid;\n    struct sockaddr_in s,c;\n    char buffer[20];\n    int clen; \n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    printf(\"\\nEnter the number of clients to serve/ server iterations : \");\n    scanf(\"%d\",&itr);\n    sid=socket(AF_INET,SOCK_STREAM,6);\n    if(sid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=bind(sid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)\n    {\n        perror(\"BIND-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    rval=listen(sid,5);\n    if(rval==-1)\n    {\n        perror(\"LISTEN-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    for(i=1;i<=itr;i++)\n    {\n        clen=sizeof(c);\n        sid1=accept(sid,(struct sockaddr*)&c,&clen);\n        if(sid1==-1)\n        {\n            perror(\"ACCEPT-ERR:\");\n            close(sid);\n            exit(1);\n        }\n        pid=fork();\n        if(pid==-1)\n        {\n            perror(\"FRK-ERR:\");\n            close(sid1);\n            close(sid);\n            exit(1);\n        }\n        if(pid==0) \n        {\n            rval=recv(sid1,buffer,sizeof(buffer),0);\n            if(rval==-1)\n            {\n                perror(\"MSG-RCV-ERR:\");\n            }\n            else\n            {\n                printf(\"\\nClient request is %s\\n\",buffer);\n            }\n            rval=send(sid1,buffer,sizeof(buffer),0);\n            if(rval==-1)\n            {\n                perror(\"MSG-SND-ERR:\");\n            }\n            else\n            {\n                printf(\"\\nResponse sent\\n\");\n            }\n            close(sid1);\n            exit(0);\n        }\n        else \n        close(sid1);\n    }\n    close(sid);\n    exit(0);\n}"}
{"author": "haon1026", "file": "linux-programming__cond_produce_multconsumer.1.c", "original_string": "void *producer(void *arg)\n{\n    while(1)\n    {\n        struct msg *mp = malloc(sizeof(struct msg));\n        mp->num = rand() % 1000 + 1;                    \n        printf(\"-----produce %d\\n\", mp->num);\n        pthread_mutex_lock(&mutex);                     \n        mp->next = head;                                \n        head = mp;\n        pthread_mutex_unlock(&mutex);                   \n        pthread_cond_signal(&has_data);              \n        sleep(rand()%3);\n    }\n    return NULL;\n}"}
{"author": "dishanp", "file": "DSA__q15.3.c", "original_string": "int main()\n{\n    int n, key, index;\n    printf(\"Number of elements : \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n    {\n        scanf(\"%d\", &A[i]);\n    }\n    create(A, n);\n    printf(\"Enter key to be searched : \");\n    scanf(\"%d\", &key);\n    delete(first, key);\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__execute.1.c", "original_string": "static void loop(t_m *m, int x, int y)\n{\n    if (y == m->ac)\n        final_print(m);\n    else if (m->av[y][x] == 0)\n        loop(m, 0, y + 1);\n    else\n    {\n        if (is_enemy(m, x, y))\n        {\n            m->enemy = m->av[y][x];\n            check_enemy(m, x, y);\n        }\n        loop(m, x + 1, y);\n    }\n}"}
{"author": "tadeograch", "file": "sorting_algorithms__103-merge_sort.2.c", "original_string": "void TopDownMerge(int A[], int iBegin, int iMiddle, int iEnd, int B[])\n{\n    int i = iBegin, j = iMiddle, k, index;\n    for (k = iBegin; k < iEnd; k++)\n    {\n        if (i < iMiddle && (j >= iEnd || A[i] <= A[j]))\n        {\n            B[k] = A[i];\n            i = i + 1;\n        }\n        else\n        {\n            B[k] = A[j];\n            j = j + 1;\n        }\n    }\n    printf(\"[left]: \");\n    for (index = iBegin; index < iMiddle; index++)\n    {\n        printf(\"%d\", A[index]);\n        if (index != iMiddle - 1)\n            printf(\", \");\n    }\n    printf(\"\\n\");\n    printf(\"[right]: \");\n    for (index = iMiddle; index < iEnd; index++)\n    {\n        printf(\"%d\", A[index]);\n        if (index != iEnd - 1)\n            printf(\", \");\n    }\n    printf(\"\\n\");\n}"}
{"author": "paawankohli", "file": "DSA-LAB__week_1.0.c", "original_string": "double add(double L[], int n)\n{\n    double sum = 0;\n    for(int i = 0 ; i < n ; i++)\n        sum += L[i];\n    return sum;\n}"}
{"author": "shengelenge", "file": "wstep-do-programowania__zad130.0.c", "original_string": "long oblicz(int A[], int n)\n{\n    long w = A[0];\n    for (int i = 1; i <= n ; i++)\n    {\n        w = w*2 + A[i];\n    }\n    return w;\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_6_b.0.c", "original_string": "int main()\n{\n    int one[5] = {5, 6, 8, 8, 10};\n    int two[5];\n    printf(\"Elementy tablicy1: \");\n    for(int i = 0; i < (sizeof(one)/sizeof(one[0])); i++){\n        printf(\"%d \", one[i]);\n    }\n    copyArrays(5, one, two);\n    printf(\"\\nElementy tablicy2: \");\n    for(int i = 0; i < (sizeof(two)/sizeof(two[0])); i++){\n        printf(\"%d \", two[i]);\n    }\n    getchar();;\n    return 0;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_33.1.c", "original_string": "void imprimirVetor() {\n    for (int i = 0; i < 15; i++) {\n        if (vetor[i] != 0) {\n            printf(\"Posicao %d valor do vetor: %d\\n\", i, vetor[i]);\n        }\n    }\n}"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__map_utils.0.c", "original_string": "void        surrend_by_spaces(char **map)\n{\n    int i;\n    int j;\n    i = 0;\n    j = 0;\n    while (map[i])\n    {\n        while (j < g_map_width + 2)\n            j++;\n        map[i][j] = '\\0';\n        i++;\n        j = 0;\n    }\n    i = -1;\n    while (map[++i])\n        map[i][0] = ' ';\n    i = -1;\n    while (map[0][++i])\n        map[0][i] = ' ';\n    i = -1;\n    while (map[g_map_height][++i])\n        map[g_map_height + 1][i] = ' ';\n    i = -1;\n    while (map[++i])\n        map[i][g_map_width + 1] = ' ';\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad10.8.c", "original_string": "int WriteInFile(char* nameOfFile, treePointer root)\n{\n    FILE* fp = NULL;\n    fp = fopen(nameOfFile, \"w\");\n    if (!fp)\n    {\n        printf(\"Greska kod otvaranja datoteke!\\n\");\n        return 1;\n    }\n    InOrderPrintInFile(fp, root);\n    fclose(fp);\n    return 0;\n}"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__Ejercicio_4.0.c", "original_string": "int main(int argc, char const *argv[])\n{\n    pid_t pid, pid1, pid2, pid3;\n    for(int i = 0; i < 4 ; i++){ \n        switch (pid = fork())\n        {\n        case 0:\n            printf(\"PID hijo: %d, PID padre: %d\\n\",getpid(),getppid());\n            if(i==0||i==1){\n                for(int j = 0; j < 2; j++){ \n                    switch(pid1 = fork()){\n                    case 0:\n                        printf(\"PID hijo: %d, PID padre: %d\\n\",getpid(),getppid());\n                        if(j == 0){\n                            switch(pid3 = fork()){\n                            case 0:\n                                printf(\"PID hijo: %d, PID padre: %d\\n\",getpid(),getppid());\n                                break;\n                            case -1:\n                                printf(\"ERROR\");\n                                exit(-1);\n                            default:\n                                break;\n                            }\n                            if(pid3 == 0) break;\n                        }\n                        break;\n                    case -1:\n                        printf(\"ERROR\");\n                        exit(-1);\n                    default:\n                        break;\n                    }\n                    if(pid1 == 0) break;\n                }\n            }else if(i==2){\n                switch(pid2 = fork())\n                {\n                case 0:\n                    printf(\"PID hijo: %d, PID padre: %d\\n\",getpid(),getppid());\n                    break;\n                case -1:\n                    printf(\"ERROR\");\n                    exit(-1);\n                default:\n                    break;\n                }\n                if(pid2 == 0) break;\n            }\n            break;\n        case -1:\n            printf(\"ERROR\");\n            exit(-1);\n        default:\n            break;\n        }\n        if(pid == 0) break;\n    }\n    return 0;\n}"}
{"author": "dle2005", "file": "Algorithm__Hamiltonian_v2.0.c", "original_string": "void hamiltonian(int i) {\n    for(int j = 1; j <= n-1; j++)\n        printf(\"%d \", vindex[j]);\n    printf(\"\\n\");\n    if(promising(i)) {\n        if(i == n-1) {\n            printf(\"vindex = \");\n            for(int j = 1; j <= n-1; j++)\n                printf(\"%d \", vindex[j]);\n            printf(\"\\n\");\n        }\n        else {\n            for(int j = 2; j <= n; j++) {\n                vindex[i+1] = j;\n                hamiltonian(i+1);\n            }\n        }\n    }\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise2.0.c", "original_string": "int CheckString(char s[]){\n    int i=0 ,j=0;\n    int result = TRUE;\n    while(s[i] != '\\0'){\n        j = i+1;  \n            while(s[j] != '\\0'){\n                if(s[i] == s[j]){\n                    result = FALSE;\n                }\n                j++;\n            }\n            i++;\n        }\n        return result;\n}"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal_gpio.2.c", "original_string": "GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)\n{\n  GPIO_PinState bitstatus;\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\n  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)\n  {\n    bitstatus = GPIO_PIN_SET;\n  }\n  else\n  {\n    bitstatus = GPIO_PIN_RESET;\n  }\n  return bitstatus;\n}"}
{"author": "fikepaci", "file": "binary_trees__114-bst_remove.2.c", "original_string": "bst_t *bst_remove_recursive(bst_t *root, bst_t *node, int value)\n{\n    if (node != NULL)\n    {\n        if (node->n == value)\n            return (bst_delete(root, node));\n        if (node->n > value)\n            return (bst_remove_recursive(root, node->left, value));\n        return (bst_remove_recursive(root, node->right, value));\n    }\n    return (NULL);\n}"}
{"author": "ankitraj311", "file": "450_babbar__1_reverse_using_1array_GEEK.2.c", "original_string": "int main()\n{\n  int arr[100],no,j=0,temp=0,mid=0,n=0;\n  printf(\"Enter length of array\");\n  scanf(\"%d\",&no);\n  for(int i = 0; i<no; i++)\n  {\n    scanf(\"%d\",&arr[i]);\n  }\n  array_print(arr,no);\n  reverse_array(arr,0,no-1);\n  printf(\"\\n\");\n  array_print(arr,no);\n}"}
{"author": "earth429", "file": "mulpre__decrement.1.c", "original_string": "int decrement(struct NUMBER *a, struct NUMBER *b) {\n    struct NUMBER one;\n    int r;\n    setInt(&one, 1);\n    r = sub(a, &one, b);\n    return r;\n}"}
{"author": "augustogunsch", "file": "jackc__io.3.c", "original_string": "char* getname(char* f, int len) {\n    int startind = 0;\n    int endind = len - 1;\n    bool readsmt = false;\n    for(int i = endind; i >= 0; i--) {\n        if(f[i] == '/') {\n            if(!readsmt) {\n                endind = i-1;\n                f[i] = '\\0';\n                continue;\n            }\n            startind = i+1;\n            break;\n        }\n        readsmt = true;\n    }\n    int sz = sizeof(char)*(endind - startind + 2);\n    char* startstr = strhead(f, startind);\n    char* retstr = (char*)malloc(sz);\n    snprintf(retstr, sz, \"%s\", startstr);\n    return retstr;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_DLL.5.c", "original_string": "void insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node *)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    newnode->next=0;\n    temp=head;\n    while(temp->next!=0)\n    {\n        temp=temp->next;\n    }\n    temp->next=newnode;\n    newnode->pre=temp;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__count_the_elem_in_DCLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__nonVIC.0.c", "original_string": "int main()\n{\n        IODIR1 = IODIR1| LED_ALL;\n        PINSEL0 = PINSEL0 | (1<<29); \n        PINSEL0 = PINSEL0 & ~(1<<28);\n        timer_config();\n        intr_config();\n        while(1)\n        {\n            blink_led(17);\n        }\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__goal_server.7.c", "original_string": "int main(int argc, char **argv){\n    if(argc != 2){\n        printf(\"Usage: %s <port>\\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n    char *ip = \"127.0.0.1\";\n    int port = atoi(argv[1]);\n    int option = 1;\n    int listenfd = 0, connfd = 0;\n  struct sockaddr_in serv_addr;\n  struct sockaddr_in cli_addr;\n  pthread_t tid;\n  listenfd = socket(AF_INET, SOCK_STREAM, 0);\n  serv_addr.sin_family = AF_INET;\n  serv_addr.sin_addr.s_addr = inet_addr(ip);\n  serv_addr.sin_port = htons(port);\n    signal(SIGPIPE, SIG_IGN);\n    if(setsockopt(listenfd, SOL_SOCKET,(SO_REUSEPORT | SO_REUSEADDR),(char*)&option,sizeof(option)) < 0){\n        perror(\"ERROR: setsockopt failed\");\n    return EXIT_FAILURE;\n    }\n  if(bind(listenfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n    perror(\"ERROR: Socket binding failed\");\n    return EXIT_FAILURE;\n  }\n  if (listen(listenfd, 10) < 0) {\n    perror(\"ERROR: Socket listening failed\");\n    return EXIT_FAILURE;\n    }\n    printf(\"=== WELCOME TO THE CHATROOM ===\\n\");\n    while(1){\n        socklen_t clilen = sizeof(cli_addr);\n        connfd = accept(listenfd, (struct sockaddr*)&cli_addr, &clilen);\n        if((cli_count + 1) == MAX_CLIENTS){\n            printf(\"Max clients reached. Rejected: \");\n            print_client_addr(cli_addr);\n            printf(\":%d\\n\", cli_addr.sin_port);\n            close(connfd);\n            continue;\n        }\n        client_t *cli = (client_t *)malloc(sizeof(client_t));\n        cli->address = cli_addr;\n        cli->sockfd = connfd;\n        cli->uid = uid++;\n        queue_add(cli);\n        pthread_create(&tid, NULL, &handle_client, (void*)cli);\n        sleep(1);\n    }\n    return EXIT_SUCCESS;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_33.2.c", "original_string": "int main() {\n    setlocale(LC_ALL, \"\");\n    for (int i = 0; i < 15; i++) {\n        printf(\"Preencha o valor do vetor1 numero %d\\n\", i);\n        scanf(\"%d\", &vetor[i]);\n    }\n    system(\"cls\");\n    compactarVetor();\n    imprimirVetor();\n    return 0;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_38.0.c", "original_string": "int main()\n{\n    int i, x, aux, v[10];\n    for(i=0;i<10;i++){\n        printf(\"Digite o valor da posicao [%i]: \", i);\n        scanf(\"%i\", &v[i]);\n    }\n    for(i=0;i<10;i++){\n        for(x=i+1;x<10;x++){\n            if(v[i]>v[x]){\n                aux=v[i];\n                v[i]=v[x];\n                v[x]=aux;\n            }\n        }\n    }\n     for(i=0;i<10;i++){\n         printf(\"\\nO valor da posicao [%i] agora eh: [%i]\", i,v[i]);\n     }\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__FCFS.0.c", "original_string": "void main()\n{\n    int n,i,j,temp,sum=0;\n    float Waiting_time;\n    char s[10];\n    printf(\"\\nEnter the number of processess : \");\n    scanf(\"%d\",&n);\n    struct process p[n];\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter process : \");\n        scanf(\"%s\",p[i].name);\n        printf(\"\\nEnter AT : \");    \n        scanf(\"%d\",&p[i].AT);\n        printf(\"\\nEnter BT : \");\n        scanf(\"%d\",&p[i].BT);\n        p[i].CT=0;\n    }\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(p[i].AT>p[j].AT)\n            {\n                temp=p[i].AT;\n                p[i].AT=p[j].AT;\n                p[j].AT=temp;\n                temp=p[i].BT;\n                p[i].BT=p[j].BT;\n                p[j].BT=temp;\n                strcpy(s,p[i].name);\n                strcpy(p[i].name,p[j].name);\n                strcpy(p[j].name,s);\n            }   \n        }\n    }\n    p[0].CT=p[0].AT;\n    for(i=0;i<n;i++)\n    {\n        if(i!=0)\n            p[i].CT=p[i-1].CT;\n        p[i].CT=p[i].CT+p[i].BT;\n        p[i].TAT=p[i].CT-p[i].AT;\n        p[i].WT=p[i].TAT-p[i].BT;\n        sum=sum+p[i].WT;\n    }\n    printf(\"\\nprocess\\tAT\\tBT\\tCT\\tTAT\\tWT\");\n    for(i=0;i<n;i++)\n        printf(\"\\n%s\\t%d\\t%d\\t%d\\t%d\\t%d\",p[i].name,p[i].AT,p[i].BT,p[i].CT,p[i].TAT,p[i].WT);\n    Waiting_time=(sum*1.0)/n;\n    printf(\"\\nAverage Waiting_time : %f\",Waiting_time);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q4_poly.0.c", "original_string": "void create_node(int x, int y, struct Node **temp) \n{ \n    struct Node *r, *z; \n    z = *temp; \n    if(z == NULL) \n    { \n        r =(struct Node*)malloc(sizeof(struct Node)); \n        r->coeff = x; \n        r->pow = y; \n        *temp = r; \n        r->next = (struct Node*)malloc(sizeof(struct Node)); \n        r = r->next; \n        r->next = NULL; \n    } \n    else\n    { \n        r->coeff = x; \n        r->pow = y; \n        r->next = (struct Node*)malloc(sizeof(struct Node)); \n        r = r->next; \n        r->next = NULL; \n    } \n}"}
{"author": "behergue", "file": "Operating_Systems__mytar_routines.4.c", "original_string": "int extractTar(char tarName[]){\n    FILE * f = fopen(tarName, \"r\");\n    int nFiles;\n    stHeaderEntry* s = readHeader(f, &nFiles);\n    for(int i = 0; i < nFiles; i++){\n        FILE * a = fopen(s[i].name, \"w\");\n        copynFile(f, a, s[i].size);\n        fclose(a);\n    }\n    fclose(f);\n    return EXIT_SUCCESS;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__drv_ws2812.2.c", "original_string": "static void convert_rgb_to_pwm_sequence(void)\n{\n    uint8_t * ptr = (uint8_t *)led_matrix_buffer;\n    uint32_t i = 0;\n    for(int led = 0; led < LED_MATRIX_TOTAL_BYTE_WIDTH; led++)\n    {\n        for(int bit = 7; bit >= 0; bit--)\n        {\n            uint8_t b = (*ptr >> bit) & 0x01;\n            uint16_t pwm = 0;\n            if(b == 1)\n            {\n                pwm = WS2812_T1H;\n            }\n            else\n            {\n                pwm = WS2812_T0H;\n            }\n            pwm_duty_cycle_values[i++].channel_1 = pwm;\n        }\n        ptr++;\n    }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__binarySearchTree.1.c", "original_string": "void inOrderTraversal(struct Node *root){\n     if(root==NULL){\n          return;\n     }else{\n          inOrderTraversal(root->left);\n          printf(\"%d \",root->data);\n          inOrderTraversal(root->right);\n          return;\n     }\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad6-PowerFunction.0.c", "original_string": "int main()\n{\n    double userNumber;\n    int userPower;\n    printf(\"Podaj liczb\\251: \");\n    scanf(\"%lf\", &userNumber);\n    printf(\"Podaj pot\\251g\\251 ca\\210kowit\\245: \");\n    scanf(\"%d\", &userPower);\n    printf(\"%.3lf do pot\\251gi %d wynosi %.3lf\\n\", userNumber, userPower, power(userNumber, userPower));\n    return 0;\n}"}
{"author": "bgmanuel99", "file": "PracticasArquitecturaDeComputadores__ejercicio1Parte2.0.c", "original_string": "int main(int argc, char *argv[]) {\n    int rank, \n    size, \n    valor; \n    MPI_Status status; \n    MPI_Init(&argc, &argv); \n    MPI_Comm_size(MPI_COMM_WORLD, &size); \n    MPI_Comm_rank(MPI_COMM_WORLD, &rank); \n    srand(time(NULL));\n    if (rank == 0) {\n        valor = rand() % 4 + 1;\n        valor *= valor;\n    }\n    printf(\"[%d]: Antes del Bcast, el valor es %d \\n\", rank, valor);\n    MPI_Bcast(&valor, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    printf(\"[%d]: Despues del Bcast, el valor es %d \\n\", rank, valor);\n    MPI_Finalize();\n    return 0;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__planetas.7.c", "original_string": "void desenhaPlanetaCentral(){\n    glPushMatrix();\n    GLfloat diffuse[4];\n    GLfloat specular[4];\n    GLfloat ns;\n    diffuse[0] = 1.0;\n    diffuse[1] = 1.0;\n    diffuse[2] = 1.0;\n    diffuse[3] = 1.0f;\n    specular[0] = 1;\n    specular[1] = 1;\n    specular[2] = 1;\n    specular[3] = 1.0f;\n    ns = 50.0f;\n    glMaterialfv(GL_FRONT,GL_AMBIENT_AND_DIFFUSE,diffuse);\n    glMaterialfv(GL_FRONT,GL_SPECULAR,specular);\n    glMaterialf(GL_FRONT, GL_SHININESS, ns);\n    glBindTexture(GL_TEXTURE_2D, 0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        esferaQuadrica();\n    glPopMatrix();\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__timer_1MR.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | (0xFF<<17);       \n    T0PR = 14;                  \n    T0MR0 = 500000;     \n    T0MCR   = (1<<0)|(1<<1);            \n    T0TCR   = (1<<0);           \n    while(1)\n    {\n        blink_LED(24);\n        if(T0IR & (1<<0))           \n        {\n            blink_LED(17);\n            T0IR = 1<<0;            \n        }\n    }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_6.1.c", "original_string": "void enqueue(struct Node** head_ref, int new_data) \n{ \n    struct Node* new_node = createNode();\n    struct Node *last = *head_ref;\n    new_node->data  = new_data; \n    if (*head_ref == NULL) \n    { \n       *head_ref = new_node; \n       return; \n    }   \n    while (last->next != NULL) \n        last = last->next; \n    last->next = new_node; \n    return;     \n}"}
{"author": "SugumaranEvil", "file": "Datastructure__tree.2.c", "original_string": "void inorder(struct  database *node){\n    if(node == NULL){\n        return;\n    } else { \n        inorder(node->left);\n        printf(\"%d\\n\",node->roll_no);\n        inorder(node->right);\n    }\n}"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio2.1.c", "original_string": "int main(int argc, char *argv[]){\n    thmain = pthread_self();\n    pthread_attr_init(&attr);\n    printf(\"Soy la funcion main y voy a lanzar un thread \\n\");\n    pthread_create(&thread1, &attr, cuenta,\"ejemplo.txt\");\n    sleep(2);\n    printf(\"Fichero ejemplo.txt: 30 caracteres 'a' o 'A' encontrados\\n\");\n    printf(\"Soy main: he lanzado un thread y termino\\n\");\n    pthread_exit(NULL);\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__sum999.1.c", "original_string": "void *sumofnum(void *arra)\n{\n    int sum=0;\n    int *arr=(int *)arra;\n    for(i=0;i<n;i++)\n    {\n        sum+=arr[i];\n    }\n    printf(\"the sum is %d\\n\",sum);\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.3.c", "original_string": "void ensurenoduplicate(SCOPE* s, DEBUGINFO* d, char* name) {\n    VAR* v = getvar(s, name);\n    if(v != NULL)\n        doubledeclaration(name, d, v->debug);\n    CLASS* c = getclass(s, name);\n    if(c != NULL)\n        doubledeclaration(name, d, c->debug);\n    SUBROUTDEC* sr = getsubroutdec(s, name);\n    if(sr != NULL)\n        doubledeclaration(name, d, sr->debug);\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Deletion_At_The_End_of_A_Single_Linked_List.1.c", "original_string": "void display_nodes(struct node*temp1)\n{\n    printf(\"The Elements are:\");\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__is.2.c", "original_string": "int is_enemy(t_m *m, int x, int y)\n{\n    char    c;\n    c = m->av[y][x];\n    if (c == 'P' || c == 'B' || c == 'R' || c == 'Q')\n        return (1);\n    else\n        return (0);\n}"}
{"author": "augustogunsch", "file": "jack-compiler__os.4.c", "original_string": "CLASS* mkarray(CLASS* os) {\n    CLASS* arrclass = mkosclass(os, \"Array\");\n    adddec(arrclass, function, \"Array\", \"new\");\n    adddec(arrclass, method, \"void\", \"dispose\");\n    return arrclass;\n}"}
{"author": "augustogunsch", "file": "jackc__vm-lines.2.c", "original_string": "void println(LINE* ln, FILE* stream) {\n    for(int i = 0; i < ln->count; i++) {\n        fprintf(stream, \"%s\", ln->tokens[i]);\n        if(i + 1 < ln->count)\n            fprintf(stream, \" \");\n    }\n    fprintf(stream, \"\\n\");\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__circularlinkedlist.4.c", "original_string": "void main()\n{\n    int ch;\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the value to insert:\");\n                scanf(\"%d\",&value);\n                insert(value);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter the value to delete:\");\n                scanf(\"%d\",&value);\n                delete(value);\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the value to search:\");\n                scanf(\"%d\",&value);\n                search(value);\n                break;\n            }\n            case 4:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise18.0.c", "original_string": "int LongestConsecutive(int arr[],int size , int element){\n    int max_consec = 0;\n    int count = 0;\n    int i;\n    int ahead , current;\n    for(i = 0; i < size ; i++){\n        ahead = arr[i+1];\n        current = arr[i];\n        if(arr[i] == element){\n            count++;\n            if(count > max_consec){\n                max_consec = count;\n            }\n        }\n        if( ahead != current){\n            count = 0;\n        }\n    }\n    return max_consec;\n}"}
{"author": "ankitraj311", "file": "450_babbar__1_reverse_using_1array_GEEK.0.c", "original_string": "void array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__reverse_concat.0.c", "original_string": "void StrcatXX(char *Src, char *Dest)\n{\n    if(  (Src == NULL) ||  (Dest == NULL)   )\n    {\n        return;\n    }\n    while(*Dest != '\\0')   \n    {\n        Dest++;                \n    }\n    *Dest = ' ';        \n    Dest++;\n    while(*Src != '\\0')\n   {\n       *Dest = *Src;\n       Src++;\n       Dest++;\n   }\n    *Dest = '\\0';\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__1000-sort_deck.0.c", "original_string": "void swap_func(deck_node_t **deck, deck_node_t *node1, deck_node_t *node2)\n{\n    deck_node_t *tmp;\n    if (node1->next == node2)\n    {\n        if (node2->next)\n            node2->next->prev = node1;\n        node2->prev = node1->prev;\n        node1->next = node2->next;\n        node2->next = node1;\n        if (node1->prev)\n            node1->prev->next = node2;\n        node1->prev = node2;\n        if (*deck == node1)\n            *deck = node2;\n    }\n    else\n    {\n        node1->next->prev = node2;\n        if (node1->prev)\n            node1->prev->next = node2;\n        node2->prev->next = node1;\n        if (node2->next)\n            node2->next->prev = node1;\n        tmp = node1->next;\n        node1->next = node2->next;\n        node2->next = tmp;\n        tmp = node2->prev;\n        node2->prev = node1->prev;\n        node1->prev = tmp;\n        if (*deck == node1)\n            *deck = node2;\n    }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_nus_c.0.c", "original_string": "static void tx_buffer_process(void)\n{\n        if (m_tx_index != m_tx_insert_index)\n        {\n                uint32_t err_code;\n                if (m_tx_buffer[m_tx_index].type == READ_REQ)\n                {\n                        err_code = sd_ble_gattc_read(m_tx_buffer[m_tx_index].conn_handle,\n                                                     m_tx_buffer[m_tx_index].req.read_handle,\n                                                     0);\n                }\n                else\n                {\n                        err_code = sd_ble_gattc_write(m_tx_buffer[m_tx_index].conn_handle,\n                                                      &m_tx_buffer[m_tx_index].req.write_req.gattc_params);\n                }\n                if (err_code == NRF_SUCCESS)\n                {\n                        NRF_LOG_DEBUG(\"SD Read/Write API returns Success..\");\n                        m_tx_index++;\n                        m_tx_index &= TX_BUFFER_MASK;\n                }\n                else\n                {\n                        NRF_LOG_DEBUG(\"SD Read/Write API returns error. This message sending will be \"\n                                      \"attempted again..\");\n                }\n        }\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad7.3.c", "original_string": "int pop(pozicija head)\n{\n    pozicija temp = NULL;\n    int element;\n    if (head == NULL)\n        printf(\"Stog je prazan!\\n\");\n    else {\n        temp = head->next;\n        element = temp->el;\n        head->next = temp->next;\n        free(temp);\n    }\n    return element;\n}"}
{"author": "dishanp", "file": "DSA__q45.2.c", "original_string": "void remduplicates(struct node *p)\n{\n    struct node *q, *r, *t;\n    while(p)\n    {\n        q = p->next;\n        r = p;\n        while(q)\n        {\n            if(p->data == q->data)\n            {\n                r->next = q->next;\n                t = q;\n                free(t);\n                q = q->next;\n            }\n            else\n            {\n                r = q;\n                q = q->next;\n            }\n        }\n        p = p->next;\n    }\n}"}
{"author": "254Odeke", "file": "OpeartingSystems__os16.2.c", "original_string": "void cphyaddr(){\n    int log_add,paddr,disp,phy_add,base_add;\n    printf(\"Enter the Base Address: \");\n    scanf(\"%d\",&base_add);\n    printf(\"Enter the Logical Address: \");\n    scanf(\"%d\",&log_add);\n    paddr = log_add / psize;\n    disp = log_add % psize;\n    if(ptable[paddr].pbit == 1 )\n        phy_add = base_add + (ptable[paddr].fno*psize) + disp;\n    printf(\"\\nThe Physical Address where the instruction present: %d\",phy_add);\n}"}
{"author": "haon1026", "file": "linux-programming__base.5.c", "original_string": "int Connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    int ret = connect(sockfd, addr, addrlen);\n    if(ret == -1)\n    {\n        sys_err(\"connect() error\");\n    }\n    return ret;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e30.0.c", "original_string": "char * gerarCaptcha( char captchaSistema[CAPTCHA]){\n    int cont, guardaValor, aleatorio[CAPTCHA], geradorCaptcha[CAPTCHA];\n    srand(time(NULL));\n    for (cont = 0;cont < CAPTCHA; cont++){\n        guardaValor = rand();\n        aleatorio[cont] = (guardaValor % 122);\n        if((aleatorio[cont] >= 48 && aleatorio[cont] <= 57) || (aleatorio[cont] >= 65 && aleatorio[cont] <= 90) || (aleatorio[cont] >= 97 && aleatorio[cont] <= 122) ){\n            captchaSistema[cont] = aleatorio[cont];\n        }\n        else{\n            cont--;\n        }\n    }\n    return captchaSistema;\n}"}
{"author": "dle2005", "file": "Algorithm__Knapsack3.5.c", "original_string": "void main() {\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"W = \");\n    scanf(\"%d\", &W);\n    w = (int *)malloc(sizeof(int) * n + 1);\n    p = (int *)malloc(sizeof(int) * n + 1);\n    printf(\"w[1...n] = \");\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", &w[i]);\n    printf(\"p[1...n] = \");\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", &p[i]);\n    printf(\"\\n\");\n    knapsack3();\n    printf(\"maxprofit = %d\\n\", maxprofit);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_client_misc.4.c", "original_string": "error_t scpClientSendDirective(ScpClientContext *context,\n   const ScpDirective *directive)\n{\n   error_t error;\n   size_t n;\n   error = NO_ERROR;\n   while(!error)\n   {\n      if(context->bufferLen == 0)\n      {\n         n = scpFormatDirective(directive, context->buffer);\n         context->bufferLen = n;\n         context->bufferPos = 0;\n      }\n      else if(context->bufferPos < context->bufferLen)\n      {\n         error = sshWriteChannel(&context->sshChannel,\n            context->buffer + context->bufferPos,\n            context->bufferLen - context->bufferPos, &n, 0);\n         if(error == NO_ERROR || error == ERROR_TIMEOUT)\n         {\n            context->bufferPos += n;\n         }\n      }\n      else\n      {\n         context->bufferLen = 0;\n         context->bufferPos = 0;\n         break;\n      }\n      if(error == ERROR_WOULD_BLOCK || error == ERROR_TIMEOUT)\n      {\n         error = scpClientProcessEvents(context);\n      }\n   }\n   return error;\n}"}
{"author": "behergue", "file": "Computer_Structure__keyboard.0.c", "original_string": "int kb_scan(void)\n{\n    int value = -1;\n    int i;\n    char temp;\n    int lines[4]  = {0xfd, 0xfb, 0xf7, 0xef};\n    int map[4][4] = {{0, 1, 2, 3},\n                    {4, 5, 6, 7},\n                    {8, 9, 0xA, 0xB},\n                    {0xC, 0xD, 0xE, 0xF}};\n    for (i = 0; (i < 4) && (value == -1); i++) {\n        temp = *(keyboard_base+lines[i]);\n        if(( temp & KEY_VALUE_MASK) != KEY_VALUE_MASK) {\n        }\n    }\n    return value;\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad5.0.c", "original_string": "int main()\n{\n   float array[10] = {8.2, 32, -4.56, 5.666, 6.32, 93, 345, -74.32, 424.23, -425.53, 89, 56};\n    printf(\"Roznica najwiekszej i najmniejszej wartosci, to: %.2f\\n\", difference(array));\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__count_the_elem_in_DCLL.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=5)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_DLL.3.c", "original_string": "int count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n    return c;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes2.9.c", "original_string": "void imprimir_asistencias(const int posicion){\n    printf(\"Asistencias: \");\n    for (int i = 0; i < MAX_ASISTENCIA-1; i++)\n    {\n        if (lista_estudiantes[posicion].asistencias[i] == 1)\n            printf(\"%s\", \"A, \");    \n        else \n            printf(\"%s\", \"F, \");         \n    }\n    (lista_estudiantes[posicion].asistencias[MAX_ASISTENCIA-1] == 1)?printf(\"%s\", \"A\"):printf(\"%s\", \"F\");\n    printf(\"\\n\");\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__AF.1.c", "original_string": "long int supersigma(int i, int j)\n{\n    long int soma = 0;\n    for (int a = i; a <= j; a++)\n    {\n        soma += fib[a];\n    }\n    return soma;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_SLL.0.c", "original_string": "int main()\n{\n    printf(\"Linked list functions\\n\");\n    int choice;\n    printf(\"1.implementation\\n\");\n    printf(\"2.display\\n\");\n    printf(\"3.count\\n\");\n    printf(\"4.insert the element at the beginning position of linked list\\n\");\n    printf(\"5.insert the element at the last position of linked list\\n\");\n    printf(\"6.insert the element at any position of linked list\\n\");\n    printf(\"7.delete the element at the beginning position of linked list\\n\");\n    printf(\"8.delete the element at the last position of linked list \\n\");\n    printf(\"9.delete the element at any position of linked list\\n\");\n    printf(\"10.reverse the linked list\\n\");\n    printf(\"11.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    while(choice!=12)\n    {\n    switch(choice)\n    {\n    case 1:printf(\"implementation \\n\");\n    create();\n    break;\n    case 2:printf(\"display\\n\");\n    display();\n    break;\n    case 3:printf(\"count the element in linked list\\n\");\n    count();\n    break;\n    case 4:printf(\"insert the element at the beginning position of linked list\\n\");\n    insert_beg();\n    break;\n    case 5:printf(\"insert the element at the last position of linked list\\n\");\n    insert_end();\n    break;\n    case 6:printf(\"insert the element at any position of linked list\\n\");\n    insert_at_pos();\n    break;\n    case 7:printf(\"delete the element at the beginning position of linked list\\n\");\n    delete_beg();\n    break;\n    case 8:printf(\"delete the element at the last position of linked list\\n\");\n    delete_end();\n    break;\n    case 9:printf(\"delete the element at any position of linked list\\n\");\n    delete_at_pos();\n    break;\n    case 10:printf(\"reverse the linked list\\n\");\n    reverse();\n    break;\n    case 11:printf(\"exit\\n\");\n    exit(0);\n    break;\n    default: printf(\"wrong choice \\n\");\n    break;\n    }\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    }\n}"}
{"author": "0712023", "file": "Basis-and-Practice-in-Programming_SKKU__5_even_out.1.c", "original_string": "int power(int x, int n){\n    if (n ==1 ){\n      return x;\n    } else if(n == 0){\n      return 1;\n    }\n    return (x*power(x,n-1));\n  }"}
{"author": "dle2005", "file": "File_Structure__read_rand.0.c", "original_string": "int main(int argc, char* argv[]) {\n    FILE *fp = fopen(argv[1], \"r\");\n    struct timeval startTime, endTime;\n    int diffTime;\n    int *read_order_list;\n    int num_of_records;\n    int i;\n    char buffer[101];\n    fseek(fp, 0, SEEK_END);\n    num_of_records = ftell(fp) / 100;\n    read_order_list = malloc(sizeof(int) * num_of_records +1);\n    GenRecordSequence(read_order_list, num_of_records);\n    gettimeofday(&startTime, NULL);\n    for(i=0; i<num_of_records; i++) {\n        fseek(fp, read_order_list[i]*100, SEEK_SET);\n        fread(buffer, sizeof(char), 100, fp);\n        memset(buffer, 0, 100);\n    }\n    gettimeofday(&endTime, NULL);\n    diffTime = (endTime.tv_usec - startTime.tv_usec) * 1000;\n    printf(\"#records: %d timecost: %d us\\n\", num_of_records, diffTime);\n    return 0;\n}"}
{"author": "ankitraj311", "file": "Socket-thread__test_thread1.1.c", "original_string": "int main()\n{\n  pthread_t thread_id;\n  printf(\"Befor Execution of Thread\\n\");\n  pthread_create(&thread_id,NULL,fun_call,NULL);\n  printf(\"Thread_id is %lu\\n\",thread_id);\n  pthread_join(thread_id,NULL);\n  printf(\"after Execution of Thread\\n\");\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__ssh_server.6.c", "original_string": "error_t sshServerLoadHostKey(SshServerContext *context, const char_t *publicKey,\n   size_t publicKeyLen, const char_t *privateKey, size_t privateKeyLen)\n{\n   error_t error;\n   if(!context->running)\n   {\n      error = sshLoadHostKey(&context->sshContext, publicKey, publicKeyLen,\n         privateKey, privateKeyLen);\n   }\n   else\n   {\n      error = ERROR_WRONG_STATE;\n   }\n   return error;\n}"}
{"author": "sdukesameer", "file": "c__tower_of_hanoi.0.c", "original_string": "int main()\n{\n    int n;\n    scanf(\"%d\", &n);                \n    printf(\"Number of disks: %d\\n\", n);\n    move(n, SRC, DEST, INTER);\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CDLL.9.c", "original_string": "void delete_at_pos()\n{\n    struct node *temp;\n    temp=head;\n    int i=1;\n    int pos;\n    int leg=count();\n    printf(\"enter the position in between the 1 to %d\\n\",leg);\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    while(i<pos)\n    {\n        temp=temp->next;\n        i++;\n    }\n    temp->pre->next=temp->next;\n    temp->next->pre=temp->pre;\n    free(temp);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.8.c", "original_string": "static bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"r\");\n  if (updateInfoFile == NULL) \n  {\n    return false;\n  }\n  memset(updateInfoString, 0, updateInfoStringSize);\n  while (isWhitespace(updateInfoString))\n  {\n    if (fgets(updateInfoString, ((int32_t) updateInfoStringSize), updateInfoFile) == NULL) \n    {\n      fclose(updateInfoFile);\n      return false;\n    }\n  }\n  fclose(updateInfoFile);\n  return true;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_04.3.c", "original_string": "int main(int argc, char* argv[])\n{\n    int num; char s;int size;\n        int* arr;\n        F1 = fopen(argv[1], \"r\");\n        F2 = fopen(argv[2], \"w\");\n        while(1)\n        {\n        fscanf(F1 ,\"%c %d\",&s, &num);\n        if(s == 'r')\n        {\n                size = num;\n                arr = read(num);\n        }\n        else if(s == 's')\n        {\n                sort(arr, size);\n        }\n        else if(s == 'd')\n        {\n                display(arr, num);\n                fprintf(F2, \"\\n\");\n        }\n        else if(s == 't')\n                return 0;\n        }\n        fclose(F1);\n        fclose(F2);\n}"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__readfile.1.c", "original_string": "void    routing(char *line)\n{\n    if (line[0] == 'R' && line[1] == ' ')\n        get_re(line);\n    else if (line[0] == 'N' && line[1] == 'O' && line[2] == ' ')\n        get_no(line);\n    else if (line[0] == 'S' && line[1] == 'O' && line[2] == ' ')\n        get_so(line);\n    else if (line[0] == 'W' && line[1] == 'E' && line[2] == ' ')\n        get_we(line);\n    else if (line[0] == 'E' && line[1] == 'A' && line[2] == ' ')\n        get_ea(line);\n    else if (line[0] == 'S' && line[1] == ' ')\n        get_s(line);\n    else if (line[0] == 'F' && line[1] == ' ')\n        get_f(line);\n    else if (line[0] == 'C' && line[1] == ' ')\n        get_c(line);\n    else if (all_params())\n        readmap(line);\n    else\n    {\n        ft_putstr(\"one or many parametres format is wrong or missing!\\n\");\n        exit(0);\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.24.c", "original_string": "void addlocalvars(SCOPE* s, VARDEC* localvars) {\n    int i = 0;\n    while(localvars != NULL) {\n        addlocalvar(s, localvars, &i);\n        localvars = localvars->next;\n    }\n}"}
{"author": "shengelenge", "file": "wp-lab3__zad13.0.c", "original_string": "long oblicz(int A[], int n)\n{\n    long w = A[0];\n    for (int i = 1; i <= n ; i++)\n    {\n        w = w*2 + A[i];\n    }\n    return w;\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__RandomizedQuickSort.4.c", "original_string": "int partition(int a[50],int p,int r)\n   {\n    int x,i,j,temp,y;\n    y=myrandom(p,r-1);\n    temp=a[y];\n    a[y]=a[r];\n    a[r]=temp;\n    x=a[r];\n    i=p-1;\n    count++;\n    for(j=p;j<=r-1;j++)\n    {\n        count++;\n        if(a[j]<=x)\n        {\n        count++;\n            i=i+1;\n        count++;\n            temp=a[j];\n        count++;\n            a[j]=a[i];\n        count++;\n            a[i]=temp;\n        count++;\n        }\n        count++;\n    }\n    count++;\n    temp =a[r];\n    count++;\n    a[r]=a[i+1];                       \n    count++;\n    a[i+1]=temp;\n    count++;\n    return i+1;\n    }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es40.0.c", "original_string": "int main(void) {\n  int dim; \n  printf(\"inserire dimensione array: \"); \n  scanf(\"%d\", &dim);\n  int a[dim];\n  int b[dim];\n  for(int i=0; i<dim; i++){\n    printf(\"a[%d] = \", i);\n    scanf(\"%d\", &a[i]);\n  }\n  printf(\"\\n\");\n  for(int i=0; i<dim; i++){\n    printf(\"b[%d] = \", i);\n    scanf(\"%d\", &b[i]);\n  }\n  printf(\"\\n\");\n  int c[dim];\n  for(int i=0; i<=dim-1; i++) {\n    c[i] = a[i] + b[i];\n  }\n  for(int i=0; i<dim; i++){\n    printf(\"%d \", c[i]);\n  }\n  printf(\"\\n\");\n  for(int i=0; i<dim; i++){\n    c[i] = a[i] * b[i];\n    printf(\"%d \", c[i]);\n  }\n  printf(\"\\n\");\n  for(int i=0; i<dim; i++){\n    if(a[i]<=b[i]) {\n      c[i] = b[i];\n    }\n    else {\n      c[i] = a[i];\n    }\n    printf(\"%d \", c[i]); \n  }\n  printf(\"\\n\");\n  int max, min;\n  float media; \n  max = c[0];\n  min = c[0];\n  media = c[0];\n  for(int i=1; i<dim; i++) {\n    if(c[i]>max){\n      max = c[i];\n    }\n    if(c[i]<min){\n      min = c[i];\n    }\n    media += c[i];\n  }\n  printf(\"\\nMax in c: %d\\n\", max);\n  printf(\"\\nMin in c: %d\\n\", min);\n  media = media/dim; \n  printf(\"\\nMedia elementi di c: %lf\\n\", media);\n  return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q1_doublylq.2.c", "original_string": "void inserten(nptr* start,nptr* end,int x)\n{\n    nptr temp=createNode(x);\n    if(!*end)\n    {\n        *start=temp; *end=temp; \n        return;\n    }\n    else\n    {\n        (*end)->rlink=temp;\n        temp->llink=*end;\n        *end=temp;\n    }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__OC.3.c", "original_string": "void search(int key,int value)\n{\n    int index=H(key);\n    int ct=0;\n    if(HASH[index]!=NULL)\n    {\n        temp=HASH[index];\n        while(temp->next!=NULL)\n        {\n            if(temp->val==value)\n            {\n                printf(\"\\nValue found\");\n                ct++;\n            }\n            temp=temp->next;\n        }\n        if(temp->val==value)\n        {\n            printf(\"\\nValue found\");\n            ct++;\n        }\n        if(ct==0)\n        printf(\"\\nValue not found\");\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__singlyLL.4.c", "original_string": "void insertRear(nptr &head, int ele)\n{\n    if (head == NULL)\n    {\n        head = createNode(ele);\n        return;\n    }\n    nptr rear = head;\n    while(rear -> next != NULL)\n        rear = rear -> next;\n    nptr temp = createNode(ele);\n    rear -> next = temp;\n}"}
{"author": "2security", "file": "Array__Transpose.0.c", "original_string": "int main()\n    {\n    int i,j,r,c,**mat1,**mat2;\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    mat1=(int **)malloc(r*sizeof(int *));   \n    mat2=(int **)malloc(r*sizeof(int *));                                   \n    for(i=0;i<r;i++)\n        mat1[i]=(int *)malloc(c*sizeof(int ));\n    for(i=0;i<r;i++)\n        mat2[i]=(int *)malloc(c*sizeof(int ));\n    printf(\"\\n Enter the matrix \\n\");\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)                \n    scanf(\"%d\",&mat1[i][j]);\n    Transpose(mat1,mat2,r,c);\n    printf(\"Transpose of the matrix is:\\n\");\n    displayMat(mat2,r,c);\n    return 0;\n    }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__ft_prime_sum.3.c", "original_string": "int     ft_is_prime(int nb)\n{\n    int i;\n    i = 2;\n    while (i < nb)\n    {\n        if (nb % i == 0)\n            return (0);\n        i++;\n    }\n    return (1);\n}"}
{"author": "theuwis", "file": "AdventOfCode2015__main23.0.c", "original_string": "int main(){\n   memcpy(temp, data, sizeof(data));\n   for(int time = 0; time < TOTAL_TIME; time++){\n      for(int reindeer = 0; reindeer < 9; reindeer++){\n         if(temp[reindeer][1] > 0){\n            distances[reindeer] += data[reindeer][0];\n            temp[reindeer][1]--;\n         }\n         else if(temp[reindeer][1] == 0){\n            temp[reindeer][2]--;\n            if(temp[reindeer][2] == 0){\n               temp[reindeer][1] = data[reindeer][1];\n               temp[reindeer][2] = data[reindeer][2];\n            }\n         }\n      }\n      longest_distance = 0;\n      for(int reindeer = 0; reindeer < 9; reindeer++){\n         if(distances[reindeer] > longest_distance){\n            longest_distance = distances[reindeer];\n         }\n      }\n      for(int reindeer = 0; reindeer < 9; reindeer++){\n         if(distances[reindeer] == longest_distance){\n            points[reindeer]++;\n         }\n      }\n   }\n   int most_points = 0;\n   for(int reindeer = 0; reindeer < 9; reindeer++){\n      if(points[reindeer] > most_points){\n         most_points = points[reindeer];\n      }\n   }\n   printf(\"winner=%d\\n\", most_points);\n   return 0;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__arreglo_uni_dinamico.0.c", "original_string": "int main(){\n    int *calorias = NULL;\n    int tamanno;\n    printf(\"Ingresa cantidad de d\u00edas en que se registrar\u00e1n las calor\u00edas:\");\n    scanf(\"%d\", &tamanno);\n    calorias = (int *) malloc (tamanno * sizeof(int));\n    if (calorias != NULL){\n       leer_calorias(calorias, tamanno);\n       printf(\"El promedio de calor\u00edas consumidas en %d d\u00edas fue %.2f\\n\"\n        , tamanno\n        , promedio_calorias(calorias, tamanno));\n        free(calorias);\n    } else {\n        printf(\"No se pudo reservar la memoria\\n\");\n    }\n    return 0;\n}"}
{"author": "254Odeke", "file": "Operating-Systems_Lab__Deadlock_Prevention_with_Known_Required_Resourses_Simulation.1.c", "original_string": "void input()\n{\nint i,j;\nprintf(\"Enter the no of Processes\\t\");\nscanf(\"%d\",&n);\nprintf(\"Enter the no of resource instances\\t\");\nscanf(\"%d\",&r);\nprintf(\"Enter the Max Matrix\\n\");\nfor(i=0;i<n;i++)\n{\nfor(j=0;j<r;j++)\n{\nscanf(\"%d\",&max[i][j]);\n}\n}\n printf(\"Enter the Allocation Matrix\\n\");\n for(i=0;i<n;i++)\n {\nfor(j=0;j<r;j++)\n{\nscanf(\"%d\",&alloc[i][j]);\n}\n }\n printf(\"Enter the available Resources\\n\");\n for(j=0;j<r;j++)\n {\n scanf(\"%d\",&avail[j]);\n }\n46;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__count_the_elem_in_CLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__DD.1.c", "original_string": "void main()\n{\n    int i,j,s;\n    printf(\"\\nEnter the available resources  : \");\n    for(i=0;i<m;i++)\n        scanf(\"%d\",&available[i]);\n    printf(\"\\nEnter allocation : \");    \n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nfor process %d : \",i);\n        for(j=0;j<m;j++)\n        {\n            scanf(\"%d\",&allocation[i][j]);\n        }\n    }\n    printf(\"\\nEnter request : \\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nfor process %d : \",i);\n        for(j=0;j<m;j++)\n        {\n            scanf(\"%d\",&request[i][j]);\n        }\n    }\n    s=safety_module();\n    if(s==1)\n        printf(\"No Deadlock\");\n    else\n        printf(\"\\nDeadlock\");\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__rpn_calc.4.c", "original_string": "int     main(int ac, char **av)\n{\n    int stack[512];\n    if (ac == 2)\n        rpn_calc(av[1], stack);\n    else\n        write(1, \"Error\\n\", 6);\n    return (0);\n}"}
{"author": "sahadipanjan6", "file": "Programs-in-C__P1.1.c", "original_string": "int factorial(int number)\n{\n    int copy=number;\n    int i=0;\n    int fact=1;\n    for(i=1; i<=copy; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;\n}"}
{"author": "dle2005", "file": "File_Structure__heapsort.4.c", "original_string": "void writePage(FILE *fp, const char *pagebuf, int pagenum) {\n    fseek(fp, PAGE_SIZE * pagenum, SEEK_SET);\n    fwrite(pagebuf, sizeof(char), PAGE_SIZE, fp);\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-structure.8.c", "original_string": "SUBROUTDEC* parsesubroutdec(PARSER* p, CLASS* c) {\n    SUBROUTCLASS subroutclass = parsesubroutclass(p);\n    if(subroutclass == -1)\n        return NULL;\n    next(p);\n    SUBROUTDEC* subroutdec = (SUBROUTDEC*)malloc(sizeof(SUBROUTDEC));\n    subroutdec->subroutclass = subroutclass;\n    if(differs(p, \"void\"))\n        subroutdec->type = parsetype(p);\n    else {\n        subroutdec->type = p->current->token;\n        next(p);\n    }\n    subroutdec->debug = getdebug(p);\n    subroutdec->name = parseidentifier(p);\n    checkcontent(p, \"(\");\n    subroutdec->parameters = parseparameters(p);\n    checkcontent(p, \")\");\n    checkcontent(p, \"{\");\n    subroutdec->body = parsesubroutbody(p);\n    checkcontent(p, \"}\");\n    subroutdec->class = c;\n    return subroutdec;\n}"}
{"author": "revathy16296", "file": "rtos_lab_asssignment_1__6_dates.0.c", "original_string": "int main()\n{\n    date d1,d2;\n    printf(\"enter the date 1 in format DD-MM-YYYY:\\t\");\n    scanf(\"%d-%d-%d\",&d1.day,&d1.month,&d1.year);\n    printf(\"enter the date 2 in format DD-MM-YYYY:\\t\");\n    scanf(\"%d-%d-%d\",&d2.day,&d2.month,&d2.year);\n    comp_dat(d1,d2);\n    return 0;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__enter_value_to_node.0.c", "original_string": "void createList(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int data, i;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter node data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n; i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter node data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=temp->next;\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__pthread_shared_mutex.1.c", "original_string": "int main()\n{\n    srand(time(NULL));\n    pthread_t tid;\n    int ret = pthread_mutex_init(&mutex, NULL);     \n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_mutex_init error:%s\\n\", strerror(ret));\n        exit(1);\n    }\n    pthread_create(&tid, NULL, fun, NULL);\n    while (1)\n    {\n        pthread_mutex_lock(&mutex);     \n        printf(\"HELLO \");\n        sleep(rand()%3);\n        printf(\"WORLD\\n\");\n        pthread_mutex_unlock(&mutex);   \n        sleep(rand()%3);\n    }\n    pthread_join(tid, NULL);\n    pthread_mutex_destroy(&mutex);      \n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__poly.0.c", "original_string": "nptr createNode(int c, int e)\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp -> coeff = c;\n    temp -> exp = e;\n    temp -> next = NULL;\n    return temp;\n}"}
{"author": "haon1026", "file": "linux-programming__pthread_shared.0.c", "original_string": "void *fun(void *arg)\n{\n    srand(time(NULL));\n    while (1)\n    {\n        printf(\"hello \");\n        sleep(rand()%3);    \n        printf(\"world\\n\");\n        sleep(rand()%3);\n    }\n    return NULL;\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__single_link_list.0.c", "original_string": "void insert_node(int data,char *ptr3)\n{\n    struct node *ptr = (struct node *)malloc(sizeof(struct node));\n    ptr->regno = data;\n    ptr->name = ptr3;\n    ptr->next = head;\n    head = ptr;\n    i++;\n}"}
{"author": "dle2005", "file": "Algorithm__Sum_of_Subsets_v2.1.c", "original_string": "void sum_of_subsets(int i, int weight, int total) {\n    printf(\"total: %d\\n\", total);\n    for(int j = 1; j <= i; j++)\n        printf(\"%d \", include[j]);\n    if(promising(i, weight, total)) {\n        if(weight == W) {\n            for(int j = 1; j <= i; j++)\n                save[i] = include[i];\n        }\n        else {\n            include[i+1] = 1;\n            sum_of_subsets(i+1, weight + w[i+1], total - w[i+1]);\n            include[i+1] = 0;\n            sum_of_subsets(i+1, weight, total - w[i+1]);\n        }\n    }\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Insertion_Sort.1.c", "original_string": "void display(int array[MAX], int length)\n{\n    int i = 0;\n    for(i=0; i<length; i++)\n        printf(\"%d\\t\", array[i]);\n    printf(\"\\n\");\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__BinHexConverter0.4.c", "original_string": "size_t convertBinDataToHexString8(uint8_t *inputData, size_t inputDataSize, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < inputDataSize * 2) \n  {\n    return 0;\n  }\n  outputStr[0] = '\\0';\n  size_t count = 0;\n  for ( size_t i = 0 ; i < inputDataSize; i++ )\n  {\n    count += convertBinValueToHexString8(inputData[i], outputStr + 2 * i, outputStrSize - count, upperCase);\n  }\n  if (outputStrSize > count) \n  {\n    outputStr[count++] = '\\0';\n  }\n  return count;\n}"}
{"author": "flora0110", "file": "hw01git__2-1tqueue.8.c", "original_string": "int bfs(char*** maze,int*** d,int sr,int sc,int sh){\n    int laststep=0;\n    int arrive=0;\n    element position;\n    position.row = sr;\n    position.col = sc;\n    position.hei = sh;\n    addq(position);\n    int i,j,k,q;\n    for(i=0;i<n/2+1;i++){\n        for(j=0;j<n+2;j++){\n            for(k=0;k<n+2;k++){\n                d[i][j][k]=MAX;\n            }\n        }\n    }\n    d[sh][sr][sc]=0;\n    int nr,nc,nh;\n    int row,col,hei;\n    while(rear!=front){\n        position = deleteq();\n        row = position.row;\n        col = position.col;\n        hei = position.hei;\n        if(laststep!=d[hei][row][col] ){\n            if(front2!=rear2){\n                for(i=front2+1;i<=rear2;i++){\n                    if(queue2[i].flag!=0){\n                        if((queue2[i].flag-d[hei][row][col]+laststep)>=0){\n                            queue2[i].flag-=(d[hei][row][col]-laststep);\n                        }\n                        else queue2[i].flag=0;\n                    }\n                    if(queue2[i].flag==0){\n                        addq(queue2[i].t);\n                        deleteq2();\n                        nr = queue2[i].t.row;\n                        nc = queue2[i].t.col;\n                        nh = queue2[i].t.hei;\n                        d[nh][nr][nc]=d[hei][row][col]+1;\n                    }\n                }\n            }\n            laststep=d[hei][row][col];\n        }\n        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='D'){\n            int upanddown=-1;\n            if(maze[hei][row][col]=='U'){\n                upanddown=1;\n            }\n            nr = row;\n            nc = col;\n            nh = hei+upanddown;\n            if(nh>=0){\n                if(maze[nh][nr][nc]=='F'){\n                    d[nh][nr][nc]=d[hei][row][col]+1;\n                    if(min>d[nh][nr][nc]){\n                        min = d[nh][nr][nc];\n                    }\n                    return 1;\n                }\n                if(maze[nh][nr][nc]=='T'&& d[nh][nr][nc]==MAX){\n                    d[nh][nr][nc]=-1;\n                    element nextposition;\n                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                        tpoint Tpoint;\n                        Tpoint.t=nextposition;\n                        Tpoint.flag=2;\n                        addq2(Tpoint);\n                        int r = queue2[front2].t.row;\n                        int c = queue2[front2].t.col;\n                        int h = queue2[front2].t.hei;\n                }\n                else if (maze[nh][nr][nc]!='X'  && d[nh][nr][nc]==MAX){\n                    d[nh][nr][nc]=d[hei][row][col]+1;\n                    element nextposition;\n                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                    addq(nextposition);\n                }\n            }\n        }\n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            nh = hei+move[i].hei;\n            if(maze[nh][nr][nc]=='T'&& d[nh][nr][nc]==MAX){\n                d[nh][nr][nc]=-1;\n                element nextposition;\n                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                    tpoint Tpoint;\n                    Tpoint.t=nextposition;\n                    Tpoint.flag=2;\n                    addq2(Tpoint);\n                    int r = queue2[rear2].t.row;\n                    int c = queue2[rear2].t.col;\n                    int h = queue2[rear2].t.hei;\n            }\n            else if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]==MAX){\n                d[nh][nr][nc]=d[hei][row][col]+1;\n                element nextposition;\n                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                addq(nextposition);\n            }\n        }\n        if(rear==front){\n            int lastflag=queue2[front2+1].flag;\n            for(i=front2+1;i<=rear2;i++){\n                if(queue2[i].flag==lastflag){\n                    addq(queue2[i].t);\n                    deleteq2();\n                    nr = queue2[i].t.row;\n                    nc = queue2[i].t.col;\n                    nh = queue2[i].t.hei;\n                    d[nh][nr][nc]=d[hei][row][col]+3;\n                }\n                else{\n                    queue2[i].flag-=lastflag;\n                }\n            }\n            laststep=lastflag;\n        }\n    }\n    return arrive;\n}"}
{"author": "Dhruvik-Chevli", "file": "PPLab__q3.0.c", "original_string": "int main(int argc, char* argv[])\n{\n    int rank,size;\n    int res;\n    int s;\n    MPI_Init(&argc,&argv);\n    MPI_Comm_size(MPI_COMM_WORLD,&size);\n    MPI_Comm_rank(MPI_COMM_WORLD,&rank);\n    char st[100];\n    char* c=(char*)malloc(sizeof(char)*100);\n    int* b=(int*)malloc(size*sizeof(int));\n    if(rank==0)\n    {\n        scanf(\"%s\",st);\n        int k=strlen(st);\n        if(k%size!=0)\n        {\n            printf(\"String length should be divisible by the number of processes.\");\n            return 0;\n        }\n        s=k/size;\n    }\n    MPI_Bcast(&s,1,MPI_INT,0,MPI_COMM_WORLD);\n    MPI_Scatter(st,s,MPI_CHAR,c,s,MPI_CHAR,0,MPI_COMM_WORLD);\n    res=0;\n    for(int i=0;i<s;i++)\n    {\n        if(c[i]=='a'||c[i]=='e'||c[i]=='i'||c[i]=='o'||c[i]=='u')\n            continue;\n        res+=1;\n    }\n    MPI_Gather(&res,1,MPI_INT,b,1,MPI_INT,0,MPI_COMM_WORLD);\n    if(rank==0)\n    {\n        res=0;\n        for(int i=0;i<size;i++)\n        {\n            res+=b[i];\n        }\n        printf(\"The total number of non vowels is:%d\\n\",res);\n    }   \n    MPI_Finalize();\n}"}
{"author": "jose120918", "file": "binary_trees__102-binary_tree_is_complete.2.c", "original_string": "int binary_tree_is_complete(const binary_tree_t *tree)\n{\n    int nodes, pos = 0;\n    if (tree != NULL)\n    {\n        nodes = tree_size(tree);\n        return (is_complete((binary_tree_t *)tree, pos, nodes));\n    }\n    return (0);\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__patternmatch.1.c", "original_string": "void main()\n{\n    int n,m,i;\n    char S[100],P[100];\n    printf(\"\\nEnter String:\");\n    gets(S);\n    printf(\"\\nEnter Pattern:\");\n    gets(P);\n    n=strlen(S);\n    m=strlen(P);\n    Brute_Force(S,P,n,m);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__merg_sort.1.c", "original_string": "void mergesort(int a[],int l,int r)\n{\n    int mid;\n    if(l<r)\n    {\n        mid=(l+r)/2;\n        mergesort(a,l,mid);\n        mergesort(a,mid+1,r);\n        merge(a,l,mid,r);\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__CA.0.c", "original_string": "int main()\n{\n    double A[100][100], B[100][100], soma = 0;\n    int n, m, k, l;\n    scanf(\"%i %i %i %i\", &n, &m, &k, &l);\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            scanf(\"%lf\", &A[i][j]);\n        }\n    }\n    for (int i = 0; i < k; i++)\n    {\n        for (int j = 0; j < l; j++)\n        {\n            scanf(\"%lf\", &B[i][j]);\n        }\n    }\n    if (m != k)\n    {\n        printf(\"impossivel\\n\");\n        return 0;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < l; j++)\n        {\n            for (int a = 0; a < m; a++)\n            {\n                soma += A[i][a] * B[a][j];\n            }\n            printf(\"%.2lf \", soma);\n            soma = 0;\n        }\n        putchar('\\n');\n    }\n    return 0;\n}"}
{"author": "tadeograch", "file": "sorting_algorithms__105-radix_sort.0.c", "original_string": "void radix_sort(int *array, size_t size)\n{\n    int digits = 0, i, j, max_num = 0, start = 0, len, at_index = 0, div = 10, temp, a;\n    int *arr_aux;\n    int *arr_aux2;\n    len = (int)size;\n    arr_aux = malloc(sizeof(int) * size);\n    arr_aux2 = malloc(sizeof(int) * size);\n    arr_cpy(array, arr_aux2, len);\n    for(i = 0; i < len; i++)\n    {\n        if(array[i] > max_num)\n            max_num = array[i];\n    }\n    while(max_num > 0)\n    {\n        max_num = max_num / 10;\n        digits++;\n    }\n    while(digits >= 0)\n    {\n        for(a = 0; a < len; a++)\n        {\n            if(arr_aux2[a] != 0)\n                arr_aux[a] = arr_aux2[a] % 10;\n            else\n                arr_aux[a] = arr_aux2[a];\n        }\n        print_array(arr_aux, size);\n        for(start = 0; start < len; start++)\n        {\n            at_index = get_index_lower(arr_aux, start, len);\n            printf(\"index: %d\\n\", at_index);\n            temp = array[start];\n            array[start] = array[at_index];\n            array[at_index] = temp;\n        }\n        print_array(arr_aux2, size);\n        for(j = 1; j < len; j++)\n        {\n            arr_aux2[i] = arr_aux2[i] / div; \n        }\n        div = div * 10;\n        digits--;\n    }\n}"}
{"author": "Theemiss", "file": "simple_shell___strtok.1.c", "original_string": "char *_strtok(char *str, const char *delim)\n{\n    static char *ts;\n    static char *nt;\n    unsigned int i;\n    if (str != NULL)\n        nt = str;\n    ts = nt;\n    if (ts == NULL)\n        return (NULL);\n    for (i = 0; ts[i] != '\\0'; i++)\n    {\n        if (check_delim(ts[i], delim) == 0)\n            break;\n    }\n    if (nt[i] == '\\0' || nt[i] == '#')\n    {\n        nt = NULL;\n        return (NULL);\n    }\n    ts = nt + i;\n    nt = ts;\n    for (i = 0; nt[i] != '\\0'; i++)\n    {\n        if (check_delim(nt[i], delim) == 1)\n            break;\n    }\n    if (nt[i] == '\\0')\n        nt = NULL;\n    else\n    {\n        nt[i] = '\\0';\n        nt = nt + i + 1;\n        if (*nt == '\\0')\n            nt = NULL;\n    }\n    return (ts);\n}"}
{"author": "2security", "file": "If-else__MonthToDay.0.c", "original_string": "int main()\n    {\n    int mno;\n    printf(\"Enter the month number\");\n    scanf(\"%d\",&mno);\n    if(mno==1)\n        printf(\"\\n January months 31 days\\n\");\n    else if(mno==2) \n        printf(\"\\n February month 28 or 29 days\\n\");\n    else if(mno==3) \n        printf(\"\\n March month 31 days\\n\");     \n    else if(mno==4) \n        printf(\"\\n April month 30 days\\n\");\n    else if(mno==5) \n        printf(\"\\n May month 31 days\\n\");   \n    else if(mno==6) \n        printf(\"\\n June month 30 days\\n\");\n    else if(mno==7) \n        printf(\"\\n July month 31 days\\n\");  \n    else if(mno==8) \n        printf(\"\\n August month 31 days\\n\");\n    else if(mno==9) \n        printf(\"\\n September month 30 days\\n\");     \n    else if(mno==10) \n        printf(\"\\n October month 31 days\\n\");\n    else if(mno==11) \n        printf(\"\\n November month 30 days\\n\");      \n    else if(mno==12) \n        printf(\"\\n December month 31 days\\n\");\n    else\n        printf(\"\\n OOPS!! Enter corrent month number\\n\");\n    return 0;\n    }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__biggest_pal.1.c", "original_string": "void        ft_putstr(char *str)\n{\n    int i = 0;\n    while (str[i] != '\\0')\n    {\n        write(1, &str[i], 1);\n        i++;\n    }\n}"}
{"author": "dle2005", "file": "Algorithm__Floyd_v2.1.c", "original_string": "void path(int q, int r, int **P) {\n    if(P[q][r] != 0) { \n        path(q, P[q][r], P); \n        printf(\"v%d -> \", P[q][r]);\n        path(P[q][r], r, P);\n    }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_11.6.c", "original_string": "int Prec(char ch) \n{ \n    switch (ch) \n    { \n    case '+': \n    case '-': \n        return 1; \n    case '*': \n    case '/': \n        return 2; \n    case '^': \n        return 3; \n    } \n    return -1; \n}"}
{"author": "augustogunsch", "file": "jackc__tokenizer.9.c", "original_string": "bool isint(char* str) {\n    int i = 0;\n    while(str[i] != '\\0') {\n        if(!isdigit(str[i]))\n            return false;\n        i++;\n    }\n    return true;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__selection_sort.0.c", "original_string": "void selection(int a[],int n)\n{\n    int p,j,min,temp;\n    for(p=0;p<n-1;p++)\n    {\n        min=p;\n        for(j=p+1;j<n;j++)\n        {\n            if(a[j]<a[min])\n            {\n                min=j;\n            }\n        }\n        if(min!=p)\n        {\n            temp=a[p];\n            a[p]=a[min];\n            a[min]=temp;\n        }\n    }\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__goal_server.1.c", "original_string": "void str_trim_lf (char* arr, int length) {\n  int i;\n  for (i = 0; i < length; i++) { \n    if (arr[i] == '\\n') {\n      arr[i] = '\\0';\n      break;\n    }\n  }\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.17.c", "original_string": "void addvar(SCOPE* s, VAR** dest, VAR* v) {\n    ensurenoduplicate(s, v->debug, v->name);\n    if(!v->primitive) {\n        CLASS* type = getclass(s, v->type);\n        if(type == NULL)\n            notdeclared(v->type, v->debug);\n    }\n    v->next = *dest;\n    *dest = v;\n}"}
{"author": "andi-s0106", "file": "sorting_algorithms__3-quick_sort.0.c", "original_string": "int partition(int *array, int lo, int hi, size_t size)\n{\n    int i, j, pivot, tmp;\n    pivot = array[hi];\n    i = lo;\n    j = lo;\n    while (j < hi)\n    {\n        if (array[j] <= pivot)\n        {\n            if (i != j)\n            {\n                tmp = array[i];\n                array[i] = array[j];\n                array[j] = tmp;\n                print_array(array, size);\n            }\n            i++;\n        }\n        j++;\n    }\n    if (i != hi)\n    {\n        tmp = array[i];\n        array[i] = array[hi];\n        array[hi] = tmp;\n        print_array(array, size);\n    }\n    return (i);\n}"}
{"author": "qtgeo1248", "file": "ProjectEuler__ans4.3.c", "original_string": "int main() {\n    size_t max_palin = 0;\n    for (size_t i = 100; i < 1000; i++)\n        for (size_t j = i; j < 1000; j++)\n            if (is_palin(i * j, num_digits(i * j)) && i * j > max_palin)\n                max_palin = i * j;\n    printf(\"Answer: %zu\\n\", max_palin);\n    return 0;\n}"}
{"author": "Theemiss", "file": "binary_trees__binary_tree_print.0.c", "original_string": "static int print_t(const binary_tree_t *tree, int offset, int depth, char **s)\n{\n    char b[6];\n    int width, left, right, is_left, i;\n    if (!tree)\n        return (0);\n    is_left = (tree->parent && tree->parent->left == tree);\n    width = sprintf(b, \"(%03d)\", tree->n);\n    left = print_t(tree->left, offset, depth + 1, s);\n    right = print_t(tree->right, offset + left + width, depth + 1, s);\n    for (i = 0; i < width; i++)\n        s[depth][offset + left + i] = b[i];\n    if (depth && is_left)\n    {\n        for (i = 0; i < width + right; i++)\n            s[depth - 1][offset + left + width / 2 + i] = '-';\n        s[depth - 1][offset + left + width / 2] = '.';\n    }\n    else if (depth && !is_left)\n    {\n        for (i = 0; i < left + width; i++)\n            s[depth - 1][offset - width / 2 + i] = '-';\n        s[depth - 1][offset + left + width / 2] = '.';\n    }\n    return (left + width + right);\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise21.1.c", "original_string": "int main(void) {\n    int count;\n    int n1 = 5,n2=10;\n    int *ptr;\n    int arr_size_used = 0;\n    ptr = PrintReverseInclusive(n1,n2,&arr_size_used);\n    printf(\"Output Array = \");\n    for(count=0;count<arr_size_used;count++)\n    {\n        printf(\"%d \",ptr[count]);\n    }\n    printf(\"\\nOutput Array Size = %d\",arr_size_used);\n    return 0;\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-3test.2.c", "original_string": "int*** make3darrint(int rows, int cols,int hei){\n    int ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__carro.0.c", "original_string": "void circulo()\n{\n  int i;\n  float angulo = 0.0;\n  glBegin(GL_POLYGON);\n  for (i = 0; i <= 8; i++)\n  {\n    angulo = 2 * M_PI * i / 8;\n    glVertex2f(0.125 * cos(angulo), 0.125 * sin(angulo));\n  }\n  glEnd();\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ili9341_ext.4.c", "original_string": "static void command_list(void)\n{\n    write_command(ILI9341_SWRESET);\n    nrf_delay_ms(120);\n    write_command(ILI9341_DISPOFF);\n    nrf_delay_ms(120);\n    write_command(ILI9341_PWCTRB);\n    write_data(0x00);\n    write_data(0XC1);\n    write_data(0X30);\n    write_command(ILI9341_TIMCTRA);\n    write_data(0x85);\n    write_data(0x00);\n    write_data(0x78);\n    write_command(ILI9341_PWCTRSEQ);\n    write_data(0x39);\n    write_data(0x2C);\n    write_data(0x00);\n    write_data(0x34);\n    write_data(0x02);\n    write_command(ILI9341_PUMP);\n    write_data(0x20);\n    write_command(ILI9341_TIMCTRB);\n    write_data(0x00);\n    write_data(0x00);\n    write_command(ILI9341_PWCTR1);\n    write_data(0x23);\n    write_command(ILI9341_PWCTR2);\n    write_data(0x10);\n    write_command(ILI9341_VMCTR1);\n    write_data(0x3e);\n    write_data(0x28);\n    write_command(ILI9341_VMCTR2);\n    write_data(0x86);\n    write_command(ILI9341_MADCTL);\n    write_data(0x48);\n    write_command(ILI9341_PIXFMT);\n    write_data(0x55);\n    write_command(ILI9341_FRMCTR1);\n    write_data(0x00);\n    write_data(0x18);\n    write_command(ILI9341_DFUNCTR);\n    write_data(0x08);\n    write_data(0x82);\n    write_data(0x27);\n    write_command(ILI9341_ENGMCTR);\n    write_data(0x00);\n    write_command(ILI9341_GAMMASET);\n    write_data(0x01);\n    write_command(ILI9341_GMCTRP1);\n    write_data(0x0F);\n    write_data(0x31);\n    write_data(0x2B);\n    write_data(0x0C);\n    write_data(0x0E);\n    write_data(0x08);\n    write_data(0x4E);\n    write_data(0xF1);\n    write_data(0x37);\n    write_data(0x07);\n    write_data(0x10);\n    write_data(0x03);\n    write_data(0x0E);\n    write_data(0x09);\n    write_data(0x00);\n    write_command(ILI9341_GMCTRN1);\n    write_data(0x00);\n    write_data(0x0E);\n    write_data(0x14);\n    write_data(0x03);\n    write_data(0x11);\n    write_data(0x07);\n    write_data(0x31);\n    write_data(0xC1);\n    write_data(0x48);\n    write_data(0x08);\n    write_data(0x0F);\n    write_data(0x0C);\n    write_data(0x31);\n    write_data(0x36);\n    write_data(0x0F);\n    write_command(ILI9341_SLPOUT);\n    nrf_delay_ms(120);\n    write_command(ILI9341_DISPON);\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_posix.12.c", "original_string": "bool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   int_t ret;\n   struct timespec ts;\n   if(timeout == 0)\n   {\n      ret = sem_trywait(event);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      ret = sem_wait(event);\n   }\n   else\n   {\n      clock_gettime(CLOCK_REALTIME, &ts);\n      ts.tv_sec += timeout / 1000;\n      ts.tv_nsec += (timeout % 1000) * 1000000;\n      if(ts.tv_nsec >= 1000000000)\n      {\n         ts.tv_sec += 1;\n         ts.tv_nsec -= 1000000000;\n      }\n      ret = sem_timedwait(event, &ts);\n   }\n   if(ret == 0)\n   {\n      do\n      {\n         ret = sem_trywait(event);\n      } while(ret == 0);\n      return TRUE;\n   }\n   else\n   {\n      return FALSE;\n   }\n}"}
{"author": "jose120918", "file": "binary_trees__18-binary_tree_uncle.0.c", "original_string": "binary_tree_t *brother(binary_tree_t *node)\n{\n    binary_tree_t *parent = NULL;\n    if (node == NULL)\n    {\n        return (NULL);\n    }\n    if ((*node).parent == NULL)\n    {\n        return (NULL);\n    }\n    parent = (*node).parent;\n    if ((*parent).left != NULL && (*parent).right != NULL)\n    {\n        if (node == (*parent).left)\n            return ((*parent).right);\n        return ((*parent).left);\n    }\n    return (NULL);\n}"}
{"author": "augustogunsch", "file": "jackc__util.6.c", "original_string": "STRINGLIST* onestr(const char* str) {\n    STRINGLIST* strlist = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n    strlist->content = ezheapstr(str);\n    strlist->next = NULL;\n    return strlist;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_c_extended.0.c", "original_string": "static void tx_buffer_process(void)\n{\n    if (m_tx_index != m_tx_insert_index)\n    {\n        uint32_t err_code;\n        if (m_tx_buffer[m_tx_index].type == READ_REQ)\n        {\n            err_code = sd_ble_gattc_read(m_tx_buffer[m_tx_index].conn_handle,\n                                         m_tx_buffer[m_tx_index].req.read_handle,\n                                         0);\n        }\n        else\n        {\n            err_code = sd_ble_gattc_write(m_tx_buffer[m_tx_index].conn_handle,\n                                          &m_tx_buffer[m_tx_index].req.write_req.gattc_params);\n        }\n        if (err_code == NRF_SUCCESS)\n        {\n            NRF_LOG_DEBUG(\"SD Read/Write API returns Success..\");\n            m_tx_index++;\n            m_tx_index &= TX_BUFFER_MASK;\n        }\n        else\n        {\n            NRF_LOG_DEBUG(\"SD Read/Write API returns error. This message sending will be \"\n                \"attempted again..\");\n        }\n    }\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_cortex.10.c", "original_string": "void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)\n{\n  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));\n  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__tree.1.c", "original_string": "void add_element(void) \n{\n    struct database * current_node = root;\n    struct database * temp_ptr = (struct database* )malloc (sizeof(struct database ));\n    printf(\"Enter the value:\");\n    scanf(\"%d\",&temp_ptr->roll_no);\n    temp_ptr->left = NULL;\n    temp_ptr->right = NULL;\n    if(root == NULL){\n        root = temp_ptr;\n    } else {\n        while (current_node != NULL) {\n            if(temp_ptr->roll_no > current_node->roll_no){\n                if (current_node->right !=NULL){\n                    current_node = current_node ->right;\n                } else {\n                    current_node->right = temp_ptr;\n                    return;\n                }\n            }else {\n                if(current_node->left !=NULL){\n                    current_node = current_node->left;\n                }else {\n                    current_node->left = temp_ptr;\n                    return;\n                }\n            }\n        }\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc.4.c", "original_string": "void rec_preorder(node* root) \n{ \n    if (root != NULL) \n    {\n        printf(\"\\t%d\\n\", root->data); \n        rec_preorder(root->left);\n        rec_preorder(root->right);\n    } \n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__routing2.1.c", "original_string": "int     array_is_rgb(char **colors)\n{\n    int i;\n    i = 0;\n    while (colors[i])\n    {\n        if (str_is_digits(colors[i]))\n        {\n            if (!(atoi(colors[i]) <= 255) || !(atoi(colors[i]) >= 0))\n            {\n                ft_putstr(\"Error\\n Wrong colors parametres!\");\n                exit(0);\n            }\n        }\n        else\n            return (0);\n        i++;\n    }\n    return (1);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__Main.0.c", "original_string": "int32_t main(int32_t argc, char *argv[])\n{\n  char *programDir = dirname(strdup(argv[0]));\n  chdir(programDir);\n  firmwareUpdateInfoReader_init();\n  fotaUpdateWorkflow_init();\n  fotaUpdateSelfTest_init();\n  fotahub_init(argv[0], DEMO_PRODUCT_ID, DEMO_PRODUCT_NAME, &FOTA_UPDATE_CLIENT_CONFIG);\n  printf(\"\\n--------------------------------------------------------------------------\\n\");\n  printf(\"Running %s %s firmware\\n\", DEMO_PRODUCT_NAME, DEMO_PRODUCT_FIRMWARE_VERSION);\n  printf(\"--------------------------------------------------------------------------\\n\\n\");\n  fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);\n  char *separator = (strlen(programDir) > 0) ? (\"/\") : (\"\");\n  printf(\"Waiting for firmware update info (<new-version>:<checksum-or-signature>) to be entered and saved in '%s%s%s' file\\n\", programDir, separator, DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n  while (true)\n  {\n    firmwareUpdateInfoReader_run();\n    fotahub_run();\n  }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__stp_conditions.1.c", "original_string": "bool_t stpDesignatedBridge(StpBridgeContext *context)\n{\n   uint_t i;\n   bool_t res;\n   StpBridgePort *port;\n   res = FALSE;\n   for(i = 0; i < context->numPorts; i++)\n   {\n      port = &context->ports[i];\n      if(stpCompareBridgeId(&port->designatedBridge, &context->bridgeId) == 0)\n      {\n         res = TRUE;\n      }\n   }\n   return res;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.6.c", "original_string": "TERM* parsekeyword(PARSER* p) {\n    TERM* t = mkterm(keywordconstant);\n    if(!existsinarray(&keywordconstants, p->current->token))\n        unexpected(p);\n    t->string = p->current->token;\n    next(p);\n    return t;\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__restoring_three_numbers.2.c", "original_string": "void quicksort(int vector[], int inf, int sup){\n  int i, j, x;\n  i = inf;\n  j = sup;\n  x = vector[(i+j)/2];\n  while(i <= j){ \n      while(vector[i] < x)    \n    i++;\n      while(vector[j] > x)  \n    j--;\n      if(i<=j){\n    change(vector, i, j);\n    i++;\n    j--;\n      }\n  }\n  if(inf < j)\n    quicksort(vector, inf, j);\n  if(i < sup)\n    quicksort(vector, i, sup);\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__DFS1.2.c", "original_string": "void create(struct graph* G[],int n)\n{\n    int i,j,m,data;\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nenter the number of vertices adjacent to vertex %d :\",i);\n        scanf(\"%d\",&m);\n        for(j=0;j<m;j++)\n        {\n            printf(\"\\nEnter the vertex to be inserted:\");\n            scanf(\"%d\",&data);\n            struct graph* p=(struct graph*)malloc(sizeof(struct graph));\n            p->val=data;\n            p->next=NULL;\n            if(G[i]==NULL)\n                G[i]=p;\n            else\n            {\n                last=G[i];\n                while(last->next!=NULL)\n                    last=last->next;\n                last->next=p;\n            }\n        }\n    }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__displayReversedList.1.c", "original_string": "struct Node *reversedList(struct Node *head){\n     struct Node *p = head;\n     printf(\"%d\\n\", p->data);\n     struct Node *q = head->next;\n     printf(\"%d\\n\", q->data);\n     head=head->next;\n     printf(\"%d\\n\", head->data);\n     p->next=NULL;\n     while (q->next!=NULL)\n     {\n          head=head->next;\n          printf(\"b\\n\");\n          q=q->next;\n          printf(\"d\\n\");\n          p=q->next;\n          printf(\"a\\n\");\n     }\n     return head;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_SLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    int count=0;\n    temp=head;\n    while(temp!=0)\n    {\n        count++;\n        temp=temp->next;\n    }\n    printf(\"the number of element in linked list is %d\", count);\n    printf(\"\\n\");\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_SLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    int count=0;\n    temp=head;\n    while(temp!=0)\n    {\n        count++;\n        temp=temp->next;\n    }\n    printf(\"the number of element in linked list is %d\", count);\n    printf(\"\\n\");\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_end_DCLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}"}
{"author": "theuwis", "file": "AdventOfCode2017__main11.0.c", "original_string": "int main(void){\n    int curr_nr = 0, curr_pos = 0;\n    while(curr_nr < TOTAL_LEN - 1){\n        for(int i = 0; i < STEP_SIZE; i++){\n            if(curr_pos < curr_nr){\n                curr_pos++;\n            }\n            else{\n                curr_pos = 0;\n            }\n        }\n        curr_pos++;\n        for(int i = curr_nr; i > curr_pos; i--){\n            array[i] = array[i - 1];\n        }\n        curr_nr++;\n        array[curr_pos] = curr_nr;\n    }\n    printf(\"answer=%d\\n\", array[curr_pos + 1]);\n    return EXIT_SUCCESS;\n}"}
{"author": "MFarid94", "file": "Assignment-2__Exercise4.1.c", "original_string": "int main(void){\n        setvbuf(stdout , NULL , _IONBF , 0);                            \n        setvbuf(stderr , NULL , _IONBF , 0);\n        char op;\n        float number1;\n        float number2;\n        float result;\n        int error = NO_ERROR_VALID_OPERATION;       \n        printf(\"Enter the required operation: \");\n        scanf(\"%c\",&op);                            \n        printf(\"Enter first number: \");\n        scanf(\"%f\",&number1);                       \n        printf(\"Enter second number: \");\n        scanf(\"%f\",&number2);                       \n        result = calculate(number1 , number2 , op , &error);        \n        if( error == NO_ERROR_VALID_OPERATION ){\n            printf(\"Result = %f\",result);\n        }\n        else if( error == ERROR_INVALID_OPERATION ){\n            printf(\"No result , invalid operation\");\n        }\n        return 0;\n}"}
{"author": "mandarvu", "file": "msc__problem71.2.c", "original_string": "int perf_check(int n) {\n  int summ = 0;\n  for (int ii = 1; ii <= sqrt(n) + 1; ii++)\n  {\n    if (n % ii == 0)\n      summ += ii;\n  }\n  return (summ == n ? 1 : 0);\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__48_orthogonal_matrix.0.c", "original_string": "int main()\n{\n  int i,j,k,r1,c1,r2,c2,row_sum = 0, col_sum = 0, diagnoal1 = 0, diagnoal2 = 0;\n  float expo= 0.0;\n  printf(\"Enter Value of r1, c1 and Exponential\\n\");\n  scanf(\"%d%d%f\",&r1,&c1,&expo);\n  int m1[r1][c1], m2[r1][c1], mul[r1][c1], sum = 0;\n  printf(\"Enter value of Matrix1\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      scanf(\"%d\",&m1[i][j]);\n    }\n  }\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      printf(\"%d \",m1[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      m2[j][i] = m1[i][j];\n    }\n  }\n  printf(\"\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      printf(\"%d \",m2[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<r1; j++)\n    {\n      for(k=0; k<r1; k++)\n      {\n        sum = sum + m1[i][k]*m2[k][j];\n      }\n      mul[i][j] = sum;\n      sum = 0;\n    }\n  }\n  printf(\"\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      printf(\"%d \",mul[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-1.13.c", "original_string": "int main(){\n    move[0].vert=-1;\n    move[0].horiz=0;\n    move[0].hei=0;\n    move[1].vert=0;\n    move[1].horiz=1;\n    move[1].hei=0;\n    move[2].vert=1;\n    move[2].horiz=0;\n    move[2].hei=0;\n    move[3].vert=0;\n    move[3].horiz=-1;\n    move[3].hei=0;\n    move[4].vert=0;\n    move[4].horiz=0;\n    move[4].hei=1;\n    move[5].vert=0;\n    move[5].horiz=0;\n    move[5].hei=-1;\n    char y;\n    int i,j,k;\n    FILE *pfile;\n    char name[50];\n    int control;\n    for(control=1;control<=100;control++){\n        min=100000;\n        sprintf(name,\"test%d.txt\",control);\n        pfile = fopen(name,\"r\");\n        if(NULL==pfile){\n            printf(\"Open failure\");\n            return 1;\n        }\n        else{\n            printf(\"reading %s\\n\",name);\n            char* bottom = make1darr(MAXLEN);\n            n=0;\n            char y;\n            bottom[n]=fgetc(pfile);\n            while(bottom[n]!='\\n'){\n                fgetc(pfile);\n                bottom[++n]=fgetc(pfile);\n            }\n            char ***maze=make3darr(n/2+1,n+2,n+2);\n            char ***road=make3darr(n/2+1,n+2,n+2);\n            char ***mark=make3darr(n/2+1,n+2,n+2);\n            int ***d=make3darrint(n/2+1,n+2,n+2);\n            int len=0;\n            int sr,sc,sh;\n            for(i=0;i<n/2+1;i++){\n                for(j=0;j<n+2;j++){\n                    for(k=0;k<n+2;k++){\n                        if(j==0 || k==0 || j==n+1 || k==n+1){\n                            maze[i][j][k]='X';\n                        }\n                        else if(i==0 && j==1){\n                            maze[i][j][k]=bottom[k-1];\n                        }\n                        else if(j > len && j <= n-len && k > len && k <= n-len){\n                            fscanf(pfile,\"%c \",&maze[i][j][k]);\n                        }\n                        else{\n                            maze[i][j][k]='X';\n                        }\n                        if(maze[i][j][k]=='S'){\n                            sh=i;\n                            sr=j;\n                            sc=k;\n                        }\n                        road[i][j][k]=maze[i][j][k];\n                        mark[i][j][k]=maze[i][j][k];\n                    }\n                }\n                len++;\n            }\n            FILE *wfile;\n            sprintf(name,\"4108056029test%d_ans.txt\",control);\n            wfile = fopen(name,\"w\");\n            if( NULL == wfile ){\n                printf( \"wfile open failure\" );\n                return 1;\n            }\n            else{\n                if(bfs(maze,d,sr,sc,sh)){\n                    path(maze,road,mark,d,sr,sc,sh);\n                    fprintf(wfile,\"Path length: %d\\n\",min);\n                    fprintf(wfile,\"=====outMaze=====\\n\");\n                    for(i=0;i<n/2+1;i++){\n                        for(j=i+1;j<n+2-i-1;j++){\n                            for(k=i+1;k<n+2-i-1;k++){\n                                fprintf(wfile,\"%c \",road[i][j][k] );\n                            }\n                            fprintf(wfile,\"\\n\");\n                        }\n                        fprintf(wfile,\"\\n\");\n                    }\n                }\n                else fprintf(wfile,\"The maze does not have a path\\n\" );\n            }\n            free(bottom);\n            free(maze);\n            free(mark);\n            free(road);\n            free(d);\n        }\n        fclose(pfile);\n    }\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.8.c", "original_string": "float maximo(float *c){\n    float max = c[0];\n    for (int i = 1; i < MAX_CALIFICACIONES; i++){\n        if (max < c[i]){\n            max = c[i];\n        }\n    }\n    return max;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Linked.1.c", "original_string": "void add_file(int id,int size)\n{\n    int ct=ispossible(),i,j;\n    if(ct>=size)\n    {\n        for(i=0;i<16 && size>0;i++)\n        {\n            if(disk[i].id==0)\n            {\n                disk[i].id=id;\n                size--;\n                for(j=i+1;j<16;j++)\n                {\n                    if(disk[j].id==0 && size>0)\n                    {\n                        disk[i].next_index=j;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    else\n    {\n        printf(\"\\nNot possible\");\n    }\n}"}
{"author": "mandarvu", "file": "msc__problem55.0.c", "original_string": "int main(void) {\n    struct student stud[3];\n    for (int i = 0; i < 3; i++) {\n        printf(\"\\nEnter First name - middle name - last name: \");\n        scanf(\"%s %s %s\", stud[i].name.fname, \n                stud[i].name.mname,\n                stud[i].name.lname);\n        printf(\"\\nEnter Roll no.: \");\n        scanf(\"%d\", &stud[i].roll);\n        printf(\"\\nEnter DOB in form DD - MM - YY: \");\n        scanf(\"%d %d %d\", &stud[i].dob.DD, &stud[i].dob.MM, &stud[i].dob.YYYY);        \n    }\n    for (int i = 0; i < 3; i++) {\n        printf(\"NAME = %s %s %s\\n\", \n                (stud+i)->name.fname, \n                (stud+i)->name.mname, \n                (stud+i)->name.lname);\n        printf(\"ROLL = %d\\n\",(stud+i)->roll);\n        printf(\"DOB  = %2d/%2d/%4d\\n\",\n                ((stud+i)->dob).DD, \n                ((stud+i)->dob).MM, \n                ((stud+i)->dob).YYYY);\n        printf(\"\\n\");\n    }\n    return 0;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sum_Of_All_Diagonals.0.c", "original_string": "void main()\n{\n    int i, j = 0;\n    int input_matrix[R][C];\n    int sum_of_principal_diagonal = 0;\n    int sum_of_counter_diagonal = 0;\n    printf(\"\\nEnter the matrix elements...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &input_matrix[i][j]);\n        }\n    }\n    printf(\"\\nInput Matrix is as follows:- \\n\");\n    display(input_matrix);\n    sum_of_principal_diagonal = find_sum_principal(input_matrix);\n    printf(\"\\nSum of Principal Diagonal = %d\\n\", sum_of_principal_diagonal);\n    sum_of_counter_diagonal = find_sum_counter(input_matrix);\n    printf(\"\\nSum of Counter Diagonal = %d\\n\", sum_of_counter_diagonal);\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__SelectionSort.1.c", "original_string": "int selectionSort(int x[], int n)              \n{                                              \n    int i,j,temp;                              \n    for(i=0;i<n;i++)                           \n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(x[i] > x[j])\n            {\n                temp = x[j];\n                x[j] = x[i];\n                x[i] = temp;\n            }\n        }\n    }\n    printf(\"sorted array:\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\n\",x[i]);\n    }\n}"}
{"author": "SugumaranEvil", "file": "Linux_programming__prc20.0.c", "original_string": "int main()\n{\n    int shmid;\n    char data[30];\n    char *data_ptr;\n    shmid = shmget(100, 8192, 0); \n    perror(\"shmget: \");\n    data_ptr = shmat(shmid, NULL,0);\n    perror(\"shmat: \");\n    strcpy(data, data_ptr);\n    printf(\"%s\\n\",data);\n    shmdt(data_ptr);\n    perror(\"shmdt: \");\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__heap_sort.1.c", "original_string": "void sort(int a[],int n,int i)\n{\n    int large,l,r;\n    large=i;\n    l=2*i+1;\n    r=2*i+2;\n    while(l<n && a[l]>a[large])\n    {\n        large=l;\n    }\n    while(r<n && a[r]>a[large])\n    {\n        large=r;\n    }\n    if(large!=i)\n    {\n        elemsw(&a[large],&a[i]);\n        sort(a,n,large);\n    }\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__arreglo_uni_dinamico.2.c", "original_string": "float promedio_calorias(int a[], int tam){\n    int suma = 0;\n    for (int i = 0; i < tam; i++){\n        suma += a[i];\n    }\n    return (suma/tam);\n}"}
{"author": "MartinMarinovich", "file": "ParcialLaboratorio1GCompleto__main.0.c", "original_string": "int main()\n{\n    eNotebook listaDeNotebooks[TAM_NOTEBOOKS];\n    eMarca listadoDeMarcas[TAM_MARCAS];\n    eTrabajo listadoDeTrabajos[TAM_TRABAJOS];\n    eTipo listadoDeTipos[TAM_TIPOS];\n    eServicio listadoDeServicios [TAM_SERVICIOS];\n    eCliente listadoDeClientes [TAM_CLIENTES];\n    int proximoIdTrabajo = 100;\n    int proximoIdNotebook = 1;\n    int auxModificacion;\n    int auxBaja;\n    int opcionMenu;\n    if(!inicializarNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !inicializarTrabajo(listadoDeTrabajos,TAM_TRABAJOS))\n    {\n        printf(\"Sistema inicializado con exito!\\n\\n\");\n    }else\n    {\n        printf(\"Problema para inicializar el sistema\\n\");\n    }\n    hardCodearTipos(listadoDeTipos,TAM_TIPOS);\n    hardcodearMarcas(listadoDeMarcas,TAM_MARCAS);\n    hardCodearServicios(listadoDeServicios,TAM_SERVICIOS);\n    hardCodearClientes(listadoDeClientes,TAM_NOTEBOOKS);\n    hardCodearTrabajos(listadoDeTrabajos,TAM_NOTEBOOKS);\n    do\n    {\n        menu(&opcionMenu);\n        switch(opcionMenu)\n        {\n            case 1:\n                if(!altaNotebook(listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,TAM_NOTEBOOKS,TAM_CLIENTES,proximoIdNotebook,TAM_TIPOS,TAM_MARCAS))\n                {\n                    proximoIdNotebook++;\n                    printf(\"ALTA EXITOSA!\\n\");\n                }\n                else\n                {\n                    printf(\"Problema para realizar el alta\\n\");\n                }\n            break;\n            case 2:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    auxModificacion = modificarNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);\n                    if( auxModificacion == 0)\n                    {\n                        printf(\"Modificacion exitosa\\n\");\n                    }\n                    else if(auxModificacion == 2)\n                    {\n                        printf(\"La modificacion ha sido cancelada por usuario\\n\");\n                    }\n                    else\n                    {\n                        printf(\"Se ha producido un error en la modificacion\\n\");\n                    }\n                }else\n                {\n                    printf(\"No hay notebooks en el listado\\n\");\n                }\n            break;\n            case 3 :\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    auxBaja = bajaNotebook(listaDeNotebooks,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TIPOS,TAM_MARCAS);\n                    if( auxBaja == 0)\n                    {\n                        printf(\"Modificacion exitosa\\n\");\n                    }\n                    else if(auxBaja == 2)\n                    {\n                        printf(\"La baja ha sido cancelada por usuario\\n\");\n                    }\n                    else\n                    {\n                        printf(\"Se ha producido un error en la baja\\n\");\n                    }\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 4:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    ordenarNotebooks(listaDeNotebooks,TAM_NOTEBOOKS);\n                    listarNotebook(listaDeNotebooks, listadoDeMarcas,listadoDeClientes,listadoDeTipos,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_MARCAS,TAM_TIPOS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 5:\n                system(\"cls\");\n                listarMarcas(listadoDeMarcas,TAM_MARCAS);\n            break;\n            case 6:\n                system(\"cls\");\n                listarTipos(listadoDeTipos,TAM_TIPOS);\n            break;\n            case 7:\n                system(\"cls\");\n                listarServicios(listadoDeServicios,TAM_SERVICIOS);\n            break;\n            case 8:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    if(altaTrabajo(listaDeNotebooks,listadoDeTrabajos,listadoDeServicios,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,\n                            TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_TIPOS,TAM_MARCAS,proximoIdTrabajo)==0)\n                    {\n                        proximoIdTrabajo++;\n                        printf(\"ALTA TRABAJO EXITOSA!\\n\");\n                    }else\n                    {\n                        printf(\"Se produjo un error al ingresa el trabajo\\n\");\n                    }\n                }else\n                {\n                    printf(\"No hay notebooks en la lista, no se puede ingresar trabajo\\n\");\n                }\n            break;\n            case 9:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) &&\n                    !verificarExistenciaTrabajo(listadoDeTrabajos,TAM_TRABAJOS))\n                {\n                    system(\"cls\");\n                    listarTrabajos(listadoDeTrabajos,listaDeNotebooks,listadoDeServicios,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS);\n                }else\n                {\n                    printf(\"No se ingresaron trabajos o notebooks\\n\");\n                }\n            break;\n            case 10:\n                system(\"cls\");\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    listarPorTipo(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeClientes,TAM_CLIENTES,TAM_MARCAS,listadoDeTipos,TAM_TIPOS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 11:\n                system(\"cls\");\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    listarPorMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS,TAM_TIPOS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 12:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS))\n                {\n                    contarNotebooksMarcaYTipo(listaDeNotebooks, TAM_NOTEBOOKS,listadoDeMarcas,TAM_MARCAS,listadoDeClientes, TAM_CLIENTES, listadoDeTipos, TAM_TIPOS);\n                }\n            break;\n            case 13:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    listarNotebookXCadaMarca(listaDeNotebooks,listadoDeClientes,TAM_CLIENTES,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_TIPOS,TAM_MARCAS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 14:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    marcaFavorita(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,TAM_MARCAS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 15:\n                if(verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS)==0)\n                {\n                    system(\"cls\");\n                    notebookMasBarata(listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,listadoDeTipos,listadoDeClientes,TAM_CLIENTES,TAM_TIPOS,TAM_MARCAS);\n                }else\n                {\n                    printf(\"No hay notebooks en la lista\\n\");\n                }\n            break;\n            case 16:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    listarTrabajosXNotebook(listadoDeTrabajos,listaDeNotebooks,listadoDeClientes,listadoDeMarcas,listadoDeTipos,listadoDeServicios,TAM_CLIENTES,TAM_NOTEBOOKS,TAM_TRABAJOS,TAM_SERVICIOS,TAM_MARCAS,TAM_TIPOS);\n                }\n            break;\n            case 17:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    mostrarSumaDeImportesXNotebook(listadoDeServicios, TAM_SERVICIOS, listadoDeTrabajos, listaDeNotebooks, TAM_NOTEBOOKS, listadoDeMarcas, listadoDeTipos, listadoDeClientes, TAM_CLIENTES, TAM_TIPOS, TAM_MARCAS, TAM_TRABAJOS);\n                }else\n                {\n                    printf(\"No hay notebooks o trabajos cargados\\n\");\n                }\n            break;\n            case 18:\n                 if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    mostrarFechaYNotebookXServicio(listadoDeClientes,listadoDeTrabajos,TAM_TRABAJOS,listadoDeServicios,TAM_SERVICIOS,listaDeNotebooks,TAM_NOTEBOOKS,listadoDeMarcas,TAM_MARCAS,listadoDeTipos,TAM_TIPOS,TAM_CLIENTES);\n                }else\n                {\n                    printf(\"No hay notebooks o trabajos cargados\\n\");\n                }\n            break;\n            case 19:\n                if(!verificarExistenciaNotebook(listaDeNotebooks,TAM_NOTEBOOKS) && !verificarExistenciaTrabajo(listadoDeTrabajos, TAM_TRABAJOS))\n                {\n                    mostrarServiciosXFecha(listadoDeTrabajos,TAM_TRABAJOS,listadoDeServicios,TAM_SERVICIOS);\n                }else\n                {\n                    printf(\"No hay notebooks o trabajos cargados\\n\");\n                }\n            break;\n        }\n    }while(opcionMenu != 20);\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__DemoFOTAUpdateSelfTest.2.c", "original_string": "void validateFirmwareUpdateActivation(void)\n{\n  printf(\"Validating firmware update\\n\");\n  if (runRandomSelfTest(SIMULATED_ACTIVATION_SUCCESS_RATE)) \n  {\n    printf(\"Firmware update successfully activated\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED);\n  }\n  else\n  {\n    printf(\"Firmware update activation failed\\n\");\n    fotahub_onFirmwareUpdateStatusChanged(FOTA_UPDATE_STATUS_ACTIVATION_FAILED);\n  }\n}"}
{"author": "DanielSalis", "file": "AED1__teste6.3.c", "original_string": "void inserir(TipoLista* l, int id){\n    TipoElemento* novoElemento = (TipoElemento*)malloc(sizeof(TipoElemento));\n    novoElemento->id = id;\n    if(existeNalista(l, id) == 1){\n        printf(\"processo ja esta na fila\\n\"); \n    }\n    else{\n        if(l->tamanho == 0){\n            l->primeiro = novoElemento;\n            l->ultimo = novoElemento;\n            novoElemento->prox = NULL;\n            l->tamanho++;\n            l->tamMod++;\n        }else{\n            l->ultimo->prox = novoElemento;\n            l->ultimo = novoElemento;\n            novoElemento->prox = NULL;\n            l->tamanho++;\n            l->tamMod++;\n        }\n        if(l->tamMod == 3){\n            printf(\"removendo processo %d em espera a muito tempo...\\n\", l->primeiro->id); \n            remover(l);\n            l->tamMod = 0;\n        }\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__circular_linked_list.1.c", "original_string": "void createList(int n)\n{\n    int i, data;\n    struct node *temp, *newNode;\n        head = (struct node *)malloc(sizeof(struct node));\n        printf(\"Enter data of 1 node: \");\n        scanf(\"%d\", &data);\n        head->data = data;\n        head->next = NULL;\n        temp = head;\n        for(i=2; i<=n; i++)\n        {\n            newNode = (struct node *)malloc(sizeof(struct node));\n            printf(\"Enter data of %d node: \", i);\n            scanf(\"%d\", &data);\n            newNode->data = data;\n            newNode->next = NULL;\n            temp->next = newNode;\n            temp = newNode;\n        }\n        temp->next = head;\n        printf(\"\\nCIRCULAR LINKED LIST CREATED SUCCESSFULLY\\n\");\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__expand_str.0.c", "original_string": "int     main(int ac, char **av)\n{\n    int     i;\n    i = 0;\n    if (ac == 2)\n    {\n        while (av[1][i] == ' ' || av[1][i] == '\\t')\n            i++;\n        while (av[1][i])\n        {\n            if ((av[1][i] == ' ') || (av[1][i] == '\\t'))\n            {\n                if (av[1][i + 1] > 32 && av[1][i + 1] != '\\0')\n                    write(1, \"   \", 3);\n            }\n            else if (av[1][i] != ' ' || av[1][i] != '\\t')\n                write(1, &av[1][i],1);\n            i++;\n        }\n    }\n    write(1, \"\\n\", 1);\n    return (0);\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_03.0.c", "original_string": "int main()\n{\n    float a[10],b[10];\n    int i;\n    for(i=0; i<10; i++)\n    {\n        printf(\" digite o %d valor: \",i);\n        scanf(\"%f\",&a[i]);\n    }\n    for(i=0; i<10; i++)\n        b[i] = a[i] * a[i];\n    printf(\"\\n\\nConjunto 1: \\n\");\n    for(i=0; i<10; i++)\n    printf(\"\\n%2.f \",a[i]);\n    printf(\"\\n\\nConjunto 2: \\n\");\n    for(i=0; i<10; i++)\n        printf(\" \\n%2.f \",b[i]);\nreturn 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q1.3.c", "original_string": "void preorder(nptr root)\n{\n    if (root == NULL)\n        return;\n    printf(\"%d \", root->data);\n    preorder(root->lchild);\n    preorder(root->rchild);\n}"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio1.2.c", "original_string": "int main(void){\n    thmain = pthread_self();\n    pthread_attr_init(&attr);\n    printf(\"Soy la funcion main y voy a lanzar los dos threads \\n\");\n    pthread_create(&thread1, &attr, func1, 4);\n    pthread_create(&thread2, &attr, func2, 5);\n    sleep(2);\n    printf(\"Soy main: he lanzado los dos threads y termino\\n\");\n    pthread_exit(NULL);\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example4_1.2.c", "original_string": "int ustAlma(int ust)\n{\n    int i,deger=1;\n    for(i=1;i<=ust;i++)\n        deger*=2;  \n    if(ust==0)\n    deger=1;\n    return deger;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-util.4.c", "original_string": "DEBUGINFO* getdebug(PARSER* p) {\n    DEBUGINFO* d = (DEBUGINFO*)malloc(sizeof(DEBUGINFO));\n    d->file = p->file;\n    d->definedat = p->current->definedat;\n    return d;\n}"}
{"author": "ankitraj311", "file": "Socket-thread__t.0.c", "original_string": "void *myThreadFun(void *vargp) \n{ \n    int *myid = (int *)vargp; \n    static int s = 0; \n    ++s; ++g; \n    printf(\"Thread ID: %u, Static: %d, Global: %d\\n\", *myid, ++s, ++g); \n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__adivina.0.c", "original_string": "int main(void){\n    srand(time(NULL));\n    char respuesta = 'N';\n    do {\n        int op = menu();\n        switch (op) {\n        case 1: jugar();\n            break;\n        default:\n            break;\n        }\n        printf(\"Deseas continuar jugando? [S]i o [N]o \\n\");\n        fflush(stdin);\n        scanf(\"%c\", &respuesta);\n    } while( respuesta == 'S');\n    return 0;\n}"}
{"author": "sdukesameer", "file": "c__structure.0.c", "original_string": "void dispStudents ( studentType students[], int n ) {\n    int i;\n    for (i=0; i<n; i++)\n        printf(\"#%d Roll: %d | Name:%s\\n\",i+1, students[i].rollNo, students[i].name );\n}"}
{"author": "mehedi9021", "file": "C__delete_number_in_any_position_aray.0.c", "original_string": "int main()\n{\n    int arr[MAX_SIZE];\n    int i, size, pos;\n    printf(\"Enter size of the array : \");\n    scanf(\"%d\", &size);\n    printf(\"Enter elements in array : \");\n    for(i=0; i<size; i++)\n    {\n        scanf(\"%d\", &arr[i]);\n    }\n    printf(\"Enter the element position to delete : \");\n    scanf(\"%d\", &pos);\n    if(pos==size+1 || pos<0)\n    {\n        printf(\"Invalid position! Please enter position between 1 to %d\", size);\n    }\n    else\n    {\n        for(i=pos-1; i<size-1; i++)\n        {\n            arr[i] = arr[i + 1];\n        }\n        size--;\n    }\n    printf(\"\\nElements of array after delete are : \");\n    for(i=0; i<size; i++)\n    {\n        printf(\"%d\\t\", arr[i]);\n    }\n    return 0;\n}"}
{"author": "jose120918", "file": "binary_trees__18-binary_tree_uncle.1.c", "original_string": "binary_tree_t *binary_tree_uncle(binary_tree_t *node)\n{\n    if (node == NULL)\n    {\n        return (NULL);\n    }\n    if ((*node).parent == NULL)\n    {\n        return (NULL);\n    }\n    return (brother((*node).parent));\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSL__tls13_server_misc.0.c", "original_string": "error_t tls13NegotiateCipherSuite(TlsContext *context, const void *clientHello,\n   size_t clientHelloLen, const TlsCipherSuites *cipherSuites,\n   TlsHelloExtensions *extensions)\n{\n   error_t error;\n   context->keyExchMethod = TLS_KEY_EXCH_NONE;\n   error = tls13ParseClientPreSharedKeyExtension(context, clientHello,\n      clientHelloLen, extensions->identityList, extensions->binderList);\n   if(error)\n      return error;\n   if(context->selectedIdentity >= 0)\n   {\n      error = tlsNegotiateCipherSuite(context, context->cipherSuite.prfHashAlgo,\n         cipherSuites, extensions);\n      if(!error)\n      {\n         context->keyExchMethod = TLS13_KEY_EXCH_PSK;\n      }\n      else\n      {\n         context->keyExchMethod = TLS_KEY_EXCH_NONE;\n         context->selectedIdentity = -1;\n      }\n   }\n   if(context->keyExchMethod == TLS_KEY_EXCH_NONE)\n   {\n      error = tlsNegotiateCipherSuite(context, NULL, cipherSuites, extensions);\n      if(error)\n         return ERROR_HANDSHAKE_FAILED;\n   }\n   if(context->state != TLS_STATE_CLIENT_HELLO_2)\n   {\n      error = tlsInitTranscriptHash(context);\n      if(error)\n         return error;\n   }\n   error = tls13ParseClientEarlyDataExtension(context,\n      extensions->earlyDataIndication);\n   if(error)\n      return error;\n   error = tls13ParseClientKeyShareExtension(context, extensions->keyShareList);\n   if(error)\n      return error;\n   if(extensions->keyShareList != NULL && context->namedGroup == TLS_GROUP_NONE)\n   {\n      error = tls13SelectGroup(context, extensions->supportedGroupList);\n      if(error)\n         return error;\n      context->state = TLS_STATE_HELLO_RETRY_REQUEST;\n   }\n   else\n   {\n      if(context->keyExchMethod == TLS13_KEY_EXCH_DHE ||\n         context->keyExchMethod == TLS13_KEY_EXCH_ECDHE)\n      {\n      }\n      else if(context->keyExchMethod == TLS13_KEY_EXCH_PSK ||\n         context->keyExchMethod == TLS13_KEY_EXCH_PSK_DHE ||\n         context->keyExchMethod == TLS13_KEY_EXCH_PSK_ECDHE)\n      {\n         error = tls13ParsePskKeModesExtension(context,\n            extensions->pskKeModeList);\n         if(error)\n            return error;\n         error = tls13VerifyPskBinder(context, clientHello, clientHelloLen,\n            extensions->identityList, extensions->binderList,\n            context->selectedIdentity);\n         if(error)\n            return error;\n      }\n      else\n      {\n         return ERROR_HANDSHAKE_FAILED;\n      }\n   }\n   return NO_ERROR;\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_6.4.c", "original_string": "void display()\n{\n    struct node * temp = root;\n    if(root == NULL)\n    {\n        printf(\"List is Empty\\n\\n\");\n    }\n    else\n    {\n        while(temp != NULL)\n        {\n            printf(\"%d --> \", temp->data);\n            temp = temp->right;\n        }\n        printf(\"\\n\\n\");\n    }\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_sys_bios.18.c", "original_string": "bool_t osCreateMutex(OsMutex *mutex)\n{\n   Semaphore_Params semaphoreParams;\n   Semaphore_Params_init(&semaphoreParams);\n   semaphoreParams.mode = Semaphore_Mode_BINARY_PRIORITY;\n   mutex->handle = Semaphore_create(1, &semaphoreParams, NULL);\n   if(mutex->handle != NULL)\n      return TRUE;\n   else\n      return FALSE;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad10.9.c", "original_string": "int InOrderPrintInFile(FILE* fp, treePointer root)\n{\n    if (root)\n    {\n        InOrderPrintInFile(fp, root->left);\n        fprintf(fp, \"%c \", root->data);\n        InOrderPrintInFile(fp, root->right);\n    }\n    return 0;\n}"}
{"author": "andi-s0106", "file": "binary_trees__15-binary_tree_is_full.0.c", "original_string": "int binary_tree_is_full(const binary_tree_t *tree)\n{\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    if (tree->left != NULL && tree->right == NULL)\n    {\n        return (0);\n    }\n    if (tree->left == NULL && tree->right != NULL)\n    {\n        return (0);\n    }\n    if (tree->left == NULL && tree->right == NULL)\n    {\n        return (1);\n    }\n    if (binary_tree_is_full(tree->left) == 0)\n    {\n        return (0);\n    }\n    if (binary_tree_is_full(tree->right) == 0)\n    {\n        return (0);\n    }\n    return (1);\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_posix.10.c", "original_string": "void osSetEvent(OsEvent *event)\n{\n   int_t ret;\n   int_t value;\n   ret = sem_getvalue(event, &value);\n   if(ret == 0 && value == 0)\n   {\n      sem_post(event);\n   }\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica3-3a.4.c", "original_string": "int consumirDato(){                      \n    int numConsumido= v[indiceConsumicion];   \n    v[indiceConsumicion] = '\\0';  \n    indiceConsumicion = (indiceConsumicion +1)%n;   \n    for(int i=0; i<n; i++){ printf(\"%d \", v[i]); }\n    return numConsumido;   \n}"}
{"author": "shengelenge", "file": "wp-lab3__zad13.1.c", "original_string": "int main()\n{\n    int A[MAX];\n    long w;\n    int n;\n    printf(\"podaj liczbe cyfr wczytywanej liczby binarnej: \");\n    scanf(\"%d\", &n);\n    printf(\"Podaj %d cyfr liczby (od lewej): \", n);\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"A[%d] = \", i);\n        scanf(\"%d\", &A[i]);\n    }\n    w = oblicz(A, n-1);\n    printf(\"Iteracyjnie: wynik = %ld\", w);\n    printf(\"(10)\");\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_DCLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__str_capitilizer.0.c", "original_string": "int     ft_toupper(char  a,char b)\n{\n    if ( a == ' ' || a == '\\t')\n    {\n        if (b >= 'a' && b <= 'z')\n            return (1);\n    }\n    return (0);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__4,_5,_6.3.c", "original_string": "long int catalan(float n)\n{\n    return (n > 0) ? ((4*n - 2) / (n+1)) * catalan(n-1) : 1;\n}"}
{"author": "theuwis", "file": "AdventOfCode2016__main27.0.c", "original_string": "int main(void){\n    parse_instructions();\n    max_instr = curr_instr;\n    curr_instr = 0;\n    regs[2] = 1;\n    while(curr_instr < max_instr){\n        switch(instr[curr_instr].cmd){\n            case 0 :\n                regs[instr[curr_instr].y] = regs[instr[curr_instr].x];\n                curr_instr++;\n                break;\n            case 1 :\n                regs[instr[curr_instr].y] = instr[curr_instr].x;\n                curr_instr++;\n                break;\n            case 2 :\n                regs[instr[curr_instr].x]++;\n                curr_instr++;\n                break;\n            case 3 :\n                regs[instr[curr_instr].x]--;\n                curr_instr++;\n                break;\n            case 4 :\n                if(regs[instr[curr_instr].x] != 0){\n                    curr_instr += instr[curr_instr].y;\n                }\n                else{\n                    curr_instr++;\n                }\n                break;\n            case 5:\n                if(instr[curr_instr].x != 0){\n                    curr_instr += instr[curr_instr].y;\n                }\n                else{\n                    curr_instr++;\n                }\n                break;\n            default :\n                printf(\"Not a valid instruction!\\n\");\n                exit(EXIT_FAILURE);\n        }\n    }\n    printf(\"ans=%d\\n\", regs[0]);\n    return EXIT_SUCCESS;\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__11.0.c", "original_string": "int main(void)\n{\n    int vetor[tamanho], aux, i = 0, k = 0, maior, menor, indice_maior[tamanho], indice_menor[tamanho];\n    printf(\"\\nInforme os n\u00fameros do vetor:\\n\");\n    for (int a = 0; a < tamanho; a++)\n    {\n        scanf(\"%i\", &vetor[a]);\n        if (a == 0)\n        {\n            maior = vetor[a];\n            indice_maior[i] = a;\n            menor = vetor[a];\n            indice_menor[k] = a;\n        }\n        else\n        {\n            if (vetor[a] > maior)\n            {\n                maior = vetor[a];\n                for (int j = 0; j < tamanho; j++)\n                {\n                    indice_maior[j] = 0;\n                }\n                i = 0;\n                indice_maior[i] = a;\n            }\n            else if (vetor[a] == maior)\n            {\n                i++;\n                indice_maior[i] = a;\n            }\n            else if (vetor[a] < menor)\n            {\n                menor = vetor[a];\n                for (int l = 0; l < tamanho; l++)\n                {\n                    indice_menor[l] = 0;\n                }\n                k = 0;\n                indice_menor[k] = a;\n            }\n            else if (vetor[a] == menor)\n            {\n                k++;\n                indice_menor[k] = a;\n            }\n        }\n    }\n    if (k != 0)\n    {\n        printf(\"\\nMenor = indices \");\n        for (int c = 0; c <= k; c++)\n        {\n            if (c == k)\n            {\n                printf(\"%i. \", indice_menor[c]);\n            }\n            else\n            {\n                printf(\"%i, \", indice_menor[c]);\n            }\n        }\n        printf(\"com valor %i\", menor);\n    }\n    else if (k == 0)\n    {\n        printf(\"\\nMenor = indice %i com valor %i\", indice_menor[k], menor);\n    }\n    if (i != 0)\n    {\n        printf(\"\\nMaior = indices \");\n        for (int b = 0; b <= i; b++)\n        {\n            if (b == i)\n            {\n                printf(\"%i. \", indice_maior[b]);\n            }\n            else\n            {\n                printf(\"%i, \", indice_maior[b]);\n            }\n        }\n        printf(\"com valor %i\", maior);\n    }\n    else if (i == 0)\n    {\n        printf(\"\\nMaior = indice %i com valor %i\", indice_maior[i], maior);\n    }\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"author": "paawankohli", "file": "CN-Lab__q4_server.0.c", "original_string": "void main() {\n    int serverfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (serverfd == -1) {\n        printf(\"Couldn't create socket. Exiting!\\n\");\n        exit(0);\n    } else {\n        printf(\"Socket created \\n\");\n    }\n    struct sockaddr_in server_address, client_address;\n    int len = sizeof(server_address);\n    server_address.sin_family = AF_INET;\n    server_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    server_address.sin_port = PORT;\n    if (bind(serverfd, (struct sockaddr *)&server_address, len) == -1) {\n        exit(0);\n    } else {\n        printf(\"Binding successful!\\n\");\n    }\n    if (listen(serverfd, 5) == -1) {\n        printf(\"Couldn't start listening. Exit.\\n\");\n        exit(0);\n    } else {\n        printf(\"Server listening.\\n\\n\");\n    }\n    while (1) {\n        int clientfd = accept(serverfd, (struct sockaddr *)&client_address, &len);\n        time_t rawtime;\n        struct tm * timeinfo;\n        time ( &rawtime );\n        timeinfo = localtime ( &rawtime );\n        char* time_to_output = malloc(strlen(asctime (timeinfo)) + 1);\n        strcpy(time_to_output, asctime (timeinfo));\n        write(clientfd, time_to_output, 100);\n        char process_id_to_output[100];\n        sprintf(process_id_to_output, \"%d\", getpid());\n        write(clientfd, &process_id_to_output, 100);\n        close(clientfd);\n    }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__pushPopInStack.4.c", "original_string": "int main()\n{\n    struct stack *sp=(struct stack*)malloc(sizeof(struct stack));\n    sp->size=10;\n    sp->top= -1;\n    sp->arr= (int *)malloc(sp->size* sizeof(int));\n    printf(\"Before pushing, Full: %d\\n\", isFull(sp));\n    printf(\"Before pushing, Empty: %d\\n\", isEmpty(sp));\n    push(sp, 56);\n    push(sp, 55);\n    push(sp, 54);\n    push(sp, 53);\n    push(sp, 52);\n    push(sp, 51);\n    push(sp, 50);\n    push(sp, 49);\n    push(sp, 48);\n    push(sp, 47); \n    push(sp, 46);\n    printf(\"After pushing, Full: %d\\n\", isFull(sp));\n    printf(\"After pushing, Empty: %d\\n\", isEmpty(sp));\n    printf(\"Popped %d from the stack\\n\", pop(sp)); \n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q4.4.c", "original_string": "int main()\n{\n    node *root, *c;\n    root = create();\n    c = copy(root);\n    printf(\"\\nThe inorder traversal of copied tree is:\\n\");\n    inorder(c);\n    printf(\"\\nThe inorder traversal of original tree is:\\n\");\n    inorder(root);\n    if(Equal(root, c))\n        printf(\"\\nEqual!\\n\");\n    else\n        printf(\"\\nNot Equal!\\n\");\n    return 0;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__st.0.c", "original_string": "int     ft_to_lower(char c, char d, int i)\n{\n    if (c != ' ' && c != '\\t' && i != -1)\n    {\n        if (d >= 'A' && d <= 'Z')\n            return (1);\n    }\n    return (0);\n}"}
{"author": "davibernardos", "file": "DB-PJ__e20.9.c", "original_string": "int main() {\n    char captcha[TOTAL], entrada[TOTAL], verificador[7][20];\n    int verificacao, entradaNumerica, cont;\n    strcpy(palavras[0].nome,\"Amarelo\");\n    palavras[0].tipo=1;\n    strcpy(palavras[1].nome,\"Azul\");\n    palavras[1].tipo=1;\n    strcpy(palavras[2].nome,\"Roxo\");\n    palavras[2].tipo=1;\n    strcpy(palavras[3].nome,\"Verde\");\n    palavras[3].tipo=1;\n    strcpy(palavras[4].nome,\"Cinza\");\n    palavras[4].tipo=1;\n    strcpy(palavras[5].nome,\"Porco\");\n    palavras[5].tipo=2;\n    strcpy(palavras[6].nome,\"Cavalo\");\n    palavras[6].tipo=2;\n    strcpy(palavras[7].nome,\"Rato\");\n    palavras[7].tipo=2;\n    strcpy(palavras[8].nome,\"Cachorro\");\n    palavras[8].tipo=2;\n    strcpy(palavras[9].nome,\"Gato\");\n    palavras[9].tipo=2;\n    strcpy(palavras[10].nome,\"Garfo\");\n    palavras[10].tipo=3;\n    strcpy(palavras[11].nome,\"Faca\");\n    palavras[11].tipo=3;\n    strcpy(palavras[12].nome,\"Prato\");\n    palavras[12].tipo=3;\n    strcpy(palavras[13].nome,\"Copo\");\n    palavras[13].tipo=3;\n    strcpy(palavras[14].nome,\"Panela\");\n    palavras[14].tipo=3;\n    srand(time(NULL));\n    do {\n        system(\"cls\");\n        strcpy(captcha,gerarCaptchaSimples());\n        printf(\"\\n%s\",captcha);\n        printf(\"\\nDigite os caracteres da linha anetior: \");\n        gets(entrada);\n        verificacao=verificarCaptchaSimples(captcha,entrada);\n        if (verificacao) {\n            printf(\"\\nCaptcha correto!\\n\");\n        } else {\n            printf(\"\\nCaptcha incorreto!\\n\");\n        }\n        system(\"pause\");\n    }while(verificacao==FALSE);\n    do{\n        system(\"cls\");\n        strcpy(captcha,gerarCaptchaMatematico());\n        printf(\"\\n%s\",captcha);\n        printf(\"\\nDigite o resultado da operacao anterior: \");\n        scanf(\"%d\",&entradaNumerica);\n        verificacao=verificarCaptchaMatematico(captcha,entradaNumerica);\n        if (verificacao) {\n            printf(\"\\nCaptcha correto!\\n\");\n        } else {\n            printf(\"\\nCaptcha incorreto!\\n\");\n        }\n        system(\"pause\");\n    }while(verificacao==FALSE);\n    do{\n        system(\"cls\");\n        gerarCaptchaLogico(verificador);\n        for(cont=1;cont<6;cont++){\n            printf(\"\\n%d - %s\",cont,verificador[cont]);\n        }\n        printf(\"\\nSelecione um(a) %s da lista anterior:\",verificador[0]);\n        scanf(\"%d\",&entradaNumerica);\n        while(entradaNumerica<1 || entradaNumerica>5){\n            printf(\"\\nOpcao invalida. Digite novamente: \");\n            scanf(\"%d\",&entradaNumerica);\n        }\n        verificacao=verificarCaptchaLogico(verificador,entradaNumerica);\n        if (verificacao) {\n            printf(\"\\nCaptcha correto!\\n\");\n        } else {\n            printf(\"\\nCaptcha incorreto!\\n\");\n        }\n        system(\"pause\");\n    }while(verificacao==FALSE);\n}"}
{"author": "davibernardos", "file": "DB-PJ__e80.3.c", "original_string": "int main(void) {\n    char valor[CAPTCHA], *retorno, digitado[CAPTCHA], copia[CAPTCHA + 1];\n    while (loop == 1) {\n        retorno = gerarCaptcha(valor);\n        trasformarCaptcha(copia, retorno);\n        printf(\"%s\", retorno);\n        printf(\"\\nDigite a CAPTCHA: \");\n        gets(digitado);\n        comparaCaptcha(copia, digitado);\n    }\n    return 0;\n}"}
{"author": "haon1026", "file": "linux-programming__sigaction.2.c", "original_string": "int main()\n{\n    struct sigaction act, oldact;\n    act.sa_handler = sig_catch;         \n    sigemptyset(&act.sa_mask);          \n    act.sa_flags = 0;                   \n    int ret = sigaction(SIGINT, &act, &oldact);     \n    if(ret == -1)\n        sys_err(\"sigaction error\");\n    ret = sigaction(SIGBUS, &act, &oldact);\n    if(ret == -1)\n        sys_err(\"sigaction error\");\n    while(1);\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_conditions.9.c", "original_string": "bool_t rstpReRooted(RstpBridgePort *port)\n{\n   uint_t i;\n   bool_t res;\n   RstpBridgeContext *context;\n   res = TRUE;\n   context = port->context;\n   for(i = 0; i < context->numPorts; i++)\n   {\n      if(&context->ports[i] != port && context->ports[i].rrWhile != 0)\n      {\n         res = FALSE;\n      }\n   }\n   return res;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLL.1.c", "original_string": "nptr insertLeft(nptr head, int x)\n{\n    if (head == NULL)\n        return createNode(x);\n    else\n    {\n        nptr temp = createNode(x);\n        temp -> right = head;\n        head -> left = temp;\n        return temp;\n    }\n}"}
{"author": "2security", "file": "Matrix__26Multiplication.1.c", "original_string": "void Product(int mat1[][20],int mat2[][20],int r,int c)\n    {\n    int i,j,temp[20][20],k;\n    for(i=0;i<r;i++)\n            {\n            for(j=0;j<c;j++)\n                {\n                temp[i][j]=0;\n                for(k=0;k<c;k++)\n                    temp[i][j]+=mat1[i][k]*mat2[k][j];\n                }\n            }\n    displayMat(temp,r,c);\n    }"}
{"author": "sdukesameer", "file": "dsa__dfs.0.c", "original_string": "void input(graph* g){\n    int i,j,f,x=1;\n    while(x){\n        printf(\"\\nEnter the number of vertices: \");\n        scanf(\"%d\",&g->n);\n        if(g->n>0)\n            x=0;\n        else\n            printf(\"Invalid input. Try again.\\n\");\n    }\n    g->arr=(int**) malloc(sizeof(int*)*g->n);\n    for(i=0;i<g->n;i++)\n        g->arr[i]=(int*)malloc(sizeof(int)*g->n);\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++)\n            g->arr[i][j]=-1;\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++){\n            if(g->arr[i][j]==1 || g->arr[i][j]==0)\n                continue;\n            if(i==j){\n                g->arr[i][j]=0;\n                continue;\n            }\n            x=1;\n            while(x){\n                printf(\"Is there an edge between %c and %c (Yes=1 & No=0): \",'A'+i,'A'+j);\n                scanf(\"%d\",&f);\n                if(f==0 || f==1){\n                    g->arr[i][j]=f;\n                    g->arr[j][i]=f;\n                    x=0;\n                }\n                else\n                    printf(\"Invalid input. Try again.\\n\");\n            }\n        }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__SinglePartitionDemoFirmwareUpdateInfoSerialReader.0.c", "original_string": "void firmwareUpdateInfoReader_init(void)\n{\n  FirmwareUpdateInfoParser__init(&updateInfoParser);\n  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);\n  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));\n  memset(updateVerificationData, 0, updateVerificationDataSize);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__check_bit_on_off.0.c", "original_string": "BOOL CheckBit(int iNo)\n{\n    int iMask = 0X00800000;\n    int iResult = 0;\n    if(iNo < 0)\n    {\n        iNo = -iNo;\n    }\n    iResult = iNo & iMask;\n    if(iResult == iMask)\n    {\n        return TRUE;\n    }\n    else\n    {\n        return FALSE;\n    }\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__sender.3.c", "original_string": "int send_frame(unsigned char *frame, unsigned int frame_len){\n    FILE *file = fopen(\"pipe.bin\", \"wb+\");\n    if(file == NULL)\n    {\n        printf(\"[INFO] File open error!\\n\");\n        return 0;\n    }\n    fwrite(&frame_len,sizeof(frame_len),1,file);\n    fwrite(frame, sizeof(char), frame_len, file);\n    fclose(file);\n    printf(\"[INFO] Frame send success!\\n\");\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__list-del-rev.0.c", "original_string": "node* createNode(node* head, int n)\n{\n    node* newnode=malloc(sizeof(node));\n    newnode->data=n;\n    newnode->next=head;\n    return newnode;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_08.4.c", "original_string": "int getMax(int arr[], int n) {\n    int mx = arr[0];\n    int i;\n    for (i = 1; i < n; i++)\n        if (arr[i] > mx)\n            mx = arr[i];\n    return mx;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__LLqueue.3.c", "original_string": "void display(nptr &head)\n{\n    if (head == NULL)\n    {   \n        printf(\"EMPTY\\n\");\n        return;\n    }\n    nptr curr = head;\n    while(curr)\n    {\n        printf(\"    %d \\n\", curr -> data);\n        curr = curr -> next;\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__util.3.c", "original_string": "int countplaces(int n) {\n    int places = 1;\n    int divisor = 1;\n    if(n < 0) {\n        n = -n;\n        places++;\n    }\n    while(n / divisor >= 10) {\n        places++;\n        divisor *= 10;\n    }\n    return places;\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__select.0.c", "original_string": "void main() \n{\n    fd_set readfd;\n        char ch;\n    FD_ZERO(&readfd);\n    FD_SET(0,&readfd);\n    struct timeval tm;\n    tm.tv_sec=5;\n    tm.tv_usec=3000000;\n    int ret=select(1,&readfd,NULL,NULL,&tm);\n    if(ret==-1)\n    {\n        printf(\"SEL-ERR\");\n        exit(0);\n    }\n    else if(ret==0)\n    {\n    printf(\"Timeout Occured\");\n    }\n    else\n    {   \n        if(FD_ISSET(0,&readfd))\n        {\n            scanf(\"%c\",&ch);\n            printf(\"The character is %c\\n\",ch);\n        }\n    }   \n}"}
{"author": "flora0110", "file": "hw01git__check_ans_2-2.1.c", "original_string": "char*** make3darr(int rows, int cols,int hei){\n    char ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}"}
{"author": "earth429", "file": "mulpre__warizan.1.c", "original_string": "int divide(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c, struct NUMBER *d) {\n    struct NUMBER m, n, p, q;\n    if(getSign(a) > 0 && getSign(b) < 0){ \n        getAbs(b, &p);\n        divide(a, &p, c, d);\n        setSign(c, -1);\n        return 0; \n    } else if(getSign(a) < 0 && getSign(b) > 0){ \n        getAbs(a, &p);\n        divide(&p, b, c, d);\n        setSign(c, -1);\n        setSign(d, -1);\n        return 0; \n    } else if(getSign(a) < 0 && getSign(b) < 0) { \n        getAbs(a, &p);\n        getAbs(b, &q);\n        divide(&p, &q, c, d);\n        setSign(d, -1);\n        return 0; \n    }\n    clearByZero(c);\n    clearByZero(d);\n    if(isZero(b) != -1){ \n        return -1;\n    }\n    copyNumber(a, &n);\n    while(1){\n        if(numComp(&n, b) != -1){ \n            increment(c, &m);\n            copyNumber(&m, c);\n            sub(&n, b, &m);\n            copyNumber(&m, &n);\n        } else { \n            copyNumber(&n, d);\n            break;\n        }\n    }\n    return 0;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_01.1.c", "original_string": "void display(int A[],int n)\n{\n        int i;\n        for(i=0;i<n;i++)\n        {\n                fprintf(F2,\"%d \",A[i]);\n        }\n        fprintf(F2,\"\\n\");\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_29.2.c", "original_string": "int main() {\n    setlocale(LC_ALL, \"\");\n    int numero[6];\n    for (int i = 0; i < 6; i++) {\n        printf(\"Preencha o valor numero %d\\n\", i);\n        scanf(\"%d\", &numero[i]);\n    }\n    system(\"cls\");\n    calcularTotal(numero);\n    imprimirResultados();\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q11.2.c", "original_string": "void push(stack* ps, char x)\n{\n    if(ps->top == MAX - 1)\n        isFull();\n    else\n        ps->item[++(ps->top)] = x;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__ft_prime_sum.4.c", "original_string": "int     ft_add_prime_sum(int nb)\n{\n    int     i;\n    int     sum;\n    i = 2;\n    sum = 0;\n        if (nb <= 0)\n            return (0);\n    while (i <= nb)\n    {\n        if (ft_is_prime(i))\n            sum += i;\n        i++;\n    }\n    return (sum);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__multiple_isr.2.c", "original_string": "void intr_config(void)\n{\n        VICIntSelect = VICIntSelect & ~((1<<4)|(1<<5)|(1<<15)); \n        VICVectCntl2 = (1<<5)|4;   \n        VICVectAddr2 = (long)&timer0_isr;\n        VICVectCntl1 = (1<<5)|5;   \n        VICVectAddr1 = (long)&timer1_isr;\n        VICVectCntl3 = (1<<5)|15;   \n        VICVectAddr3 = (long)&ext_isr;\n        VICIntEnable = (1<<5)|(1<<4)|(1<<15);   \n        EXTMODE = 1<<1; \n        EXTPOLAR = 1<<1;    \n}"}
{"author": "haon1026", "file": "linux-programming__ls-wc.1.c", "original_string": "int main()\n{\n    int fd[2];\n    int ret = pipe(fd);\n    if(ret == -1)\n        sys_error(\"pipe error\");\n    pid_t pid = fork();\n    if(pid == -1)\n    {   \n        sys_error(\"fork error\");\n    }\n    else if (pid > 0)\n    {\n        close(fd[1]);\n        dup2(fd[0], STDIN_FILENO);\n        execlp(\"wc\", \"wc\", \"-l\", NULL);\n        sys_error(\"execlp wc error\");\n    }\n    else if (pid == 0)\n    {\n        close(fd[0]);\n        dup2(fd[1], STDOUT_FILENO);\n        execlp(\"ls\", \"ls\", NULL);\n        sys_error(\"execlp ls error\");\n    }\n    return 0;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__18_.1.c", "original_string": "void Columnas(int contador, int pibote){\n        if(contador <= 19){\n                if(contador == (1 + pibote) || contador == (19 - pibote))\n                        printf(\"Z\");\n                else\n                        printf(\" \");\n                Columnas(++contador, pibote);\n        }\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__ArmStrongNumWithoutPow.0.c", "original_string": "int main()\n{\n    int n;\n    int count = 0;\n    printf(\"enter a number:\");\n    scanf(\"%d\",&n);\n    int temp = n;\n    while(temp!=0)\n    {\n        count++;\n        temp/=10;\n    }\n    printf(\"count:%d\\n\",count);\n    int rem = 0, sum = 0;\n    int t = n;\n    int i;\n    while(t!=0)\n    {\n        int mul=1;\n        rem = t%10;\n        for(i=1;i<=count;i++)\n        {\n            mul = mul*rem;\n        }\n        printf(\"Power of %d is : %d\\n\",rem,mul);\n        sum = sum+mul;\n        t = t/10;   \n    }\n    if(sum == n)\n    {\n        printf(\"ARMSTRONG NUMBER\");\n    }\n    else\n    printf(\"NOT ARMSTRONG NUMBER\");\n    return 0;\n}"}
{"author": "ria3999", "file": "cbnst__LAGRANGES_INTERPOLATION.0.c", "original_string": "int main()\n{\n    int m,i,j;\n    float Y[20][20]={0},x,res=1.0,sum=0;\n    printf(\"\\n\\n\\t\\t\\t\\t***INPUT*\");\n    printf(\"\\nEnter the limit:\");\n    scanf(\"%d\",&m);\n    printf(\"\\nEnter the elements of x and y:\");\n    for(i=0;i<m;i++)\n    {\n        for(j=0;j<2;j++)\n            scanf(\"%f\",&Y[i][j]);\n    }\n    printf(\"\\nThe table entered is:\\n\");\n     for(i=0;i<m;i++)\n    {\n        for(j=0;j<2;j++)\n            printf(\"%0.3f  \",Y[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\nEnter the value of x to find y:\");\n    scanf(\"%f\",&x);\n    printf(\"\\n\\n\\t\\t\\t\\t***OUTPUT*\\n\");\n    for(i=0;i<m;i++)\n    {\n        res=1.0;\n        for(j=0;j<m;j++)\n        {\n            if(j!=i)\n                res*=((x-Y[j][0])*1.0)/(Y[i][0]-Y[j][0]);\n            else\n                continue;\n        }\n        sum+=res*Y[i][1];\n    }\n    printf(\"The value of y at x=%0.3f is %0.3f\",x,sum);\n}"}
{"author": "augustogunsch", "file": "jackc__parser-structure.2.c", "original_string": "int parsepossibilities(PARSER* p, STRINGARRAY* poss) {\n    for(int i = 0; i < poss->size; i++)\n        if(equals(p, poss->items[i]))\n            return i;\n    return -1;\n}"}
{"author": "dishanp", "file": "DSA__q34.5.c", "original_string": "int delete_index(struct node *p, int index)\n{\n    if(index < 0 || index > length(first))\n    {\n        printf(\"\\nInvalid index\\n\");\n        return -1;\n    }\n    struct node *q = p;\n    int x = 0;\n    if(index == 1)\n    {\n        q = first;\n        x = first->data;\n        first = first->next;\n        free(q);\n        return x;\n    }\n    else\n    {\n        for(int i = 0 ; i < index - 1; i++)\n        {\n            q = p;\n            p = p->next;\n        }\n        q->next = p->next;\n        x = p->data;\n        free(p);\n        return x;\n    }\n}"}
{"author": "theuwis", "file": "AdventOfCode2015__main28.0.c", "original_string": "int main(void){\n    long house_nr = 0, nr_presents = 0;\n    while(1){\n        for(long i = 1; i <= house_nr; i++){\n            if((house_nr%i == 0) && (house_nr / i < 50)){   \n                    nr_presents += i * 11;\n            }\n        }\n        if(nr_presents >= 33100000){\n            printf(\"answer=%ld\\n\", house_nr);\n            break;\n        }\n        if(house_nr%10000 == 0)\n            printf(\"%ld - %ld\\n\", house_nr, nr_presents);\n        house_nr++;\n        nr_presents = 0;\n    }\n    return EXIT_SUCCESS;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_any_pos_DLL.0.c", "original_string": "int main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of element in the linked list\\n\");\n    printf(\"4.insert an element at any position\\n\");\n    printf(\"5.exit\\n\");\n    int choice;\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=5)\n    {\n        switch(choice)\n        {\n            case 1: printf(\"implementation\\n\");\n            creat();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of element in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"inserting the element at any position\\n\");\n            insert_at_pos();\n            break;\n            case 5:printf(\"exit \\n\");\n            exit(0);\n            break;\n            default:printf(\"invalied choice \\n\");\n            break;\n        }\n         printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_6.7.c", "original_string": "void delvalue(int value)\n{\n    struct node* temp = root, *p, *q;\n    if(root->data == value)\n    {\n        root = temp->right;\n        free(temp);\n    }\n    else if(search(value) == 1)\n    {\n        while(temp->data != value)\n        {\n            temp = temp->right;\n        }\n        q = temp->right;\n        p = temp->left;\n        if(temp->right != NULL)\n        {\n            p->right = q;\n            q->left = p;\n            free(temp);\n        }\n        else\n        {\n            p->right = NULL;\n            free(temp);\n        }\n    }\n    else\n    {\n        printf(\"Value not found in the list.\\n\\n\");\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__insert_a_node_in_circular_linked_list.1.c", "original_string": "void createList(int n)\n{\n    int i, data;\n    struct node *prevNode, *newNode;\n        head = (struct node *)malloc(sizeof(struct node));\n        printf(\"Enter data of 1 node: \");\n        scanf(\"%d\", &data);\n        head->data = data;\n        head->next = NULL;\n        prevNode = head;\n        for(i=2; i<=n; i++)\n        {\n            newNode = (struct node *)malloc(sizeof(struct node));\n            printf(\"Enter data of %d node: \", i);\n            scanf(\"%d\", &data);\n            newNode->data = data;\n            newNode->next = NULL;\n            prevNode->next = newNode;\n            prevNode = newNode;\n        }\n        prevNode->next = head;\n}"}
{"author": "MFarid94", "file": "Assignment-2__Exercise8.0.c", "original_string": "void display_prime(int num1, int num2){\n    int number = num1;\n    int rem_of_two, rem_of_three;                           \n    for (int i = num1; i<=num2 ; ){\n        rem_of_two = number % 2;\n        rem_of_three = number % 3;\n        if(number == 2 || number == 3){\n                printf(\"%d \",number);                                               \n            }\n            else{\n                if( rem_of_two == 0 || rem_of_three == 0){\n                    i++;\n                    number++;\n                    continue;\n                }\n                else{\n                    printf(\"%d \",number);\n                }\n            }\n        i++;\n        number++;\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_last_CLL.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.insert the element at the last position \\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"insert the element at the last position \\n\");\n            insert_end();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad6MatrixCopy.0.c", "original_string": "int main()\n{\n   int array1[7][3] = {\n        {8, 32, -4},\n        {5, 6, 93},\n        {345, 32, -32},\n        {3, 3, -3},\n        {-6, -5, -5},\n        {0, 0, 0},\n        {0, 2, -2}\n        };\n   int array2[7][3];\n   int array3[7][3];\n   int arraySizeOut = sizeof(array1)/sizeof(*array1);\n   int arraySizeIn = sizeof(array1[0])/sizeof(*array1[0]);\n    for(int i = 0; i < arraySizeOut; i++){\n        copyArrayNormal(array1[i], array2[i], arraySizeIn);\n    }\n    for(int i = 0; i < arraySizeOut; i++){\n        copyArrayPointer(array1[i], array3[i], arraySizeIn);\n    }\n    printf(\"array1\");\n    for(int i = 0; i < arraySizeOut; i++){\n        printf(\"\\nPodtablica: \");\n        for(int j = 0; j < arraySizeIn; j++){\n            printf(\"%d \", array1[i][j]);\n        }\n    }\n    printf(\"\\n\\narray2\");\n    for(int i = 0; i < arraySizeOut; i++){\n        printf(\"\\nPodtablica: \");\n        for(int j = 0; j < arraySizeIn; j++){\n            printf(\"%d \", array2[i][j]);\n        }\n    }\n    printf(\"\\n\\narray3\");\n    for(int i = 0; i < arraySizeOut; i++){\n        printf(\"\\nPodtablica: \");\n        for(int j = 0; j < arraySizeIn; j++){\n            printf(\"%d \", array3[i][j]);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_nus_c.7.c", "original_string": "uint32_t ble_nus_c_tx_notif_enable(ble_nus_c_t * p_ble_nus_c)\n{\n        VERIFY_PARAM_NOT_NULL(p_ble_nus_c);\n        if ( (p_ble_nus_c->conn_handle == BLE_CONN_HANDLE_INVALID)\n             ||(p_ble_nus_c->handles.nus_tx_cccd_handle == BLE_GATT_HANDLE_INVALID)\n             )\n        {\n                return NRF_ERROR_INVALID_STATE;\n        }\n        return cccd_configure(p_ble_nus_c->conn_handle,p_ble_nus_c->handles.nus_tx_cccd_handle, true);\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad4.4.c", "original_string": "int zbroj(pozicija p, pozicija q, pozicija r)\n{\n    while (p->next != NULL && q->next != NULL)\n    {\n        pozicija s = NULL;\n        s = (pozicija)malloc(sizeof(struct polinom));\n        if (s == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        s->next = NULL;\n        if (p->next->eksponent < q->next->eksponent)\n        {\n            s->eksponent = p->next->eksponent;\n            s->koeficijent = p->next->koeficijent;\n            p = p->next;\n        }\n        else if (p->next->eksponent > q->next->eksponent)\n        {\n            s->eksponent = q->next->eksponent;\n            s->koeficijent = q->next->koeficijent;\n            q = q->next;\n        }\n        else\n        {\n            s->eksponent = p->next->eksponent;\n            s->koeficijent =(p->next->koeficijent + q->next->koeficijent);\n            p = p->next;\n            q = q->next;\n        }\n        r->next = s;\n        r = s;\n    }\n    pozicija temp;\n    if (p->next == NULL)\n        temp = q->next;\n    else\n        temp = p->next;\n    while (temp != NULL)\n    {\n        pozicija s = NULL;\n        s = (pozicija)malloc(sizeof(struct polinom));\n        if (s == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        s->next = NULL;\n        s->eksponent = temp->eksponent;\n        s->koeficijent = temp->koeficijent;\n        r->next = s;\n        r = s;\n        temp = temp->next;\n    }\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__ext3_intr.4.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__test3.0.c", "original_string": "unsigned short Checksum(unsigned char* buffer, unsigned short size){\n    unsigned int sum = 0;\n    unsigned short cksum;\n    unsigned char lower,higher;\n    unsigned short temp;\n    while(size > 1){\n        lower = buffer[size-1];\n        higher = buffer[size - 2];\n        temp = higher;\n        temp = (temp << 8) + lower;\n        printf(\"%04x\\n\",temp);\n        sum += temp;\n        size -= 2;\n    }\n    if(size == 1){  \n        lower = buffer[size-1];\n        higher = 0x00;\n        temp = higher;\n        temp = (temp << 8) + lower;\n        sum += temp;\n    }\n    cksum = (sum >> 16) + (sum & 0xffff);\n    cksum = ~cksum;\n    printf(\"%04x\\n\",cksum);\n    return cksum;\n}"}
{"author": "augustogunsch", "file": "jackc__io.10.c", "original_string": "FILELIST* getsinglefile(char* file) {\n    int len = strlen(file);\n    if(isdotjack(file, len)){\n        char* name = getname(file, len);\n        char* fullname = heapstr(file, len);\n        FILE* input = fopen(fullname, \"r\");\n        if(input == NULL) {\n            eprintf(\"Error while reading file '%s': %s\\n\", file, strerror(errno));\n            exit(errno);\n        }\n        fclose(input);\n        return addfile(NULL, fullname, name);\n    }\n    else {\n        eprintf(\"Input file must be named like 'Xxx.vm'\\n\");\n        exit(1);\n    }\n}"}
{"author": "behergue", "file": "Operating_Systems__simulator.5.c", "original_string": "void Autobus_En_Parada(){\n    printf(\"EL bus est\u00e1 en la parada %d \\n\", parada_actual);\n    estado = EN_PARADA;\n    pthread_mutex_lock(&esperaSubir[parada_actual]);\n    pthread_mutex_lock(&esperaBajar[parada_actual]);\n    n_ocupantes -= esperando_bajar[parada_actual];\n    int usuarios_suben = min(MAX_USUARIOS-n_ocupantes, esperando_parada[parada_actual]);\n    n_ocupantes += usuarios_suben;\n    pthread_cond_broadcast(&bajan);\n    int j;\n    for(j = 0; j < usuarios_suben; j++){\n        pthread_cond_broadcast(&suben);\n    }\n    while(esperando_parada[parada_actual] > 0 || esperando_bajar[parada_actual] > 0){\n        if(esperando_bajar[parada_actual] > 0 && esperando_parada[parada_actual] == 0)\n            pthread_cond_wait(&hanBajado, &esperaBajar[parada_actual]);\n        else if(esperando_bajar[parada_actual] == 0 && esperando_parada[parada_actual] > 0)\n            pthread_cond_wait(&hanSubido, &esperaSubir[parada_actual]);\n        else{\n            pthread_mutex_unlock(&esperaSubir[parada_actual]);\n            pthread_cond_wait(&hanBajado, &esperaBajar[parada_actual]);\n            pthread_mutex_lock(&esperaSubir[parada_actual]);\n        }\n    }\n    pthread_mutex_unlock(&esperaSubir[parada_actual]);\n    pthread_mutex_unlock(&esperaBajar[parada_actual]);\n    estado = EN_RUTA;\n    printf(\"El bus est\u00e1 en ruta \\n\");\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q1.0.c", "original_string": "nptr createNode(int x)\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp->lchild = temp->rchild = NULL;\n    temp->data = x;\n    return temp;\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_3_2_4.0.c", "original_string": "int main()\n{\n    int number1, number2;\n    printf(\"Podaj liczbe calkowita nr 1: \");\n    scanf(\"%d\", &number1);\n    printf(\"Podaj liczbe calkowita nr 2: \");\n    scanf(\"%d\", &number2);\n    printf(\"\\nLiczba1: %d     Liczba2: %d\\n\\n\", number1, number2);\n    change(&number1, &number2);\n    printf(\"Liczba1: %d     Liczba2: %d\\n\\n\", number1, number2);\n    getchar();\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q4_poly.1.c", "original_string": "void polyadd(struct Node *poly1, struct Node *poly2, struct Node *poly) \n{ \n    while(poly1->next && poly2->next) \n    { \n        if(poly1->pow > poly2->pow) \n        { \n            poly->pow = poly1->pow; \n            poly->coeff = poly1->coeff; \n            poly1 = poly1->next; \n        } \n        else if(poly1->pow < poly2->pow) \n        { \n            poly->pow = poly2->pow; \n            poly->coeff = poly2->coeff; \n            poly2 = poly2->next; \n        } \n        else\n        { \n            poly->pow = poly1->pow; \n            poly->coeff = poly1->coeff+poly2->coeff; \n            poly1 = poly1->next; \n            poly2 = poly2->next; \n        } \n        poly->next = (struct Node *)malloc(sizeof(struct Node)); \n        poly = poly->next; \n        poly->next = NULL; \n    } \n    while(poly1->next || poly2->next) \n    { \n        if(poly1->next) \n        { \n            poly->pow = poly1->pow; \n            poly->coeff = poly1->coeff; \n            poly1 = poly1->next; \n        } \n        if(poly2->next) \n        { \n            poly->pow = poly2->pow; \n            poly->coeff = poly2->coeff; \n            poly2 = poly2->next; \n        }\n        poly->next = (struct Node *)malloc(sizeof(struct Node)); \n        poly = poly->next; \n        poly->next = NULL; \n    } \n}"}
{"author": "Theemiss", "file": "simple_shell__more_fun.1.c", "original_string": "char *_strcat(char *dest, char *src)\n{\n    char *s = dest;\n    while (*dest != '\\0')\n    {\n        dest++;\n    }\n    while (*src != '\\0')\n    {\n        *dest = *src;\n        dest++;\n        src++;\n    }\n    *dest = '\\0';\n    return (s);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__WiFiStationDrv0.0.c", "original_string": "void wifi_init(void)\n{\n  tcpip_adapter_init();\n  esp_event_loop_init(&wifiEventHandlerCallback, NULL);\n  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();\n  esp_wifi_init(&cfg);\n  esp_wifi_set_mode(WIFI_MODE_STA);\n  esp_wifi_set_storage(WIFI_STORAGE_RAM);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__lcd.4.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}"}
{"author": "kalpa96", "file": "Struct__all.0.c", "original_string": "int main() {\n    int i;\n    printf(\"Enter information of students:\\n\");\n    for (i=0;i<11;++i) {\n        s[i].no = i+1;\n        printf(\"\\nStudent 0%d\\n\", s[i].no);\n        printf(\"Enter ID number : \");\n        scanf(\"%d\",&s[i].id);\n        printf(\"Enter name : \");\n        scanf(\"%s\",&s[i].name);\n        printf(\"Enter age : \");\n        scanf(\"%d\",&s[i].age);\n        printf(\"Enter address : \");\n        scanf(\"%s\",&s[i].address);\n        printf(\"Enter marks : \");\n        scanf(\"%f\",&s[i].marks);\n    }\n    printf(\"\\nDisplaying Information:\\n\");\n    for (i=0;i<11;i++){\n        if(s[i].age==14){\n            printf(\"Name : \");\n            puts(s[i].name);\n        }\n    }\n    return 0;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__14_.2.c", "original_string": "void Filas(int contador)\n{\n        if(contador < 8){\n                Columnas(1, (contador-1));\n                printf(\"\\n\");\n                Filas(++contador);\n        }\n}"}
{"author": "mandarvu", "file": "msc__problem71.3.c", "original_string": "int main() {\n  int v1, num;\n  printf(\"1...Prime Check\\n\");\n  printf(\"2...Armstrong Check\\n\");\n  printf(\"3...Perfect number Check\\n\");\n  scanf(\"%d\",&v1);\n  switch (v1) {\n    case 1:\n      printf(\"Enter a number.\\n\");\n      scanf(\"%d\",&num);\n      printf(\"%d is a %s\\n\",num, prime(num) ? \"not prime\" : \"prime\");\n      break;\n    case 2:\n      printf(\"Enter a number.\\n\");\n      scanf(\"%d\",&num);\n      printf(\"%d is a %s\\n\",num, Armstrong(num) ? \"Armstrong number.\" : \"not Armstrong number.\");\n      break;\n    case 3:\n      printf(\"Enter a number.\\n\");\n      scanf(\"%d\",&num);\n      printf(\"%d is a %s\\n\",num, perf_check(num) ? \"perfect\" : \"not perfect\");\n      break;\n    default:\n      printf(\"ERROR (invalid input)\\n\");\n      exit(1);\n  }\n  return 0;\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__socoptions.0.c", "original_string": "void main()\n{\n    int sockopt,sockid,optlen,gs;\n    sockid=socket(AF_INET,SOCK_STREAM,0);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    optlen=sizeof(sockopt);\n    gs=getsockopt(sockid,SOL_SOCKET,SO_TYPE,&sockopt,&optlen);\n    if(gs==-1)\n    {\n        perror(\"GETSOCK-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    switch(sockopt)\n    {\n        case SOCK_DGRAM:printf(\"\\nDatagram Socket\\n\");\n                break;\n        case SOCK_STREAM:printf(\"\\nStream Socket\\n\");\n                break;\n        case SOCK_RAW:printf(\"\\nRaw Socket\\n\");\n                break;\n        default:printf(\"\\nUnknown Socket type\\n\");\n    }\n    sockopt=2048;\n    optlen=sizeof(sockopt);\n    gs=setsockopt(sockid,SOL_SOCKET,SO_SNDBUF,&sockopt,optlen);\n    if(gs!=-1)\n    printf(\"\\nSend Buffer size is %d\\n\",sockopt);\n    else\n    perror(\"SND-BUF-ERR:\");\n    optlen=sizeof(sockopt);\n    gs=getsockopt(sockid,SOL_SOCKET,SO_SNDBUF,&sockopt,&optlen);\n    if(gs!=-1)\n    printf(\"\\nSend buffer size is %d\\n\",sockopt);\n    else\n    perror(\"SND-BUF-ERR:\");\n    sockopt=2048;\n    optlen=sizeof(sockopt);\n    gs=setsockopt(sockid,SOL_SOCKET,SO_RCVBUF,&sockopt,optlen);\n    if(gs!=-1)\n    printf(\"\\nReceive Buffer size is %d\\n\",sockopt);\n    else\n    perror(\"RCV-BUF-ERR:\");\n    optlen=sizeof(sockopt);\n    gs=getsockopt(sockid,SOL_SOCKET,SO_RCVBUF,&sockopt,&optlen);\n    if(gs!=-1)\n    printf(\"\\nReceive Buffer size is %d\\n\",sockopt);\n    else\n    perror(\"RCV-BUF-ERR:\");\n    optlen=sizeof(sockopt);\n    gs=getsockopt(sockid,IPPROTO_TCP,TCP_MAXSEG,&sockopt,&optlen);\n    if(gs!=-1)\n    printf(\"\\nTCP MAX Segment size is %d\\n\",sockopt);\n    else\n    perror(\"TCP-SEG-ERR:\");\n    optlen=sizeof(sockopt);\n    sockopt=1;\n    gs=setsockopt(sockid,IPPROTO_TCP,TCP_NODELAY,&sockopt,optlen);\n    if(gs!=-1)\n    printf(\"\\nNODELAY FLAG is set\\n\");\n    else\n    perror(\"TCP-NODELAY-ERR:\");\n    optlen=sizeof(sockopt);\n    gs=getsockopt(sockid,IPPROTO_TCP,TCP_NODELAY,&sockopt,&optlen);\n    if(gs!=-1)\n    if(sockopt==1)\n    printf(\"\\nNODELAY flag is set\\n\");\n    else\n    printf(\"\\nNODELAY flag not set\\n\");\n    else\n    perror(\"TCP-NODELAY-ERR:\");\n    close(sockid);\n}"}
{"author": "earth429", "file": "mulpre__decrement.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a, b;\n    int return_val;\n    setInt(&a, 1);\n    return_val = decrement(&a, &b);\n    dispNumberZeroSuppress(&a);\n    dispNumberZeroSuppress(&b);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_SLL.4.c", "original_string": "void insert_beg()\n{\n    struct node *newnode;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    newnode->next=head;\n    head=newnode;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.10.c", "original_string": "void adjustNode(struct btreeNode *myNode, int pos) {\n        if (!pos) {\n                if (myNode->link[1]->count > MIN) {\n                        doLeftShift(myNode, 1);\n                } else {\n                        mergeNodes(myNode, 1);\n                }\n        } else {\n                if (myNode->count != pos) {\n                        if(myNode->link[pos - 1]->count > MIN) {\n                                doRightShift(myNode, pos);\n                        } else {\n                                if (myNode->link[pos + 1]->count > MIN) {\n                                        doLeftShift(myNode, pos + 1);\n                                } else {\n                                        mergeNodes(myNode, pos);\n                                }\n                        }\n                } else {\n                        if (myNode->link[pos - 1]->count > MIN)\n                                doRightShift(myNode, pos);\n                        else\n                                mergeNodes(myNode, pos);\n                }\n        }\n  }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__options.0.c", "original_string": "int     main(int argc, char **argv)\n{\n    int i = 1;\n    int t[32] = {0};\n    int j = 0;\n    if (argc == 1)\n    {\n        write(1, \"options: abcdefghijklmnopqrstuvwxyz\\n\", 36);\n        return (0);\n    }\n    i = 1;\n    while (i < argc)\n    {\n        j = 1;\n        if (argv[i][0] == '-')\n        {\n            while (argv[i][j] && argv[i][j] >= 'a' && argv[i][j] <= 'z')\n            {\n                if (argv[i][j] == 'h')\n                {\n                    write(1, \"options: abcdefghijklmnopqrstuvwxyz\\n\", 36);\n                    return (0);\n                }\n                t['z' - argv[i][j] + 6] = 1;\n                j++;\n            }\n            if (argv[i][j])\n            {\n                write(1, \"Invalid Option\\n\", 15);\n                return (0);\n            }\n            j++;\n        }\n        i++;\n    }\n    i = 0;\n    while (i < 32)\n    {\n        t[i] = '0' + t[i];\n        write(1, &t[i++], 1);\n        if (i == 32)\n            write(1, \"\\n\", 1);\n        else if (i % 8 == 0)\n            write(1, \" \", 1);\n    }\n    return (0);\n}"}
{"author": "earth429", "file": "mulpre__simpleDivide.1.c", "original_string": "int simpleDivide(int x, int y, int * z, int * w){\n    int k;\n    int x_abs, y_abs;\n    if(y == 0){\n        return -1;\n    }\n    if(x == 0){\n        z = 0;\n        w = 0;\n        return 0;\n    }\n    if(x > 0 && y > 0){\n        k = 0;\n        while(1){\n            if(x < y){\n                break;\n            }\n            x -= y;\n            k++;\n        }\n        *z = k; \n        *w = x; \n    } else if(x > 0 && y < 0){\n        y_abs = abs(y);\n        simpleDivide(x, y_abs, z, w);\n        *z *= -1;\n        *w *= -1;\n    } else if(x < 0 && y > 0){\n        x_abs = abs(x);\n        simpleDivide(x_abs, y, z, w);\n        *z *= -1;\n        *w *= -1;\n    } else {\n        x_abs = abs(x);\n        y_abs = abs(y);\n        simpleDivide(x_abs, y_abs, z, w);\n    }\n    return 0;\n}"}
{"author": "dishanp", "file": "DSA__q3.1.c", "original_string": "int *add(int A[], int B[], int n, int m)\n{\n    int max;\n    if(m>n)\n        max = m;\n    else\n        max = n;\n    int *sum = (int*)malloc(max*sizeof(int));\n    for (int i = 0; i<n; i++)\n        sum[i] = A[i];\n    for (int i=0; i<m; i++)\n        sum[i] += B[i];\n    printPoly(sum, max);\n    return sum;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linearBinarySearch.2.c", "original_string": "int main(){\n     int arr[] = {1,3,5,7,9,56,574,594,599,632};\n     int size = sizeof(arr)/sizeof(int);\n     int element = 6;\n     int searchIndex = binarySearch(arr,size,element);\n     printf(\"The element %d was found at index %d \\n\", element, searchIndex);\n     return 0;\n}"}
{"author": "haon1026", "file": "linux-programming__rwlock.0.c", "original_string": "void *thread_write(void *arg)\n{\n    int t;\n    int i = (int)arg;\n    while(1)\n    {\n        pthread_rwlock_wrlock(&rwlock);     \n        t = counter;\n        usleep(1000);       \n        printf(\"write %d:%lu: counter=%d ++counter=%d\\n\", i, pthread_self(), t, ++counter);\n        pthread_rwlock_unlock(&rwlock);\n        usleep(10000);\n    }\n    return NULL;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_CLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_c_extended.8.c", "original_string": "uint32_t ble_lbs_c_button_notif_enable(ble_lbs_c_t * p_ble_lbs_c)\n{\n    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c);\n    if (p_ble_lbs_c->conn_handle == BLE_CONN_HANDLE_INVALID)\n    {\n        return NRF_ERROR_INVALID_STATE;\n    }\n    return cccd_configure(p_ble_lbs_c->conn_handle,\n                          p_ble_lbs_c->peer_lbs_db.button_cccd_handle,\n                          true);\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__brackets.0.c", "original_string": "int     matching(char b1, char b2)\n{\n    if (b1 == '(' && b2 == ')')\n        return (1);\n    if (b1 == '[' && b2 == ']')\n        return (1);\n    if (b1 == '{' && b2 == '}')\n        return (1);\n    return (0);\n}"}
{"author": "TSN-SHINGENN", "file": "libmddl__mddl_malloc0.1.c", "original_string": "void *mddl_realloc_align(void *memblk, const size_t alignment,\n                const size_t size)\n{\n    int result;\n    void *mem;\n    result = mddl_malloc_align(&mem, alignment, size);\n    if (result) {\n    return NULL;\n    }\n    memcpy(mem, memblk, size);\n    mddl_mfree(memblk);\n    return mem;\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_freertos.16.c", "original_string": "bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   portBASE_TYPE ret;\n   if(timeout == INFINITE_DELAY)\n   {\n      ret = xSemaphoreTake(semaphore->handle, portMAX_DELAY);\n   }\n   else\n   {\n      ret = xSemaphoreTake(semaphore->handle, OS_MS_TO_SYSTICKS(timeout));\n   }\n   return ret;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__tipos_datos_size.0.c", "original_string": "int main(){\n    float f;\n    double d;\n    long double ld;\n    int i;\n    long l;\n    long long ll;\n    char c = 97;\n    short s;\n    int array[10] = {1, 2, 3, 4, 5, 6, 7, 10};\n    int *p_array = array;\n    printf(\"Tama\u00f1o de c es: %lu, el tama\u00f1o de char es:  %lu\\n\", sizeof c, sizeof(char));\n    printf(\"Tama\u00f1o de i es: %lu, el tama\u00f1o de int es:  %lu\\n\", sizeof i, sizeof(int));\n    printf(\"Tama\u00f1o de s es: %lu, el tama\u00f1o de short es:  %lu\\n\", sizeof s, sizeof(short));\n    printf(\"Tama\u00f1o de l es: %lu, el tama\u00f1o de long es:  %lu\\n\", sizeof l, sizeof(long));\n    printf(\"Tama\u00f1o de ll es: %lu, el tama\u00f1o de long long es:  %lu\\n\", sizeof l, sizeof(long long));\n    printf(\"Tama\u00f1o de f es: %lu, el tama\u00f1o de float es:  %lu\\n\", sizeof f, sizeof(float));\n    printf(\"Tama\u00f1o de d es: %lu, el tama\u00f1o de double es:  %lu\\n\", sizeof d, sizeof(double));\n    printf(\"Tama\u00f1o de ld es: %lu, el tama\u00f1o de long double es:  %lu\\n\", sizeof ld, sizeof(long double));\n    printf(\"Tama\u00f1o del arreglo es %lu\\n\", sizeof array);\n    printf(\"Tama\u00f1o del size_t es %lu\\n\", sizeof(size_t));\n    printf(\"Tama\u00f1o del apuntador al arreglo es %lu\\n\", sizeof p_array);\n    printf(\"*p_array %d\\n\", *p_array);\n    printf(\"p_array %p\\n\", p_array);\n    return false;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__i2c.1.c", "original_string": "void i2c_config(void)\n{\n    PINSEL0 |= (1<<4)|(1<<6);           \n    PINSEL0 &= ~((1<<5)|(1<<7));\n    I2CONSET    = 1<<6;     \n    I2SCLH = 75;                \n    I2SCLL = 75;\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__Hackerrankques2.0.c", "original_string": "int main()\n{\n    int k,n;\n    scanf(\"%d\", &n);\n    scanf(\"%d\", &k);\n    gateOperation(n,k);\n    return 0;\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b2.4.c", "original_string": "bool is_pid(char *field, size_t n) {\n    if (n != 9) return false;\n    for (size_t i = 0; i < n; i++) {\n        if (!isdigit(field[i])) return false;\n    }\n    return true;\n}"}
{"author": "sdukesameer", "file": "c__sort-structure.2.c", "original_string": "void dispStudents ( StudentType students[], int n ) {\n    int i;\n    for (i=0; i<n; i++)\n        printf(\"#%d Roll: %d | Name:%s\\n\",i+1, students[i].rollNo, students[i].name );\n}"}
{"author": "paawankohli", "file": "CN-Lab__udps.0.c", "original_string": "void main () {\n    int serverfd = socket(AF_INET, SOCK_DGRAM, 0);\n    struct sockaddr_in seradd;\n    seradd.sin_family = AF_INET;\n    seradd.sin_port = 4000;\n    seradd.sin_addr.s_addr = INADDR_ANY;\n    bind(serverfd, (struct sockaddr *) &seradd, sizeof(seradd));\n    while (1) {\n        char buf[100];\n        struct sockaddr_in cliadd;\n        int len = sizeof(cliadd);\n        recvfrom(serverfd, buf, 100, 0, (struct sockaddr*) &cliadd, &len);\n        printf(\"Client: %s\\n\", buf);\n        strcpy(buf, \"Got it bro\");\n        sendto(serverfd, buf, 100, 0, (struct sockaddr*) &cliadd, len);\n    }\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__receiver.3.c", "original_string": "int receive_frame(){\n    FILE *file = fopen(\"pipe.bin\", \"r\");\n    fread(&frame_len,sizeof(frame_len),1,file);\n    printf(\"[INFO] frame length: %d\\n\",frame_len);\n    if(frame_len < 64){  \n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(frame_len >1518){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    fread(&frame,sizeof(char),frame_len,file);\n    memcpy(&des_addr,&frame[0],6);\n    memcpy(&sta_addr,&frame[6],6);\n    memcpy(&protocol,&frame[12],sizeof(protocol));\n    payload = &frame[14];    \n    if(!addr_check(des_addr))   exit(1);\n    init_crc_table();\n    unsigned int crc32_temp = crc32(frame,frame_len-4);\n    unsigned char crc32_result[4];\n    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));\n    int i = 0;\n    int flag_crc32 = 1;\n    for(i = 3;i<sizeof(crc32_result);i--){\n        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;\n    }\n    if(flag_crc32){\n        printf(\"[INFO] CRC32 check success!\\n\");\n    }else {\n        printf(\"[Error] CRC32 check error!\\n\");\n        printf(\"[Error] frame's CRC32 : \");\n        printf(\"%02x %02x %02x %02x\\n\",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);\n        printf(\"[Error] calculated CRC32 : \");\n        output_octal(crc32_result,4);\n        exit(1);\n    }\n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: \");\n    output_octal(sta_addr,6);\n    printf(\"Des address  : \");\n    output_octal(des_addr,6);\n    printf(\"protocol     : %d\\n\",protocol);\n    printf(\"payload      : \");\n    output_octal(payload,frame_len-6-6-2-4);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result,4);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] Frame received success!\\n\");\n}"}
{"author": "Oryx-Embedded", "file": "Common__str.1.c", "original_string": "char_t *strTrimWhitespace(char_t *s)\n{\n   char_t *end;\n   char_t *result;\n   while(isspace((uint8_t) *s))\n   {\n      s++;\n   }\n   result = s;\n   for(end = NULL; *s != '\\0'; s++)\n   {\n      if(!isspace((uint8_t) *s))\n         end = NULL;\n      else if(!end)\n         end = s;\n   }\n   if(end)\n      *end = '\\0';\n   return result;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__15_For.0.c", "original_string": "void Columna(int pibote)\n{\n    for(int i = 1; i <= 34; ++i)\n    {\n    if(i >= 28){\n        if(i >= (28 + pibote) && i <= 34 - pibote){\n        printf(\" \");\n        }else{\n        printf(\"A\");\n        }\n    }else{\n        printf(\" \");\n    }\n    }\n}"}
{"author": "bgmanuel99", "file": "PracticasArquitecturaDeComputadores__ejercicio2.0.c", "original_string": "int main(int argc, char **argv){\n  MPI_Init(NULL, NULL);\n double A[10000];\n double B[10000];\n int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n  if (world_size < 2) {\n    fprintf(stderr, \"World size must be greater than 1 for %s\\n\", argv[0]);\n    MPI_Abort(MPI_COMM_WORLD, 1);\n  }\n  if (world_rank != 0) {\n    int i = 0;\n    for(i; i < 10000; i++){\n        A[i]=world_rank;\n    }\n    MPI_Recv(&B, 10000, MPI_INT, world_rank - 1, 0, MPI_COMM_WORLD,\n             MPI_STATUS_IGNORE);\n    printf(\"Process %d received B[109] %d from process %d\\n\", world_rank, B[109],\n           world_rank - 1);\n  } else {\n    int i = 0;\n    for(i; i < 10000; i++){\n        A[i]=world_rank;\n    }\n  }\n  MPI_Send(&A, 10000, MPI_INT, (world_rank + 1) % world_size, 0,\n           MPI_COMM_WORLD);\n  if (world_rank == 0) {\n    MPI_Recv(&B, 10000, MPI_INT, world_size - 1, 0, MPI_COMM_WORLD,\n             MPI_STATUS_IGNORE);\n    printf(\"Process %d received B[109] %d from process %i\\n\", world_rank, B[109],\n           1);\n  }\n  MPI_Finalize();\n}"}
{"author": "dishanp", "file": "DSA__q53.0.c", "original_string": "void rearrange( int *arr, int n)\n{\n    int *aux =(int*)malloc(n*sizeof(int));\n    for(int i = 0 ; i < n ; i++)\n    {\n        if(i == 0)\n        *(aux + i) = *(arr + i) * (*(arr + i+1));\n        else if(i == (n - 1))\n        *(aux + i) = *(arr + i) * (*(arr + i-01));\n        else\n        *(aux + i) = (*(arr + i-1))  * (*(arr + i + 1));\n    }\n    for(int i = 0 ; i < n ; i++)\n    {\n        *(arr + i) = *(aux + i);\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__n-rooks_castle.2.c", "original_string": "void rooks(int arr[N][N], int n){\n    if(n>=N){\n        display(arr);\n        int trs[N][N], t=0;\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                trs[j][i]=arr[i][j];\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                if(trs[i][j]==arr[i][j])\n                    t++;\n        if(t!=(N*N))\n            display(trs);\n        return;\n    }\n    for (int i = 0; i < N; i++){\n        if(safe(arr,i,n)){\n            arr[i][n]=1;\n            rooks(arr,n+1);\n            arr[i][n]=0;\n        }\n    }\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "2lista_de_C__main4.0.c", "original_string": "int main()\n{\n    unsigned long int dec;\n    unsigned long int c;\n    unsigned long int d = 1;\n    unsigned long int e = 0;\n    unsigned long int f = 1;\n    unsigned long int g;\n    printf(\"Digite um numero decimal: \");\n    scanf(\"%lu\",&dec);\n    while(dec != 0)\n    {\n        c = dec % 2;\n        printf(\"Passo %3lu: %10lu/2, Resto = %3lu, Quociente = %8lu\\n\",d++,dec,c, dec / 2);\n        dec /= 2;\n        e += c * f;\n        f *= 10;\n    }\n        printf(\"o numero em binario eh: %lu\",e);\n        printf(\"\\n\");\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_print_combn.6.c", "original_string": "void comb5(int *numeros,int a,int b,int c, int d,int e)\n{\n  while(a<=5)\n       {\n          while(b<=6)\n               {\n                while(c<=7)\n                    {\n                      while(d<=8)\n                           {\n                            while(e<=9)\n                                {\n                                  printf(\"%i%i%i%i%i, \",numeros[a],numeros[b],numeros[c],numeros[d],numeros[e]);\n                                  e=e+1;\n                                }\n                            d=d+1;\n                            e=d+1;\n                           }\n                      c=c+1;\n                      d=c+1;\n                      e=d+1;\n                    }\n                b=b+1;\n                c=b+1;\n                d=c+1;\n                e=d+1;\n               } \n          a=a+1;\n          b=a+1;\n          c=b+1;\n          d=c+1;\n          e=d+1;\n       }\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__HeapSort.4.c", "original_string": "void build_max_heap(int a[100],int n)\n    {\n        int i;\n        count++;\n        for(i=(n/2)-1;i>=0;i--)\n        {\n            count++;\n            max_heapify(a,n,i);\n            count++;\n        }\n    }"}
{"author": "0712023", "file": "Arduino-Mood-Light-DIY-kit__Moodlight.0.c", "original_string": "void setup() {\n  pinMode(TRIG_PIN, OUTPUT);  \n  pinMode(ECHO_PIN, INPUT);  \n  pixels.begin();  \n  pixels.show();  \n  BT.begin(9600);\n  RGB.reserve(30);\n}"}
{"author": "dishanp", "file": "DSA__q33.1.c", "original_string": "void rearrange(int *arr, int n)\n{\n    int i = 0, j = n-1;\n    while (i < j)\n    {\n        while (arr[i]%2 == 0 && i < j)\n            i++;\n        while (arr[j]%2 == 1 && i< j)\n            j--;\n        if (i < j)\n        {\n            swap(&arr[i], &arr[j]);\n            i++;\n            j--;\n        }\n    }\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__fibonacci.1.c", "original_string": "int fibonacci_recursivo(int posicion){\n    if (posicion == 0)\n        return 0;\n    if (posicion == 1)\n        return 1;\n    if (posicion == 2)\n        return 1;\n    else\n        return fibonacci_recursivo(posicion - 1) + fibonacci_recursivo(posicion - 2);\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__12_basic_mul_by_addition.0.c", "original_string": "int main()\n{\n  int a,b,i,j,flag=-1,small,large,mul=0,sum;\n  printf(\"Enter the value of the a and b\");\n  scanf(\"%d%d\",&a,&b);\n  if( (a<0 && b<0) || (a>0 && b>0) )\n  {\n    flag = 0;\n  }\n  else if((a>0 && b<0) || (a<0 && b>0))\n  {\n    flag = 1;\n  }\n  if(a<0)\n  { \n    a = -1 * a;\n  }\n  else if(b < 0)\n  {\n    b = -1 * b;\n  }\n  printf(\"a is %d, b is %d\",a,b);\n  if(a>b)\n  {\n    large = a;\n    small = b;\n  }\n  else\n  {\n    large = b;\n    small = a;\n  }\n  for(i=1;i<=small;i++)\n  {\n    mul = mul + large;\n  }\n  if(flag == 0)\n  {\n    printf(\"multiplication is %d\",mul);\n  }\n  else if(flag == 1)\n  {\n    printf(\"multiplication is -%d\",mul);\n  }\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__harf_notu_1.0.c", "original_string": "int main ()\n{\n    int n;\n    printf(\"ders notunuzu 0-100 aras\u0131nda giriniz:\");\n    scanf(\"%d\",&n);\n        if(90<=n && n<=100)\n            printf(\"harf notunuz A\");\n        else if(80<=n && n<90)\n            printf(\"harf notunuz B\");\n        else if(70<=n && n<80)\n            printf(\"harf notunuz C\");   \n        else \n            {\n                if(0<=n && n<=100)\n                printf(\"harf notunuz F\");\n                else \n                  printf(\"ge\u00e7ersiz not girildi\");\n        }\n    return 0;\n    }"}
{"author": "MartinMarinovich", "file": "MarinovichMartinLABIPP1G-__servicio0.4.c", "original_string": "int buscarServicios(eServicio servicios[],int tam_s,int idServicio)\n{\n    int indice=-1;\n    for(int i=0;i<tam_s;i++)\n    {\n        if(servicios[i].idServicio ==idServicio)\n        {\n            indice=i;\n            break;\n        }\n    }\n        return indice;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__F.0.c", "original_string": "int main()\n{\n    int n;\n    scanf (\"%i\", &n);\n    n = (n/2)+1;\n    for (int i=1; i<=n; i++)\n    {\n        for (int j=(n-1); j>=i; j--)\n        {\n            putchar (' ');\n        }\n        for (int k=1; k<=i; k++)\n        {\n            putchar ('*');\n        }\n        for (int l=1; l<i; l++)\n        {\n            putchar ('*');\n        }\n        putchar ('\\n');\n    }\n    for (int i=(n-1); i>0; i--)\n    {\n        for (int j=i; j<n; j++)\n        {\n            putchar (' ');\n        }\n        for (int k=1; k<=i; k++)\n        {\n            putchar ('*');\n        }\n        for (int l=1; l<i; l++)\n        {\n            putchar ('*');\n        }\n        putchar ('\\n');\n    }\n    putchar ('\\n');\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-statements.0.c", "original_string": "STATEMENT* mkstatement(PARSER* p, STATEMENTTYPE t) {\n    STATEMENT* s = (STATEMENT*)malloc(sizeof(STATEMENT));\n    s->type = t;\n    s->debug = getdebug(p);\n    return s;\n}"}
{"author": "2security", "file": "Pointer__18ReturnMultipleValue.1.c", "original_string": "int main()\n    {\n        int *a,m,i;\n        printf(\"\\n Enter size of array1:: \");\n        scanf(\"%d\",&m);\n        a=(int *)malloc(m*sizeof(int *));\n        printf(\"\\n Enter %d elements of array::\",m);\n        for(i=0;i<m;i++)\n            scanf(\"%d\",&*(a+i));\n        Myreturn(a,m);\n        printf(\"\\n Result:: \");\n        for(i=0;i<m;i++)\n            printf(\"%d \",*(a+i));\n        return 0;\n    }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__1.2.c", "original_string": "bool imprime_renda(aluno_t *turma, int semestre, int n)\n{\n    bool sem = false;\n    int k = 0;\n    float media = 0.0;\n    for (int i = 0; i < n; i++)\n    {\n        if (turma[i].semestre == semestre)\n        {\n            if (sem == false) sem = true;\n            media += turma[i].renda_mensal;\n            k++;\n        }\n    }\n    if (sem == false)\n    {\n        printf(\"\\nNenhum aluno foi encontrado no semestre escolhido.\\n\");\n        return false;\n    }\n    media /= k;\n    printf(\"\\nMedia = %f\\n\", media);\n    for (int i = 0; i < n; i++)\n    {\n        if (turma[i].renda_mensal >= media && turma[i].semestre == semestre)\n        {\n            imprime_aluno(turma[i]);\n        }\n    }\n    return true;\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__main.2.c", "original_string": "static void MX_FMC_Init(void)\n{\n  FMC_SDRAM_TimingTypeDef SdramTiming;\n  hsdram1.Instance = FMC_SDRAM_DEVICE;\n  hsdram1.Init.SDBank = FMC_SDRAM_BANK2;\n  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_8;\n  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_12;\n  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;\n  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;\n  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_3;\n  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;\n  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_2;\n  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_DISABLE;\n  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_1;\n  SdramTiming.LoadToActiveDelay = 2;\n  SdramTiming.ExitSelfRefreshDelay = 7;\n  SdramTiming.SelfRefreshTime = 4;\n  SdramTiming.RowCycleDelay = 7;\n  SdramTiming.WriteRecoveryTime = 3;\n  SdramTiming.RPDelay = 2;\n  SdramTiming.RCDDelay = 2;\n  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)\n  {\n    _Error_Handler(__FILE__, __LINE__);\n  }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_DLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*tail;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n            newnode->pre=0;\n       if(head==0)\n       {\n            head=tail=newnode;\n       }\n       else\n       {\n            tail->next=newnode;\n            newnode->pre=tail;\n            tail=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n           scanf(\"%d\",& choice);\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader0.0.c", "original_string": "static bool isWhitespace(char *str)\n{\n  size_t idx = 0;\n  char currentChr = str[idx++];\n  while (currentChr != '\\0')\n  {\n    if (isspace(currentChr) == 0) \n    {\n      return false;\n    }\n    currentChr = str[idx++];\n  }\n  return true;\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.8.c", "original_string": "CLASS* getclass(SCOPE* s, const char* name) {\n    CLASS* curr = s->classes;\n    while(curr != NULL) {\n        if(!strcmp(curr->name, name))\n            return curr;\n        curr = curr->next;\n    }\n    if(s->previous != NULL)\n        return getclass(s->previous, name);\n    return NULL;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader0.1.c", "original_string": "void firmwareUpdateInfoReader_init(void)\n{\n  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);\n  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));\n  memset(updateVerificationData, 0, updateVerificationDataSize);\n  if (!createFirmwareUpdateInfoFile()) \n  {\n    return;\n  }\n  openFirmwareUpdateInfoFileInVSCode();\n}"}
{"author": "dle2005", "file": "File_Structure__ftlmgr.3.c", "original_string": "int optionR(char* fileName, int ppn) {\n    flashfp = fopen(fileName, \"r+t\");\n    dd_read(ppn, pagebuf);\n    for(int i = 0; i < SECTOR_SIZE && pagebuf[i] != (char)0xFF; i++)\n        printf(\"%c\", pagebuf[i]);\n    printf(\" \");\n    for(int i = SECTOR_SIZE; i < PAGE_SIZE && pagebuf[i] != (char)0xFF; i++)\n        printf(\"%c\", pagebuf[i]);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_CLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__SinglePartitionDemoFirmwareUpdateInfoSerialReader0.0.c", "original_string": "void firmwareUpdateInfoReader_init(void)\n{\n  FirmwareUpdateInfoParser__init(&updateInfoParser);\n  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);\n  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));\n  memset(updateVerificationData, 0, updateVerificationDataSize);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_auth.3.c", "original_string": "AcmeAuthStatus acmeClientParseAuthorizationStatus(const char_t *label)\n{\n   AcmeAuthStatus status;\n   if(!osStrcmp(label, \"pending\"))\n   {\n      status = ACME_AUTH_STATUS_PENDING;\n   }\n   else if(!osStrcmp(label, \"valid\"))\n   {\n      status = ACME_AUTH_STATUS_VALID;\n   }\n   else if(!osStrcmp(label, \"invalid\"))\n   {\n      status = ACME_AUTH_STATUS_INVALID;\n   }\n   else if(!osStrcmp(label, \"expired\"))\n   {\n      status = ACME_AUTH_STATUS_EXPIRED;\n   }\n   else if(!osStrcmp(label, \"deactivated\"))\n   {\n      status = ACME_AUTH_STATUS_DEACTIVATED;\n   }\n   else if(!osStrcmp(label, \"revoked\"))\n   {\n      status = ACME_AUTH_STATUS_REVOKED;\n   }\n   else\n   {\n      status = ACME_AUTH_STATUS_INVALID;\n   }\n   return status;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__count_one.1.c", "original_string": "int main()\n{\n    int iNo = 0;\n    int iRet = 0;\n    printf(\"Enter number\\n\");\n    scanf(\"%d\",&iNo);\n    iRet = CountOne(iNo);\n    printf(\"Number of 1's in the numer is : %d\\n\",iRet);\n    return 0;\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__21.1.c", "original_string": "void largest(int a[][90],int r,int c)\n{\n    int max=a[0][0],i,j;\n    for(i=0;i<r;i++)\n    {\n        for(j=0;j<c;j++)\n        {\n            if(max<a[i][j])\n                max=a[i][j];\n        }\n    }\n    printf(\"%d\",max);\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_nus.1.c", "original_string": "static void on_write(ble_nus_t * p_nus, ble_evt_t const * p_ble_evt)\n{\n    ret_code_t                    err_code;\n    ble_nus_evt_t                 evt;\n    ble_nus_client_context_t    * p_client;\n    ble_gatts_evt_write_t const * p_evt_write = &p_ble_evt->evt.gatts_evt.params.write;\n    err_code = blcm_link_ctx_get(p_nus->p_link_ctx_storage,\n                                 p_ble_evt->evt.gatts_evt.conn_handle,\n                                 (void *) &p_client);\n    if (err_code != NRF_SUCCESS)\n    {\n        NRF_LOG_ERROR(\"Link context for 0x%02X connection handle could not be fetched.\",\n                      p_ble_evt->evt.gatts_evt.conn_handle);\n    }\n    memset(&evt, 0, sizeof(ble_nus_evt_t));\n    evt.p_nus       = p_nus;\n    evt.conn_handle = p_ble_evt->evt.gatts_evt.conn_handle;\n    evt.p_link_ctx  = p_client;\n    if ((p_evt_write->handle == p_nus->tx_handles.cccd_handle) &&\n        (p_evt_write->len == 2))\n    {\n        if (p_client != NULL)\n        {\n            if (ble_srv_is_notification_enabled(p_evt_write->data))\n            {\n                p_client->is_notification_enabled = true;\n                evt.type                          = BLE_NUS_EVT_COMM_STARTED;\n            }\n            else\n            {\n                p_client->is_notification_enabled = false;\n                evt.type                          = BLE_NUS_EVT_COMM_STOPPED;\n            }\n            if (p_nus->data_handler != NULL)\n            {\n                p_nus->data_handler(&evt);\n            }\n        }\n    }\n    else if ((p_evt_write->handle == p_nus->rx_handles.value_handle) &&\n             (p_nus->data_handler != NULL))\n    {\n        evt.type                  = BLE_NUS_EVT_RX_DATA;\n        evt.params.rx_data.p_data = p_evt_write->data;\n        evt.params.rx_data.length = p_evt_write->len;\n        p_nus->data_handler(&evt);\n    }\n    else\n    {\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q1.5.c", "original_string": "int main()\n{\n    printf(\"Enter Value of Root: \");\n    int key;\n    scanf(\"%d\", &key);\n    nptr root = createNode(key);\n    int ch;\n    printf(\"1. Insert node    2. In-Order    3. Pre-Order    4. Post-Order      5. Exit\\n\");\n    do\n    {\n        printf(\"Command: \");\n        scanf(\"%d\", &ch);\n        switch (ch)\n        {\n            case 1: char P[10];\n                    printf(\"Enter Path: \");\n                    scanf(\"%s\", P);\n                    root = insertNode(root, P);\n                    break;\n            case 2: inorder(root);\n                    printf(\"\\n\");\n                    break;\n            case 3: preorder(root);\n                    printf(\"\\n\");\n                    break;\n            case 4: postorder(root);\n                    printf(\"\\n\");\n                    break;\n        }\n    }while(ch != 5);\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__flor.1.c", "original_string": "void quadrado(float x, float y){\n  glBegin(GL_POLYGON);\n    glVertex2f(-0.2+x, 0.2+y);\n    glVertex2f(0.2+x, 0.2+y);\n    glVertex2f(0.2+x, -0.2+y);\n    glVertex2f(-0.2+x, -0.2+y);\n  glEnd();\n}"}
{"author": "sdukesameer", "file": "dsa__Md_Sameer_13000119114.8.c", "original_string": "int find(list* root, int n){\n    if (root==NULL)\n        return 0;\n    else{\n        if (n<root->key)\n            find(root->left,n);\n        else if(n>root->key)\n            find(root->right,n);\n        else\n            return 1;\n    }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_03.0.c", "original_string": "int* read(int n)\n{\n        int i;\n        int s = sizeof(int);\n        int* arr1= (int*)malloc(s * n);\n        for(i = 0; i<n; i++)\n        {\n                fscanf(F1, \"%d\", (arr1+i));\n        }\n        return arr1;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__DemoFOTAUpdateWorkflow0.1.c", "original_string": "void fotahub_onConnectionStatusChanged(ConnectionStatus_t status)\n{\n  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__ssh_exchange_hash.2.c", "original_string": "error_t sshFinalizeExchangeHash(SshConnection *connection, uint8_t *digest,\n   size_t *digestLen)\n{\n   error_t error;\n   error = NO_ERROR;\n   if(connection->hashAlgo != NULL)\n   {\n      connection->hashAlgo->final(connection->hashContext, digest);\n      *digestLen = connection->hashAlgo->digestSize;\n   }\n   else\n   {\n      error = ERROR_FAILURE;\n   }\n   return error;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__multiParenthesis.5.c", "original_string": "int parenthesisMatch(char*exp){\n     struct stack* sp;\n     sp->size=100;\n     sp->top= -1;\n     sp->arr = (char*)malloc(sp->size * sizeof(char));\n     char popped_ch;\n     for (int i = 0; exp[i]!='\\0'; i++)\n     {\n          if (exp[i]=='(' || exp[i]=='[' || exp[i]=='{' )\n          {\n               push(sp, exp[i]);\n          }\n          else if (exp[i]==')' || exp[i]=='}' || exp[i]==']')\n          {\n               if (isEmpty(sp))\n               {\n                    return 0;\n               }\n               popped_ch = pop(sp);\n               if(!match(popped_ch, exp[i])){\n                    return 0;\n               }\n          }\n     }\n     if (isEmpty(sp))\n     {\n          return 1;\n     }\n     else{\n          return 0;\n     }\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__queue.3.c", "original_string": "void display(void){\n    if(rear == -1)\n        printf(\"Queue is empty\\n\");\n    else {\n        int i;\n        printf(\"Queue elements are:\\n\");\n        for(i=front; i<=rear; i++)\n            printf(\"%d\\t\",queue[i]);\n        printf(\"\\n\");\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q2_longadd.2.c", "original_string": "nptr getnum(char num[50])\n{\n    nptr head=createNode();\n    for(int i=strlen(num)-1;i>=0;i--)\n        insert(head,num[i]-'0');\n    return head;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q23.1.c", "original_string": "void enqueueleft(queue *q,char* n)\n{\n    if (q->front == 0)\n        printf(\"Side Full\\n\");\n    else\n        q->c[--(q->front)]=n;\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-3test.12.c", "original_string": "int main(){\n    move[0].vert=-1;\n    move[0].horiz=0;\n    move[0].hei=0;\n    move[1].vert=0;\n    move[1].horiz=1;\n    move[1].hei=0;\n    move[2].vert=1;\n    move[2].horiz=0;\n    move[2].hei=0;\n    move[3].vert=0;\n    move[3].horiz=-1;\n    move[3].hei=0;\n    move[4].vert=0;\n    move[4].horiz=0;\n    move[4].hei=1;\n    move[5].vert=0;\n    move[5].horiz=0;\n    move[5].hei=-1;\n    int n=0;\n    char y;\n    int i,j,k;\n    FILE *pfile;\n    char name[50];\n    int control;\n    for(control=2;control<=2;control++){\n        sprintf(name,\"test%d.txt\",control);\n        pfile = fopen(name,\"r\");\n        if(NULL==pfile){\n            printf(\"Open failure\");\n            return 1;\n        }\n        else{\n            printf(\"reading %s\\n\",name);\n            char* bottom = make1darr(MAXLEN);\n            int n=0;\n            char y;\n            bottom[n]=fgetc(pfile);\n            while(bottom[n]!='\\n'){\n                fgetc(pfile);\n                bottom[++n]=fgetc(pfile);\n            }\n            char ***maze=make3darr(n/2+1,n+2,n+2);\n            char ***road=make3darr(n/2+1,n+2,n+2);\n            char ***mark=make3darr(n/2+1,n+2,n+2);\n            int ***d=make3darrint(n/2+1,n+2,n+2);\n            int len=0;\n            int sr,sc,sh;\n            int pnum=0;\n            for(i=0;i<n/2+1;i++){\n                for(j=0;j<n+2;j++){\n                    for(k=0;k<n+2;k++){\n                        if(j==0 || k==0 || j==n+1 || k==n+1){\n                            maze[i][j][k]='X';\n                        }\n                        else if(i==0 && j==1){\n                            maze[i][j][k]=bottom[k-1];\n                        }\n                        else if(j > len && j <= n-len && k > len && k <= n-len){\n                            fscanf(pfile,\"%c \",&maze[i][j][k]);\n                        }\n                        else{\n                            maze[i][j][k]='X';\n                        }\n                        if(maze[i][j][k]=='S'){\n                            sh=i;\n                            sr=j;\n                            sc=k;\n                        }\n                        if(maze[i][j][k]=='P'){\n                            pnum++;\n                        }\n                        road[i][j][k]=maze[i][j][k];\n                        mark[i][j][k]=maze[i][j][k];\n                    }\n                }\n                len++;\n            }\n            FILE *wfile;\n            wfile = fopen( \"4108056029output.txt\",\"a\" );\n            if( NULL == wfile ){\n                printf( \"wfile open failure\" );\n                return 1;\n            }\n            else{\n                fprintf(wfile, \"test%d Starts now.\\n\",control );\n                if(1){\n                    mark[sh][sr][sc]='X';\n                    pathnum=0;\n                    path(maze,mark,road,sr,sc,sh,n,pnum);\n                    printf(\"Shortest path: %d, The number of different paths: %d\\n\\n\",min-1,pathnum);\n                    fprintf(wfile,\"Shortest path: %d, The number of different paths: %d\\n\\n\",min-1,pathnum);\n                }\n                else fprintf(wfile,\"The maze does not have a path\\n\" );\n            }\n            free(bottom);\n            free(maze);\n            free(mark);\n            free(road);\n            free(d);\n        }\n        fclose(pfile);\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CLL.3.c", "original_string": "int count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the list is %d\\n\",c);\n    return c;\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_eight_queens_puzzle.1.c", "original_string": "int ft_eight_queens_puzzle(void){\n    int Tabla[8][8] = {{0,0,0,0,0,0,0,0},     \n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0}};\n    int  contador = 0;\n    for(int Col_0 = 0; Col_0 < 8; Col_0++){  \n        Tabla[Col_0][0] = 1; \n        for(int Col_1 = 0; Col_1 < 8; Col_1++){ \n            if(Mov_Queen(Tabla, Col_1, 1) == 0){\n               Tabla[Col_1][1] = 1; \n               for (int Col_2 = 0; Col_2 < 8; Col_2++){ \n                   if(Mov_Queen(Tabla, Col_2, 2) == 0){\n                        Tabla[Col_2][2] = 1; \n                        for (int Col_3 = 0; Col_3 < 8; Col_3++){ \n                            if(Mov_Queen(Tabla, Col_3, 3) == 0){\n                                Tabla[Col_3][3] = 1; \n                                for (int Col_4 = 0; Col_4 < 8; Col_4++){  \n                                    if(Mov_Queen(Tabla, Col_4, 4) == 0){\n                                        Tabla[Col_4][4] = 1; \n                                        for (int Col_5 = 0; Col_5 < 8; Col_5++){ \n                                            if(Mov_Queen(Tabla, Col_5, 5) == 0){\n                                                Tabla[Col_5][5] = 1; \n                                                for (int Col_6 = 0; Col_6 < 8; Col_6++){ \n                                                    if(Mov_Queen(Tabla, Col_6, 6) == 0){\n                                                        Tabla[Col_6][6] = 1; \n                                                        for (int Col_7 = 0; Col_7 < 8; Col_7++) \n                                                        {\n                                                            if(Mov_Queen(Tabla, Col_7, 7) == 0){\n                                                                Tabla[Col_7][7] = 1; \n                                                                contador++;\n                                                            }\n                                                            Tabla[Col_7][7] = 0;  \n                                                        }\n                                                    }\n                                                    Tabla[Col_6][6] = 0;\n                                                }\n                                            }\n                                            Tabla[Col_5][5] = 0;\n                                        }  \n                                    } \n                                    Tabla[Col_4][4] = 0;\n                                }\n                            }\n                            Tabla[Col_3][3] = 0;\n                        }\n                    }\n                    Tabla[Col_2][2] = 0; \n                }\n            }\n            Tabla[Col_1][1] = 0;\n        }\n        Tabla[Col_0][0] = 0;\n    }\n    return contador; \n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__key.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | LED_ALL ;  \n    IODIR1 = IODIR1 & ~(1<<25);  \n    while(1)\n    {\n        if(IOPIN1 & (1<<25))\n        {\n            IOSET1 = 0x0F<<17;\n        }\n    }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__stack1.4.c", "original_string": "void main()\n{\n    int ch;\n    printf(\"1.INSERT\\n2.DELETE\\n3.SEARCH\\n4.PRINT\\n\\n\");\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the value to insert:\");\n                scanf(\"%d\",&value);\n                push(stack,value);\n                break;\n            }\n            case 2:\n            {\n                pop(stack);\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the value to search:\");\n                scanf(\"%d\",&value);\n                search(stack,value);\n                break;\n            }\n            case 4:\n            {\n                display(stack);\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"author": "mandarvu", "file": "msc__problem16.1.c", "original_string": "void string_reverse(char *origin, char *rev) {\n    int f = 0, cnt = 0, j = 0; \n    while ( *(origin + f) != '\\0' ) { \n        cnt++;\n        f++;\n    }\n    for (int i = cnt - 1; i >= 0; i--)\n    {\n        *(rev + j) = *(origin + i);\n        j++;\n    }\n    *(rev + j) = '\\0'; \n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc-a.5.c", "original_string": "void postorder(list *root)\n{\n    if (root != NULL)\n    {\n        postorder(root->left);\n        postorder(root->right);\n        printf(\"   %d \\n\", root->key); \n    }\n}"}
{"author": "earth429", "file": "mulpre__kaijyou.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a, b;\n    int return_val;\n    int x;\n    x = 0;\n    setInt(&a, x);\n    printf(\"x = %d\\n\", x);\n    return_val = factorial(&a, &b);\n    dispNumberZeroSuppress(&b);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n    return 0;\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__utils.2.c", "original_string": "void    ft_putstr(char *str)\n{\n    int i;\n    i = 0;\n    while (str[i] != '\\0')\n    {\n        ft_putchar(str[i]);\n        i++;\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CLL.8.c", "original_string": "void delete_end()\n{\n    struct node *temp,*endnode;\n    temp =head;\n    while(temp->next!=head)\n    {\n        endnode=temp;\n        temp=temp->next;\n    }\n    endnode->next=head;\n    free(temp);\n}"}
{"author": "mehedi9021", "file": "Data_Structure__string_in_stack.3.c", "original_string": "int main() {\n    char inputString[100], c;\n    int i, length;\n    printf(\"Enter a string\\n\");\n    gets(inputString);\n    printf(\"\\n\\n\");\n    puts(inputString);\n    length = strlen(inputString);\n            return 0;\n    printf(\"\");\n    return 0;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__count_vowels.0.c", "original_string": "int CountVowels(char str[])\n{\n    int iCnt = 0, i = 0;\n    if(str == NULL)\n    {\n        return -1;\n    }\n    while(str[i] != '\\0')\n    {\n        if(\n           (str[i] == 'a') || (str[i] == 'A') || (str[i] == 'e') || (str[i] == 'E') || (str[i] == 'i') || (str[i] == 'I') || (str[i] == 'o')||(str[i] == 'O') || (str[i] == 'u')||(str[i] == 'U') )\n        {\n            iCnt++;\n        }\n        i++;\n    }\n    return iCnt;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-expressions.4.c", "original_string": "TERM* parseint(PARSER* p) {\n    TERM* t = mkterm(intconstant);\n    t->integer = atoi(p->current->token);\n    next(p);\n    return t;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__WiFiHelper.5.c", "original_string": "bool getIPConfig(IPConfig_t *pIPConfig, wifi_mode_t mode)\n{\n  if (pIPConfig == NULL) \n  {\n    return false;\n  }\n  tcpip_adapter_ip_info_t info;\n  if (tcpip_adapter_get_ip_info((mode == WIFI_MODE_AP) ? (TCPIP_ADAPTER_IF_AP) : (TCPIP_ADAPTER_IF_STA), &info) == ESP_OK) \n  {\n    pIPConfig->localIPAddress = info.ip.addr;\n    pIPConfig->gatewayIPAddress = info.gw.addr;\n    pIPConfig->subnetMask = info.netmask.addr;\n    return true;\n  }\n  return false;\n}"}
{"author": "SugumaranEvil", "file": "Linux_programming__truncate.0.c", "original_string": "int main()\n{\n    int tr,file_des,sn;\n    char buf[10],snp[30],snp1[30];\n    char buf1[8]=\"sugukavi\";\n    ssize_t rd,wt;\n    file_des = open(\"./text\",O_CREAT | O_RDWR,0644);\n    perror(\"open\");                   \n    printf(\"fd %d\\n\",file_des);       \n    wt = write(file_des,buf1,8);      \n    perror(\"write\");\n    printf(\"write %d\\n\",wt);\n    rd = read(file_des,buf,8);        \n    perror(\"read\");\n    printf(\"read %d\\n\",rd);\n    sn = snprintf(snp1,20,\"%s\",buf);   \n    printf(\"%s\\n\",snp1);              \n    printf(\"snprintf %d\\n\",sn);\n    tr = truncate(\"./text\",20);       \n    perror(\"truncate\");\n    printf(\"truncate %d\\n\",tr);\n    lseek(file_des,0,SEEK_SET);       \n    rd = read(file_des,buf,20);      \n    perror(\"read\");\n    snprintf(snp1,20,\"%s\",buf);\n    printf(\"%s\\n\",snp1);\n    close(file_des);                  \n}"}
{"author": "davibernardos", "file": "DB-PJ__e140.1.c", "original_string": "int main(int argc, char *argv[]) {\n    char captchaDigitado[6];\n    int continuar = 1;\n    while(continuar = 1)\n    {\n        printf(\"CAPTCHA\\n\\n\");\n        printf(\"Captcha gerado:\\n\");\n        gerado();\n        printf(\"\\n\");\n        printf(\"Digite o Captcha gerado:\\n\");\n        gets(captchaDigitado);\n        printf(\"\\n\");\n        if(strcmp (captchaDigitado, gerarCaptcha) == 0)\n        {\n            printf(\"Captcha correto.\\n\\n\");\n        }else{\n            printf(\"Captcha incorreto.\\n\\n\");\n        }\n        system(\"pause\");\n        system(\"cls\");\n    }\n    return 0;\n}"}
{"author": "haon1026", "file": "linux-programming__sem_product_multconsumer.2.c", "original_string": "int main()\n{\n    srand(time(NULL));\n    pthread_t cid[5], pid;\n    sem_init(&blank_number, 0, NUM);            \n    sem_init(&product_number, 0, 0);            \n    pthread_create(&pid, NULL, product, NULL);\n    for(int i = 0; i < 5; i++)\n    {\n        pthread_create(&cid[i], NULL, comsumer, NULL);\n    }\n    pthread_join(pid, NULL);\n    for(int i = 0; i < 5; i++)\n    {\n        pthread_join(cid[i], NULL);\n    }\n    sem_destroy(&blank_number);\n    sem_destroy(&product_number);\n    return 0;\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__BubbleSort.0.c", "original_string": "int main()\n{\n    int n;\n    printf(\"enter the no. of elements:\");\n    scanf(\"%d\",&n);\n    int arr[n];\n    int i;\n    printf(\"enter the elements:\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&arr[i]);\n    }\n    bubbleSort(arr,n);\n    return 0;\n}"}
{"author": "dishanp", "file": "DSA__q2.0.c", "original_string": "int main()\n{\n    int m, n;\n    printf(\"Enter dimensions (m,n) : \");\n    scanf(\"%d%d\", &m, &n);\n    int **p = (int**)malloc(m*sizeof(int*));\n    for(int i = 0 ; i < m ; i++)\n    {\n        p[i] = (int*)malloc(n*sizeof(int));\n    }\n    printf(\"Enter elements : \\n\");\n    for(int i = 0 ; i < m ; i++)\n    {\n        for(int j = 0 ; j < n ; j++)\n        {\n            scanf(\"%d\", &p[i][j]);\n        }\n    }\n    printf(\"\\nThe matrix : \\n\");\n    for(int i = 0 ; i < m ; i++)\n    {\n        for(int j = 0 ; j < n ; j++)\n        {\n            printf(\"%d \", p[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad6.4.c", "original_string": "int push(pozicija p)\n{ \n    pozicija q = NULL;\n    q = (pozicija)malloc(sizeof(struct cvor));\n    if (q == NULL)\n    {\n        printf(\"Neuspjesna alokacija memorije!\\n\");\n        return 1;\n    }\n    int broj = (rand() % (MAX - MIN + 1)) + MIN;\n    q->el = broj;\n    q->next = p->next;\n    p->next = q;\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__keypad.3.c", "original_string": "void col_2(void)                    \n{\n    int val;\n    IODIR1 = IODIR1 & ~COLS;        \n    IODIR1 = IODIR1 | ROWS;         \n    val = IOPIN1 & COLS;        \n    val = val >> 17;\n    switch(val)\n    {\n        case 0x0E:  lcd_data('4');  delay(200); break;\n        case 0x0D:  lcd_data('5');  delay(200); break;\n        case 0x0B:  lcd_data('6');  delay(200); break;\n        case 0x07:  lcd_data('x');  delay(200); break;\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__n-rooks_castle.0.c", "original_string": "void display(int arr[N][N]){\n    static int n=1;\n    printf(\"\\nSolution No. %d: \\n\",n++);\n    for (int i = 0; i < N; i++){\n        if(i==0){\n            for (int k = 0; k < N; k++)\n                printf(\" ---\");\n            printf(\"\\n\");\n        }\n        printf(\"|\");\n        for (int j = 0; j < N; j++){\n            if(arr[i][j])\n                printf(\" R |\");\n            else\n                printf(\"   |\");\n        }\n        printf(\"\\n\");\n        for (int k = 0; k < N; k++)\n            printf(\" ---\");\n        printf(\"\\n\");\n    }\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__planetas.1.c", "original_string": "void CarregaTexturas()\n{\n    BMPImage textura;\n    glGenTextures(MAX_NO_TEXTURES, texture_id);\n    int i;\n    for ( i=0; i<MAX_NO_TEXTURES; i++ ) {\n        getBitmapImageData( filenameArray[i], &textura);\n        glBindTexture(GL_TEXTURE_2D, texture_id[i]);\n        glTexImage2D(GL_TEXTURE_2D, 0, 3, textura.width, textura.height, 0, GL_RGB, GL_UNSIGNED_BYTE, textura.data);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q1_queue.4.c", "original_string": "int deletee(queue* q)\n{\n    int temp;\n    node* t;\n    if(q->front==NULL)\n        return queueEmpty();\n    else if(q->front==q->rear)\n    {\n        temp=q->front->data;\n        init(q);\n    }\n    else\n    {\n        temp=q->front->data;\n        t=q->front;\n        q->front=q->front->link;\n        free(t);\n    }\n    return temp;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_certificate.5.c", "original_string": "error_t acmeClientParseRevokeCertResponse(AcmeClientContext *context)\n{\n   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))\n      return ERROR_UNEXPECTED_STATUS;\n   if(context->nonce[0] == '\\0')\n      return ERROR_INVALID_RESPONSE;\n   return NO_ERROR;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_after_pos_DLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSL__ssl_misc.2.c", "original_string": "uint32_t sslVerifyPadding(TlsEncryptionEngine *decryptionEngine,\n   const uint8_t *data, size_t dataLen, size_t *paddingLen)\n{\n   size_t i;\n   size_t n;\n   uint8_t b;\n   uint8_t mask;\n   uint32_t c;\n   uint32_t bad;\n   uint32_t bad1;\n   uint32_t bad2;\n   n = data[dataLen - 1];\n   bad = CRYPTO_TEST_GTE_32(n, dataLen);\n   bad |= CRYPTO_TEST_GTE_32(n, decryptionEngine->cipherAlgo->blockSize);\n   for(bad1 = 0, i = 1; i < dataLen && i < 256; i++)\n   {\n      b = data[dataLen - 1 - i];\n      c = CRYPTO_TEST_LTE_32(i, n);\n      mask = CRYPTO_SELECT_8(b, n, c);\n      bad1 |= CRYPTO_TEST_NEQ_8(b, mask);\n   }\n   for(bad2 = 0, i = 1; i < dataLen && i < 256; i++)\n   {\n      b = data[dataLen - 1 - i];\n      c = CRYPTO_TEST_LTE_32(i, n);\n      mask = CRYPTO_SELECT_8(b, 0, c);\n      bad2 |= CRYPTO_TEST_NEQ_8(b, mask);\n   }\n   bad |= bad1 & bad2;\n   *paddingLen = CRYPTO_SELECT_32(n, 0, bad);\n   return bad;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__robo.2.c", "original_string": "void triangulo(float x1, float y1, float x2, float y2, float x3, float y3)\n{\n  glBegin(GL_TRIANGLES);\n    glVertex2f(x1,y1);\n    glVertex2f(x2,y2);\n    glVertex2f(x3,y3);\n  glEnd();\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__multiParenthesis.4.c", "original_string": "int match(char a, char b){\n     if (a=='{' && b=='}' )\n     {\n          return 1;\n     }\n     if (a=='[' && b==']' )\n     {\n          return 1;\n     }\n     if (a=='(' && b==')' )\n     {\n          return 1;\n     }\n     return 0;\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b2.5.c", "original_string": "int main() {\n    char *filename = \"Passports.txt\";\n    FILE *f = fopen(filename, \"r\");\n    size_t count = 0;\n    bool *valids = calloc(sizeof(bool), 7);\n    char *curs = calloc(sizeof(char), 3);\n    for (char cur = fgetc(f); cur != EOF; cur = fgetc(f)) {\n        if (cur == ':') switch (curs[0] + curs[1] + curs[2]) {\n            case 333: { \n                size_t n = 0;\n                char *field = get_field(&n, f);\n                char *tmp = NULL;\n                int byr = strtol(field, &tmp, 10);\n                if (1920 <= byr && byr <= 2002)\n                    valids[0] = true;\n                free(field); break;\n            } case 340: { \n                size_t n = 0;\n                char *field = get_field(&n, f);\n                char *tmp = NULL;\n                int iyr = strtol(field, &tmp, 10);\n                if (2010 <= iyr && iyr <= 2020)\n                    valids[1] = true;\n                free(field); break;\n            } case 336: { \n                size_t n = 0;\n                char *field = get_field(&n, f);\n                char *tmp = NULL;\n                int eyr = strtol(field, &tmp, 10);\n                if (2020 <= eyr && eyr <= 2030)\n                    valids[2] = true;\n                free(field); break;\n            } case 323: { \n                size_t n = 0;\n                char *field = get_field(&n, f);\n                char *tmp = NULL;\n                int hgt = strtol(field, &tmp, 10);\n                if (strcmp(tmp, \"cm\") == 0 && 150 <= hgt && hgt <= 193\n                    || strcmp(tmp, \"in\") == 0 && 59 <= hgt && hgt <= 76)\n                    valids[3] = true;\n                free(field); break;\n            } case 311: { \n                size_t n = 0;\n                char *field = get_field(&n, f);\n                if (is_hair_color(field, n))\n                    valids[4] = true;\n                free(field); break;\n            } case 308: { \n                size_t n = 0;\n                char *field = get_field(&n, f);\n                if (is_eye_color(field))\n                    valids[5] = true;\n                free(field); break;\n            } case 317: { \n                size_t n = 0;\n                char *field = get_field(&n, f);\n                if (is_pid(field, n))\n                    valids[6] = true;\n                free(field); break;\n            } case 304: { \n                size_t n = 0;\n                char *field = get_field(&n, f);\n                free(field); break;\n            }\n        }\n        if (cur == '\\n') {\n            if (is_pass(valids)) count++;\n            free(valids);\n            valids = calloc(sizeof(bool), 7);\n        }\n        curs[0] = curs[1];\n        curs[1] = curs[2];\n        curs[2] = cur;\n    }\n    printf(\"Answer: %zu\\n\", count);\n    free(valids);\n    free(curs);\n    fclose(f);\n    return 0;\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client4.0.c", "original_string": "void *get_in_addr(struct sockaddr *sa)\n{\n    if (sa->sa_family == AF_INET) {\n        return &(((struct sockaddr_in*)sa)->sin_addr);\n    }\n    return &(((struct sockaddr_in6*)sa)->sin6_addr);\n}"}
{"author": "augustogunsch", "file": "jackc__tokenizer.0.c", "original_string": "STRING* mkstring(int size) {\n    STRING* str = (STRING*)malloc(sizeof(STRING));\n    str->size = sizeof(char) * size; \n    str->str = (char*)malloc(str->size);\n    str->count = 0;\n    return str;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__timer.2.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.25.c", "original_string": "void addparameters(SCOPE* s, bool isformethod, PARAMETER* params) {\n    int i = isformethod ? 1 : 0;\n    while(params != NULL) {\n        addparameter(s, params, &i);\n        params = params->next;\n    }\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__selectsdserver.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    int rval,sockid;\n    sockid=socket(AF_INET,SOCK_STREAM,6);   \n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    struct sockaddr_in s,c;\n    system(\"clear\");\n    if(argc<2)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(1);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=bind(sockid,(struct sockaddr*)&s,sizeof(s)); \n    if(rval==-1)  \n    {   \n        perror(\"BIND-ERR:\");   \n        close(sockid);   \n        exit(1);  \n    }   \n    rval=listen(sockid,5);\n    if(rval==-1)  \n    {   \n        perror(\"LISTEN-ERR:\");   \n        close(sockid);   \n        exit(1);  \n    }  \n    fd_set rdfs,copy;\n    FD_ZERO(&rdfs);\n    FD_SET(STDIN,&rdfs);\n    FD_SET(sockid,&rdfs);\n    int maxfd=STDIN>=sockid?STDIN:sockid;\n    maxfd=maxfd+1;\n    char msg[100];\n    struct timeval tm;\n    int ret;\n    while(1)\n    {\n        copy=rdfs;\n        tm.tv_sec=5;\n        tm.tv_usec=5000000;\n        ret=select(maxfd,&copy,NULL,NULL,&tm);\n        if(ret==-1)\n        perror(\"SEL-ERR\");\n        if(ret==0)\n        printf(\"Timeout occured\");\n        else\n        {\n            if(FD_ISSET(STDIN,&copy))\n            {\n                scanf(\"%s\",msg);\n                printf(\"Message is:%s\\n\",msg);\n            }\n            if(FD_ISSET(sockid,&copy))\n            {\n                int clen=sizeof(c);  \n                int sid1=accept(sockid,(struct sockaddr*)&c,&clen); \n                if(sid1==-1)\n                {\n                    perror(\"ACC-ERR\");\n                    exit(0);\n                }\n                FD_SET(sid1,&rdfs);\n                maxfd=maxfd>=sid1?maxfd:sid1;\n                maxfd=maxfd+1;\n                int k=recv(sid1,msg,sizeof(msg),0);\n                msg[k]='\\0';\n                printf(\"Message from client is:%s\\n\",msg);\n                close(sid1);\n                FD_CLR(sid1,&rdfs);\n            }\n        }\n    }\n    close(sockid);          \n}"}
{"author": "earth429", "file": "mulpre__mulprec.16.c", "original_string": "int sub(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    int h = 0;\n    int i;\n    int return_val;\n    int x, y; \n    struct NUMBER a_abs, b_abs; \n    clearByZero(c);\n    if(getSign(a) > 0 && getSign(b) > 0){ \n        return_val = numComp(a, b); \n        switch (return_val)\n        {\n        case 1: \n            for (i = 0; i < KETA;i++){\n                x = a->n[i] - h;\n                y = b->n[i];\n                if(a->n[i] < b->n[i]){\n                    c->n[i] = 10 + x - y;\n                    h = 1; \n                } else if(a->n[i] >= b->n[i]){\n                    c->n[i] = x - y;\n                    h = 0; \n                }\n            }\n            if(h != 0){ \n                return -1;\n            }\n            return 0; \n        case -1: \n            sub(b, a, c);\n            setSign(c, -1);\n            return 0;\n        case 0: \n            return 0;\n        }\n    } else if(getSign(a) > 0 && getSign(b) < 0){ \n        getAbs(b, &b_abs);\n        add(a, &b_abs, c);\n        return 0; \n    } else if(getSign(a) < 0 && getSign(b) > 0){ \n        getAbs(a, &a_abs);\n        add(&a_abs, b, c);\n        setSign(c, -1);\n        return 0; \n    } else if(getSign(a) < 0 && getSign(b) < 0){ \n        getAbs(b, &b_abs);\n        add(a, &b_abs, c);\n        return 0; \n    }\n    return 100; \n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__test.1.c", "original_string": "void interrupt_config(void)\n{\n PINSEL0 |= (1<<29);\n PINSEL0 &=~(1<<28);\n VICIntSelect &= ~(1<<15); \n VICVectCntl1 = (   1<<5)|15;   \n VICVectAddr1 = (long)eint_isr;\n VICIntEnable = (1<<15);\n EXTMODE = (1<<1);\n EXTPOLAR = (1<<1); \n}"}
{"author": "jdes01", "file": "practicassoo__practica2ej3.5.c", "original_string": "void * sumaHilos (void* d){\n    int * suma = malloc( sizeof(int) );\n    *suma = 0;\n    vInfo *v;\n    v = (vInfo*) d;\n    for (int i = 0; i < v->numeroElementos; i++){\n        *suma = *suma + v->vector[i];\n    }\n    printf(\"La suma de los elementos de este vector es: %d \\n\", *suma);\n    pthread_exit((void**) suma);\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.18.c", "original_string": "EXPRESSIONLIST* parseexpressionlist(PARSER* p) {\n    if(!strcmp(p->current->token, \")\"))\n        return NULL;\n    EXPRESSIONLIST* head = (EXPRESSIONLIST*)malloc(sizeof(EXPRESSIONLIST));\n    head->expression = parseexpressionnullified(p);\n    EXPRESSIONLIST* current = head;\n    EXPRESSIONLIST* nextls;\n    while(!strcmp(p->current->token, \",\")) {\n        next(p);\n        nextls = (EXPRESSIONLIST*)malloc(sizeof(EXPRESSIONLIST));\n        nextls->expression = parseexpression(p);\n        current->next = nextls;\n        current = nextls;\n    }\n    if(current != NULL)\n        current->next = NULL;\n    return head;\n}"}
{"author": "2security", "file": "Star__HollowPyramidStar.0.c", "original_string": "int main()\n    {\n    int n,i,j,k;\n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<=n-i;j++)\n            printf(\" \");\n        for(k=1;k<=2*i-1;k++)\n            {\n                if(k==1||i==n||k==2*i-1)\n                    printf(\"*\");\n                else\n                    printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_pwr_ex.14.c", "original_string": "HAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void)\n{\n  uint32_t tickstart = 0U;\n  __HAL_RCC_PWR_CLK_ENABLE();\n  __HAL_PWR_OVERDRIVESWITCHING_DISABLE();\n  tickstart = HAL_GetTick();\n  while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))\n  {\n    if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    }\n  } \n  __HAL_PWR_OVERDRIVE_DISABLE();\n  tickstart = HAL_GetTick();\n  while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))\n  {\n    if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_OK;\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad7ElementsCopy.1.c", "original_string": "void copyArrayNormal(int sourceArray[], int outputArray[], int size){\n    for(int i = 0; i < size; i++){\n        outputArray[i] = sourceArray[i];\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__9.3.c", "original_string": "int main()\n{\n    int n;\n    do\n    {\n        printf(\"\\nDigite um inteiro positivo: \");\n        scanf(\"%i\", &n);\n        getchar();\n        system(\"clear\");\n    } while(n <= 0);\n    if (n >= 5) printf(\"\\nFatorial exponencial de %i = %e\\n\\n\", n, super_fatorial(n));\n    else printf(\"\\nFatorial exponencial de %i = %.0lf\\n\\n\", n, super_fatorial(n));\n    return 0;\n}"}
{"author": "shengelenge", "file": "wstep-do-programowania__zad101.0.c", "original_string": "int main()\n{\n    long double min, max, kolejna, suma = 0, srednia;\n    printf(\"Podaj liczby rzeczywsite, po wpisaniu 0 program zakonczy wczytywanie.\\nLiczby:\\n\");\n    scanf(\"%Lf\", &kolejna);\n    suma += kolejna;\n    if (kolejna != 0)\n    {\n        int i = 1;\n        min = kolejna;\n        max = kolejna;\n        scanf(\"%Lf\", &kolejna);\n        suma += kolejna;\n        srednia = suma / i++;\n        while (kolejna)\n        {\n            if (kolejna > max)\n                max = kolejna;\n            else {\n                if (kolejna < min)\n                    min = kolejna;\n            }\n            scanf(\"%Lf\", &kolejna);\n            suma += kolejna;\n            srednia = suma / i++;\n        }\n        printf(\"min = %.2Lf, max = %.2Lf\\n\", min, max);\n        printf(\"suma = %.2Lf, \", suma);\n        printf(\"srednia = %.2Lf, \", srednia);\n    }\n    else\n        printf(\"Ciag wejsciowy jest pusty.\\n\");\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__DemoFOTAUpdateWorkflow.3.c", "original_string": "void fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)\n{\n  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;\n  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad2.0.c", "original_string": "int main()\n{\n    int userYear;\n    int userDay;\n    char userMonth[MAXNAME];\n    printf(\"Program wyswietli liczbe dni od poczatku roku do podanego dnia miesiaca.\\n\");\n    printf(\"Podaj numer dnia.\\n\");\n    scanf(\"%d\", &userDay);\n    printf(\"Podaj (nazwe, numer lub skrot) miesiaca.\\n\");\n    scanf(\"%s\", &userMonth);\n    printf(\"Podaj rok.\\n\");\n    scanf(\"%d\", &userYear);\n    printf(\"Liczba dni: %d\", numberOfDays(userMonth, userDay, userYear));\n    getchar();\n    return 0;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__23_cosh.2.c", "original_string": "int main(){\n        double X;\n        printf(\"Programa para calcular el cosh(X) por medio de sumas de Taylor\\nValor de X:\");\n        scanf(\"%lf\", &X);\n        cosh(1,30,0,X);\n        return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__poly.4.c", "original_string": "nptr add(nptr poly1, nptr poly2)\n{\n    nptr poly3, temp1 = poly1, temp2 = poly2;\n    while(temp1)\n    {\n        if ( getCoeff(poly2, temp1 -> exp) )\n            poly3 = insert(poly3,               temp1 -> coeff + getCoeff(poly2, poly1 -> exp),            poly1 -> exp);\n        poly1 = poly1 -> next;\n    }\n    temp1 = poly1, temp2 = poly2;\n    while(temp1)\n    {\n        if (getCoeff(poly3, temp1 -> exp) == 0)\n            poly3 = insert(poly3, temp1 -> coeff, temp1 -> exp);\n        temp1 = temp1 -> next;\n    }\n    while(temp2)\n    {\n        if (getCoeff(poly3, temp2 -> exp) == 0)\n            poly3 = insert(poly3, temp2 -> coeff, temp2 -> exp);\n        temp2 = temp2 -> next;\n    }\n    return poly3;\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__cub2d_utils.2.c", "original_string": "void        norm_it(char **meh)\n{\n    int e;\n    int f;\n    int x;\n    int y;\n    e = 0;\n    f = 0;\n    x = 0;\n    y = 0;\n    while (meh[e])\n    {\n        while (meh[e][f])\n        {\n            if (meh[e][f] == '1')\n                draw_cube(y, x);\n            f++;\n            x = x + g_tile_size;\n        }\n        f = 0;\n        e++;\n        x = 0;\n        y = y + g_tile_size;\n    }\n}"}
{"author": "ankitraj311", "file": "450_babbar__7_intersection_array_SELF.0.c", "original_string": "void array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__heap_sort.4.c", "original_string": "int main(void) {\n    printf(\"sorting the elements in the array \\n\"); \n    printf(\"heap sort \\n\");\n    int a[]={15,12,9,54,60,45};\n    int n=sizeof(a)/sizeof(a[0]);\n    printf(\"the elements in the array are :\\n \");\n    printarray(a,n);\n    printf(\"\\n after sorting elements in the array are :\\n\");\n    heapsort(a,n);\n    printarray(a,n);\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ili9341_ext.8.c", "original_string": "static void ili9341_pixel_draw(uint16_t x, uint16_t y, uint32_t color)\n{\n    set_addr_window(x, y, x, y);\n    const uint8_t data[2] = {color >> 8, color};\n    nrf_gpio_pin_set(ILI9341_DC_PIN);\n    spi_write(data, sizeof(data));\n    nrf_gpio_pin_clear(ILI9341_DC_PIN);\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_gpio.0.c", "original_string": "void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)\n{\n  uint32_t position;\n  uint32_t ioposition = 0x00U;\n  uint32_t iocurrent = 0x00U;\n  uint32_t temp = 0x00U;\n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\n  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));\n  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));\n  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));\n  for(position = 0U; position < GPIO_NUMBER; position++)\n  {\n    ioposition = 0x01U << position;\n    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;\n    if(iocurrent == ioposition)\n    {\n      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))\n      {\n        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));\n        temp = GPIOx->AFR[position >> 3U];\n        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;\n        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));\n        GPIOx->AFR[position >> 3U] = temp;\n      }\n      temp = GPIOx->MODER;\n      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));\n      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));\n      GPIOx->MODER = temp;\n      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||\n         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))\n      {\n        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));\n        temp = GPIOx->OSPEEDR; \n        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));\n        temp |= (GPIO_Init->Speed << (position * 2U));\n        GPIOx->OSPEEDR = temp;\n        temp = GPIOx->OTYPER;\n        temp &= ~(GPIO_OTYPER_OT_0 << position) ;\n        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);\n        GPIOx->OTYPER = temp;\n      }\n      temp = GPIOx->PUPDR;\n      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));\n      temp |= ((GPIO_Init->Pull) << (position * 2U));\n      GPIOx->PUPDR = temp;\n      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)\n      {\n        __HAL_RCC_SYSCFG_CLK_ENABLE();\n        temp = SYSCFG->EXTICR[position >> 2U];\n        temp &= ~(0x0FU << (4U * (position & 0x03U)));\n        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));\n        SYSCFG->EXTICR[position >> 2U] = temp;\n        temp = EXTI->IMR;\n        temp &= ~((uint32_t)iocurrent);\n        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)\n        {\n          temp |= iocurrent;\n        }\n        EXTI->IMR = temp;\n        temp = EXTI->EMR;\n        temp &= ~((uint32_t)iocurrent);\n        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)\n        {\n          temp |= iocurrent;\n        }\n        EXTI->EMR = temp;\n        temp = EXTI->RTSR;\n        temp &= ~((uint32_t)iocurrent);\n        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)\n        {\n          temp |= iocurrent;\n        }\n        EXTI->RTSR = temp;\n        temp = EXTI->FTSR;\n        temp &= ~((uint32_t)iocurrent);\n        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)\n        {\n          temp |= iocurrent;\n        }\n        EXTI->FTSR = temp;\n      }\n    }\n  }\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__unique.4.c", "original_string": "void imprime(int ns[]){\n  for(int i = 0; i < 9; i++)\n    if(ns[i] != 0)\n      printf(\"%d\", ns[i]);\n  printf(\"\\n\");\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__readfile.0.c", "original_string": "int     readline(void)\n{\n    int     fd;\n    char    *line;\n    fd = open(\"map.cub\", O_RDONLY);\n    global_init();\n    while (get_next_line(fd, &line))\n    {\n        if (!all_params())\n        {\n            if (*line != '\\0')\n                routing(line);\n        }\n        else\n            routing(line);\n        free(line);\n    }\n    free(line);\n    return (0);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__21_Dowhile.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cos(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    do{\n        if(i%2 == 0)\n            Suma_total += (Exp(X, i*2) / Fac(i*2));\n        else\n            Suma_total -= (Exp(X, i*2) / Fac(i*2));\n        ++i;\n    }while(i <= veces);\n    printf(\"cos(%i) es igual a %lf\", X, (Suma_total + 1.0));\n    return 0;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_11.0.c", "original_string": "struct Stack* createStack( unsigned capacity ) \n{ \n    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack)); \n    if (!stack)  \n        return NULL; \n    stack->top = -1; \n    stack->capacity = capacity; \n    stack->array = (int*) malloc(stack->capacity * sizeof(int)); \n    if (!stack->array) \n        return NULL; \n    return stack; \n}"}
{"author": "dishanp", "file": "DSA__q1.1.c", "original_string": "int** createsparserow(int **p, int m, int n)\n{\n    int r = num + 1;\n    int **sparse = (int**)malloc(r * sizeof(int*));\n    for(int i = 0 ; i < r ; i++)\n    {\n        sparse[i] = (int*)malloc(3 * sizeof(int));\n    }\n    sparse[0][0] = m;\n    sparse[0][1] = n;\n    sparse[0][2] = num;\n    int k = 1;\n    for(int i = 0 ; i < m ; i++)\n    {\n        for(int j = 0 ; j < n ; j++)\n        {\n            if(p[i][j] != 0)\n            {\n                sparse[k][0] = i;\n                sparse[k][1] = j;\n                sparse[k][2] = p[i][j];\n                k++;\n            }\n        }\n    }\n    return sparse;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.6.c", "original_string": "static bool canOpenFirmwareUpdateInfoFile(void)\n{\n  char *os = getenv(\"OS\");\n  char command[260 + 1] = \"\";\n  if (os != NULL && strcmp(os, \"Windows_NT\") == 0) \n  {\n    snprintf(command, sizeof(command), \"powershell -command \\\"where.exe code | Measure-Object -Line | Select-Object -ExpandProperty Lines\\\"\");\n  }\n  else\n  {\n    snprintf(command, sizeof(command), \"which code | wc -l\");\n  }\n  FILE *commandPipe = popen(command, \"r\");\n  if (commandPipe == NULL) \n  {\n    printf(\"Failed to run '%s' command: %s (error code: %i)\\n\", command, strerror(errno), errno);\n    return false;\n  }\n  int32_t count = 0;\n  if (fscanf(commandPipe, \"%d\", &count) != 1) \n  {\n    pclose(commandPipe);\n    return false;\n  }\n  pclose(commandPipe);\n  return count > 0;\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.6.c", "original_string": "VAR* getvar(SCOPE* s, const char* name) {\n    VAR* var = getvarinvars(s->localvars, name);\n    if(var != NULL)\n        return var;\n    var = getvarinvars(s->parameters, name);\n    if(var != NULL)\n        return var;\n    var = getvarinvars(s->fields, name);\n    if(var != NULL)\n        return var;\n    var = getvarinvars(s->staticvars, name);\n    if(var != NULL)\n        return var;\n    if(s->previous != NULL)\n        return getvar(s->previous, name);\n    return NULL;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__cycle_detector2.0.c", "original_string": "int     cycle_detector(const t_list *list)\n{\n    const t_list *p;\n    const t_list *q;\n    p = list;\n    q = list;\n    while (p && q && q->next)\n    {\n        p = p->next;\n        q = q->next->next;\n        if (p == q)\n            return (1);\n    }\n    return (0);\n}"}
{"author": "Theemiss", "file": "simple_shell__more_bul.0.c", "original_string": "int print_echo(char **cmd)\n{\n    pid_t pid;\n    int status;\n    pid = fork();\n    if (pid == 0)\n    {\n    if (execve(\"/bin/echo\", cmd, environ) == -1)\n    {\n        return (-1);\n    }\n        exit(EXIT_FAILURE);\n    }\n    else if (pid < 0)\n    {\n        return (-1);\n    }\n    else\n    {\n        do {\n            waitpid(pid, &status, WUNTRACED);\n        } while (!WIFEXITED(status) && !WIFSIGNALED(status));\n    }\n    return (1);\n}"}
{"author": "sdukesameer", "file": "dsa__dll-ins-seq-sor-del.2.c", "original_string": "node* search_node(node* head, int n) \n{\n    node* dll=head;\n    while (dll!=NULL)\n    {\n        if(dll->data==n)\n            return dll;\n        dll=dll->next;\n    }\n    return NULL;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader0.6.c", "original_string": "static bool canOpenFirmwareUpdateInfoFile(void)\n{\n  char *os = getenv(\"OS\");\n  char command[260 + 1] = \"\";\n  if (os != NULL && strcmp(os, \"Windows_NT\") == 0) \n  {\n    snprintf(command, sizeof(command), \"powershell -command \\\"where.exe code | Measure-Object -Line | Select-Object -ExpandProperty Lines\\\"\");\n  }\n  else\n  {\n    snprintf(command, sizeof(command), \"which code | wc -l\");\n  }\n  FILE *commandPipe = popen(command, \"r\");\n  if (commandPipe == NULL) \n  {\n    printf(\"Failed to run '%s' command: %s (error code: %i)\\n\", command, strerror(errno), errno);\n    return false;\n  }\n  int32_t count = 0;\n  if (fscanf(commandPipe, \"%d\", &count) != 1) \n  {\n    pclose(commandPipe);\n    return false;\n  }\n  pclose(commandPipe);\n  return count > 0;\n}"}
{"author": "jdes01", "file": "practicassoo__practica1ej2.0.c", "original_string": "int main(){\n    int status;\n    pid_t hijo;\n    printf(\"Soy el padre \\n\");\n    printf(\"\\n\");\n    hijo = fork();\n    if (hijo == -1){\n        printf(\"Error \\n\");\n        exit(EXIT_FAILURE);\n    }\n    if (hijo == 0){\n        printf(\"HIJO ID: %d \\n\", getpid());\n        exit(EXIT_SUCCESS);\n    }\n    else{\n        printf(\"sleep 20s \\n\");\n        sleep(20);\n        wait(&status);\n        printf(\"Proceso hijo termindo con el codigo %d \\n\", WEXITSTATUS(status));\n        sleep(20);\n        exit(EXIT_SUCCESS);\n    }\n    return 0;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad9.1.c", "original_string": "treePointer AllocateMemory(int element)\n{\n    treePointer newNode = (treePointer)malloc(sizeof(struct treeNode));\n    if (!newNode)\n    {\n        printf(\"Problem s alokacijom memorije!\\n\");\n        return newNode;\n    }\n    newNode->data = element;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}"}
{"author": "behergue", "file": "Operating_Systems__myFS.21.c", "original_string": "int readBlock(MyFileSystem *myFileSystem, DISK_LBA blockNumber, void *buffer)\n{\n    if(blockNumber < 0 || blockNumber >= myFileSystem->superBlock.diskSizeInBlocks) {\n        fprintf(stderr,\"Firts bocks to be read must be between 0 and %d\\n\", myFileSystem->superBlock.diskSizeInBlocks-1);\n        return -1;\n    }\n    if( lseek(myFileSystem->fdVirtualDisk, blockNumber*BLOCK_SIZE_BYTES, SEEK_SET) == (off_t)-1 ) {\n        perror(\"Failed lseek in readBlock()\");\n        return -1;\n    }\n    if( read(myFileSystem->fdVirtualDisk, buffer, BLOCK_SIZE_BYTES) != BLOCK_SIZE_BYTES ) {\n        perror(\"Failed read in readBlock()\");\n    }\n    return 0;\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_pwr.8.c", "original_string": "void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)\n{\n  assert_param(IS_PWR_REGULATOR(Regulator));\n  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));\n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));\n  if(SLEEPEntry == PWR_SLEEPENTRY_WFI)\n  {   \n    __WFI();\n  }\n  else\n  {\n    __SEV();\n    __WFE();\n    __WFE();\n  }\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.35.c", "original_string": "ASMBLK* translatereturn(VMTRANSLATOR* t) {\n    ASMBLK* blk = copytemplate(&tstartreturn);\n    for(int i = tframevars.count-1; i >= 0; i--) {\n        tretpop.items[tretpop.count-2] = tframevars.items[i];\n        mergeasmblks(blk, copytemplate(&tretpop));\n    }\n    mergeasmblks(blk, copytemplate(&tendreturn));\n    return blk;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__main.0.c", "original_string": "int main(int argc, char* argv[]) {\n    if(argc < 2) {\n        eprintf(\"Usage: %s {input file(s)}\\n\", argv[0]);\n        return 1;\n    }\n    FILELIST* files = getfiles(argv[1]);\n    FILELIST* curr = files->next;\n    COMPILEUNIT* head = (COMPILEUNIT*)malloc(sizeof(COMPILEUNIT));\n    head->file = files;\n    head->parser = mkparser(tokenize(files->fullname), files->name);\n    COMPILEUNIT* currunit = head;\n    while(curr != NULL) {\n        COMPILEUNIT* newunit = (COMPILEUNIT*)malloc(sizeof(COMPILEUNIT));\n        newunit->file = curr;\n        newunit->parser = mkparser(tokenize(curr->fullname), curr->name);\n        currunit->next = newunit;\n        currunit = newunit;\n        curr = curr->next;\n    }\n    currunit->next = NULL;\n    actonunits(head, parseunit);\n    CLASS* headclass = head->parsed;\n    CLASS* currclass = headclass;\n    currunit = head->next;\n    while(currunit != NULL) {\n        currclass->next = currunit->parsed;\n        currclass = currunit->parsed;\n        currunit = currunit->next;\n    }\n    currclass->next = NULL;\n    COMPILER* compiler = mkcompiler(headclass);\n    currunit = head;\n    while(currunit != NULL) {\n        currunit->compiler = compiler;\n        currunit = currunit->next;\n    }\n    actonunits(head, compileunit);\n    currunit = head;\n    while(currunit != NULL) {\n        FILE* output = fopen(currunit->file->outname, \"w\");\n        if(output == NULL) {\n            eprintf(\"%s\", strerror(errno));\n            exit(1);\n        }\n        if(currunit->compiled == NULL) {\n            eprintf(\"Class '%s' is empty; file '%s'\\n\", currunit->parsed->name, currunit->file->name);\n            exit(1);\n        }\n        printlns(currunit->compiled->head, output);\n        fclose(output);\n        COMPILEUNIT* next = currunit->next;\n        freeunit(currunit);\n        currunit = next;\n    }\n    freecompiler(compiler);\n    freetree(headclass);\n    freefilelist(files);\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-structure.1.c", "original_string": "char* parsetype(PARSER* p) {\n    if(p->current->type != identifier && p->current->type != keyword)\n        unexpected(p);\n    char* result = p->current->token;\n    next(p);\n    return result;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__functions.4.c", "original_string": "int AddToHashTable(position newStudent, pointerHash hashTable)\n{\n    int hashKey = CountKey(newStudent->lastName, hashTable->size);\n    if (!hashTable->hashList[hashKey])\n        hashTable->hashList[hashKey] = newStudent;\n    else\n    {\n        position currentStudent = hashTable->hashList[hashKey];\n        if (currentStudent && (strcmp(newStudent->lastName, currentStudent->lastName) < 0 || (strcmp(newStudent->lastName, currentStudent->lastName) == 0 && strcmp(newStudent->firstName, currentStudent->firstName) < 0)))\n        {\n            hashTable->hashList[hashKey] = newStudent;\n            newStudent->next = currentStudent;\n        }\n        else \n        {\n            while (currentStudent->next)\n            {\n                if (strcmp(newStudent->lastName, currentStudent->next->lastName) < 0 || (strcmp(newStudent->lastName, currentStudent->next->lastName) == 0 && strcmp(newStudent->firstName, currentStudent->next->firstName) < 0))\n                {\n                    newStudent->next = currentStudent->next;\n                    currentStudent->next = newStudent;\n                    break;\n                }\n                currentStudent = currentStudent->next;\n            }\n            if (!currentStudent->next)\n            {\n                newStudent->next = currentStudent->next;\n                currentStudent->next = newStudent;\n            }\n        }\n    }\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__io.4.c", "original_string": "char* getfullname(char* fname, int fnamelen, char* dirname, int dirlen) {\n    int sz = sizeof(char)*(fnamelen+dirlen+2);\n    char* fullname = (char*)malloc(sz);\n    sprintf(fullname, \"%s/%s\", dirname, fname);\n    return fullname;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSL__tls_ticket.2.c", "original_string": "error_t tlsDecryptTicket(TlsContext *context, const uint8_t *ciphertext,\n   size_t ciphertextLen, uint8_t *plaintext, size_t *plaintextLen, void *param)\n{\n   error_t error;\n   const uint8_t *iv;\n   const uint8_t *data;\n   const uint8_t *tag;\n   TlsTicketContext *ticketContext;\n   TlsTicketEncryptionState *state;\n   if(context == NULL || param == NULL)\n      return ERROR_INVALID_PARAMETER;\n   if(ciphertext == NULL || plaintext == NULL || plaintextLen == NULL)\n      return ERROR_INVALID_PARAMETER;\n   if(ciphertextLen < (TLS_TICKET_KEY_NAME_SIZE + TLS_TICKET_IV_SIZE +\n      TLS_TICKET_TAG_SIZE))\n   {\n      return ERROR_DECRYPTION_FAILED;\n   }\n   error = NO_ERROR;\n   iv = NULL;\n   data = NULL;\n   tag = NULL;\n   state = NULL;\n   ticketContext = (TlsTicketContext *) param;\n   osAcquireMutex(&ticketContext->mutex);\n   tlsCheckTicketKeyLifetime(&ticketContext->encryptionState);\n   tlsCheckTicketKeyLifetime(&ticketContext->prevEncryptionState);\n   if(tlsCompareTicketKeyName(ciphertext, ciphertextLen,\n      &ticketContext->encryptionState))\n   {\n      state = &ticketContext->encryptionState;\n   }\n   else if(tlsCompareTicketKeyName(ciphertext, ciphertextLen,\n      &ticketContext->prevEncryptionState))\n   {\n      state = &ticketContext->prevEncryptionState;\n   }\n   else\n   {\n      error = ERROR_DECRYPTION_FAILED;\n   }\n   if(!error)\n   {\n      iv = ciphertext + TLS_TICKET_KEY_NAME_SIZE;\n      data = iv + TLS_TICKET_IV_SIZE;\n      tag = ciphertext + ciphertextLen - TLS_TICKET_TAG_SIZE;\n      *plaintextLen = ciphertextLen - TLS_TICKET_KEY_NAME_SIZE -\n         TLS_TICKET_IV_SIZE - TLS_TICKET_TAG_SIZE;\n      error = aesInit(&ticketContext->aesContext, state->key,\n         TLS_TICKET_KEY_SIZE);\n   }\n   if(!error)\n   {\n      error = gcmInit(&ticketContext->gcmContext, AES_CIPHER_ALGO,\n         &ticketContext->aesContext);\n   }\n   if(!error)\n   {\n      error = gcmDecrypt(&ticketContext->gcmContext, iv, TLS_TICKET_IV_SIZE,\n         state->keyName, TLS_TICKET_KEY_NAME_SIZE, data, plaintext,\n         *plaintextLen, tag, TLS_TICKET_TAG_SIZE);\n   }\n   osReleaseMutex(&ticketContext->mutex);\n   return error;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__timer1_isr.5.c", "original_string": "void delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler.2.c", "original_string": "void Display(PNODE Head, PNODE Tail)\n{\n        if((Head == NULL) && (Tail == NULL))\n        {\n            return;\n        }\n        do\n        {\n            printf(\"|%d| <-> \",Head->data);\n            Head = Head->next;\n        }while(Head != Tail->next);\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_30.2.c", "original_string": "void imprimirVetorIntersecao() {\n    for (int i = 0; i < 10; i++) {\n        if (intersecao[i] > 0) {\n            printf(\"%d\\n\", intersecao[i]);\n        }\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q2_set1.2.c", "original_string": "nodeptr intersection(nodeptr a,nodeptr b)\n{\n    nodeptr c,at;\n    at=a;\n    c=NULL;\n    for(;b;b=b->link)\n    {\n        for(;at;at=at->link)\n            if(b->data==at->data)\n            {\n                add(&c,b->data);\n                break;\n            }\n        at=a;\n    }\n    return c;\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-statements.9.c", "original_string": "LINEBLOCK* compilestatementsretlast(SCOPE* s, STATEMENT* sts, STATEMENT** retlast) {\n    LINEBLOCK* head = NULL;\n    STATEMENT* last = NULL;\n    while(sts != NULL) {\n        head = mergelnblks(head, compilestatement(s, sts));\n        last = sts;\n        sts = sts->next;\n    }\n    *retlast = last;\n    return head;\n}"}
{"author": "fikepaci", "file": "sorting_algorithms__103-merge_sort.0.c", "original_string": "void merge_sort(int *array, size_t size)\n{\n    int low;\n    int high;\n    int *temp;\n    low = 0;\n    high = size - 1;\n    temp = malloc(sizeof(int) * size);\n    if (temp == NULL)\n        return;\n    sort(array, low, high, temp);\n    free(temp);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_DLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    int count=0;\n    temp=head;\n    while(temp!=0)\n    {\n        count++;\n        temp=temp->next;\n    }\n    printf(\"the number of element in linked list is %d\", count);\n    printf(\"\\n\");\n}"}
{"author": "kbtomic", "file": "Seminarski-StrukturePodataka__Stack.2.c", "original_string": "int CleanStack(stackPointer stackHead)\n{\n    stackPointer prev = stackHead->next, top = stackHead->next;\n    stackHead = stackHead->next;\n    while (top->next)\n    {\n        while (stackHead->next)\n        {\n            prev = stackHead;\n            stackHead = stackHead->next;\n        }\n        free(stackHead);\n        prev->next = NULL;\n        stackHead = top->next;\n        prev = top;\n    }\n    return 0;\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client_archive.1.c", "original_string": "void str_trim_lf(char *arr, int length)\n{\n    int i;\n    for (i = 0; i < length; i++)\n    {\n        if (arr[i] == '\\n')\n        {\n            arr[i] = '\\0';\n            break;\n        }\n    }\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__MFT.0.c", "original_string": "void main()\n{\n    int n,i,size,IF=0,EF=0;\n    printf(\"\\nEnter the size of memory : \");\n    scanf(\"%d\",&Mem);\n    printf(\"\\nEnter size of each block : \");\n    scanf(\"%d\",&block);\n    printf(\"\\nEnter the number of programs : \");\n    scanf(\"%d\",&n);\n    struct program p[n];\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter name : \");\n        scanf(\"%s\",p[i].name);\n        printf(\"\\nEnter size : \");\n        scanf(\"%d\",&p[i].size);\n        p[i].If=0;\n        p[i].status=0;\n    }\n    for(i=0;i<n;i++)\n    {\n        if(p[i].size<=block)\n        {\n            p[i].status=1;\n            p[i].If=block-p[i].size;\n            IF=IF+p[i].If;\n        }\n        else\n        {\n            EF=EF+block;\n        }\n    }\n    printf(\"\\nprogram\\tsize\\tIF\\n\");\n    for(i=0;i<n;i++)\n        printf(\"%s\\t%d\\t%d\\n\",p[i].name,p[i].size,p[i].If);\n    printf(\"\\nTotal Internal Fragmentation is : %d\",IF);\n    printf(\"\\nTotal External Fragmentation is : %d\",EF);\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__tab_mlt.1.c", "original_string": "void    ft_putnbr(int nb)\n{\n    if (nb < 0)\n        nb *= -1;\n    if (nb > 9)\n    {\n        ft_putnbr(nb / 10);\n        ft_putnbr(nb % 10);\n    }\n    else\n        ft_putchar(nb + 48);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__2.6.c", "original_string": "int main()\n{\n    QUEUE q1, q2; q1.front = q1.rear = q2.front = q2.rear = 0;            \n    int n;\n    printf(\"Enter no. of elements: \");\n    scanf(\"%d\", &n);\n    printf(\"Enter elements: \");\n    for(int i = 0 ; i < n ; i++)\n    {\n        int a;\n        scanf(\"%d\", &a);\n        enqueue(&q1, a);\n    }\n    printf(\"QUEUE 1:\");    display(&q1);\n    reverse(&q1, &q2,n);\n    printf(\"QUEUE 2:\");    display(&q2);\n    return 0;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__40_diff_n_matrix.0.c", "original_string": "int main()\n{\n  int i,j,k,r1,c1,r2,c2,flag = 0;\n  printf(\"Enter Value of r1, c1, r2, c2\\n\");\n  scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n  int m1[r1][c1], m2[r2][c2], add_array[r1][c1], mul[r1][c2];\n  printf(\"Enter value of Matrix1\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      scanf(\"%d\",&m1[i][j]);\n    }\n  }\n  do\n  {\n    printf(\"Enter value of Matrix2\\n\");\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        scanf(\"%d\",&m2[i][j]);\n      }\n    }\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        add_array[i][j] = m2[i][j] - m1[i][j];\n      }\n    }\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        printf(\"%.2d \",add_array[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        m1[i][j] = add_array[i][j];\n    add_array[i][j] = 0;\n      }\n    }\n    printf(\"Enter 1 To Add more Matrix\\n\");\n    scanf(\"%d\",&flag);\n  }while(flag);\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__InsertionOfNodeAtEndInLL.0.c", "original_string": "int insert_at_end(struct node*temp1)\n{\n    struct node*tempo;\n    tempo = (struct node*) malloc (sizeof(struct node));\n    printf(\"Enter the data:\");\n    scanf(\"%d\",&tempo->data);\n    tempo->link = NULL;\n    temp1->link = tempo;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler.0.c", "original_string": "void InsertLast(PPNODE Head, PPNODE Tail, int value)\n{\n    PNODE newn = NULL;\n    newn = (PNODE)malloc(sizeof(NODE));\n    newn->data = value;\n    newn->next = NULL;\n    newn->prev = NULL;\n    if((*Head ==NULL) && (*Tail == NULL))       \n    {\n        *Head = newn;\n        *Tail = newn;\n    }\n    else            \n    {\n        (*Tail)->next = newn;\n        newn->prev = *Tail;\n        *Tail = (*Tail) ->next;   \n    }\n    (*Tail)->next = *Head;\n    (*Head)->prev = *Tail;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-central-scanner-with-whitelist__nrf_fstorage.3.c", "original_string": "ret_code_t nrf_fstorage_write(nrf_fstorage_t const * p_fs,\n                              uint32_t               dest,\n                              void           const * p_src,\n                              uint32_t               len,\n                              void                 * p_context)\n{\n    NRF_FSTORAGE_PARAM_CHECK(p_fs,        NRF_ERROR_NULL);\n    NRF_FSTORAGE_PARAM_CHECK(p_src,       NRF_ERROR_NULL);\n    NRF_FSTORAGE_PARAM_CHECK(p_fs->p_api, NRF_ERROR_INVALID_STATE);\n    NRF_FSTORAGE_PARAM_CHECK(len,         NRF_ERROR_INVALID_LENGTH);\n    NRF_FSTORAGE_PARAM_CHECK(!(len % p_fs->p_flash_info->program_unit), NRF_ERROR_INVALID_LENGTH);\n    NRF_FSTORAGE_PARAM_CHECK(addr_is_aligned32(dest),                NRF_ERROR_INVALID_ADDR);\n    NRF_FSTORAGE_PARAM_CHECK(addr_is_aligned32((uint32_t)p_src),     NRF_ERROR_INVALID_ADDR);\n    NRF_FSTORAGE_PARAM_CHECK(addr_is_within_bounds(p_fs, dest, len), NRF_ERROR_INVALID_ADDR);\n    return (p_fs->p_api)->write(p_fs, dest, p_src, len, p_context);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_any_pos_DLL.0.c", "original_string": "int main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of element in the linked list\\n\");\n    printf(\"4.delete the element from any position from the linked list\\n\");\n    printf(\"5.exit\\n\");\n    int choice;\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1: printf(\"implementation\\n\");\n            creat();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of element in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"delete the element from any position from the linked list\\n\");\n            delete_at_pos();\n            break;\n            case 5:printf(\"exit \\n\");\n            exit(0);\n            break;\n            default:printf(\"invalied choice \\n\");\n            break;\n        }\n         printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client_thread.3.c", "original_string": "void* recv_msg_handler(void* pclient)\n{\n    int sockfd = *((int* ) pclient);\n    char message[LENGTH] = {};\n    while (1)\n    {\n        int receive = recv(sockfd, message, LENGTH, 0);\n        if (receive > 0)\n        {\n            printf(\"%s\", message);\n            str_overwrite_stdout();\n        }\n        else if (receive == 0)\n        {\n            break;\n        }\n        memset(message, 0, sizeof(message));\n    }\n    return NULL;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__DAG1.5.c", "original_string": "int check(char dir)\n{\n    int flag=-1;\n    int i;\n    for(i=0;i<pos;i++)\n    {\n        temp=G[i];\n        while(temp!=NULL)\n        {\n            if(temp->name==dir && temp->id==1)\n            {\n                flag=1;\n                break;\n            }\n            else\n            {\n                temp=temp->next;\n            }\n        }\n        if(flag==1)\n            break;\n    }\n    return(flag);\n}"}
{"author": "davibernardos", "file": "DB-PJ__e80.2.c", "original_string": "void comparaCaptcha(char valor[CAPTCHA], char digitado[CAPTCHA]){\n    if (strcmp(valor, digitado) == 0) {\n        printf(\"Obrigado, esta confirmado que voce nao e um robo!\\n\");\n        loop = 0;\n    } else {\n        printf(\"CAPTCHA digitado incorretamente, por favor tente novamente.\\n\");\n    }\n}"}
{"author": "dishanp", "file": "DSA__q53.1.c", "original_string": "int main()\n{\n    int *arr;\n    int n;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n    rearrange(arr, n);\n    for (int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d \", *(arr + i));\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader.5.c", "original_string": "static bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"r\");\n  if (updateInfoFile == NULL) \n  {\n    return false;\n  }\n  memset(updateInfoString, 0, updateInfoStringSize);\n  while (isWhitespace(updateInfoString))\n  {\n    if (fgets(updateInfoString, ((int32_t) updateInfoStringSize), updateInfoFile) == NULL) \n    {\n      fclose(updateInfoFile);\n      return false;\n    }\n  }\n  fclose(updateInfoFile);\n  return true;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__st.2.c", "original_string": "int     main(int ac, char **av)\n{\n    int i;\n    int i2;\n    i = 0;\n    if (ac > 1)\n    {\n        while (i < ac)\n        {\n            i++;\n            i2 = 0;\n            while (av[i][i2] != '\\0')\n            {\n                if (av[i][0] >= 'a' && av[i][0] <= 'z')\n                    av[i][0] -= 32;\n                else if (ft_to_lower(av[i][i2 - 1], av[i][i2], i2 - 1))\n                    av[i][i2] += 32;\n                else if (ft_to_upper(av[i][i2 - 1], av[i][i2]))\n                    av[i][i2] -= 32;\n                write(1, &av[i][i2], 1);\n                i2++;\n            }\n            write(1, \"\\n\", 1);\n        }\n    }\n    else\n        write(1, \"\\n\", 1);\n    return (0);\n}"}
{"author": "kalpa96", "file": "Pointers__sort.0.c", "original_string": "int main(){\n    int *a,n,i,j,temp;\n    printf(\"Enter size of array:\");\n    scanf(\"%d\",&n);\n    a=calloc(sizeof(int),n);\n    printf(\"Enter %d Elements:\\n\",n);\n    for(i=0;i<n;i++){\n        printf(\"    element - %d : \",i);\n        scanf(\"%d\",a+i);\n    }\n    for(i=0;i<n-1;i++)\n    {\n        for(j=0;j<n-1;j++)\n        {\n            if(*(a+j)>*(a+j+1))\n            {\n                temp=*(a+j);\n                *(a+j)=*(a+j+1);\n                *(a+j+1)=temp;\n            }\n        }\n    }\n    printf(\"After sorting array :\\n\");\n    for(i=0;i<n;i++){\n        printf(\"%d \",*(a+i));\n    }\n    return 0;           \n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_end_DCLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n}"}
{"author": "augustogunsch", "file": "jack-compiler__tokenizer.6.c", "original_string": "CHARTYPE getchartype(unsigned char c) {\n    if(isspace(c)) return space;\n    if(isalnum(c) || c == '_' || c == '\"') return common;\n    return charsymbol;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Two.3.c", "original_string": "void display()\n{\n    int i;\n    for(i=0;i<5;i++)\n    {\n        temp=dir[i];\n        printf(\"\\nDirectory %d - \",i);\n        while(temp!=NULL)\n        {\n            printf(\"%c\\t\",temp->file);\n            temp=temp->next;\n        }\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__tokenizer.5.c", "original_string": "TOKEN* appendtoken(TOKEN* curitem, STRING* token, char* file, int definedat) {\n    append(token, '\\0');\n    return appendtokenraw(curitem, token, definedat, gettokentype(token, file, definedat));\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__queue_using_array.1.c", "original_string": "void dequeue()\n{\n    if(front==-1 && rear==-1)\n    {\n        printf(\"underflow\\n\");\n    }\n    else if(front==rear)\n    {\n        printf(\"the delete element is %d\\n\",queue[front]);\n        front=rear=-1;\n    }\n    else\n    {\n        printf(\"the delete element is %d\\n\",queue[front]);\n        front++;\n    }\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Seg.3.c", "original_string": "void display_Mem()\n{\n    int i;\n    printf(\"\\nMemory is : \");\n    for(i=0;i<16;i++)\n        printf(\"%d\\t\",Mem[i]);\n}"}
{"author": "ankitraj311", "file": "450_babbar__6_union_array_Geek_usorted_array.2.c", "original_string": "int remove_repeat(int arr[], int size_arr) \n{\n  for(int i = 0; i<size_arr; i++)\n  {\n    for(int j = i+1; j<size_arr;j++)\n    { \n      if(arr[i] == arr[j])\n      {\n        for(int k = j; k<size_arr; k++)\n    {\n          arr[k] = arr[k+1];\n    }\n    size_arr--;\n      }\n    }\n  }\n  return size_arr;\n}"}
{"author": "augustogunsch", "file": "jackc__tokenizer.14.c", "original_string": "void skipmultiln(FILE* input, int* lnscount) {\n    unsigned char c;\n    while(c = fgetc(input), c != '\\0')\n        if(c == '\\n')\n            (*lnscount)++;\n        else if(c == '*')\n            if(fgetc(input) == '/')\n                break;\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__test.4.c", "original_string": "static unsigned int crc32(unsigned char *buffer, unsigned int size)\n{\n    unsigned int crc = 0xFFFFFFFF;\n    unsigned int i;\n    for (i = 0; i < size; i++) {\n        crc = crc_table[(crc ^ buffer[i]) & 0xff] ^ (crc >> 8);\n    }\n    return crc ;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__31_math_cos1.0.c", "original_string": "int main()\n{\n  float i,j,degree,radian,result, cose = 0;\n  int count = 0, k = 0, accurate;\n  printf(\"Enter the degree to find it by sin value by it\");\n  scanf(\"%f\",&degree);\n  radian = (float)degree * (3.1415/180);\n  printf(\"Minimum is 3.Enter the value of the accurate, upto which you want to find the result\");\n  scanf(\"%d\",&accurate);\n  do\n  {\n    if(count % 2 == 0)\n    {\n      cose = (float)cose + (pow(radian,k)/factorial(k));\n    }\n    if(count % 2 == 1)\n    {\n      cose = (float)cose - (pow(radian,k)/factorial(k));\n    }\n    count++;\n    k = k + 2;\n  }\n  while(count <= accurate);\n  printf(\"\\nValue of cos %f\", cose);\n  printf(\"\\nValue of cos %f\", cos(radian));\n}"}
{"author": "paawankohli", "file": "DSA-LAB__LLunion.4.c", "original_string": "nptr listUnion(nptr head1, nptr head2)\n{\n    nptr head3 = NULL;;\n    nptr temp = head1;\n    while(temp)\n    {\n        insertRear(head3, temp -> data);\n        temp = temp -> next;\n    }\n    temp = head2;\n    while(temp)\n    {\n        if (elementFound(head3, temp -> data) == 0) \n            insertRear(head3, temp -> data);\n        temp = temp -> next;\n    }\n    return head3;\n}"}
{"author": "HakNinja", "file": "C-Basic__26binary.0.c", "original_string": "void main()\n {int a[10],n,s,first,middle,last;\n  printf(\"Enter no of element:\");\n  scanf(\"%d\",&n);\n  printf(\"Enter element in ascending order:\");\n  for(int i=0;i<n;i++)\n   {scanf(\"%d\",&a[i]);\n    }\n  printf(\"Enter element to be search:\");\n  scanf(\"%d\",&s);\n  first=0;\n  last=n-1;\n  middle=(first+last)/2;\n  while(first<=last)\n   {if(a[middle]<s)\n     { first=middle+1;\n      }\n    else if(a[middle]==s)\n     {printf(\"Number is present\\n\");\n      break;         \n      }\n    else\n     {last=middle-1;\n      }\n    middle=(first+last)/2;\n    }\n  if (first>last)\n   { printf(\"not found!!!\");\n    }\n  }"}
{"author": "augustogunsch", "file": "jackc__io.2.c", "original_string": "char* trimstr(char* str, int len, int end) {\n    int count = len - end;\n    char oldchar = str[count];\n    str[count] = '\\0';\n    char* newstr = (char*)malloc(sizeof(char) * (1 + count));\n    strcpy(newstr, str);\n    str[count] = oldchar;\n    return newstr;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__implementation_of_LL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n       if(head==0)\n       {\n            head=temp=newnode;\n       }\n       else\n       {\n            temp->next=newnode;\n            temp=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n       scanf(\"%d\",& choice);\n    }\n}"}
{"author": "shengelenge", "file": "wp-lab3__zad14.0.c", "original_string": "double pierwiastek(double p, double E)\n{\n    double a = 1, b = p;\n    while (fabs(a - b) >= E)\n    {\n        a = (a + b) / 2;\n        b = p / a;\n    }\n    return a;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.16.c", "original_string": "SUBROUTCALL* parsesubroutcallnullified(PARSER* p) {\n    if(p->current->type != identifier)\n        return NULL;\n    anchorparser(p);\n    SUBROUTCALL* c = (SUBROUTCALL*)malloc(sizeof(SUBROUTCALL));\n    c->debug = getdebug(p);\n    if(nextequals(p, \".\")) {\n        c->parentname = p->current->token;\n        next(p);\n        next(p);\n    }\n    else\n        c->parentname = NULL;\n    if(p->current->type != identifier)\n        return nullsubroutcall(p, c);\n    c->name = p->current->token;\n    next(p);\n    if(differs(p, \"(\"))\n        return nullsubroutcall(p, c);\n    next(p);\n    c->parameters = parseexpressionlist(p);\n    if(differs(p, \")\"))\n        return nullsubroutcall(p, c);\n    next(p);\n    return c;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__testingbinary.3.c", "original_string": "struct node* insert(struct node *root, int x)\n{\n    if(root==NULL)\n        return new_node(x);\n    else if(x>root->data) \n        root->right_child = insert(root->right_child, x);\n    else \n        root->left_child = insert(root->left_child,x);\n    return root;\n}"}
{"author": "revathy16296", "file": "rtos_lab_asssignment_1__9_string_cmp.1.c", "original_string": "void choice_one(char b[SIZE])\n{\n    char p[4]=\"SIOS\";\n        if (strncmp(b,p,4)==0)\n        {printf(\"the value is matching with SIOS\\n\");}\n        else{\n        printf(\"the  string is not matching with SIOS\\n\");\n        printf(\"the length of given string is %d\",n-3);}\n}"}
{"author": "ankitraj311", "file": "Socket-thread__test.0.c", "original_string": "void *fun_thread(void *vargs)\n{\n  int myid;\n  myid = *(int *)vargs;\n  static int s = 0;\n  s++;\n  g++;\n  while(1)\n  {\n    int i = 1;\n  }\n  printf(\"Thread Id u: %d, Thread Id d: %d, Static: %d, Global: %d\\n\",myid,myid,++s,++g);\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__unique2.1.c", "original_string": "int get_numbers(int n, int max, int ns[], int i){\n  int r = n - max;\n  int check;\n  if(i == 10)\n    return 0;\n  if(r < 10 && check_number(r, ns, i)){\n    ns[i] = max;\n    i++;\n    if(check_number(r, ns, i)){\n    ns[i] = r;\n    return 1;\n      }\n    else{\n      check = get_numbers(r, max-1, ns, i);\n    }\n  }\n  else{\n    ns[i] = max;\n    i++;\n    check = get_numbers(r, max-1, ns, i);\n  }\n  return (max == 9)? valid_array(ns, n): check;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_c_extended.11.c", "original_string": "uint32_t ble_lbs_c_handles_assign(ble_lbs_c_t    * p_ble_lbs_c,\n                                  uint16_t         conn_handle,\n                                  const lbs_db_t * p_peer_handles)\n{\n    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c);\n    p_ble_lbs_c->conn_handle = conn_handle;\n    if (p_peer_handles != NULL)\n    {\n        p_ble_lbs_c->peer_lbs_db = *p_peer_handles;\n    }\n    return NRF_SUCCESS;\n}"}
{"author": "Theemiss", "file": "simple_shell__more_charfun.1.c", "original_string": "int _isalpha(int c)\n{\nif (((c >= 97) && (c <= 122)) || ((c >= 65) && (c <= 90)))\n{\nreturn (1);\n}\nelse\n{\nreturn (0);\n}\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__23.0.c", "original_string": "void main()\n{\n    int ar[90],n,i;\n    printf(\"enter the limit\");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n        scanf(\"%d\",&ar[i]);\n    largest(ar,n);\n    sumaverage(ar,n);\n    sorting(ar,n);\n}"}
{"author": "mehedi9021", "file": "C__separate_odd_even.0.c", "original_string": "int main()\n{\n    int i,n;\n    printf(\"Enter the element of array:\");\n    scanf(\"%d\", &n);\n    int a[n];\n    for(i=0; i<=n-1; i++)\n    {\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\nEven numbers:\");\n    for(i=0; i<=n-1; i++)\n    {\n        if(a[i]%2==0)\n        {\n            printf(\"%d \", a[i]);\n        }\n    }\n    printf(\"\\n\\nOdd numbers:\");\n    for(i=0; i<=n-1; i++)\n    {\n        if(a[i]%2==1)\n        {\n            printf(\"%d \", a[i]);\n        }\n    }\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__util.3.c", "original_string": "int countplaces(int n) {\n    int places = 1;\n    int divisor = 1;\n    if(n < 0) {\n        n = -n;\n        places++;\n    }\n    while(n / divisor >= 10) {\n        places++;\n        divisor *= 10;\n    }\n    return places;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-expressions.10.c", "original_string": "TERM* parsearrayterm(PARSER* p) {\n    TERM* t = mkterm(arrayitem);\n    t->array = (ARRAY*)malloc(sizeof(ARRAY));\n    t->array->name = p->current->token;\n    next(p);\n    checkcontent(p, \"[\");\n    t->array->exp = parseexpression(p);\n    checkcontent(p, \"]\");\n    return t;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__Main0.0.c", "original_string": "int32_t main(int32_t argc, char *argv[])\n{\n  char *programDir = dirname(_strdup(argv[0]));\n  _chdir(programDir);\n  printf(\"\\n--------------------------------------------------------------------------\\n\");\n  printf(\"Running %s %s firmware\\n\", DEMO_PRODUCT_NAME, DEMO_PRODUCT_FIRMWARE_VERSION);\n  printf(\"--------------------------------------------------------------------------\\n\\n\");\n  firmwareUpdateInfoReader_init();\n  fotaUpdateWorkflow_init();\n  fotahub_init(argv[0], DEMO_PRODUCT_ID, DEMO_PRODUCT_NAME, &FOTA_UPDATE_CLIENT_CONFIG);\n  fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);\n  firmwareUpdateInfoReader_explain(programDir);\n  while (true)\n  {\n    firmwareUpdateInfoReader_run();\n    fotahub_run();\n  }\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-statements.5.c", "original_string": "STATEMENT* parseif(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, ifstatement);\n    IFSTATEMENT* ifst = (IFSTATEMENT*)malloc(sizeof(IFSTATEMENT));\n    ifst->base = parsecond(p);\n    if(equals(p, \"else\")) {\n        next(p);\n        checkcontent(p, \"{\");\n        ifst->elsestatements = parsestatements(p);\n        checkcontent(p, \"}\");\n    }\n    else\n        ifst->elsestatements = NULL;\n    s->type = ifstatement;\n    s->ifstatement = ifst;\n    return s;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__testingbinary.0.c", "original_string": "struct node* search(struct node *root, int x)\n{\n    if(root==NULL || root->data==x) \n        return root;\n    else if(x>root->data) \n        return search(root->right_child, x);\n    else \n        return search(root->left_child,x);\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_sys_bios.2.c", "original_string": "OsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,\n   void *param, size_t stackSize, int_t priority)\n{\n   Error_Block eb;\n   Task_Params taskParams;\n   Task_Handle task;\n   Error_init(&eb);\n   Task_Params_init(&taskParams);\n   taskParams.arg0 = (UArg) param;\n   taskParams.stackSize = stackSize * sizeof(uint_t);\n   taskParams.priority = priority;\n   task = Task_create((Task_FuncPtr) taskCode, &taskParams, &eb);\n   return task;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__AJ.2.c", "original_string": "int main(int argc, char **argv)\n{\n    int t, tam, primovf;\n    long int n[200000], maior = 0, n0, vet[10000];\n    scanf(\"%i\", &t);\n    for (int i = 0; i < t; i++)\n    {\n        scanf(\"%li\", &n[i]);\n        if (n[i] > maior)\n            maior = n[i];\n    }\n    tam = primos(maior, vet);\n    for  (int i = 0; i < t; i++)\n    {\n        primovf = primo(n[i], vet, tam);\n        n0 = n[i];\n        while (primovf == true && n[i] >= 10)\n        {\n            n[i] /= 10;\n            primovf = primo(n[i], vet, tam);\n        }\n        if (primovf == true)\n            printf(\"S\\n\");\n        else if (primovf == false)\n            printf(\"N\\n\");\n    }    \n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q32.2.c", "original_string": "int del(QUEUE* q)\n{\n    if(q->front==q->rear)\n    {\n        printf(\"QUEUE EMPTY\\n\");\n        return -1;\n    }\n    q->front+=1;\n    return q->arr[q->front];\n}"}
{"author": "mandarvu", "file": "msc__problem5.1.c", "original_string": "void merge_array(int *source1, int *source2, int *target) {\n  int j = 0;\n  for (j; j < (2*SIZE); j++) {\n    if (j < SIZE) {\n      *(target + j) = *(source1 + j);\n    }\n    else {\n      *(target + j) = *(source2 + j - SIZE);\n    }\n  }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_tcm.1.c", "original_string": "void rstpTcmFsm(RstpBridgePort *port)\n{\n   switch(port->tcmState)\n   {\n   case RSTP_TCM_STATE_INACTIVE:\n      if(port->learn && !port->fdbFlush)\n      {\n         rstpTcmChangeState(port, RSTP_TCM_STATE_LEARNING);\n      }\n      break;\n   case RSTP_TCM_STATE_LEARNING:\n      if(port->rcvdTc || port->rcvdTcn || port->rcvdTcAck || port->tcProp)\n      {\n         rstpTcmChangeState(port, RSTP_TCM_STATE_LEARNING);\n      }\n      else if((port->role == STP_PORT_ROLE_ROOT ||\n         port->role == STP_PORT_ROLE_DESIGNATED) &&\n         port->forward && !port->operEdge)\n      {\n         rstpTcmChangeState(port, RSTP_TCM_STATE_DETECTED);\n      }\n      else if(port->role != STP_PORT_ROLE_ROOT &&\n         port->role != STP_PORT_ROLE_DESIGNATED &&\n         !(port->learn || port->learning) &&\n         !(port->rcvdTc || port->rcvdTcn || port->rcvdTcAck || port->tcProp))\n      {\n         rstpTcmChangeState(port, RSTP_TCM_STATE_INACTIVE);\n      }\n      else\n      {\n      }\n      break;\n   case RSTP_TCM_STATE_NOTIFIED_TCN:\n      rstpTcmChangeState(port, RSTP_TCM_STATE_NOTIFIED_TC);\n      break;\n   case RSTP_TCM_STATE_DETECTED:\n   case RSTP_TCM_STATE_NOTIFIED_TC:\n   case RSTP_TCM_STATE_PROPAGATING:\n   case RSTP_TCM_STATE_ACKNOWLEDGED:\n      rstpTcmChangeState(port, RSTP_TCM_STATE_ACTIVE);\n      break;\n   case RSTP_TCM_STATE_ACTIVE:\n      if((port->role != STP_PORT_ROLE_ROOT &&\n         port->role != STP_PORT_ROLE_DESIGNATED) || port->operEdge)\n      {\n         rstpTcmChangeState(port, RSTP_TCM_STATE_LEARNING);\n      }\n      else if(port->rcvdTcn)\n      {\n         rstpTcmChangeState(port, RSTP_TCM_STATE_NOTIFIED_TCN);\n      }\n      else if(port->rcvdTc)\n      {\n         rstpTcmChangeState(port, RSTP_TCM_STATE_NOTIFIED_TC);\n      }\n      else if(port->tcProp && !port->operEdge)\n      {\n         rstpTcmChangeState(port, RSTP_TCM_STATE_PROPAGATING);\n      }\n      else if(port->rcvdTcAck)\n      {\n         rstpTcmChangeState(port, RSTP_TCM_STATE_ACKNOWLEDGED);\n      }\n      else\n      {\n      }\n      break;\n   default:\n      rstpFsmError(port->context);\n      break;\n   }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__led_pattern.1.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "earth429", "file": "mulpre__increment.1.c", "original_string": "int increment(struct NUMBER *a, struct NUMBER *b) {\n    struct NUMBER one;\n    int r;\n    setInt(&one, 1);\n    r = add(a, &one, b);\n    return r;\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_9.1.c", "original_string": "void changeCells(unsigned int n, int * array1, int * array2, int * array3){\n    int i = 0;\n    for(i; i < n; i++){\n        int a = array1[i], b = array2[i], c = array3[i];\n        int max = (a>=b && a>=c) ? a : (b>=a&&b>=c) ? b : c;\n        int min = (a<=b && a<=c) ? a : (b<=a&&b<=c) ? b : c;\n        int mid = (c!=max && c!=min) ? c : (b!=max && b!=min) ? b : a;\n        array1[i] = max;\n        array2[i] = mid;\n        array3[i] = min;\n    }\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__19_Dowhile.1.c", "original_string": "int main()\n{\n    int contador1 = 0;\n    int contador2 = 10;\n    do\n    {\n        if(contador1 > 5)\n            Columna(contador2);\n        else\n            Columna(contador1);\n        --contador2;\n        printf(\"\\n\");\n        ++contador1;\n    }while(contador1 < 11);\n    return 0;\n}"}
{"author": "fikepaci", "file": "monty__monty_funcs_2.3.c", "original_string": "void monty_mul(stack_t **stack, unsigned int line_number)\n{\n    if ((*stack)->next == NULL || (*stack)->next->next == NULL)\n    {\n        set_op_tok_error(short_stack_error(line_number, \"mul\"));\n        return;\n    }\n    (*stack)->next->next->n *= (*stack)->next->n;\n    monty_pop(stack, line_number);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__testingbinary.6.c", "original_string": "int main()\n{\n    struct node *root;\n    root = new_node(20);\n    insert(root,5);\n    insert(root,1);\n    insert(root,15);\n    insert(root,9);\n    insert(root,7);\n    insert(root,12);\n    insert(root,30);\n    insert(root,25);\n    insert(root,40);\n    insert(root, 45);\n    insert(root, 42);\n    inorder(root);\n    printf(\"\\n\");\n    root = delete(root, 1);\n    root = delete(root, 40);\n    inorder(root);\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__map_utils.1.c", "original_string": "void        fill_map(char **map)\n{\n    int i;\n    int j;\n    int x;\n    int y;\n    i = 1;\n    j = 1;\n    x = 0;\n    y = 0;\n    while (x < g_map_height)\n    {\n        while (y < g_map_width)\n        {\n            if (y < ft_strlen(g_map_array[x]))\n                map[i][j] = g_map_array[x][y];\n            else\n                map[i][j] = ' ';\n            y++;\n            j++;\n        }\n        i++;\n        x++;\n        j = 1;\n        y = 0;\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_fsm.1.c", "original_string": "void rstpFsm(RstpBridgeContext *context)\n{\n   uint_t i;\n   RstpBridgePort *port;\n   do\n   {\n      context->busy = FALSE;\n      rstpPrsFsm(context);\n      for(i = 0; i < context->numPorts; i++)\n      {\n         port = &context->ports[i];\n         rstpPtiFsm(port);\n         rstpPrxFsm(port);\n         rstpPpmFsm(port);\n         rstpBdmFsm(port);\n         rstpPimFsm(port);\n         rstpPrtFsm(port);\n         rstpPstFsm(port);\n         rstpTcmFsm(port);\n         if(port->fdbFlush)\n         {\n            rstpRemoveFdbEntries(port);\n         }\n      }\n      if(!context->busy)\n      {\n         for(i = 0; i < context->numPorts; i++)\n         {\n            port = &context->ports[i];\n            rstpPtxFsm(port);\n         }\n      }\n   } while(context->busy);\n}"}
{"author": "sdukesameer", "file": "dsa__list-ins-rem_even.1.c", "original_string": "void insert(node** head, int inp)\n{\n    node* linklist=createnode(inp);\n    linklist->next=*head;\n    *head=linklist;\n    printf(\"%d inserted\\n\",(*head)->data);\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zadOsmi.3.c", "original_string": "int PrintDirectory(Position current)\n{\n    if (!current->child)\n        printf(\"Directory is empty!\\n\");\n    else\n    {\n        current = current->child;\n        while (current)\n        {\n            printf(\" %s\\n\", current->name);\n            current = current->sibling;\n        }\n    }\n    return 0;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__matrices_dinamicas.0.c", "original_string": "int main() {\n    float **temperaturas = NULL;\n    int tamanno_filas, frecuencia, tamanno_columnas;\n    printf(\"Ingrese la cantidad de d\u00edas que se registrar\u00e1n tempereraturas:\");\n    scanf(\"%d\", &tamanno_filas);\n    printf(\"Ingrese cada cuanta horas se registrar\u00e1n temperatural por d\u00eda\");\n    scanf(\"%d\", &frecuencia);\n    tamanno_columnas = 24 / frecuencia; \n    temperaturas = (float **) malloc (tamanno_filas * sizeof(float *));\n    if( temperaturas == NULL){\n        printf(\"No se reservo la memoria\");\n        return -1;\n    }\n    for (int i = 0; i < tamanno_filas; i++) {\n        temperaturas[i] = (float *) malloc (tamanno_columnas * sizeof(float));\n        if(temperaturas[i] == NULL){\n            printf(\"No se reerv\u00f3 la memoria\");\n            return -1;\n        }\n    }\n    leer_temperaturas(temperaturas, tamanno_filas, tamanno_columnas);\n    mostrar_temperaturas(temperaturas, tamanno_filas, tamanno_columnas);\n    for (int i = 0; i < tamanno_columnas; i++){\n        free(temperaturas[i]);\n    }\n    free(temperaturas);\n    return 0;\n}"}
{"author": "dishanp", "file": "DSA__q16.0.c", "original_string": "int main()\n{\n    struct sparse s;\n    int *A;\n    int n, m;\n    int choice;\n    int size = 0;\n    int t;\n    printf(\"1 : Diagonal Matrix\\n2 : Lower Triangular Matrix\\n\");\n    printf(\"3 : for Upper Triangular Matrix\\n4 : Tri-diagonal Matrix\\n\");\n    printf(\"5 : Toeplitz Matrix\\n6 : Symmetric Matrix\\n7 : Sparse Matrix\\n\");\n    printf(\"Enter Choice : \");\n    scanf(\"%d\", &choice);\n    printf(\"Enter Dimensions (same m & n values for options 1-6: \");\n    scanf(\"%d%d\",&m, &n);\n    switch(choice)\n    {\n        case 1 :\n        size = n;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i == j)\n                {\n                    A[i - 1] = t ;\n                }\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i == j)\n                {\n                    printf(\"%d \", A[i - 1]);\n                }\n                else\n                {\n                    printf(\"0 \");\n                }\n            }\n            printf(\"\\n\");\n        }\n        break;\n        case 2 :\n        size = n*(n + 1) / 2;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i >= j)\n                {\n                    A[i*(i-1)/2 + (j-1)] = t ;\n                }\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i >= j)\n                {\n                    printf(\"%d \", A[i*(i-1)/2 + (j-1)]);\n                }\n                else\n                {\n                    printf(\"0 \");\n                }\n            }\n            printf(\"\\n\");\n        }\n        break;\n        case 3 :\n        size = n * (n + 1) / 2;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i <= j)\n                {\n                    A[(n*(i-1) - (i-1)*(i-2)/2) + (j-i)] = t ;\n                }\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i <= j)\n                {\n                    printf(\"%d \", A[(n*(i-1) - (i-1)*(i-2)/2) + (j-i)]);\n                }\n                else\n                {\n                    printf(\"0 \");\n                }\n            }\n            printf(\"\\n\");\n        }\n        break;\n        case 4 :\n        size = (3 * n) - 2;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if((i - j) == 1)\n                    A[i-2] = t;\n                else if((i - j) == 0)\n                    A[n - 1 + i - 1] = t;\n                else if((i - j) == -1)\n                    A[(2*n) - 1 + i - 1] = t;\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if((i - j) == 1)\n                    printf(\"%d \", A[i - 2]);\n                else if((i - j) == 0)\n                    printf(\"%d \", A[n - 1 + i - 1]);\n                else if((i - j) == -1)\n                    printf(\"%d \", A[(2*n) - 1 + i - 1]);\n                else\n                    printf(\"0 \");\n            }\n            printf(\"\\n\");\n        }\n        break;\n        case 5 :\n        size = (2 * n) - 1;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i <= j)\n                    A[j - i] = t;\n                else if(j < i)\n                    A[n + i - j - 1] = t;\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i <= j)\n                    printf(\"%d \", A[j - i]);\n                else if(j < i)\n                    printf(\"%d \", A[n + i - j - 1]);\n            }\n            printf(\"\\n\");\n        }\n        break;\n        case 6 :\n        size = n*(n + 1) / 2;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i >= j)\n                {\n                    A[i*(i-1)/2 + (j-1)] = t ;\n                }\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        int temp1,temp2;\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i >= j)\n                {\n                    printf(\"%d \", A[i*(i-1)/2 + (j-1)]);\n                }\n                else\n                {\n                    temp1 = i;\n                    temp2 = j;\n                    printf(\"%d \", A[temp2*(temp2-1)/2 + (temp1-1)]);\n                }\n            }\n            printf(\"\\n\");\n        }\n        break;\n        case 7 :\n        s.r = m;\n        s.c = n;\n        int k = 0;\n        printf(\"\\nEnter number of non-zero elements : \");\n        scanf(\"%d\", &s.num);\n        s.ele = (struct element *)malloc(s.num*sizeof(struct element));\n        printf(\"\\nEnter all elements : \\n\");\n        for(int i = 1 ; i <= s.r ; i++)\n        {\n            for(int j = 1 ; j <= s.c ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(t != 0)\n                {\n                    s.ele[k].row = i;\n                    s.ele[k].col = j;\n                    s.ele[k].x = t;\n                    k++;\n                }\n            }\n        }\n        printf(\"\\nColumnar representation of the Sparse Matrix : \\n\");\n        printf(\"%d \", s.r);\n        for(int i = 0; i < s.num ; i++)\n        {\n            printf(\"%d \", s.ele[i].row);\n        }\n        printf(\"\\n%d \", s.c);\n        for(int i = 0; i < s.num ; i++)\n        {\n            printf(\"%d \", s.ele[i].col);\n        }\n        printf(\"\\n%d \", s.num);\n        for(int i = 0; i < s.num ; i++)\n        {\n            printf(\"%d \", s.ele[i].x);\n        }\n        printf(\"\\nDisplaying matrix from stored columnar representation : \\n\");\n        k = 0;\n        for(int i = 1 ; i <= s.r ; i++)\n        {\n            for(int j = 1 ; j <= s.c ; j++)\n            {\n                if(i == s.ele[k].row && j == s.ele[k].col)\n                {\n                    printf(\"%d \", s.ele[k].x);\n                    k++;\n                }\n                else\n                {\n                    printf(\"0 \");\n                }\n            }\n            printf(\"\\n\");\n        }\n    }\n}"}
{"author": "earth429", "file": "mulpre__doubleCos.1.c", "original_string": "int main(int argc, char **argv)\n{\n    double a;\n    double theta = 3.14;\n    int n = 100;\n    int return_val;\n    return_val = doubleCos(&a, theta, n);\n    printf(\"a = %f\\ntheta = %f\\n\", a, theta);\n    printf(\"cos = %f\\n\", cos(theta));\n    printf(\"\u623b\u308a\u5024 = %d\", return_val);\n    return 0;\n}"}
{"author": "ankitraj311", "file": "450_babbar__1_reverse_using_2array.0.c", "original_string": "int main()\n{\n  int arr[100],arr1[100],no,j=0;\n  printf(\"Enter length of array\");\n  scanf(\"%d\",&no);\n  for(int i = 0; i<no; i++)\n  {\n    scanf(\"%d\",&arr[i]);\n  }\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n  for(int i = no-1; i>=0; i--)\n  {\n    arr1[j] = arr[i];\n    j++;\n  }\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr1[i]);\n  }\n}"}
{"author": "earth429", "file": "mulpre__accessSign.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a;\n    clearByZero(&a);\n    dispNumberZeroSuppress(&a);\n    setSign(&a, -1);\n    dispNumberZeroSuppress(&a);\n    return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__1.3.c", "original_string": "bool imprime_semestre(aluno_t *turma, int semestre, int n)\n{\n    bool sem = false;\n    for (int i = 0; i < n; i++)\n    {\n        if (turma[i].semestre == semestre)\n        {\n            if (sem == false) sem = true;\n            imprime_aluno(turma[i]);\n        }\n    }\n    if (sem == false)\n    {\n        printf(\"\\nNenhum aluno foi encontrado no semestre escolhido.\\n\");\n        return false;\n    }\n    return true;\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__RandomizedQuickSort.1.c", "original_string": "void getdata(int x[50],int n)\n       {\n        int k;\n        printf(\"enter the value  for sorting\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        }     \n       }"}
{"author": "mehedi9021", "file": "Data_Structure__insert_element_at_begining_single_linked_list.0.c", "original_string": "int main()\n{\n    int n, data;\n    printf(\"Enter the total number of nodes: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    printf(\"\\nData in the list \\n\");\n    displayList();\n    printf(\"\\nEnter data to insert at beginning of the list: \");\n    scanf(\"%d\", &data);\n    inab(data);\n    printf(\"\\nData in the list \\n\");\n    displayList();\n    return 0;\n}"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__3-1.3.c", "original_string": "void selection_sort(int a[], int n){\n  int smallest;\n  int k;\n  for(int i = 0; i < n - 1; i++){\n    smallest = a[i];\n    k = i;\n    for(int j = i+1; j < n; j++)\n      if(a[j] < smallest){\n    smallest = a[j];\n    k = j;\n      }\n    if(i != k)\n      change(a, i, k);\n  }\n}"}
{"author": "haon1026", "file": "linux-programming__setitimer.1.c", "original_string": "int main()\n{\n    struct itimerval newit, oldit;\n    signal(SIGALRM, myfunc);\n    newit.it_value.tv_sec = 2;\n    newit.it_value.tv_usec = 0;\n    newit.it_interval.tv_sec = 5;\n    newit.it_interval.tv_usec = 0;\n    if(setitimer(ITIMER_REAL, &newit, &oldit) == -1)\n    {\n        perror(\"setitimer error\");\n        return -1;\n    }\n    while(1);\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-structure.8.c", "original_string": "SUBROUTDEC* parsesubroutdec(PARSER* p, CLASS* c) {\n    SUBROUTCLASS subroutclass = parsesubroutclass(p);\n    if(subroutclass == -1)\n        return NULL;\n    next(p);\n    SUBROUTDEC* subroutdec = (SUBROUTDEC*)malloc(sizeof(SUBROUTDEC));\n    subroutdec->subroutclass = subroutclass;\n    if(differs(p, \"void\"))\n        subroutdec->type = parsetype(p);\n    else {\n        subroutdec->type = p->current->token;\n        next(p);\n    }\n    subroutdec->debug = getdebug(p);\n    subroutdec->name = parseidentifier(p);\n    checkcontent(p, \"(\");\n    subroutdec->parameters = parseparameters(p);\n    checkcontent(p, \")\");\n    checkcontent(p, \"{\");\n    subroutdec->body = parsesubroutbody(p);\n    checkcontent(p, \"}\");\n    subroutdec->class = c;\n    return subroutdec;\n}"}
{"author": "sdukesameer", "file": "dsa__dll-ins-seq-sor-del-a.3.c", "original_string": "void deletion(list** head, list* del)\n{\n    if (*head==del)\n        *head=del->next;\n    else \n    {\n        if (del->next!=NULL)\n            del->next->prev=del->prev;\n        if (del->prev!=NULL)\n            del->prev->next=del->next;\n    }\n    free(del);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_DCLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica1-6.2.c", "original_string": "int main(){\n    signal(SIGALRM, ring); \n    printf(\"Alarma en 5 segundo\\n\");\n    funcion(5); \n    printf(\"Alarma en 3 segundo\\n\");\n    funcion(3);\n    for (int i = 0; i < 90; i++){\n        printf(\"Alarma en 1 segundo\\n\");\n        funcion(1);\n        printf(\"TIMBRAZOS: %d\\n\", i+1);\n        if (i==3) kill(getpid(),9);\n    }\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__doublylinkedlist.3.c", "original_string": "void display()\n{\n    if(start==NULL)\n    printf(\"\\nList is empty\");\n    else\n    {\n        temp=start;\n        while(temp->next!=NULL)\n        {\n            printf(\"\\t%d\",temp->val);\n            temp=temp->next;\n        }\n    }\n    printf(\"\\t%d\",temp->val);\n}"}
{"author": "earth429", "file": "mulpre__kakezan.1.c", "original_string": "int multiple(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    int i, j, h, e, aj, bi;\n    struct NUMBER a_abs, b_abs, d, tmp;\n    clearByZero(c);\n    if(getSign(a) > 0 && getSign(b) > 0){ \n        for (i = 0; i < KETA;i++){\n            bi = b->n[i];\n            h = 0;\n            clearByZero(&d);\n            for (j = 0; j < KETA;j++){\n                aj = a->n[j];\n                e = aj * bi + h; \n                if(j + i < KETA){ \n                    d.n[j + i] = (e % 10); \n                    e /= 10;\n                    h = e; \n                }\n            }\n            if(h != 0){ \n                return -1;\n            }\n            add(c, &d, &tmp);\n            copyNumber(&tmp, c);\n        }\n    } else if(getSign(a) > 0 && getSign(b) < 0){ \n        getAbs(b, &b_abs);\n        multiple(a, &b_abs, c);\n        setSign(c, -1);\n    } else if(getSign(a) < 0 && getSign(b) > 0){ \n        getAbs(a, &a_abs);\n        multiple(&a_abs, b, c);\n        setSign(c, -1);\n    } else if(getSign(a) < 0 && getSign(b) < 0){ \n        getAbs(a, &a_abs);\n        getAbs(b, &b_abs);\n        multiple(&a_abs, &b_abs, c);\n    }\n    return 0; \n}"}
{"author": "ria3999", "file": "Basic-C-Programs__4menu_driven.3.c", "original_string": "void perfectno(void)\n{\n    int i,sum=0,r;\n    printf(\"enter the number\");\n    scanf(\"%d\",&r);\n   for(i=1;i<=r/2;i++)\n   {\n       if(r%i==0)\n        sum+=i;\n   }\n   if(sum==r)\n   printf(\"perfect no.\");\n   else\n    printf(\"not\");\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_03.6.c", "original_string": "int main(int argc, char* argv[])\n{\n    int num; char s;int size;\n        int* arr;\n        F1 = fopen(argv[1], \"r\");\n        F2 = fopen(argv[2], \"w\");\n        while(1)\n        {\n        fscanf(F1 ,\"%c %d\",&s, &num);\n        if(s == 'r')\n        {\n                size = num;\n                arr = read(num);\n        }\n        else if(s == 's')\n        {\n                int p = search(arr, num, size);\n                fprintf(F2,\"%d\\n\", p);\n        }\n        else if(s == 'd')\n        {\n                display(arr, size);\n                fprintf(F2, \"\\n\");\n        }\n        else if(s == 't')\n                return 0;\n        }\n    fclose(F1);\n    fclose(F2);\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__30.0.c", "original_string": "int main()\n{\n    int n, i, j, multiplo = 0;\n    printf(\"\\nInforme os n\u00fameros inteiros positivos 'n','i' e 'j'.\\nOnde 'n' ser\u00e1 a quantidade de n\u00fameros em ordem crescentes,\\nque sejam m\u00faltiplos de 'i' ou de 'j' ou de ambos.\\n\");\n    printf(\"\\nInforme 'n': \");\n    scanf(\"%i\", &n);\n    printf(\"\\nInforme 'i': \");\n    scanf(\"%i\", &i);\n    printf(\"\\nInforme 'j': \");\n    scanf(\"%i\", &j);\n    printf(\"\\n\");\n    for (int qtd = 0; qtd < n;)\n    {\n        if (((multiplo % i) == 0) || ((multiplo % j) == 0))\n        {\n            if (qtd == (n - 1))\n            {\n                printf(\"%i.\", multiplo);\n            }\n            else\n            {\n                printf(\"%i,\", multiplo);\n            }\n            qtd++;\n        }\n        multiplo++;\n    }\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__DAG1.3.c", "original_string": "void del_file(char dir,char file)\n{\n    int i,flag=-1;\n    for(i=0;i<pos;i++)\n    {\n        temp=G[i];\n        q=temp;\n        while(temp!=NULL)\n        {\n            if(temp->name==file && temp->id==2 && temp->parent==dir)\n            {\n                q->next=temp->next;\n                temp=q->next;\n                flag=1;\n                break;\n            }\n            q=temp;\n            temp=temp->next;\n        }\n        if(flag==1)\n            break;\n    }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.1.c", "original_string": "void addValToNode(int val, int pos, struct btreeNode *node,\n                        struct btreeNode *child) {\n        int j = node->count;\n        while (j > pos) {\n                node->val[j + 1] = node->val[j];\n                node->link[j + 1] = node->link[j];\n                j--;\n        }\n        node->val[j + 1] = val;\n        node->link[j + 1] = child;\n        node->count++;\n  }"}
{"author": "kalpa96", "file": "Struct__text.0.c", "original_string": "int main(){\n    Emp e[4];\n    char array[1000];\n    FILE *fp;\n    int i;\n    float amount[4];\n    float total=0;\n    fp=fopen(\"data.txt\",\"r\");\n    while(!feof(fp)){\n        fgets(array,500,fp);\n        if(array[i]!='\\n'){\n            fscanf(fp,\"%s\\t\\t%d\\t\\t%f\\t\\t%f\",&e[i].Name,&e[i].EmpNo,&e[i].salary,&e[i].OT);\n        }\n        i++;\n    }\n    fclose(fp);\n     printf(\"Employee No\\tBasic salary\\tOT Hours\\tNet salary \\n\");\n    for(i=0;(sizeof(e)/sizeof(e[0]))>i;i++){\n        amount[i]=e[i].salary+e[i].salary*0.35+e[i].OT*15;\n        printf(\"%d\\t\\t%.2f\\t%.2f\\t\\t%.2f\\n\",e[i].EmpNo,e[i].salary,e[i].OT,amount[i]);\n    }\n    for(i=0;(sizeof(amount)/sizeof(amount[0]))>i;i++){\n        total=total+amount[i];\n    }\n    printf(\"\\nTotal Amount:%.2f\",total);\n}"}
{"author": "dle2005", "file": "Algorithm__Hamiltonian_v2.1.c", "original_string": "bool promising(int i) {\n    int j = 1;\n    bool swtch;\n    if(i == n-1 && !W[vindex[n-1]][vindex[0]])\n        swtch = false;\n    else if(i > 0 && !W[vindex[i-1]][vindex[i]])\n        swtch = false;\n    else {\n        swtch = true;\n        while(j < i && swtch) {\n            if(vindex[i] == vindex[j]) swtch = false;\n            j++;\n        }\n    }\n    return swtch;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__24_delet_specific.0.c", "original_string": "int main()\n{\n  int i=0,j=0,k=0,array1[100]={0},array2[100]={0},no=0,delete_no=0,delete_index=0,flag=0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n  printf(\"Enter number to delete it from Array\\n\");\n  scanf(\"%d\",&delete_no);\n  for(i=0; i<no; i++)\n  {\n    if(array1[i] == delete_no)\n    {\n      printf(\"Number is %d Index is %d\",array1[i],i);\n      delete_index = i;\n      flag = 1;\n    }\n  }\n  if(flag == 1)\n  {\n    for(i=0; i<no-1; i++)\n    {\n      if( i < delete_index)\n      {\n        array2[i] = array1[i];\n      }\n      if( i >= delete_index)\n      {\n        array2[i] = array1[i+1];\n      }\n    }\n    printf(\"\\n\");\n    for(i=0; i<no; i++)\n    {\n    for(i=0; i<no-1; i++)\n    {\n      printf(\"%d \",array2[i]);\n    }\n  }\n}\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_SLL.6.c", "original_string": "void insert_at_pos()\n{\n    struct node *newnode,*temp;\n    int pos;\n    printf(\"enter the position to insert the element =\");\n    scanf(\"%d\",&pos);\n    int i=1;\n    int leg=count();\n    if(pos>leg)\n    {\n        printf(\"invalid position\\n\");\n    }\n    else\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode->next=temp->next;\n        temp->next=newnode;\n    }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__rpn_calc.3.c", "original_string": "int     rpn_calc(char *str, int *stack)\n{\n    int     ctrl;\n    int     top;\n    top = -1;\n    ctrl = 0;\n    while(str[ctrl])\n    {\n        if(isnum(str))\n        {\n            top++;\n            stack[top] = atoi(&str[ctrl]);\n            while (str[ctr] != ' ' && str[ctrl] != '\\0')\n                ctrl++;\n        }\n        if (isop(str[ctrl]))\n        {\n            if (top > 0)\n            {\n                if(stack[top - 1] = operate(stack[top - 1],stack[top],str[ctrl]) == 99)\n                    write(1, \"Error\\n\",6);\n                top--;\n            }\n            else\n                write(1,\"Error\\n\",6);\n        }\n        ctrl++;\n    }\n    if(top == 0)\n        printf(\"%d\\n\",stack[top]);\n    else\n        write(1,\"Error\\n\",6);\n    return(0);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__wdt1.2.c", "original_string": "void delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "ria3999", "file": "cbnst__NEWTON_FORWARD_INTERPOLATION.0.c", "original_string": "float cal(float u, int n)\n{\n    float temp = u;\n    for (int i = 1; i < n; i++)\n        temp = temp * (u - i);\n    return temp;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__cNum.0.c", "original_string": "cNum add(cNum a, cNum b)\n{\n    cNum temp;\n    temp.real = a.real + b.real;\n    temp.imag = a.imag + b.imag;\n    return temp;\n}"}
{"author": "earth429", "file": "mulpre__doubleSin.1.c", "original_string": "int main(int argc, char **argv)\n{\n    double a;\n    double theta = 1.57;\n    int n = 100;\n    int return_val;\n    return_val = doubleSin(&a, theta, n);\n    printf(\"a = %f\\ntheta = %f\\n\", a, theta);\n    printf(\"sin = %f\\n\", sin(theta));\n    printf(\"\u623b\u308a\u5024 = %d\", return_val);\n    return 0;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__61_First_letter_with_capital.0.c", "original_string": "int main()\n{\nint i;\nchar str[100],c;\nprintf(\"Enter a string\\n\");\nscanf(\"%[^\\n]s\",str);\nprintf(\"%c\\n\",str[0]);\nprintf(\"%d\",str[0]-32);\nfor(i=0;i<strlen(str);i++)\n{\n  if(str[i]>='A'&&str[i]<='Z')\n  {\n      c=str[i];\n      break;\n  }\n  else\n  {\n      continue;\n  }\n}\nprintf(\"\\nFirst capital letter of string %s is %c\\n\",str,c);\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__QuickSort.4.c", "original_string": "void quick_sort(int a[50],int p,int r)\n{   \n    int q;\n    count++;\n    if(p<r)\n    {\n        count++;\n        q=partition(a,p,r);\n        count++;\n        quick_sort(a,p,q-1);\n        count++;\n        quick_sort(a,q+1,r);\n        count++;\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__cll-ins-sor-seq-del.0.c", "original_string": "node* createNode(int n)\n{\n    node* newNode=(node*)malloc(sizeof(node));\n    newNode->data=n;\n    newNode->next=NULL;\n    return newNode;\n}"}
{"author": "Theemiss", "file": "simple_shell__excute.0.c", "original_string": "int handle_builtin(char **cmd, int er)\n{\n     bul_t bil[] = {\n        {\"cd\", change_dir},\n        {\"env\", dis_env},\n        {\"help\", display_help},\n        {\"echo\", echo_bul},\n        {\"history\", history_dis},\n        {NULL, NULL}\n    };\n    int i = 0;\n    while ((bil + i)->command)\n    {\n        if (_strcmp(cmd[0], (bil + i)->command) == 0)\n        {\n            return ((bil + i)->fun(cmd, er));\n        }\n        i++;\n    }\n    return (-1);\n}"}
{"author": "MFarid94", "file": "Assignment4__Exercise6.0.c", "original_string": "int main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n    int i;\n    int array[SIZE];\n    int *ptr[SIZE];\n    printf(\"Enter array elements: \");\n    for(i=0 ; i<SIZE ; i++){\n        scanf(\"%d\",&array[i]);\n        ptr[i] = &array[i];\n    }\n    maximum = *ptr[0];\n    for(i=1 ; i<SIZE ; i++){\n        if(maximum < *ptr[i]){\n            maximum = *ptr[i];\n        }\n    }\n    for(i=0 ; i<SIZE ;i++){\n        printf(\"Array[%d] = %d\\n\",i,*ptr[i]);\n    }\n    printf(\"Maximum number is %d\",maximum);\n    return 0;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListTraversal.1.c", "original_string": "int main(){\n     struct Node *head;\n     struct Node *second;\n     struct Node *third;\n     struct Node *fourth;\n     head = (struct Node *) malloc(sizeof(struct Node));\n     second = (struct Node *) malloc(sizeof(struct Node));\n     third = (struct Node *) malloc(sizeof(struct Node));\n     fourth = (struct Node *) malloc(sizeof(struct Node));\n     head->data=7;\n     head->next=second;\n     second->data=11;\n     second->next=third;\n     third->data=70;\n     third->next=fourth;\n     fourth->data=22;\n     fourth->next=NULL;\n     linkedListTraversal(head);\n     return 0;\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__tcpclient.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    int sockid,rval;\n    char m1[20],m2[20];\n    sockid=socket(AF_INET,SOCK_STREAM,0);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR\");\n        exit(1);\n    }\n    struct sockaddr_in s;\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=connect(sockid,(struct sockaddr*)&s, sizeof(s));\n    if(rval==-1)\n    {\n        perror(\"CONN-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\nEnter the request message : \");\n    scanf(\"%s\",m1);\n    rval=send(sockid,m1,sizeof(m1),0);\n    if(rval==-1)\n    {\n        perror(\"MSG-SND-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\nMessage sent successfully\\n\");\n    rval=recv(sockid,m2,sizeof(m2),0);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\nServer response is : %s\\n\",m2);\n    close(sockid);\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc-a.13.c", "original_string": "void deleteTree(list* node)\n{\n    if(node == NULL)\n        return;\n    deleteTree(node->left);\n    deleteTree(node->right);\n    printf(\"\\n Deleting Node: %d\",node->key);\n    free(node);\n}"}
{"author": "0712023", "file": "Arduino-Mood-Light-DIY-kit__Moodlight.3.c", "original_string": "void random_set() {\n  r = random(255);\n  g = random(255);\n  b = random(255);\n  for ( int i = 0; i < NUMPIXELS; i++ ) { \n    pixels.setPixelColor(i, pixels.Color( r, g, b ) );  \n    pixels.show(); \n  }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_in_SLL.4.c", "original_string": "void insert_beg()\n{\n    struct node *newnode;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    newnode->next=head;\n    head=newnode;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.3.c", "original_string": "void modificar_alumno(){\n    system(\"clear\");\n    puts(\"\\tMenu para cambio de nombre...\");\n    int posicion = posicion_alumno();\n    estudiante estudiante_seleccionado = lista_estudiantes[posicion];\n    printf(\"El nombre del alumno es: %s\\n\", estudiante_seleccionado.nombre);\n    printf(\"Ingresa el nuevo nombre: \");\n    fflush(stdin);\n    fgets(estudiante_seleccionado.nombre, 60, stdin);\n    lista_estudiantes[posicion] = estudiante_seleccionado;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__assignment_key.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | LED_ALL ;  \n    IODIR1 = IODIR1 & ~(1<<25);  \n    while(1)\n    {\n        if(IOPIN1 & (1<<25))\n        {\n            if(keyFlag)\n            {   \n                IOSET1 = 0x0F<<17;\n                keyFlag = 0;\n            }\n            else\n            {\n                IOCLR1 = 0x0F<<17;\n                keyFlag = 1;\n            }\n            delay(500);\n        }       \n    }\n}"}
{"author": "2security", "file": "Array__Transpose.1.c", "original_string": "void displayMat(int **mat,int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }"}
{"author": "MFarid94", "file": "Assignement3__Exercise5.1.c", "original_string": "int main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n    int i ;\n    int size = 5;\n    int arr[size];\n    int result, element;\n    printf(\"Enter array of numbers:\");\n    for(i=0 ; i<size ; i++){\n        scanf(\"%d\",&arr[i]);\n    }\n    printf(\"Enter required element:\");\n    scanf(\"%d\",&element);\n    result = LinearSearch(arr, element ,size);\n    if(result == -1){\n        printf(\"Item is not on the list\");\n    }\n    else{\n        printf(\"The index of required item is %d\",result);\n    }\n    return 0;\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_putbr.2.c", "original_string": "void ft_putnbr(int numero){\n    int longitud = longitud_N(numero, 0);\n    int negativo = 0;\n    char string_intermedio[11] = \"\";\n    if(numero < 0){\n        numero = numero*(-1);\n        longitud++;\n        llenar_string(string_intermedio, numero, longitud);\n        string_intermedio[0] = '-';\n    }else{\n        llenar_string(string_intermedio, numero, longitud);\n    }\n    printf(\"%s\", string_intermedio);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSL__ssl_misc.0.c", "original_string": "error_t sslExpandKey(const uint8_t *secret, size_t secretLen,\n   const uint8_t *random, size_t randomLen, uint8_t *output, size_t outputLen)\n{\n   uint_t i;\n   size_t n;\n   char_t pad[16];\n   Md5Context *md5Context;\n   Sha1Context *sha1Context;\n   if(outputLen > (sizeof(pad) * MD5_DIGEST_SIZE))\n      return ERROR_INVALID_LENGTH;\n   md5Context = tlsAllocMem(sizeof(Md5Context));\n   if(md5Context == NULL)\n   {\n      return ERROR_OUT_OF_MEMORY;\n   }\n   sha1Context = tlsAllocMem(sizeof(Sha1Context));\n   if(sha1Context == NULL)\n   {\n      tlsFreeMem(md5Context);\n      return ERROR_OUT_OF_MEMORY;\n   }\n   for(i = 0; outputLen > 0; i++)\n   {\n      osMemset(pad, 'A' + i, i + 1);\n      sha1Init(sha1Context);\n      sha1Update(sha1Context, pad, i + 1);\n      sha1Update(sha1Context, secret, secretLen);\n      sha1Update(sha1Context, random, randomLen);\n      sha1Final(sha1Context, NULL);\n      md5Init(md5Context);\n      md5Update(md5Context, secret, secretLen);\n      md5Update(md5Context, sha1Context->digest, SHA1_DIGEST_SIZE);\n      md5Final(md5Context, NULL);\n      n = MIN(outputLen, MD5_DIGEST_SIZE);\n      osMemcpy(output, md5Context->digest, n);\n      output += n;\n      outputLen -= n;\n   }\n   tlsFreeMem(md5Context);\n   tlsFreeMem(sha1Context);\n   return NO_ERROR;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__pwm_double_edge.0.c", "original_string": "int main()\n{\n    PINSEL0 |= (1<<17);\n    PINSEL0 &= ~(1<<16);                \n    PWMPR = 14;\n    PWMMR0 = 10000;                         \n    PWMLER = (1<<0);\n    PWMMCR = (1<<1);                        \n    PWMPCR |= (1<<12)|(1<<4);                   \n    PWMTCR = (1<<0) | (1<<3);       \n    while(1)\n    {\n            PWMMR3 = 3000;          \n            PWMMR4 = 5500;          \n            PWMLER = (1<<3)|(1<<4);\n            delay_ms(1000);\n            PWMMR3 = 3000;          \n            PWMMR4 = 7000;          \n            PWMLER = (1<<3)|(1<<4);\n            delay_ms(1000);\n    }   \n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Calculates_the_Length_of_A_Single_Linked_List.1.c", "original_string": "void display_nodes(struct node*temp1)\n{\n    printf(\"The elements are:\");\n    if(temp1 == 0)\n    {\n        printf(\"NO DATA\");\n    }\n    else\n    while(temp1!=NULL)\n    {\n        printf(\"%d\\t\",temp1->data);\n        temp1 = temp1->ptr;\n    }\n}"}
{"author": "MartinMarinovich", "file": "MarinovichMartinLABIPP1G-__servicio0.3.c", "original_string": "int getIdServicio(eServicio servicios[],int tam_s)\n{\n    int auxId;\n    listarServicios(servicios,tam_s);\n    utn_getNumeroInt(&auxId,\"Ingrese id\",\"Error, ingrese id valido\",2000,2003,4);\n    while(buscarServicios(servicios,tam_s,auxId) == -1)\n    {\n         utn_getNumeroInt(&auxId,\"Ingrese un id valido\",\"Error, ingrese id valido\",2000,2003,4);\n    }\n    return auxId;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__implementation_of_DCLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__bisseccao.0.c", "original_string": "int main()\n{\n    int n;\n    double a[7], l, r, m;\n    scanf(\"%i\", &n); \n    getchar();\n    for (int i = 0; i <= n; i++)\n    {\n        scanf(\"%lf\", &a[i]); \n        getchar();\n    }\n    scanf(\"%lf\", &l); \n    getchar();\n    scanf(\"%lf\", &r); \n    getchar();\n    for (long int i = 0; i <= iteracoes; i++)\n    {\n        m = l + ((r-l)/2);\n        if (fabs(f_de_x(n, a, m)) <= 0.0001) \n        {\n            printf(\"\\n%lf\\n\\n\", m); \n            return 0;\n        }\n        if ((f_de_x(n, a, m) * f_de_x(n, a, l)) < 0) \n        {\n            r = m; \n        }\n        else \n        {\n            l = m; \n        }\n        if (i == iteracoes)\n        {\n            printf(\"raiz nao encontrada\\n\"); \n        }\n    }\n    return 0;\n}"}
{"author": "behergue", "file": "Operating_Systems__myFS.0.c", "original_string": "void copyNode(NodeStruct *dest, NodeStruct *src)\n{\n    int i;\n    dest->numBlocks = src->numBlocks;\n    dest->fileSize = src->fileSize;\n    dest->modificationTime = src->modificationTime;\n    dest->freeNode = src->freeNode;\n    for(i = 0; i < MAX_BLOCKS_PER_FILE; i++)\n        dest->blocks[i] = src->blocks[i];\n}"}
{"author": "MartinMarinovich", "file": "MarinovichMartinLABIPP1G-__marca0.2.c", "original_string": "int listarMarcas(eMarca listaDeMarcas[], int tamanio)\n{\n    int error = -1;\n    if(listaDeMarcas !=NULL && tamanio>0)\n    {\n        system(\"cls\");\n        printf(\"\\n****  LISTADO DE MARCAS  ****\\n\");\n        printf(\" Id       Descripcion\\n\");\n        printf(\"----------------------------------\\n\");\n        for(int i = 0 ; i<tamanio; i++)\n        {\n            mostrarMarca(listaDeMarcas[i]);\n        }\n        error = 0;\n    }\n    return error;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__15_Dowhile.1.c", "original_string": "int main()\n{\n    int contador1 = 1;\n    int contador2 = 7;\n    do\n    {\n        printf(\"\\n\");\n            if(contador1 >= 4)\n            Columna(contador2);\n        else\n            Columna(contador1);\n        --contador2;\n        ++contador1;\n    }while(contador1 < 8);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__doublyLinkedList.6.c", "original_string": "struct Node *deleteLastNode(struct Node *head)\n{\n     struct Node *p = head;\n     struct Node *q = head->next;\n     while (q->next != NULL)\n     {\n          p = p->next;\n          q = q->next;\n     }\n     p->next = NULL;\n     free(q);\n     return head;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__i2c_receiver.0.c", "original_string": "int main()\n{\n    char data;\n    lcd_config();\n    i2c_config();\n    I2CONSET = 1<<2;        \n    i2c_start();\n    i2c_data(0xA0);\n    i2c_data(0x00);         \n    i2c_start();\n    i2c_data(0xA1);         \n    data = i2c_recv();\n    lcd_data(data);\n    data = i2c_recv();\n    lcd_data(data);\n    data = i2c_recv();\n    lcd_data(data);\n    i2c_stop();\n}"}
{"author": "earth429", "file": "mulpre__zerosuppress.4.c", "original_string": "void dispNumberZeroSuppress(struct NUMBER *a){\n    int i;\n    if(a->sign == 1) {\n        printf(\"+\");\n    } else {\n        printf(\"-\");\n    }\n    for (i = KETA - 1; i >= 0; i--) {\n        if(a->n[i] != 0){\n            break;\n        }\n        if(i == 0){\n            printf(\"%2d\", a->n[i]);\n        }\n    }\n    for (; i >= 0;i--) {\n        printf(\"%2d\", a->n[i]);\n    } \n}"}
{"author": "augustogunsch", "file": "jackc__util.10.c", "original_string": "bool existsinarray(STRINGARRAY* arr, const char* item) {\n    for(int i = 0; i < arr->size; i++)\n        if(!strcmp(arr->items[i], item))\n            return true;\n    return false;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica33.1.c", "original_string": "int consumirDato(){                                 \n    int numConsumido= v[indiceConsumicion];         \n    v[indiceConsumicion] = '\\0';                    \n    indiceConsumicion = (indiceConsumicion +1)%n;   \n        for(int i=0; i<n; i++){                     \n            printf(\"|%d\", v[i]);\n        }\n    printf(\"|\");\n    return numConsumido;                            \n}"}
{"author": "rgautam320", "file": "Data-Structure__main19.2.c", "original_string": "int precedence(char symbol)\n{\n    if(symbol == '^')\n        return 3;\n    else if(symbol == '*' || symbol == '/')\n        return 2;\n    else if(symbol == '+' || symbol == '-')\n        return 1;\n    else\n        return 0;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e92.6.c", "original_string": "void informarDados(struct evento show[])\n{\n    int cont, vendidos;\n    for(cont = 0; cont < contShow; cont++)\n    {\n        printf(\"Evento: %s \\n\", show[cont].nome);\n        printf(\"Total arrecadado: %g \\n\", show[cont].lucro);\n        vendidos = show[cont].cadeiras - show[cont].disponiveis;\n        printf(\"Ingressos totais vendidos: %d \\n\", vendidos);\n        printf(\"Ingressos de meia entrada vendidos: %d \\n\", show[cont].meia);\n        printf(\"Ingressos restantes: %d \\n\\n\\n\", show[cont].disponiveis);\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__DemoFOTAUpdateWorkflow.5.c", "original_string": "static bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)\n{\n  switch (instance->__currentState)\n  {\n    case DemoFOTAUpdateWorkflowEngine_idle__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          printf(\"Cannot handle firmware over-the-air update request (missing network connection)\\n\");\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_connected__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) != 0) \n          {\n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;\n            instance->updateInfo.version = (*((char **)((arguments[0]))));\n            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) \n            {\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) \n            {\n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) == 0) \n          {\n            printf(\"Ignoring firmware over-the-air update request to version %s as this version is already running\\n\", (*((char **)((arguments[0])))));\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_downloading__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) \n          {\n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            saveState(DemoFOTAUpdateWorkflowEngine_activating__state);\n            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) \n            {\n              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) \n            {\n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_restarting__state:\n    {\n      switch (event)\n      {\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_activating__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            validateFirmwareUpdateActivation();\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n            }\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED) \n          {\n            bool __transitionResult = true;\n            saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n            if (!fotahub_confirmFirmwareUpdate(&instance->updateInfo)) \n            {\n              __transitionResult = false;\n            }\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n            }\n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_FAILED) \n          {\n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            saveState(DemoFOTAUpdateWorkflowEngine_reverting__state);\n            if (!fotahub_revertFirmwareUpdate(&instance->updateInfo)) \n            {\n              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            if (!__transitionResult) \n            {\n              return false;\n            }\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_reverting__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            validateFirmwareUpdateReversion();\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_reverting__state) \n            {\n            }\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n          instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n          DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return true;\n}"}
{"author": "earth429", "file": "mulpre__divBy10.3.c", "original_string": "void setRnd(struct NUMBER *a, int k){\n    int i;\n    int judge;\n    for (i = 0; i < k;i++){\n        a->n[i] = random() % 10; \n    }\n    judge = random() % 2; \n    switch (judge) {\n        case 1:\n            a->sign = 1;\n            break;\n        case 0:\n            a->sign = -1;\n            break;\n    }\n}"}
{"author": "ankitraj311", "file": "450_babbar__6_union_array_Geek_sorted_array.2.c", "original_string": "int main()\n{\n  int arr1[] = {1,2,3,7,8,9,10}, arr2[] = {2, 8, 10, 15, 16, 100} ,no,j=0,temp=0,mid=0,n=0;\n  int size_arr1 = sizeof(arr1)/sizeof(int), size_arr2 = sizeof(arr2)/sizeof(int);\n  array_print(arr1,size_arr1);\n  array_print(arr2,size_arr2);\n  union_array(arr1,arr2,size_arr1,size_arr2);\n}"}
{"author": "mehedi9021", "file": "Data_Structure__double_list_create.0.c", "original_string": "int main()\n{\n    int n, data;\n    head = NULL;\n    last = NULL;\n    printf(\"Enter the number of nodes you want to create: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    displayListFromFirst();\n    displayListFromEnd();\n    return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__13,_14.1.c", "original_string": "void le_mmc(int *a, int *b)\n{\n    do\n    {\n        printf(\"\\nDigite dois inteiros n\u00e3o-negativos 'a' e 'b':\\n\");\n        printf(\"\\t-> a: \");\n        scanf(\"%i\", a);\n        getchar();\n        printf(\"\\t-> b: \");\n        scanf(\"%i\", b);\n        getchar();\n        system(\"clear\");\n    } while (a < 0 || b < 0);\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad9MatrixMultiply.1.c", "original_string": "void showArray(int sourceArray[], int size){\n    int * pointerSourceArray = sourceArray;\n    printf(\"array\\n\");\n    for(int i = 0; i < size; i++){\n        printf(\"Podtablica: \");\n        for(int j = 0; j < 5; j++){\n            printf(\"%d \", pointerSourceArray[j+(i*5)]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sparse_Matrix_Or_Not.0.c", "original_string": "void main()\n{\n    int i, j = 0;\n    int input_matrix[R][C];\n    printf(\"\\nEnter elements of input matrix...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &input_matrix[i][j]);\n        }\n    }\n    printf(\"\\nOriginal Matrix is a follows:- \\n\");\n    display(input_matrix);\n    if(check_sparse(input_matrix) == 1)\n        printf(\"\\nIt is a Sparse Matrix...\\n\");\n    else\n        printf(\"\\nIt is not a Sparse Matrix...\\n\");\n}"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLLcircular.6.c", "original_string": "int main()\n{\n    nptr head = NULL;\n    printf(\"1. insertLeft 2. insertRight 3. deleteLeft 4. deleteRight 5. display 6. exit\\n\");\n    int ch,  ele;\n    do\n    {\n        printf(\"Command: \"); scanf(\"%d\", &ch);\n        switch(ch)\n        {\n            case 1: \n                    scanf(\"%d\", &ele);\n                    head = insertLeft(head, ele);\n                    break;\n            case 2: \n                    scanf(\"%d\", &ele);\n                    head = insertRight(head, ele);\n                    break;\n            case 3: head = deleteLeft(head);\n                    break;\n            case 4: head = deleteRight(head);\n                    break;\n            case 5: display(head);\n                    break;\n            case 6: exit(0);\n        }\n    }while(ch != 6);\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__63_alphabatically.0.c", "original_string": "int main()\n{\n  int i,j,k, count = 0;\n  char str1[100][100], s[100];\n  printf(\"Enter Number of word you want to Enter\\n\");\n  scanf(\"%d\",&count);\n  printf(\"Enter Words, which you to be sorted Alphabatically\\n\");\n  for(i=0; i<count; i++)\n  {\n    scanf(\"%s\",str1[i]);\n  }\n  printf(\"\\n\");\n  for(i=0; i<count; i++)\n  {\n    printf(\"%s\\n\",str1[i]);\n  }\n  for(i = 0; i<count; i++)\n  {\n    for(j = i+1; j< count; j++)\n    {\n      if(strcmp(str1[i],str1[j])>0)\n      {\n        strcpy(s,str1[i]);\n    strcpy(str1[i],str1[j]);\n    strcpy(str1[j],s);\n      }\n    }\n  }\n  printf(\"Sorted Alphatically\\n\");\n  for(i=0; i<count; i++)\n  {\n    printf(\"%s\\n\",str1[i]);\n  }\n}"}
{"author": "MFarid94", "file": "Assignment4__Exercise3.0.c", "original_string": "void ReverseArray(int *ptr){ \n    int i;\n    int temp;\n    for(i=0 ; i<SIZE/2 ;i++){\n        temp = *ptr;\n        *ptr = *(ptr + (SIZE-1) - i*2);\n        *(ptr + (SIZE-1) - i*2) = temp;\n        ptr++;\n    }\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad2-KopiowanieTablic.1.c", "original_string": "void copyArrayNormal(int sourceArray[], int outputArray[], int size){\n    for(int i = 0; i < size; i++){\n        outputArray[i] = sourceArray[i];\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__cll-ins-sor-seq-del.2.c", "original_string": "void seq_insertion(node** head, int n)\n{\n    node* cll=createNode(n);\n    if(*head==NULL)\n    {\n        *head=cll;\n        cll->next=cll;\n    }\n    else\n    {\n        cll->next=*head;\n        node* last=*head;\n        while(last->next!=(*head))\n            last=last->next;\n        last->next=cll;\n        *head=cll;\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__pll_36MHz.3.c", "original_string": "void pll_12MHz(void)\n{\n    PLLCON = 1<<0;              \n    PLLFEED = 0xAA;\n    PLLFEED = 0x55;             \n    PLLCFG = (1<<6)| (1<<5) | 0;    \n    while(!(PLLSTAT & (1<<10)));            \n    PLLCON = (1<<1)|(1<<0);         \n    PLLFEED = 0xAA;\n    PLLFEED = 0x55;             \n}"}
{"author": "DanielSalis", "file": "AED1__teste5.1.c", "original_string": "void inserirFim(TipoLista* l, char nome, int agilidade){\n    TipoElemento* novoElemento = (TipoElemento*)malloc(sizeof(TipoElemento));\n    novoElemento->nome = nome;\n    novoElemento->agilidade = agilidade;\n    if(l->tamanho == 0){\n        novoElemento->prox = novoElemento;\n        novoElemento->ant = novoElemento;\n        l->primeiro = novoElemento;\n        l->tamanho++;\n    }else{\n        novoElemento->prox = l->primeiro;\n        novoElemento->ant = l->primeiro->ant;\n        l->primeiro->ant->prox = novoElemento;\n        l->primeiro->ant = novoElemento;\n        l->tamanho++;\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__lcd.5.c", "original_string": "void lcd_str(char str[])\n{\n    int i;\n    for(i=0;str[i]!='\\0';++i)\n        {\n            lcd_data(str[i]);\n        }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_nus.4.c", "original_string": "uint32_t ble_nus_init(ble_nus_t * p_nus, ble_nus_init_t const * p_nus_init)\n{\n    ret_code_t            err_code;\n    ble_uuid_t            ble_uuid;\n    ble_uuid128_t         nus_base_uuid = NUS_BASE_UUID;\n    ble_add_char_params_t add_char_params;\n    VERIFY_PARAM_NOT_NULL(p_nus);\n    VERIFY_PARAM_NOT_NULL(p_nus_init);\n    p_nus->data_handler = p_nus_init->data_handler;\n    err_code = sd_ble_uuid_vs_add(&nus_base_uuid, &p_nus->uuid_type);\n    VERIFY_SUCCESS(err_code);\n    ble_uuid.type = p_nus->uuid_type;\n    ble_uuid.uuid = BLE_UUID_NUS_SERVICE;\n    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY,\n                                        &ble_uuid,\n                                        &p_nus->service_handle);\n    VERIFY_SUCCESS(err_code);\n    memset(&add_char_params, 0, sizeof(add_char_params));\n    add_char_params.uuid                     = BLE_UUID_NUS_RX_CHARACTERISTIC;\n    add_char_params.uuid_type                = p_nus->uuid_type;\n    add_char_params.max_len                  = BLE_NUS_MAX_RX_CHAR_LEN;\n    add_char_params.init_len                 = sizeof(uint8_t);\n    add_char_params.is_var_len               = true;\n    add_char_params.char_props.write         = 1;\n    add_char_params.char_props.write_wo_resp = 1;\n    add_char_params.read_access  = SEC_OPEN;\n    add_char_params.write_access = SEC_OPEN;\n    err_code = characteristic_add(p_nus->service_handle, &add_char_params, &p_nus->rx_handles);\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n    memset(&add_char_params, 0, sizeof(add_char_params));\n    add_char_params.uuid              = BLE_UUID_NUS_TX_CHARACTERISTIC;\n    add_char_params.uuid_type         = p_nus->uuid_type;\n    add_char_params.max_len           = BLE_NUS_MAX_TX_CHAR_LEN;\n    add_char_params.init_len          = sizeof(uint8_t);\n    add_char_params.is_var_len        = true;\n    add_char_params.char_props.notify = 1;\n    add_char_params.read_access       = SEC_OPEN;\n    add_char_params.write_access      = SEC_OPEN;\n    add_char_params.cccd_write_access = SEC_OPEN;\n    return characteristic_add(p_nus->service_handle, &add_char_params, &p_nus->tx_handles);\n}"}
{"author": "MartinMarinovich", "file": "MarinovichMartinLABIPP1G-__tipo.2.c", "original_string": "int listarTipos(eTipo listaDetipos[], int tamanioTipos)\n{\n    int error = -1;\n    if(listaDetipos !=NULL && tamanioTipos>0)\n    {\n        system(\"cls\");\n        printf(\" ****  LISTADO DE TIPOS  ****\\n\");\n        printf(\"Id        Descripcion\\n\");\n        printf(\"----------------------------------\\n\");\n        for(int i = 0 ; i<tamanioTipos; i++)\n        {\n            mostrarTipo(listaDetipos[i]);\n        }\n        error = 0;\n    }\n    return error;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__robo.1.c", "original_string": "void quadrado(float x, float y)\n{\n  glBegin(GL_POLYGON);\n  glVertex2f(-0.2 + x, 0.8 + y);\n  glVertex2f(-0.4 + x, 0.6 + y);\n  glVertex2f(0.2 + x, 0.8 + y);\n  glVertex2f(0.4+ x, 0.6 + y);\n  glEnd();\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__103-merge_sort.0.c", "original_string": "void TopDownMerge(int *copy, int begin, int middle, int end, int *array)\n{\n    int i, j, k;\n    i = begin;\n    j = middle;\n    k = begin;\n    printf(\"Merging...\\n\");\n    printf(\"[left]: \");\n    print_array(&copy[begin], middle - begin);\n    printf(\"[right]: \");\n    print_array(&copy[middle], end - middle);\n    while (k < end)\n    {\n        if (i < middle && (j >= end || copy[i] <= copy[j]))\n        {\n            array[k] = copy[i];\n            i++;\n        }\n        else\n        {\n            array[k] = copy[j];\n            j++;\n        }\n        k++;\n    }\n    printf(\"[Done]: \");\n    print_array(&array[begin], end - begin);\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-structure.6.c", "original_string": "CLASSVARDEC* parseclassvardecs(PARSER* p) {\n    CLASSVARDEC* head = parseclassvardec(p);\n    CLASSVARDEC* curr = head;\n    CLASSVARDEC* nextc;\n    while(nextc = parseclassvardec(p), nextc != NULL) {\n        curr->next = nextc;\n        curr = nextc;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc-a.2.c", "original_string": "list *insert(list* root, int n)\n{\n    list **temp=&root;\n    while(*temp!=NULL)\n    {\n        if(n < (*temp)->key) temp=&(*temp)->left;\n        else temp=&(*temp)->right;\n    }\n    *temp=newNode(n);\n    return root;\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client3.3.c", "original_string": "void str_trim_lf(char *arr, int length) {\n    int i;\n    for (i = 0; i < length; i++)\n    {\n        if (arr[i] == '\\n')\n        {\n            arr[i] = '\\0';\n            break;\n        }\n    }\n}"}
{"author": "ankitraj311", "file": "450_babbar__7_intersection_array_SELF.2.c", "original_string": "int main()\n{\n  int arr1[] = {1,2,3,5,6,7,8,9,10}, arr2[] = {10,2,3,6,4,9,8,7,2,3,1} ,no,j=0,temp=0,mid=0,n=0;\n  int size_arr1 = sizeof(arr1)/sizeof(int), size_arr2 = sizeof(arr2)/sizeof(int);\n  array_print(arr1,size_arr1);\n  array_print(arr2,size_arr2);\n  intersection_array(arr1,arr2,size_arr1,size_arr2);\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_dma_ex.2.c", "original_string": "HAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory)\n{\n  if(memory == MEMORY0)\n  {\n    hdma->Instance->M0AR = Address;\n  }\n  else\n  {\n    hdma->Instance->M1AR = Address;\n  }\n  return HAL_OK;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc-a.7.c", "original_string": "void mirror_ins(list* node)\n{\n    if(node==NULL)\n    return ;\n    else\n    {\n        list* temp;\n        mirror_ins(node->left);\n        mirror_ins(node->right);\n        temp=node->left;\n        node->left=node->right;\n        node->right=temp;\n    }\n}"}
{"author": "behergue", "file": "Operating_Systems__fuseLib.0.c", "original_string": "int resizeNode(uint64_t idxNode, size_t newSize)\n{\n    NodeStruct *node = myFileSystem.nodes[idxNode];\n    char block[BLOCK_SIZE_BYTES];\n    int i, diff = newSize - node->fileSize;\n    if(!diff)\n        return 0;\n    memset(block, 0, sizeof(char)*BLOCK_SIZE_BYTES);\n    if(diff > 0) {\n        if(node->numBlocks && node->fileSize % BLOCK_SIZE_BYTES) {\n            int currentBlock = node->blocks[node->numBlocks - 1];\n            if( readBlock(&myFileSystem, currentBlock, &block)==-1 ) {\n                fprintf(stderr,\"Error reading block in resizeNode\\n\");\n                return -EIO;\n            }\n            int offBlock = node->fileSize % BLOCK_SIZE_BYTES;\n            int bytes2Write = (diff > (BLOCK_SIZE_BYTES - offBlock)) ? BLOCK_SIZE_BYTES - offBlock : diff;\n            for(i = 0; i < bytes2Write; i++) {\n                block[offBlock++] = 0;\n            }\n            if( writeBlock(&myFileSystem, currentBlock, &block)==-1 ) {\n                fprintf(stderr,\"Error writing block in resizeNode\\n\");\n                return -EIO;\n            }\n        }\n        int newBlocks = (newSize + BLOCK_SIZE_BYTES - 1) / BLOCK_SIZE_BYTES - node->numBlocks;\n        if(newBlocks) {\n            memset(block, 0, sizeof(char)*BLOCK_SIZE_BYTES);\n            if(newBlocks > myFileSystem.superBlock.numOfFreeBlocks)\n                return -ENOSPC;\n            myFileSystem.superBlock.numOfFreeBlocks -= newBlocks;\n            int currentBlock = node->numBlocks;\n            node->numBlocks += newBlocks;\n            for(i = 0; currentBlock != node->numBlocks; i++) {\n                if(myFileSystem.bitMap[i] == 0) {\n                    myFileSystem.bitMap[i] = 1;\n                    node->blocks[currentBlock] = i;\n                    currentBlock++;\n                    if( writeBlock(&myFileSystem, i, &block)==-1 ) {\n                        fprintf(stderr,\"Error writing block in resizeNode\\n\");\n                        return -EIO;\n                    }\n                }\n            }\n        }\n        node->fileSize += diff;\n    }\n    else {\n        int numBlocks = (newSize + BLOCK_SIZE_BYTES - 1) / BLOCK_SIZE_BYTES;\n        myFileSystem.superBlock.numOfFreeBlocks += (node->numBlocks - numBlocks);\n        for(i = node->numBlocks; i > numBlocks; i--) {\n            int nBloque = node->blocks[i - 1];\n            myFileSystem.bitMap[nBloque] = 0;\n            if( writeBlock(&myFileSystem, nBloque, &block)==-1 ) {\n                fprintf(stderr,\"Error writing block in resizeNode\\n\");\n                return -EIO;\n            }\n        }\n        node->numBlocks = numBlocks;\n        node->fileSize += diff;\n    }\n    node->modificationTime = time(NULL);\n    sync();\n    updateSuperBlock(&myFileSystem);\n    updateBitmap(&myFileSystem);\n    updateNode(&myFileSystem, idxNode, node);\n    return 0;\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad6MatrixCopy.1.c", "original_string": "void copyArrayNormal(int sourceArray[], int outputArray[], int size){\n    for(int i = 0; i < size; i++){\n        outputArray[i] = sourceArray[i];\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__insert_value_at_doule_linked_list.3.c", "original_string": "void insertAtN(int data, int position)\n{\n    struct node *newNode, *current;\n    int i;\n    if(position == 1)\n    {\n    struct node *newNode, *current;\n    newNode = (struct node *)malloc(sizeof(struct node));\n    scanf(\"%d\", &data);\n    newNode->data = data;\n    newNode->next = head;\n    current = head;\n    while(current->next != head)\n        {\n            current = current->next;\n        }\n        current->next = newNode;\n        head = newNode;\n    }\n    else\n    {\n        newNode = (struct node *)malloc(sizeof(struct node));\n        scanf(\"%d\", &data);\n        newNode->data = data;\n        current = head;\n        for(i=2; i<=position-1; i++)\n        {\n            current = current->next;\n        }\n        newNode->next = current->next;\n        current->next = newNode;\n        printf(\"NODE INSERTED SUCCESSFULLY.\\n\");\n    }\n}"}
{"author": "2security", "file": "Star__HeartStar.0.c", "original_string": "int main()\n    {\n        int i,j,k=0,n;\n        printf(\"Enter value of n\");\n        scanf(\"%d\",&n);\n        for(i=n/2;i<n;i=i+2)\n            {\n                for(j=1;j<n-i;j=j+2)\n                    printf(\" \");\n                for(j=1;j<=i;j++)\n                    printf(\"*\");\n                for(j=1;j<=i-4*k;j++)\n                    printf(\" \");\n                for(j=1;j<=i;j++)\n                    printf(\"*\");\n            k++;\n                printf(\"\\n\");\n            }\n        for(i=n;i>=1;i--)\n            {\n                for(j=1;j<=n-i;j++)\n                    printf(\" \"); \n                for(j=1;j<=2*i-1;j++)\n                    printf(\"*\");\n                printf(\"\\n\");\n            }\n        printf(\"\\n\");\n        return 0;\n    }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es41.2.c", "original_string": "int main(void) {\n    int dim;\n    printf(\"Inserire dimensione array: \"); \n    scanf(\"%d\", &dim);\n    int a[dim];\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"---------------------------------\\n\");\n    for(int i=0; i<dim; i++)\n    {\n        a[i] = calcolaFattoriale(a[i]);\n        printf(\"Il fattoriale di a[%d] \u00e8: %d\\n\", i, a[i]);\n    }   \n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__circularqueue.3.c", "original_string": "void display()\n{\n    if((f==-1 && r==-1))\n    printf(\"\\nQueue is Empty\");\n    else if(f==(r+1)%MAX && queue[f]==-1)\n    printf(\"\\nQueue is Empty\");\n    else\n    {\n        printf(\"\\nQueue is:\\n\");\n        i=f;\n        while(i!=r)\n        {           \n            printf(\"\\t%d\",queue[i]);\n            i=(i+1)%MAX;\n        }\n        printf(\"\\t%d\",queue[r]);\n    }\n}"}
{"author": "254Odeke", "file": "Operating-Systems_Lab__Prediction.0.c", "original_string": "void main(){\n    int res,pro,i,j,n;\n    printf(\"Enter No.of Processes:\");\n    scanf(\"%d\",&pro);\n    printf(\"Enter No.of Resources:\");\n    scanf(\"%d\",&res);\n    int res_vector[res],res_avail[res],res_allocated[res];\n    printf(\"Enter Resource vector:\");\n    for(i=0;i<res;i++){\n        scanf(\"%d\",&res_vector[i]);\n        res_allocated[i]=0;\n    }\n    int max[pro][res],allocated[pro][res],needed[pro][res];\n    printf(\"Enter the Max Requirement matrix:\\n\");\n    for(i=0;i<pro;i++){\n        for(j=0;j<res;j++){\n            scanf(\"%d\",&max[i][j]);\n        }\n    }\n    printf(\"Enter the Allocated Resource matrix:\\n\");\n    for(i=0;i<pro;i++){\n        for(j=0;j<res;j++){\n            scanf(\"%d\",&allocated[i][j]);\n        }\n    }\n    for(i=0;i<pro;i++){\n        for(j=0;j<res;j++){\n            needed[i][j]=max[i][j]-allocated[i][j];\n        }\n    }\n    for(i=0;i<res;i++){\n        for(j=0;j<pro;j++){\n            res_allocated[i]+=allocated[j][i];\n        }\n        res_avail[i]=res_vector[i]-res_allocated[i];\n    }\n    while(pro!=0){\n        printf(\"Enter process number that is to be executed:\");\n        scanf(\"%d\",&n);\n        for(i=0;i<res;i++){\n            if(needed[n][i]>res_avail[i]){\n                printf(\"Resources cannot be allocated to this process now:\\n\");\n                printf(\"\\nIt is unsafe state\");\n                exit(0);\n            }\n        }\n        if(i==res){\n            printf(\"Resources are allocated to the process %d and executed\\n\",n);\n            for(j=0;j<res;j++){\n                res_avail[j]+=allocated[n][j];\n            }\n        }\n    pro--;\n    }\n    if(pro==0)\n        printf(\"\\nIt is safe state\");\n}"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio3.2.c", "original_string": "int main(int argc, char *argv[]){\n    if (pthread_mutex_init(&my_lock_main, NULL) != 0) { \n        printf(\"\\n Thread main mutex init has failed\\n\"); \n        return 1; \n    }\n    pthread_attr_init(&attr);\n    pthread_create(&my_lock1, &attr, func1, NULL);\n    sleep(5);\n    pthread_create(&my_lock2, &attr, func2, NULL);\n    sleep(10);\n    if(pthread_mutexattr_destroy(&my_lock_main) == 0){\n        printf(\"\\nSe ha destruido el main thread\\n\");\n    }\n}"}
{"author": "DanielSalis", "file": "AED1__teste8.5.c", "original_string": "node* deleteNode(node* root, int key){\n    if(root == NULL){\n        return root;\n    }\n    else if(key < root->key){\n        root->left = deleteNode(root->left, key);\n    }\n    else if(key > root->key){\n        root->right = deleteNode(root->right, key);\n    }\n    else{\n        if(root->left == NULL && root->right == NULL){\n            free(root);\n            root = NULL;\n            return root;\n        }\n        else if(root->left == NULL){\n            node* temp = root;\n            root = root->right;\n            free(temp);\n            return root;\n        }\n        else if(root->right == NULL){\n            node* temp = root;\n            root = root->left;\n            free(temp);\n            return root;\n        }\n        else{\n            node* temp = searchMinValue(root->right);\n            root->key = temp->key;\n            root->right = deleteNode(root->right, temp->key);\n        }\n    }\n    return root;\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.4.c", "original_string": "SCOPE* mkscope(SCOPE* prev) {\n    SCOPE* s = (SCOPE*)malloc(sizeof(SCOPE));\n    s->previous = prev;\n    if(prev != NULL)\n        s->compiler = prev->compiler;\n    s->localvars = NULL;\n    s->fields = NULL;\n    s->staticvars = NULL;\n    s->parameters = NULL;\n    s->classes = NULL;\n    s->subroutines = NULL;\n    return s;\n}"}
{"author": "rgautam320", "file": "Data-Structure__main18.3.c", "original_string": "int is_operator(char symbol)\n{\n    if(symbol == '^' || symbol == '/' || symbol == '*' || symbol == '+' || symbol == '-')\n        return 1;\n    else\n        return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.6.c", "original_string": "int getsymbol(ASSEMBLER* a, char* name) {\n    for(int i = 0; i < a->vars->count; i++)\n        if(strcmp(a->vars->items[i]->name, name)  == 0)\n            return a->vars->items[i]->value;\n    for(int i = 0; i < a->labels->count; i++)\n        if(strcmp(a->labels->items[i]->name, name)  == 0)\n            return a->labels->items[i]->value;\n    return -1;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e160.1.c", "original_string": "int * compararCaptcha(char captcha[6], char vetor[6], int iguais)\n{\n    int cont;\n    iguais = 0;\n    for(cont = 0; cont < 6; cont++)\n    {\n        if(captcha[cont] == vetor[cont])\n            iguais++;\n    }\n    if(iguais == 6)\n        return iguais;\n}"}
{"author": "DanielSalis", "file": "AED1__teste8.1.c", "original_string": "node* insert(node* root, int key){\n    if(root == NULL){\n        return createNode(key);\n    }\n    if(key < root->key){\n        root->left = insert(root->left, key);\n    }else if(key > root->key){\n        root->right = insert(root->right, key); \n    }\n    return root;\n}"}
{"author": "sdukesameer", "file": "c__min_largest.1.c", "original_string": "int min(int* arr, int n){\n    int m=arr[0];\n    for (int i = 0; i < n; i++){\n        if(arr[i]<m)\n            m=arr[i];\n    }\n    return m;\n}"}
{"author": "Mr-JoE1", "file": "C-Tasks-for-newbies__main25.0.c", "original_string": "int main()\n{\n    char my_string[ 100 ];\n    printf(\"Enter Your String : \");\n    scanf(\"%99[^\\n]s\" , my_string);\n    printf(\"\\nLength Of Your String Is : %u\\n\" , My_strlen( my_string , sizeof(my_string)/sizeof(char) ));\n    return 0;\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_8.1.c", "original_string": "void insert(int ele)\n{\n    struct node* temp, *p, *q;\n    temp = (struct node*)malloc(sizeof(struct node));\n    temp->data = ele;\n    temp->left = NULL;\n    temp->right = NULL;\n    if(root == NULL)\n    {\n        root = temp;\n    }\n    else\n    {\n        q = root;\n        while(1)\n        {\n            p = q;\n            if(temp->data < p->data)\n            {\n                q = q->left;\n                if(q == NULL)\n                {\n                    p->left = temp;\n                    return;\n                }\n            }\n            else\n            {\n                q = q->right;\n                if(q == NULL)\n                {\n                    p->right = temp;\n                    return;\n                }\n            }\n        }\n    }\n}"}
{"author": "jose120918", "file": "binary_trees__16-binary_tree_is_perfect.1.c", "original_string": "int scale(const binary_tree_t *tree)\n{\n    int ll = 1;\n    int lr = 1;\n    if (tree == NULL)\n    {\n        return (-1);\n    }\n    ll += scale((*tree).left);\n    lr += scale((*tree).right);\n    if (lr > ll)\n    {\n        return (lr);\n    }\n    return (ll);\n}"}
{"author": "2security", "file": "Matrix__24SubMatrix.1.c", "original_string": "void SubMat(int mat1[][20],int mat2[][20],int r,int c)\n    {\n    int i,j,temp[20][20];\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            temp[i][j]=mat1[i][j]-mat2[i][j];\n        }\n    displayMat(temp,r,c);\n    }"}
{"author": "ankitraj311", "file": "450_babbar__7_intersection_array_Geek_usorted_array.0.c", "original_string": "void array_print(int arr[], int no)  \n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_8.3.c", "original_string": "void traverse_preorder(struct node* root)\n{\n    if(root != NULL)\n    {\n        printf(\"%d\\t\", root->data);\n        traverse_preorder(root->left);\n        traverse_preorder(root->right);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q10.1.c", "original_string": "int main()\n{\n    int a[50], n;\n    printf(\"Enter number of elements: \");\n    scanf(\"%d\", &n);\n    printf(\"Enter elements: \");\n    for(int i = 0 ; i < n ; i++)\n        scanf(\"%d\", &a[i]);\n    reverse(a, n);\n    for(int i = 0 ; i < n ; i++)\n        printf(\"%d  \", a[i]);\n}"}
{"author": "RafaelFelisbino-hub", "file": "FUNCOES-exercices__Exercicio5FUNCAO.0.c", "original_string": "int main() \n{\n    float res1;\n    int res2;\n    res1 = cubo(N);\n    printf(\"O cubo e:  %.2f\\n\\n\",res1);\n    res2 = diasVividos(idade);\n    printf(\"A quantidade de dias vividos e:  %i\", res2);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__switch.0.c", "original_string": "int main()\n{\n    int flag = 0;\n    IODIR1 |= (0xFF<<17);       \n    IODIR1 = IODIR1 & ~(1<<25);     \n    while(1)\n    {\n        if(IOPIN1 & (1<<25))  \n        {\n            if(flag == 0)               \n            {\n                IOSET1 = 1<<17;\n                delay(500);\n                flag = 1;\n            }\n            else if(flag ==1)       \n            {\n                IOCLR1 = 1<<17;\n                delay(500);\n                flag = 0;\n            }\n        }\n    }\n}"}
{"author": "sdukesameer", "file": "c__rec_merge_sort.0.c", "original_string": "void printArray()\n{\n    int i;\n    for (i=0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__42.0.c", "original_string": "int main()\n{\n    char frase[200], termo[200];\n    int i, j, tam_frase, tam_termo, busca = false, indice;\n    puts(\"\\nInforme uma frase:\");\n    scanf(\"%[^\\n]s\", frase);\n    getchar();\n    puts(\"\\nInforme um termo:\");\n    scanf(\"%[^\\n]s\", termo);\n    tam_frase = strlen(frase);\n    tam_termo = strlen(termo);\n    if (tam_frase >= tam_termo)\n    {\n        for (int i = 0; i < tam_frase; i++)\n        {\n            if ((frase[i] == termo[0]) && (busca == false))\n            {\n                busca = true;\n                indice = i;\n                for (int j = 0; j < tam_termo; j++)\n                {\n                    if ((frase[i + j] != termo[j]) && (busca == true))\n                    {\n                        busca = false;\n                    }\n                }\n            }\n        }\n    }\n    if (busca == true)\n    {\n        printf(\"\\n\");\n        for (int k = 0; k < indice; k++)\n        {\n            printf(\"%c\", frase[k]);\n        }\n        for (int l = (indice + (tam_termo)); l < tam_frase; l++)\n        {\n            printf(\"%c\", frase[l]);\n        }\n        printf(\"\\n\");\n    }\n    else if (busca == false)\n    {\n        puts(\"\\nTermo n\u00e3o encontrado na frase\\n\");\n    }\n    return 0;\n}"}
{"author": "Dhruvik-Chevli", "file": "DAALab__bst.4.c", "original_string": "int main()\n{\n    int n;\n    int k;\n    struct Node* root=NULL;\n    printf(\"Please enter the number of nodes you want to insert\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Please enter the elements\\n\");\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%d\",&k);\n        root=BSTInsert(&root,k);\n    }\n    inorder(root);\n    printf(\"\\n\");\n    preorder(root);\n    printf(\"\\n\");\n    postorder(root);\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "HakNinja", "file": "C-Basic__13root.0.c", "original_string": "void main()\n {\n  float r1,r2;\n  int a,b,c,d;\n  printf(\"Enter value of a,b and c:\");\n  scanf(\"%d%d%d\",&a,&b,&c);\n  d=b*b-4*a*c;\n  if(d>0)\n   {\n    printf(\"root are real\");\n    r1=(-b+sqrt(d))/2*a;\n    r2=(-b-sqrt(d))/2*a;\n    printf(\"root are %f and %f\\n\",r1,r2);\n    }\n  else if(d==0)\n   {\n    printf(\"root are equal\");\n    r1=-b/2*a;\n    r2=-b/2*a;\n    printf(\"root are %f and %f\\n\",r1,r2);\n    }\n  else\n   {\n    printf(\"root are imaginary!\");\n    printf(\"root are not real !!\");\n    }\n  }"}
{"author": "chandanXP", "file": "Datastructure-using-C__peekInStack.2.c", "original_string": "void push(struct stack*ptr, int val){\n    if(isFull(ptr)){\n        printf(\"Stack Overflow! Cannot push %d to the stack\\n\", val);\n    }\n    else{\n        ptr->top++;\n        ptr->arr[ptr->top]=val;\n    }\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__QuickSort.3.c", "original_string": "int partition(int a[50],int p,int r)\n   {\n    int x,i,j,temp;\n    x=a[r];\n    i=p-1;\n    count++;\n    for(j=p;j<=r-1;j++)\n    {\n        count++;\n        if(a[j]<=x)\n        {\n        count++;\n            i=i+1;\n        count++;\n            temp=a[j];\n        count++;\n            a[j]=a[i];\n        count++;\n            a[i]=temp;\n        count++;\n        }\n        count++;\n    }\n    count++;\n    temp =a[r];\n    count++;\n    a[r]=a[i+1];                       \n    count++;\n    a[i+1]=temp;\n    count++;\n    return i+1;\n    }"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__pll_36MHz.0.c", "original_string": "int main()\n{\n    IODIR1 |= (0xFF<<17);\n    while(1)\n    {\n        IOSET1 = 0xFF<<17;          \n        delay_ms(500);\n        IOCLR1 = 0xFF<<17;\n        delay_ms(500);\n        count++;\n        if(count >= 10 && count<20)\n        {\n            pll_36MHz();                    \n        }\n        if (count >= 20 && count<25)\n        { \n            pll_12MHz();                \n        } else if(count >= 25)\n        {\n            pll_48MHz();\n        }\n    }\n}"}
{"author": "2security", "file": "Matrix__23AddMatrix.0.c", "original_string": "void displayMat(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server_file.2.c", "original_string": "error_t scpServerWriteData(ScpServerSession *session)\n{\n   error_t error;\n   size_t n;\n   error = NO_ERROR;\n   if(session->bufferPos < session->bufferLen)\n   {\n      error = sshReadChannel(session->channel,\n         session->buffer + session->bufferPos,\n         session->bufferLen - session->bufferPos, &n, 0);\n      if(!error)\n      {\n         session->bufferPos += n;\n      }\n   }\n   else if(session->fileOffset < session->fileSize)\n   {\n      if(session->bufferLen > 0)\n      {\n         if(session->statusCode == NO_ERROR)\n         {\n            session->statusCode = fsWriteFile(session->file, session->buffer,\n               session->bufferLen);\n         }\n         session->fileOffset += session->bufferLen;\n      }\n      if((session->fileSize - session->fileOffset) < SCP_SERVER_BUFFER_SIZE)\n      {\n         n = (size_t) (session->fileSize - session->fileOffset);\n      }\n      else\n      {\n         n = SCP_SERVER_BUFFER_SIZE;\n      }\n      session->bufferLen = n;\n      session->bufferPos = 0;\n   }\n   else\n   {\n      fsCloseFile(session->file);\n      session->file = NULL;\n      session->bufferLen = 0;\n      session->bufferPos = 0;\n      if(session->statusCode == NO_ERROR)\n      {\n         session->state = SCP_SERVER_SESSION_STATE_WRITE_STATUS;\n      }\n      else\n      {\n         session->state = SCP_SERVER_SESSION_STATE_ERROR;\n      }\n   }\n   return error;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica1-4a.1.c", "original_string": "int factorial(int n){\n   int fact=1;\n   if( n<0 ) return 0;\n   if(n==0) return 1;\n   for (int i = 1; i <= n; ++i) {fact = fact*i;} \n   return fact;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Odd_Even_Sort.2.c", "original_string": "void odd_even_sort(int array[MAX], int length)\n{\n    int i, j, temp, flag = 0;\n    int size = length;\n    do\n    {\n        flag = 0;\n        for(i=0; i<size-1; i=i+2)\n        {\n            if(array[i] > array[i+1])\n            {\n                temp = array[i+1];\n                array[i+1] = array[i];\n                array[i] = temp;\n                flag = 1;\n            }\n        }\n        for(j=1; j<size-1; j=j+2)\n        {\n            if(array[j] > array[j+1])\n            {\n                temp = array[j+1];\n                array[j+1] = array[j];\n                array[j] = temp;\n                flag = 1;\n            }\n        }\n    }while(flag);\n}"}
{"author": "andi-s0106", "file": "sorting_algorithms__101-cocktail_sort_list.0.c", "original_string": "void cocktail_sort_list(listint_t **list)\n{\n    int flag;\n    listint_t *tmp;\n    flag = 0;\n    if (list == NULL || *list == NULL || (*list)->next == NULL)\n        return;\n    tmp = *list;\n    while (flag == 0)\n    {\n        flag = 1;\n        while (tmp->next != NULL)\n        {\n            if (tmp->n > tmp->next->n)\n                flag = swap(list, tmp, 0);\n            else\n                tmp = tmp->next;\n        }\n        tmp = tmp->prev;\n        if (flag == 1)\n            break;\n        while (tmp->prev != NULL)\n        {\n            if (tmp->n < tmp->prev->n)\n                flag = swap(list, tmp, 1);\n            else\n                tmp = tmp->prev;\n        }\n        if (flag == 1)\n            break;\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__8.0.c", "original_string": "int main()\n{\n    int n;\n    float nota, notafinal = 0, denominador = 0, fator, notamedia;\n    printf(\"\\nInforme a quantidade de notas do aluno: \");\n    scanf(\"%i\", &n);\n    for (int qtd = 1; qtd <= n; qtd++)\n    {\n        printf(\"\\nInforme a %i\u00aa nota: \", qtd);\n        scanf(\"%f\", &nota);\n        if ((qtd % 2) == 0)\n        {\n            fator = 3;\n            nota = fator * nota;\n        }\n        else\n        {\n            fator = 2;\n            nota = fator * nota;\n        }\n        notafinal = notafinal + nota;\n        denominador = denominador + fator;\n    }\n    notamedia = notafinal / denominador;\n    printf(\"\\nNota m\u00e9dia = %.2f\\n\", notamedia);\n    if (notamedia < 5)\n    {\n        printf(\"\\nAluno reprovado!\\n\\n\");\n    }\n    else if ((notamedia >= 5) && (notamedia < 6))\n    {\n        printf(\"\\nAluno em recupera\u00e7\u00e3o!\\n\\n\");\n    }\n    else\n    {\n        printf(\"\\nAluno aprovado!\\n\\n\");\n        if ((notamedia >= 8) && (notamedia < 10))\n        {\n            printf(\"Parab\u00e9ns!\\n\\n\");\n        }\n        else if (notamedia == 10)\n        {\n            printf(\"Sensacional!\\n\\n\");\n        }\n    }\n    return 0;\n}"}
{"author": "qtgeo1248", "file": "ProjectEuler__ans3.0.c", "original_string": "int main() {\n    char *filename = \"num.txt\";\n    FILE *f = fopen(filename, \"r\");\n    char *line = NULL; size_t len = 0; char *tmp = NULL;\n    getline(&line, &len, f);\n    size_t p = strtol(line, &tmp, 10);\n    size_t size = ceil(sqrt(p));\n    bool *primes = calloc(sizeof(bool), size + 1); \n    for (size_t i = 2; i < size + 1; i++) {\n        if (!primes[i])\n            for (size_t j = 2 * i; j < size + 1; j += i)\n                primes[j] = true;\n    }\n    size_t maxp = 0;\n    for (size_t i = 2; i < size + 1; i++) {\n        if (!primes[i] && p % i == 0 && i > maxp)\n            maxp = i;\n    }\n    printf(\"Answer: %zu\\n\", maxp);\n    free(primes);\n    fclose(f); free(line);\n    return 0;\n}"}
{"author": "Dhruvik-Chevli", "file": "DAALab__stringSearch.0.c", "original_string": "int main()\n{\n    char str[50],substr[50];\n    int a,b,c,k=0,flag=0;\n    clock_t t1,t2;\n    printf(\"\\nEnter a string: \");\n    scanf(\"%[^\\n]%*c\",str);\n    printf(\"\\nEnter the substring to search: \");\n    scanf(\"%[^\\n]%*c\",substr);\n    t1=clock();\n    int opcount=0;\n    for (a=0;a<strlen(str);a++)\n    {\n        ++opcount;\n        c=a;\n        if (str[a]==substr[k])\n        {\n            for (b=0;b<=strlen(substr);b++)\n            {\n                ++opcount;\n                if (b==strlen(substr))\n                {\n                    flag=1;\n                    break;\n                }\n                if (str[c]==substr[b])\n                    c++;             \n                else if (str[c]!=substr[b])\n                {\n                    flag=0;\n                    break;\n                }             \n            }\n        }\n        if ( flag==1 ) break;\n    }\n    t2=clock();\n    printf(\"\\ntime taken is %ld\\n\",(t2-t1));\n    printf(\"\\nOpcount: %d\",opcount);\n    if (flag==1)\n        printf(\"\\nfound\\n\");\n    else \n        printf(\"\\nnot found\\n\");\n    return 0;\n}"}
{"author": "haon1026", "file": "linux-programming__fifo_r.1.c", "original_string": "int main(int argc, char *argv[])\n{\n    if(argc < 2)\n    {\n        printf(\"enter a fifo name\\n\");\n        return -1;\n    }\n    int fd = open(argv[1], O_RDONLY);\n    if(fd < 0)\n        sys_error(\"open error\");\n    int n;\n    char buf[1024];\n    while(1)\n    {\n        n = read(fd, buf, sizeof(buf));\n        write(STDOUT_FILENO, buf, n);\n        sleep(1);\n    }\n    close(fd);\n    return 0;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__queue_with_linkedlist.1.c", "original_string": "void Dequeue() {\n    struct Node* temp = front;\n    if(front == NULL) {\n        printf(\"Queue is Empty\\n\");\n        return;\n    }\n    if(front == rear) {\n        front = rear = NULL;\n    }\n    else {\n        front = front->next;\n    }\n    free(temp);\n}"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal_pwr.10.c", "original_string": "void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)\n{\n  assert_param(IS_PWR_REGULATOR(Regulator));\n  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));\n  CLEAR_BIT(PWR->CR,  PWR_CR_PDDS);\n  MODIFY_REG(PWR->CR, PWR_CR_LPDS, Regulator);\n  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));\n  if(STOPEntry == PWR_STOPENTRY_WFI)\n  {\n    __WFI();\n  }\n  else\n  {\n    __SEV();\n    PWR_OverloadWfe(); \n    PWR_OverloadWfe(); \n  }\n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q13.2.c", "original_string": "void deleteq(que* pq)\n{\n    if (pq->front ==  -1)\n        printf(\"Queue is empty\");\n    else if (pq->front == pq->rear)\n    {\n        printf(\"\\n%s deleted\", pq->queue[pq->front]);\n        pq->front =  -1;\n        pq->rear =  -1;\n    }\n    else if (pq->front == size - 1) \n    {\n        printf(\"\\n%s deleted\", pq->queue[pq->front]);\n        pq->front = 0;\n    }\n    else\n        printf(\"\\n%s deleted\", pq->queue[(pq->front)++]);\n}"}
{"author": "augustogunsch", "file": "jack-compiler__vm-lines.7.c", "original_string": "LINEBLOCK* mklnblk(LINE* start) {\n    LINEBLOCK* blk = (LINEBLOCK*)malloc(sizeof(LINEBLOCK));\n    blk->head = start;\n    blk->tail = start;\n    return blk;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "2lista_de_C__main16.0.c", "original_string": "int main()\n{\n    int m;\n    int n;\n    printf(\"digite o primeiro numero: \");\n    scanf(\"%d\",&m);\n    printf(\"digite o segundo numero: \");\n    scanf(\"%d\",&n);\nwhile ( m!=n)\n{\nif (m > n){\n    m = m - n;\n}else\n    n = n - m;\n}\n    printf(\"o maximo divisor comum eh:%d\", m);\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad6.6.c", "original_string": "int pushR(pozicija p)\n{ \n    pozicija q = NULL;\n    q = (pozicija)malloc(sizeof(struct cvor));\n    if (q == NULL)\n    {\n        printf(\"Neuspjesna alokacija memorije!\\n\");\n        return 1;\n    }\n     pozicija kraj = NULL;\n    if (p->next == NULL)\n        kraj = p;\n    int broj = (rand() % (MAX - MIN + 1)) + MIN;\n    q->el = broj;\n    q->next = NULL;\n    kraj->next = q;\n    kraj = q;\n    return 0;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__arreglo_uni_dinamico_realloc.0.c", "original_string": "int main(){\n    int *calorias = NULL;\n    char respuesta;\n    int posicion = 1;\n    calorias = (int *) malloc ( posicion * sizeof(int));\n    do {\n        calorias = (int *) realloc (calorias, posicion);\n        leer_calorias(calorias, posicion);\n        posicion++;\n        printf(\"Desea agregar consumo de calorias de otro d\u00eda?\");\n        fflush(stdin);\n        respuesta = getchar();  \n    } while(respuesta != 'n');\n    printf(\"El promedio de calor\u00edas consumidas en %d d\u00edas fue %.2f\\n\"\n        , posicion - 1\n        , promedio_calorias(calorias, posicion - 1));\n    free(calorias);\n    return 0;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__catavento.2.c", "original_string": "void desenhaFolhas(){\n    glPushMatrix();\n        glColor3f(1.0,0.2,0.2);\n        glRotatef(1, 0.0, 0.0, 1.0);\n        glRotatef(-90.0, 1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(0.0, 0.0, 2.0);\n        glutWireCone(1.0, 2.0, 10.0, 10.0);\n    glPopMatrix();\n    glPushMatrix();\n        glColor3f(1.0,0.2,0.2);\n        glRotatef(90.0, 0.0, 0.0, 1.0);\n        glRotatef(-90.0, 1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(0.0, 0.0, 2.0);\n        glutWireCone(1.0, 2.0, 10.0, 10.0);\n    glPopMatrix();\n    glPushMatrix();\n        glColor3f(1.0,0.2,0.2);\n        glRotatef(-90.0, 0.0, 0.0, 1.0);\n        glRotatef(-90.0, 1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(0.0, 0.0, 2.0);\n        glutWireCone(1.0, 2.0, 10.0, 10.0);\n    glPopMatrix();\n    glPushMatrix();\n        glColor3f(1.0,0.2,0.2);\n        glRotatef(-180.0, 0.0, 0.0, 1.0);\n        glRotatef(-90.0, 1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(0.0, 0.0, 2.0);\n        glutWireCone(1.0, 2.0, 10.0, 10.0);\n    glPopMatrix();\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__12_.2.c", "original_string": "void Filas(int contador){\n    if(contador < 7){\n        switch (contador){\n            case 0: Columna(1,contador,'P');break;\n            case 1: Columna(1,contador,'N');break;\n            case 2: Columna(1,contador,'L');break;\n            case 3: Columna(1,contador,'J');break;\n            case 4: Columna(1,contador,'H');break;\n            case 5: Columna(1,contador,'F');break;\n            case 6: Columna(1,contador,'D');break;\n        }\n        printf(\"\\n\");\n        Filas(++contador);\n    }\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__test.4.c", "original_string": "static unsigned int crc32(unsigned char *buffer, unsigned int size)\n{\n    unsigned int crc = 0xFFFFFFFF;\n    unsigned int i;\n    for (i = 0; i < size; i++) {\n        crc = crc_table[(crc ^ buffer[i]) & 0xff] ^ (crc >> 8);\n    }\n    return crc ;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Stack.1.c", "original_string": "void push()\n{\n    int flag = checkStackFull();\n    if(flag == 1)\n    {\n        int element = 0;\n        printf(\"\\nEnter the element to be pushed: \");\n        scanf(\"%d\", &element);\n        ptr.array[++(ptr.top)] = element;\n    }\n    else\n        printf(\"\\nStack is FULL!!!\");\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_4.4.c", "original_string": "int main()\n{\n    char infix[CAPACITY], postfix[CAPACITY], item, temp;\n    int i = 0, j = 0;\n    printf(\"Enter an Infix Expression to Convert into Postfix : \");\n    gets(infix);\n    while(infix[i]!='\\0')\n    {\n        item = infix[i];\n        if(item == '(')\n        {\n            push(item);\n        }\n        else if((item >= 'A' && item <= 'Z') || (item >= 'a' && item <= 'z'))\n        {\n            postfix[j] = item;\n            j++;\n        }\n        else if(is_operator(item) == 1)\n        {\n            temp = pop();\n            while(is_operator(temp) == 1 && precedence(temp) >= precedence(item))\n            {\n                postfix[j] = temp;\n                j++;\n                temp = pop();\n            }\n            push(temp);\n            push(item);\n        }\n        else if(item == ')')\n        {\n            temp = pop();\n            while(temp != '(')\n            {\n                postfix[j] = temp;\n                j++;\n                temp = pop();\n            }\n        }\n        else\n        {\n            printf(\"\\nInvalid Expression\");\n        }\n        i++;\n    }\n    while(top > -1)\n    {\n        postfix[j] = pop();\n        j++;\n    }\n    printf(\"\\nArithmetic Expression in Postfix form is : \");\n    puts(postfix);\n    return 0;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__insert_a_node_in_circular_linked_list.3.c", "original_string": "void insertAtBeginning(int data)\n{\n    struct node *newNode, *current;\n    if(head == NULL)\n    {\n        printf(\"List is empty.\\n\");\n    }\n    else\n    {\n        newNode = (struct node *)malloc(sizeof(struct node));\n        newNode->data = data;\n        newNode->next = head;\n        current = head;\n        while(current->next != head)\n        {\n            current = current->next;\n        }\n        current->next = newNode;\n        head = newNode;\n        printf(\"NODE INSERTED SUCCESSFULLY\\n\");\n    }\n}"}
{"author": "seefeesaw", "file": "Recursion__fibonacci.2.c", "original_string": "int mfib(int n)\n{\n     if (n <= 1)\n     {\n         F[n] = n;\n         return n;\n     }\n     else\n     {\n         if (F[n - 2] == -1)\n         {\n             F[n - 2] = mfib(n - 2);\n         }\n         if (F[n - 1] == -1)\n         {\n             F[n - 1] = mfib(n - 1);\n         }\n         F[n] = F[n - 2] + F[n - 1];\n         return F[n - 2] + F[n - 1];\n     }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server.3.c", "original_string": "error_t scpServerStop(ScpServerContext *context)\n{\n   uint_t i;\n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n   TRACE_INFO(\"Stopping SCP server...\\r\\n\");\n   if(context->running)\n   {\n      sshServerUnregisterChannelRequestCallback(context->sshServerContext,\n         scpServerChannelRequestCallback);\n      context->stop = TRUE;\n      osSetEvent(&context->event);\n      while(context->running)\n      {\n         osDelayTask(1);\n      }\n      for(i = 0; i < context->numSessions; i++)\n      {\n         if(context->sessions[i].state != SCP_SERVER_SESSION_STATE_CLOSED)\n         {\n            scpServerCloseSession(&context->sessions[i]);\n         }\n      }\n   }\n   return NO_ERROR;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__2.2.c", "original_string": "void enqueue(QUEUE* pq, int x)\n{\n    if(isFull(pq) == 0)\n        pq->q[(pq->rear)++] = x;\n    else\n        printf(\"FULL\");\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__4menu_driven.2.c", "original_string": "void sumofseries(void)\n{\n    int n,i,sum=0;\n    printf(\"enter the limit\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i=i+2)\n    {\n        sum+=i;\n    }\n    printf(\"%d\",sum);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__AJ.0.c", "original_string": "int primos(long int maior, long int vet[])\n{\n    long int primo = 3;\n    int busca, i0;\n    vet[0] = 2;\n    for (int i = i; (vet[i] * vet[i]) <= maior;)\n    {\n        busca = true;\n        for (int j = i; (j >= 0) && (busca == true); j--)\n        {\n            if (primo % vet[j] == 0)\n                busca = false;\n        }\n        if (busca == true)\n        {\n            vet[i + 1] = primo;\n            i++;\n            i0 = i;\n        }\n        else if (busca == false)\n            primo++;\n    }\n    return i0;\n}"}
{"author": "sdukesameer", "file": "c__sum-of-digits-all-even-odd.1.c", "original_string": "int evensum(int n)\n{\n    int ans=0,f;\n    if(n<0)\n        n=-n;\n    if (n>0)\n    {\n        while(n>0)\n        {\n            f=n%10;\n            if(f%2==0)\n                ans+=f;\n            n=n/10;\n        }\n    }\n    return ans;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__4_While.0.c", "original_string": "int main()\n{\n    int Mayor = 0;\n    int menor = 0;\n    int Mayor_150 = 0;\n    int negativos = 0;\n    float promedio_P = 0.0;\n    int contador = 0;\n    int num_p = 0;\n    while(contador < 10)\n    {\n     int numero = 0;\n     printf(\"\\nIngrese por favor el numero: \");\n     scanf(\"%i\", &numero);\n     if(numero != 0){\n         if(numero > 150){\n             ++Mayor_150;    \n         }\n         if(numero > Mayor){\n             Mayor = numero;    \n         }else if(numero < menor){\n             menor = numero;    \n         }\n         if(numero > 0){\n             ++num_p;\n             promedio_P += numero; \n         }else{\n             ++negativos;          \n         }\n         ++contador;\n         }\n     }\n     printf(\"\\n***Fin del Ciclo***\\n\");\n     promedio_P = promedio_P / num_p;\n     printf(\"\\nCantidad de numeros mayores a 150: %i\", Mayor_150);\n     printf(\"\\nNumero mayor: %i  Numero menor: %i\", Mayor, menor);   \n     printf(\"\\nCantidad de numeros negativos encontrador: %i\", negativos);\n     printf(\"\\nPromedio positivos encontrados: %f\", promedio_P);\n}"}
{"author": "haon1026", "file": "linux-programming__mmap.1.c", "original_string": "int main()\n{\n    int fd = open(\"testmap\", O_RDWR|O_CREAT|O_TRUNC, 0644);\n    if(fd == -1)\n        sys_err(\"open error\");\n    ftruncate(fd, 20);              \n    int len = lseek(fd, 0, SEEK_END);\n    char *p = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n    if(p == MAP_FAILED)\n        sys_err(\"mmap error\");\n    strcpy(p, \"hello map\");\n    printf(\"%s\\n\", p);\n    int ret = munmap(p, len);\n    if(ret == -1)\n        sys_err(\"munmap error\");\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__DFS.1.c", "original_string": "int pop()\n{\n    int x;\n    if(top==-1)\n    printf(\"\\nStack is Empty\");\n    else\n    {\n        x=STACK[top];\n        top=top-1;\n        return(x);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q12.2.c", "original_string": "int main()\n{\n    stack s;\n    char exp[15];\n    printf(\"Enter exp: \");\n    scanf(\"%s\", exp);\n    strrev(exp);        \n    for(int i = 0 ; exp[i] != '\\0' ; i++)\n    {\n        char token = exp[i];\n        if (token >= '0' && token <= '9')\n            push(&s, token);\n        else\n        {\n            char a = pop(&s);                       \n            char b = pop(&s);\n            switch(token)\n            {\n                case '+':   push(&s, toInt(a) + toInt(b) + '0');\n                            break;\n                case '-':   push(&s, toInt(a) - toInt(b) + '0');\n                            break;\n                case '/':   push(&s, toInt(a) / toInt(b) + '0');\n                            break;\n                case '*':   push(&s, toInt(a) * toInt(b) + '0');\n                            break;\n            }\n        }\n    }\n    printf(\"Ans = %d \\n\", toInt(pop(&s)));\n}"}
{"author": "haon1026", "file": "linux-programming__nonblood-mmap-w.1.c", "original_string": "int main()\n{\n    struct student stu = {1, \"zhangsan\", 18};\n    int fd = open(\"temp\", O_RDWR|O_CREAT|O_TRUNC, 0644);\n    if(fd == -1)\n        sys_err(\"open error\");\n    ftruncate(fd, sizeof(stu)); \n    struct student *p = mmap(NULL, sizeof(stu), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n    if(p == MAP_FAILED)\n        sys_err(\"mmap error\");\n    close(fd);\n    while(1)\n    {\n        memcpy(p, &stu, sizeof(stu));\n        stu.id++;\n        sleep(1);\n    }\n    munmap(p, sizeof(stu));\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__LLstack.2.c", "original_string": "int pop(nptr &stack)\n{\n    if(stack == NULL)\n        return -1;\n    nptr temp = stack;\n    stack = stack -> next;\n    int x = temp -> data;\n    free(temp);\n    return x;\n}"}
{"author": "sdukesameer", "file": "dsa__dfs.6.c", "original_string": "void free_graph(graph* g){\n    for(int i=0; i<g->n; i++)\n        free(g->arr[i]);\n    free(g->arr);\n}"}
{"author": "davibernardos", "file": "DB-PJ__e92.5.c", "original_string": "void pagarCartaoMeia(int contSelec, struct evento show[])\n{\n    show[contSelec].lucro += show[contSelec].valorIngresso / 2;\n    show[contSelec].disponiveis--;\n    show[contSelec].meia++;\n}"}
{"author": "jose120918", "file": "sorting_algorithms__100-shell_sort.0.c", "original_string": "void shell_sort(int *array, size_t size)\n{\n    size_t h = 1, i, n;\n    int number;\n    if (!size || !array)\n        return;\n    while (h < size)\n        h = 3 * h + 1;\n    h = (h - 1) / 3;\n    while (h > 0)\n    {\n        for (i = h; i < size; i++)\n        {\n            number = array[i];\n            for (n = i; n > h - 1 && array[n - h] > number; n = n - h)\n            {\n                array[n] = array[n - h];\n            }\n            array[n] = number;\n        }\n        h = h / 3;\n        print_array(array, size);\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__row_key.0.c", "original_string": "int main()\n{\n    int val;\n    IODIR1 = IODIR1 & ~(ROW);\n    IODIR1 = IODIR1 | (COL);\n    lcd_config();\n    while(1)\n    {\n        val = (IOPIN1 & ROW); \n        val = val >> 17;\n        if(val == 0x0E)\n        {\n            lcd_str(\"row1\");\n            delay(500);\n        }\n        if(val == 0x0D)\n        {\n            lcd_str(\"row2\");\n            delay(500);\n        }\n        if(val == 0x0B)\n        {\n            lcd_str(\"row3\");\n            delay(500);\n        }\n        if(val == 0x07)\n        {\n            lcd_str(\"Row4\");\n            delay(500);\n        }\n        lcd_cmd(0x01);\n    }   \n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_strrev.1.c", "original_string": "char *ft_strrev (char * str){\n    int longitud = ft_strlen(str);\n    char *string; \n    for(int i = 1; i <= longitud + 1; i++){\n        if(i > longitud)\n            string[longitud] = '\\0';\n        else\n            string[i -1] = str[longitud - i];\n    }\n    return string;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q4_dupl.0.c", "original_string": "void add(nodeptr* head,int x)\n{\n    nodeptr temp=malloc(sizeof(node));\n    nodeptr t;\n    temp->data=x;\n    temp->link=NULL;\n    if(!(*head))\n        *head=temp;\n    else\n    {\n        for(t=(*head);t->link;t=t->link);\n        t->link=temp;\n    }\n}"}
{"author": "behergue", "file": "Operating_Systems__simulator.4.c", "original_string": "int main(int argc, char *argv[]) {\n    int i;\n    for(i=0; i < N_PARADAS; i++){\n        pthread_mutex_init(&esperaSubir[i],NULL);\n        pthread_mutex_init(&esperaBajar[i],NULL);\n    }\n    pthread_cond_init(&suben, NULL);\n    pthread_cond_init(&bajan, NULL);\n    pthread_cond_init(&hanSubido, NULL);\n    pthread_cond_init(&hanBajado, NULL);\n    pthread_create(&hiloAutobus, NULL, thread_autobus, NULL);\n    for (i = 0; i < USUARIOS; i++)\n        pthread_create(&usuarios[i], NULL, thread_usuario, (void *) i);\n    pthread_join(hiloAutobus, NULL);\n    for (i = 0; i < USUARIOS; i++)\n        pthread_join(usuarios[i], NULL);\n    for(i=0; i<N_PARADAS; i++){\n        pthread_mutex_destroy(&esperaSubir[i]);\n        pthread_mutex_destroy(&esperaBajar[i]);\n    }\n    pthread_cond_destroy(&suben);\n    pthread_cond_destroy(&bajan);\n    pthread_cond_destroy(&hanSubido);\n    pthread_cond_destroy(&hanBajado);\n    return 0;\n}"}
{"author": "dishanp", "file": "DSA__q63.2.c", "original_string": "void display_freq(struct node_freq *p)\n{\n    while(p)\n    {\n        printf(\"Frequency of element %d is %d\\n\", p->data, p->freq);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader0.2.c", "original_string": "void firmwareUpdateInfoReader_run(void)\n{\n  char updateInfoString[260 + 1] = \"\";\n  if (!loadFirmwareUpdateInfoFile(updateInfoString, sizeof(updateInfoString))) \n  {\n    memset(lastUpdateInfoString, 0, sizeof(lastUpdateInfoString));\n    return;\n  }\n  if (strncmp(updateInfoString, lastUpdateInfoString, 260) == 0) \n  {\n    return;\n  }\n  strncpy(lastUpdateInfoString, updateInfoString, 260);\n  if (!parseFirmwareUpdateInfo(updateInfoString)) \n  {\n    return;\n  }\n  printf(\"Firmware update request towards version %s received\\n\", updateVersion);\n  fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__key.2.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__readmap.1.c", "original_string": "void    readmap(char *line)\n{\n    if (line[0] != '\\0' && !g_map_started)\n        g_map_started = 1;\n    if (g_map_started && line[0] != '\\0')\n    {\n        g_map = ft_strjoi(g_map, line);\n    }\n    if (g_map_started && line[0] == '\\0')\n    {\n        ft_putstr(\"Error:\\nmap has a new line\");\n        exit(0);\n    }\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__udpdaytimeserver.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    int sockid,rval,clen;\n    char buffer[20],smsg[30];\n    time_t t;\n    struct sockaddr_in s,c;\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    sockid=socket(PF_INET,SOCK_DGRAM,17);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=PF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=bind(sockid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)\n    {\n        perror(\"BIND-ERR\");\n        close(sockid);\n        exit(1);\n    }\n    clen=sizeof(c);\n    rval=recvfrom(sockid,buffer,sizeof(buffer),0,(struct sockaddr*)&c,&clen);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n    }   \n    else\n    {\n        printf(\"\\nClient Request is : %s\\n\",buffer);\n    }\n    t=time(0);\n    strcpy(smsg,ctime(&t));\n    rval=sendto(sockid,smsg,sizeof(smsg),0,(struct sockaddr*)&c,sizeof(c));\n    if(rval==-1)\n    {\n        perror(\"MSG-SND-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nResponse sent successfully\\n\");\n    }\n    close(sockid);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CDLL.7.c", "original_string": "void delete_beg()\n{\n    struct node *temp,*firstnode;\n    firstnode=head;\n    temp=head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    head->next->pre=head->pre;\n    temp->next=firstnode->next;\n    head=firstnode->next;\n    free(firstnode);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_DCLL.4.c", "original_string": "void delete_beg()\n{\n    struct node *temp,*firstnode;\n    firstnode=head;\n    temp=head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    head->next->pre=head->pre;\n    temp->next=firstnode->next;\n    head=firstnode->next;\n    free(firstnode);\n}"}
{"author": "haon1026", "file": "linux-programming__rwlock.2.c", "original_string": "int main()\n{\n    pthread_t tid[8];\n    pthread_rwlock_init(&rwlock, NULL);\n    int i;\n    for(i = 0; i < 3; i++)\n        pthread_create(&tid[i], NULL, thread_write, (void*)i);\n    for(i = 0; i < 5; i++)\n        pthread_create(&tid[i+3], NULL, thread_read, (void*)i);\n    for(i = 0; i < 8; i++)\n        pthread_join(tid[i], NULL);\n    pthread_rwlock_destroy(&rwlock);\n    return 0;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__20_e.3.c", "original_string": "void E(int contador, int iteraciones,double suma, double X)\n{\n        if(contador <= iteraciones){\n                printf(\"\\n->%i %0.0lf / %0.0lf = %0.6lf\",contador,Exp(contador,X),Fac((contador + 0.0)), Exp(contador,X) / (Fac(contador) + 0.0));\n                suma = suma + Exp(contador,X) / (Fac(contador));\n                printf(\"\\tSuma por el momento: %0.6lf\\n\", suma);\n                E(++contador,iteraciones,suma,X);\n        }else{                \n        printf(\"\\nEl resultado de e^%0.0lf es: %lf\",X , (suma + 1.0));\n        }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__implementation_of_DLL.1.c", "original_string": "void creat()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__dequeue1.6.c", "original_string": "void main()\n{\n    int ch;\n    printf(\"1.enqueueF\\n2.enqueueR\\n3.dequeueF\\n4.dequeueR\\n5.search\\n6.print\\n\\n\");\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the value to insert:\");\n                scanf(\"%d\",&value);\n                enqueueF(value);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter the value to insert:\");\n                scanf(\"%d\",&value);\n                enqueueR(value);\n                break;\n            }\n            case 3:\n            {\n                dequeueF();\n                break;\n            }\n            case 4:\n            {\n                dequeueR();\n                break;\n            }\n            case 5:\n            {\n                printf(\"\\nEnter the value to search:\");\n                scanf(\"%d\",&value);\n                search(value);\n                break;\n            }\n            case 6:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"author": "kalpa96", "file": "Struct__readme.2.c", "original_string": "int main(){\n    FILE *fp;\n    fp=fopen(\"readme.txt\",\"r\");\n    int i=0,medianIncome;\n    while(i<5){\n        fscanf(fp,\"%d\\t\\t%d\\t\\t\\t%d\",&fam[i].id_number,&fam[i].anu_income,&fam[i].numOfMembers);\n        sumOfIncome(fam[i].anu_income);\n        totalOfMembers(fam[i].numOfMembers,i);\n        i++;\n    }\n    printf(\"IDNumber\\tAnnualIncome($)\\tNumberOfMembers\\n\\n\");\n    for(i=0;i<5;i++){\n        printf(\"%d\\t\\t%d\\t\\t%d\\n\",fam[i].id_number,fam[i].anu_income,fam[i].numOfMembers);\n    }\n    int avrgeIncm=IncomeSum/5;\n    printf(\"\\nAverage household income($):%d\\n\",avrgeIncm);\n    printf(\"\\nTotal number of members in the town:%d\\n\",Members);\n    int medianPoint=Members/2;\n    for(i=0;i<5;i++){\n        if(medianPoint-fam[i].t<0){\n            medianIncome=fam[i].anu_income;\n            break;\n        }\n    }\n    printf(\"\\nMedian Annual Income($):%d\",medianIncome);\n    return 0;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__56_lower_2_upper_vv.0.c", "original_string": "int main()\n{\n  int i,j,k, count = 0, frequency[26] = {0};\n  char str_arr[100], str_arr1[100], f;\n  printf(\"Enter String to convert Upper to Lower & Lower to Upper\");\n  scanf(\"%[^\\n]s\",str_arr);\n  printf(\"%s\",str_arr);\n  for(i=0; str_arr[i] != '\\0'; i++)\n  {\n    if(str_arr[i] > 'a' && str_arr[i] < 'z')\n    {\n      str_arr1[i] = (char)str_arr[i] - 32;\n    }\n    else if(str_arr[i] > 'A' && str_arr[i] < 'Z')\n    {\n      str_arr1[i] = (char)str_arr[i] + 32;\n    }\n    else\n    {\n      str_arr1[i] = str_arr[i];\n    }\n  }\n  printf(\"\\nAfter Conversion String is %s\\n\",str_arr1);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CDLL.6.c", "original_string": "void insert_at_pos()\n{\n    struct node *newnode,*temp;\n    int i=1;\n    int pos;\n    int leg=count();\n    printf(\"enter the position in between the 1 to %d\\n\",leg);\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    if(pos>leg)\n    {\n        printf(\"invalied position\\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=temp->next;\n        newnode->pre=temp;\n        temp->next->pre=newnode;\n        temp->next=newnode;\n    }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_03.3.c", "original_string": "int binary_search_rev(int a[], int str, int end, int k)\n{\n        int mid = (end+str)/2;\n        while(str<=end)\n        {\n                mid = (end+str)/2;\n                if(a[mid] == k)\n                        return mid;\n                else if(a[mid]>k)\n                {\n                        str = mid+1;\n                }\n                else if(a[mid]<k)\n                {\n                        end = mid-1;\n                }\n        }\n        return -1;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad4.0.c", "original_string": "int main() {\n    struct polinom Head1;\n    struct polinom Head2;\n    struct polinom HeadZ;\n    struct polinom HeadM;\n    Head1.next = NULL;\n    Head2.next = NULL;\n    HeadZ.next = NULL;\n    HeadM.next = NULL;\n    unosPrvi(&Head1);\n    unosDrugi(&Head2);\n    printf(\"Ispis prvog polinoma:\\n\");\n    ispis(Head1.next);\n    printf(\"Ispis drugog polinoma:\\n\");\n    ispis(Head2.next);\n    zbroj(&Head1, &Head2, &HeadZ);\n    printf(\"Ispis zbrojenog polinoma:\\n\");\n    ispis(HeadZ.next);\n    umnozak(&Head1, &Head2, &HeadM);\n    printf(\"Ispis pomnozenih polinoma:\\n\");\n    ispis(HeadM.next);\n    return 0;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zadOsmi.5.c", "original_string": "Position ChangeDirectory(Position current, StackPosition stackHead, char* name)\n{\n    if (!current->child)\n    {\n        return current;\n    }\n    else\n    {\n        Position parent = current;\n        Position finderOfWantedDirectory = current->child;\n        while (finderOfWantedDirectory)\n        {\n            if (!strcmp(finderOfWantedDirectory->name, name))\n            {\n                PushStack(finderOfWantedDirectory, stackHead);\n                return finderOfWantedDirectory;\n            }\n            finderOfWantedDirectory = finderOfWantedDirectory->sibling;\n        }\n        return parent;\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__Md_Sameer_13000119114.14.c", "original_string": "int main(){\n    int ch,d,x;\n    stack *stk;\n    list *T, *root;\n    while(1){\n        printf(\"\\n\");\n        printf(\"1. Initialise Binary Search Tree \\n\");\n        printf(\"2. Initialise the stack \\n\");\n        printf(\"3. Insert in Tree \\n\");\n        printf(\"4. Push in stack \\n\");\n        printf(\"5. Delete an element from tree \\n\");\n        printf(\"6. Pop from stack \\n\");\n        printf(\"7. Pre-Order Traversal of Tree \\n\");\n        printf(\"8. Display the stack \\n\");\n        printf(\"9. Display Graphical Tree \\n\");\n        printf(\"10. Exit Program \\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1){\n            root=initialise_tree(root);\n            printf(\"Binary Search Tree Initialised. \\n\");\n        }\n        else if(ch==2){\n            printf(\"Enter size of the working Stack:\\n\");\n            scanf(\"%d\",&x);\n            stk=initialise_stack(x);\n            printf(\"Stack initialised. \\n\");\n        }\n        else if (ch==3){\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            root=insert(root,n);\n            printf(\"%d inserted in Binary Tree\\n\",n);\n        }\n        else if (ch==4){\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            push(stk,n);\n        }\n        else if (ch==5){\n            int d;\n            printf(\"Enter No.to be deleted: \");\n            scanf(\"%d\",&d);\n            if(find(root,d)==1){\n                root=del_Node(root,d);\n                printf(\"%d has been Deleted \\n\",d);\n            }\n            else\n                printf(\"%d not found in tree.\\n\");\n        }\n        else if(ch==6)\n            pop(stk);\n        else if(ch==7){\n            if(root==NULL)\n                printf(\"SORRY, TREE EMPTY\\n\");\n            else{\n                printf(\"\\nPRE-ORDER:\\n\");\n                preorder(root);\n            }\n        }\n        else if(ch==8)\n            display(stk);\n        else if(ch==9)\n            display_tree(root,1);\n        else if(ch==10){\n            printf(\"Exitting, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid Choice.\\n\");\n    }\n    return 0;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_c_extended.9.c", "original_string": "uint32_t ble_lbs_led_status_send(ble_lbs_c_t * p_ble_lbs_c, uint8_t status)\n{\n    VERIFY_PARAM_NOT_NULL(p_ble_lbs_c);\n    if (p_ble_lbs_c->conn_handle == BLE_CONN_HANDLE_INVALID)\n    {\n        return NRF_ERROR_INVALID_STATE;\n    }\n    NRF_LOG_DEBUG(\"writing LED status 0x%x\", status);\n    tx_message_t * p_msg;\n    p_msg              = &m_tx_buffer[m_tx_insert_index++];\n    m_tx_insert_index &= TX_BUFFER_MASK;\n    p_msg->req.write_req.gattc_params.handle   = p_ble_lbs_c->peer_lbs_db.led_handle;\n    p_msg->req.write_req.gattc_params.len      = sizeof(status);\n    p_msg->req.write_req.gattc_params.p_value  = p_msg->req.write_req.gattc_value;\n    p_msg->req.write_req.gattc_params.offset   = 0;\n    p_msg->req.write_req.gattc_params.write_op = BLE_GATT_OP_WRITE_CMD;\n    p_msg->req.write_req.gattc_value[0]        = status;\n    p_msg->conn_handle                         = p_ble_lbs_c->conn_handle;\n    p_msg->type                                = WRITE_REQ;\n    tx_buffer_process();\n    return NRF_SUCCESS;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__insertCharInStack.0.c", "original_string": "void main()\n{\n    int i, j, count = 0, pos, flag = 0;\n    char s1[100], s2[10], s3[100];\n    char *ptr1, *ptr2, *ptr3;\n    printf(\"\\nenter the String:\");\n    scanf(\" %[^\\n]s\", s1);\n    printf(\"\\nenter the string to be inserted:\");\n    scanf(\" %[^\\n]s\", s2);\n    printf(\"\\nenter the position you like to insert:\");\n    scanf(\"%d\", &pos);\n    ptr1 = s1;\n    ptr3 = s3;\n    for (i = 0, j = 0;*ptr1 != '\\0'; ptr1++, i++, j++, ptr3++)\n    {\n        s3[j] = s1[i];\n        if (*ptr1 == ' ' && flag != 1)\n            ++count;\n        if (flag != 1 && count == pos - 1)\n        {\n            flag = 1;\n            for(ptr2 = s2;*ptr2 != '\\0'; ptr2++)\n            {\n                s3[++j] = *ptr2;\n                ptr3++;\n            }\n            s3[++j] = ' ';\n            ptr3++;\n        }\n    }\n    s3[j] = '\\0';\n    printf(\"\\nthe string after modification is\\n\\n %s\\n\", s3);\n}"}
{"author": "davibernardos", "file": "DB-Projetos__e7.0.c", "original_string": "int main(int argc, char *argv[]) \n{\n    int opcao, opcaoDeJogadaHumano, opcaoDeJogadaComputador, opcaoDeJogadaHumano1, opcaoDeJogadaHumano2;\n    int numeroDePartidas = 0, numeroDeVitoriasHumano = 0, numeroDeVitoriasComputador = 0;\n    int numeroDeVitoriasHumano1 = 0, numeroDeVitoriasHumano2 = 0, numeroDeEmpates = 0;\n    while(1)\n    {\n        system(\"cls\");\n        printf(\"Jogo Jokenpo\\n\\n\");\n        printf(\"(1) humano x computador\\n\");\n        printf(\"(2) humano x humano\\n\");\n        printf(\"(3) resultado\\n\");\n        printf(\"(4) sair\\n\\n\");\n        printf(\"Escolha uma das opcoes acima: \");\n        scanf(\"%d\", &opcao);\n        if(opcao == 1)\n        {\n            numeroDePartidas++;\n            printf(\"\\n(1) = pedra\\n\");\n            printf(\"(2) = papel\\n\");\n            printf(\"(3) = tesoura\\n\");\n            printf(\"\\nopcao de jogada humano: \");\n            scanf(\"%d\", &opcaoDeJogadaHumano);\n            opcaoDeJogadaComputador = rand()%3;\n            printf(\"opcao de jogada computador: %d\\n\\n\", opcaoDeJogadaComputador);\n            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 1)\n            {\n                printf(\"empate\\n\");\n                numeroDeEmpates++;\n            }\n            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 2)\n            {\n                printf(\"computador ganha\\n\");\n                numeroDeVitoriasComputador++;\n            }\n            if(opcaoDeJogadaHumano == 1 && opcaoDeJogadaComputador == 3)\n            {\n                printf(\"humano ganha\\n\");\n                numeroDeVitoriasHumano++;\n            }\n            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 2)\n            {\n                printf(\"empate\\n\");\n                numeroDeEmpates++;\n            }\n            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 1)\n            {\n                printf(\"humano ganha\\n\");\n                numeroDeVitoriasHumano++;\n            }\n            if(opcaoDeJogadaHumano == 2 && opcaoDeJogadaComputador == 3)\n            {\n                printf(\"computador ganha\\n\");\n                numeroDeVitoriasComputador++;\n            }\n            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 3)\n            {\n                printf(\"empate\\n\");\n                numeroDeEmpates++;\n            }\n            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 1)\n            {\n                printf(\"computador ganha\\n\");\n                numeroDeVitoriasComputador++;\n            }\n            if(opcaoDeJogadaHumano == 3 && opcaoDeJogadaComputador == 2)\n            {\n                printf(\"humano ganha\\n\");\n                numeroDeVitoriasHumano++;\n            }\n            system(\"pause\");\n        }\n        else\n        {\n            if(opcao == 2)\n            {\n                numeroDePartidas++;\n                printf(\"\\n1 = pedra\\n\");\n                printf(\"2 = papel\\n\");\n                printf(\"3 = tesoura\\n\");\n                printf(\"\\nopcao de jogada humano 1: \");\n                scanf(\"%d\", &opcaoDeJogadaHumano1);\n                printf(\"\\nopcao de jogada humano 2: \");\n                scanf(\"%d\", &opcaoDeJogadaHumano2);\n                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 1)\n                {\n                    printf(\"\\nempate\\n\");\n                    numeroDeEmpates++;\n                }\n                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 2)\n                {\n                    printf(\"\\nhumano 2 ganha\\n\");\n                    numeroDeVitoriasHumano2++;\n                }\n                if(opcaoDeJogadaHumano1 == 1 && opcaoDeJogadaHumano2 == 3)\n                {\n                    printf(\"\\nhumano 1 ganha\\n\");\n                    numeroDeVitoriasHumano1++;\n                }\n                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 2)\n                {\n                    printf(\"\\nempate\\n\");\n                    numeroDeEmpates++;\n                }\n                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 1)\n                {\n                    printf(\"\\nhumano 1 ganha\\n\");\n                    numeroDeVitoriasHumano1++;\n                }\n                if(opcaoDeJogadaHumano1 == 2 && opcaoDeJogadaHumano2 == 3)\n                {\n                    printf(\"\\nhumano 2 ganha\\n\");\n                    numeroDeVitoriasHumano2++;\n                }\n                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 3)\n                {\n                    printf(\"\\nempate\\n\");\n                    numeroDeEmpates++;\n                }\n                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 1)\n                {\n                    printf(\"\\nhumano 2 ganha\\n\");\n                    numeroDeVitoriasHumano2++;\n                }\n                if(opcaoDeJogadaHumano1 == 3 && opcaoDeJogadaHumano2 == 2)\n                {\n                    printf(\"\\nhumano 1 ganha\\n\");\n                    numeroDeVitoriasHumano1++;\n                }\n                system(\"pause\");\n            }\n            else\n            {\n                if(opcao == 3)\n                {\n                    printf(\"\\nNumero de partidas: %d\\n\", numeroDePartidas);\n                    printf(\"Numero de vitorias humano: %d\\n\", numeroDeVitoriasHumano);\n                    printf(\"Numero de vitorias computador: %d\\n\", numeroDeVitoriasComputador);\n                    printf(\"Numero de vitorias humano 1: %d\\n\", numeroDeVitoriasHumano1);\n                    printf(\"Numero de vitorias humano 2: %d\\n\", numeroDeVitoriasHumano2);\n                    printf(\"Numero de empates: %d\\n\\n\", numeroDeEmpates);\n                    system(\"pause\");\n                }\n                else\n                {\n                    if(opcao == 4)\n                    {\n                        exit(0);\n                    }\n                    else\n                    {\n                        printf(\"\\nopcao invalida\\n\\n\");\n                    }\n                    system(\"pause\");\n                }\n            }\n        }\n    }\n    return 0;\n}"}
{"author": "dishanp", "file": "DSA__q34.6.c", "original_string": "int delete_key(struct node *p, int key)\n{\n    int index = 1;\n    struct node *q = NULL;\n    if(first->data == key)\n    {\n        q = first;\n        if(first->next != NULL)\n            first = first->next;\n        else\n            first = NULL;\n        free (q);\n        return index;\n    }\n    else\n    {\n        while(p->data != key)\n        {\n            q = p;\n            p = p->next;\n            index++;\n            if(p->next ==NULL && p->data != key)\n            {\n                printf(\"\\nKey is not present in list\\n\");\n                return -1;\n            }\n        }\n        q->next = p->next;\n        free(p);\n        return index;\n    }\n}"}
{"author": "earth429", "file": "mulpre__accessSign.1.c", "original_string": "int setSign(struct NUMBER *a, int s) {\n    if(s == 1){\n        a->sign = 1;\n    } else if(s == -1){\n        a->sign = -1;\n    } else {\n        return -1;\n    }\n    return 0;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica2-3.0.c", "original_string": "void rellenaVector(int *vector){        \n    srand(time(NULL));   \n    for (int i = 0; i < 10; ++i){ vector[i] = ((rand()%9)+1); }\n}"}
{"author": "augustogunsch", "file": "jackc__parser-expressions.8.c", "original_string": "TERM* parseinnerexpression(PARSER* p) {\n    TERM* t = mkterm(innerexpression);\n    next(p);\n    t->expression = parseexpression(p);\n    checkcontent(p, \")\");\n    return t;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q31.1.c", "original_string": "void push2(stack *s)\n{\n    if(s->tos2 - s->tos1 == 1)\n        printf(\"Array Full\");\n    else\n    {\n        printf(\"Push: \");\n        int ele;\n        scanf(\"%d\", &ele);\n        s->a[--(s->tos2)] = ele;\n    }\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__30_math_sin1.0.c", "original_string": "int main()\n{\n  float i,j,degree,radian,result, sine = 0;\n  int count = 0, k = 1, accurate;\n  printf(\"Enter the degree to find it by sin value by it\");\n  scanf(\"%f\",&degree);\n  radian = (float)degree * (3.1415/180);\n  printf(\"Minimum is 3.Enter the value of the accurate, upto which you want to find the result\");\n  scanf(\"%d\",&accurate);\n  do\n  {\n    if(count % 2 == 0)\n    {\n      sine = (float)sine + (pow(radian,k)/factorial(k));\n    }\n    if(count % 2 == 1)\n    {\n      sine = (float)sine - (pow(radian,k)/factorial(k));\n    }\n    count++;\n    k = k + 2;\n  }\n  while(count <= accurate);\n  printf(\"\\nValue of sine %f\", sine);\n  printf(\"\\nValue of sine %f\", sin(radian));\n}"}
{"author": "ankitraj311", "file": "450_babbar__1_reverse_using_1array_GEEK.1.c", "original_string": "void reverse_array(int arr[], int START, int END)\n{\n  int temp = 0;\n  while(START<END)\n  {\n    temp = arr[END];\n    arr[END] = arr[START];\n    arr[START] = temp;\n    START++;\n    END--;\n  }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__create_single_linked_list.0.c", "original_string": "int main()\n    {\n        int n,data;\n        printf(\"Enter the number of list:\");\n        scanf(\"%d\", &n);\n        createlist(n);\n        printf(\"\\nDisplay\\n\");\n        displaylist();\n        return 0;\n    }"}
{"author": "dle2005", "file": "Algorithm__N_Queens.0.c", "original_string": "bool promising(int i) {\n    bool swtch = true;\n    int k = 1;\n    while(k < i && swtch) {\n        if(col[i] == col[k] || abs(col[i] - col[k]) == abs(i - k))\n            swtch = false;\n        k++;\n    }\n    return swtch;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__15_While.0.c", "original_string": "void Columna(int pibote)\n{\n    int i = 1;\n    while(i <= 34)\n    {\n        if(i >= 28){\n            if(i >= (28 + pibote) && i <= 34 - pibote){\n            printf(\" \");\n        }else{\n            printf(\"A\");\n        }\n        }else{\n            printf(\" \");\n        }\n        ++i;\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__col_key.1.c", "original_string": "void col_key(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(COL);  \n        IODIR1 = IODIR1 | (ROW);  \n        val = (IOPIN1 & COL); \n        val = val >> 17;\n        switch(val)\n        {\n            case 0x0E: \n                lcd_str(\"C1\");\n                delay(500);\n                break;\n            case 0x0D:\n                lcd_str(\"C2\");\n                delay(500);\n                break;\n            case 0x0B:\n                lcd_str(\"C3\");\n                delay(500);\n                break;\n            case 0x07:\n                lcd_str(\"C4\");\n                delay(500);\n                break;\n            default:\n                delay(1000);\n                lcd_cmd(0x01);\n        }\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__9.0.c", "original_string": "int main()\n{\n    system(\"clear\");\n    int n;\n    float saldo = 1000, x, y;\n    printf(\"########################\\n\");\n    printf(\"# 1 - Saque            #\\n\");\n    printf(\"# 2 - Dep\u00f3sito         #\\n\");\n    printf(\"# 3 - Sair do programa #\\n\");\n    printf(\"########################\\n\");\n    printf(\"Saldo: R$%.2f\\n\", saldo);\n    printf(\"Fa\u00e7a sua escolha: \");\n    scanf(\"%i\", &n);\n    system(\"clear\");\n    while (n != 3)\n    {\n        system(\"clear\");\n        switch (n)\n        {\n        case 1:\n            printf(\"SAQUE:\\n\");\n            printf(\"\\nDigite quantos reais deseja sacar: \");\n            scanf(\"%f\", &x);\n            saldo = saldo - x;\n            break;\n        case 2:\n            system(\"clear\");\n            printf(\"DEP\u00d3SITO:\\n\");\n            printf(\"\\nDigite quantos reais deseja depositar: \");\n            scanf(\"%f\", &y);\n            saldo = saldo + y;\n            break;\n        }\n        system(\"clear\");\n        printf(\"########################\\n\");\n        printf(\"# 1 - Saque            #\\n\");\n        printf(\"# 2 - Dep\u00f3sito         #\\n\");\n        printf(\"# 3 - Sair do programa #\\n\");\n        printf(\"########################\\n\");\n        printf(\"Saldo: R$%.2f\\n\", saldo);\n        printf(\"Fa\u00e7a sua escolha: \");\n        scanf(\"%i\", &n);\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "254Odeke", "file": "Operating-Systems_Lab__Multiprogramming_with_Fixed_Number_of_Tasks_Simulation.0.c", "original_string": "int main(){\nint m,p,s,p1;\nint m1[4],i,f,f1=0,f2=0,fra1,fra2,s1,pos; \nprintf(\"\\nEnter the memory size:\"); scanf(\"%d\",&m);\nprintf(\"\\nEnter the no of partitions:\"); scanf(\"%d\",&p);\ns=m/p;\nprintf(\"\\nEach partn size is:%d\",s); printf(\"\\nEnter the no of processes:\"); scanf(\"%d\",&p1);\npos=m;\nfor(i=0;i<p1;i++)\n{\nif(pos<s)\n{\nprintf(\"\\nThere is no further memory for process%d\",i+1); m1[i]=0;\nbreak;\n}\nelse\n{\nprintf(\"\\nEnter the memory req for process%d:\",i+1); scanf(\"%d\",&m1[i]);\nif(m1[i]<=s)\n{\nprintf(\"\\nProcess is allocated in partition%d\",i+1); fra1=s-m1[i];\nprintf(\"\\nInternal fragmentation for process is:%d\",fra1); f1=f1+fra1;\npos=pos-s;\n}\nelse\n{\nprintf(\"\\nProcess not allocated in partition%d\",i+1); s1=m1[i];\nwhile(s1>s)\n{\ns1=s1-s;pos=pos-s;\n}\npos=pos-s;fra2=s-s1;f2=f2+fra2;\nprintf(\"\\nExternal Fragmentation for this process is:%d\",fra2);\n}\n}\n}\n20;\nprintf(\"\\nProcess\\tAllocated Memory\");\nfor(i=0;i<p1;i++)\nprintf(\"\\n%5d\\t%5d\",i+1,m1[i]);\nf=f1+f2;\nprintf(\"\\nThe tot no of fragmentation is:%d\",f); getch();\nreturn 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q31.2.c", "original_string": "void pop1(stack *s)\n{\n    if (s->tos1 == -1)\n        printf(\"Underflow! \\n\");\n    else\n        printf(\"%d popped\\n\", s->a[(s->tos1)--]);\n}"}
{"author": "kalpa96", "file": "c-programing__nested-if.0.c", "original_string": "int main()\n{\n    int n;\n    printf(\"Enter the print World number: \");\n    scanf(\"%d\",&n);\n    if(n==1)\n    {\n        printf(\"ONE\");\n    }\n    else if(n==2)\n    {\n        printf(\"TWO\");\n    }\n    else if(n==3)\n    {\n        printf(\"THREE\");\n    }\n    else if(n==4)\n    {\n        printf(\"FOUR\");\n    }\n    else if(n==5)\n    {\n        printf(\"FIVE\");\n    }\n    else if(n==6)\n    {\n        printf(\"SIX\");\n    }\n    else if(n==7)\n    {\n        printf(\"SEVEN\");\n    }\n    else if(n==8)\n    {\n        printf(\"EIGHT\");\n    }\n    else if(n==9)\n    {\n        printf(\"NINE\");\n    }\n    else \n    {\n        printf(\"OTHERS\");\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_DLL.7.c", "original_string": "void delete_beg()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    else if(head->next==0)\n    {\n        head=0;\n        free(head);\n    }\n    else\n    {\n        temp=head;\n        head->next->pre=0;\n        head=head->next;\n        free(temp);\n    }\n}"}
{"author": "Oryx-Embedded", "file": "Common__path.4.c", "original_string": "void pathCopy(char_t *dest, const char_t *src, size_t maxLen)\n{\n   size_t n;\n   n = osStrlen(src);\n   n = MIN(n, maxLen);\n   osStrncpy(dest, src, n);\n   dest[n] = '\\0';\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__forca053ALPHA.0.c", "original_string": "int main()\n{\n    char palavra[50], tema[50], palavra_rev[50], tentativa_acerto_palavra[50], letra, voltar;\n    int menu, jogo, tam_palavra, partida, letra_certa, letra_usada;\n    jogo = 2;\n    while ((jogo != true) && (jogo != false))\n    {\n        system(\"clear\");\n        printf(\"\\tBem vindo ao jogo da forca!\\n\\n\");\n        printf(\"\\t(1) JOGAR\\n\");\n        printf(\"\\t(2) SAIR DO JOGO\\n\\t \");\n        scanf(\"%d\", &menu);\n        switch (menu)\n        {\n        case 1:\n            jogo = true;\n            break;\n        case 2:\n            jogo = false;\n        default:\n            break;\n        }\n    }\n    while (jogo == true)\n    {\n        char letras_erradas[12 + 1] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '\\0'}; \n        int erros = 0, i_lerradas = 0, vitoria = 0, palavra_certa = true;\n        system(\"clear\");\n        setbuf(stdin, NULL); \n        printf(\"\\tInforme a palavra ou frase desejada:\\n\\t\");\n        scanf(\"%50[^\\n]s\", palavra);\n        setbuf(stdin, NULL); \n        printf(\"\\n\\tInforme o tema da palavra ou frase:\\n\\t\");\n        scanf(\"%50[^\\n]s\", tema);\n        tam_palavra = strlen(palavra);\n        palavra[tam_palavra] = '\\0';\n        for (int i = 0; palavra[i] != '\\0'; i++)\n        {\n            if (palavra[i] != ' ')\n            {\n                palavra_rev[i] = '-';\n            }\n            else\n            {\n                palavra_rev[i] = ' ';\n                vitoria++;\n            }\n        }\n        palavra_rev[tam_palavra] = '\\0';\n        partida = true;\n        while (partida == true)\n        {\n            system(\"clear\");\n            printf(\"\\tLetras erradas: %s\\n\\n\", letras_erradas);\n            printf(\"\\tTema: %s\\n\\n\", tema);\n            switch (erros)\n            {\n            case 0:\n                printf(\"\\t ------------------\\n\");\n                printf(\"\\t/|\\\\               |\\n\");\n                printf(\"\\t |                | \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |                                   %s  \\n\", palavra_rev);\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t/ \\\\ \\n\\n\\n\");\n                break;\n            case 1:\n                printf(\"\\t ------------------\\n\");\n                printf(\"\\t/|\\\\               |\\n\");\n                printf(\"\\t |                | \\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |              O  O\\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |                                   %s  \\n\", palavra_rev);\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |               \\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t/ \\\\ \\n\\n\\n\");\n                break;\n            case 2:\n                printf(\"\\t ------------------\\n\");\n                printf(\"\\t/|\\\\               |\\n\");\n                printf(\"\\t |                | \\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |              O  O\\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |                |                  %s  \\n\", palavra_rev);\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |                \\n\");\n                printf(\"\\t |                \\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t/ \\\\ \\n\\n\\n\");\n                break;\n            case 3:\n                printf(\"\\t ------------------\\n\");\n                printf(\"\\t/|\\\\               |\\n\");\n                printf(\"\\t |                | \\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |              O  O\\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |               /|                  %s  \\n\", palavra_rev);\n                printf(\"\\t |              / |\\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |                \\n\");\n                printf(\"\\t |                \\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t/ \\\\ \\n\\n\\n\");\n                break;\n            case 4:\n                printf(\"\\t ------------------\\n\");\n                printf(\"\\t/|\\\\               |\\n\");\n                printf(\"\\t |                | \\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |              O  O\\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |               /|\\\\                 %s  \\n\", palavra_rev);\n                printf(\"\\t |              / | \\\\ \\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |                \\n\");\n                printf(\"\\t |                \\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t/ \\\\ \\n\\n\\n\");\n                break;\n            case 5:\n                printf(\"\\t ------------------\\n\");\n                printf(\"\\t/|\\\\               |\\n\");\n                printf(\"\\t |                | \\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |              O  O\\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |               /|\\\\                 %s  \\n\", palavra_rev);\n                printf(\"\\t |              / | \\\\ \\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |               /\\n\");\n                printf(\"\\t |              / \\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t/ \\\\ \\n\\n\\n\");\n                break;\n            default:\n                break;\n            }\n            setbuf(stdin, NULL); \n            printf(\"\\t(1) Acertar a palavra/frase (se errar \u00e9 fim de jogo)\\n\");\n            printf(\"\\t(2) Escolher uma letra\\n\\t\");\n            scanf(\"%d\", &menu);\n            switch (menu)\n            {\n            case 1:\n                setbuf(stdin, NULL); \n                printf(\"\\n\\tInforme a palavra/frase:\\n\\t\");\n                scanf(\"%50[^\\n]s\", tentativa_acerto_palavra);\n                palavra_certa = true;\n                for (int i = 0; tentativa_acerto_palavra[i] != '\\0'; i++)\n                {\n                    if (tolower(tentativa_acerto_palavra[i]) != tolower(palavra[i]))\n                    {\n                        palavra_certa = false;\n                        erros = 6;\n                    }\n                }\n                if (palavra_certa == true)\n                {\n                    vitoria = tam_palavra;\n                }\n                break;\n            case 2:\n                setbuf(stdin, NULL); \n                printf(\"\\n\\tEscolha uma letra: \\n\\t\");\n                letra = getchar();\n                letra_usada = false;\n                for (int i = 0; i < tam_palavra; i++)\n                {\n                    if (tolower(letra) == tolower(palavra_rev[i]))\n                    {\n                        letra_usada = true;\n                    }\n                }\n                for (int i = 0; i < 12; i++)\n                {\n                    if (tolower(letra) == tolower(letras_erradas[i]))\n                    {\n                        letra_usada = true;\n                    }\n                }\n                if (letra_usada == true)\n                {\n                    printf(\"Letra ja usada...\");\n                }\n                else\n                {\n                    letra_certa = false;\n                    for (int i = 0; palavra[i] != '\\0'; i++)\n                    {\n                        if (tolower(letra) == tolower(palavra[i]))\n                        {\n                            palavra_rev[i] = palavra[i];\n                            letra_certa = true;\n                            vitoria++;\n                        }\n                    }\n                    if (letra_certa == false)\n                    {\n                        letras_erradas[i_lerradas] = letra;\n                        letras_erradas[i_lerradas + 1] = ' ';\n                        i_lerradas += 2;\n                        erros++;\n                    }\n                }\n            default:\n                break;\n            }\n            if (vitoria == tam_palavra)\n            {\n                system(\"clear\");\n                printf(\"\\tLetras erradas: %s\\n\\n\", letras_erradas);\n                printf(\"\\tTema: %s\\n\\n\", tema);\n                printf(\"\\t ------------------          PARAB\u00c9NS VOC\u00ca ADVINHOU A PALAVRA OU FRASE\\n\");\n                printf(\"\\t/|\\\\                \\n\");\n                printf(\"\\t |                  \\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |              O**O\\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |              \\\\ | /\\n\");\n                printf(\"\\t |               \\\\|/                 %s\\n\", palavra);\n                printf(\"\\t |                | \\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |               / \\\\\\n\");\n                printf(\"\\t |              /   \\\\\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t/ \\\\ \\n\\n\\n\");\n                printf(\"Aperte qualque tecla para voltar: \");\n                scanf(\"%c\", &voltar);\n                getchar();\n                partida = false;\n            }\n            else if (erros == 6)\n            {\n                system(\"clear\");\n                printf(\"\\tLetras erradas: %s\\n\\n\", letras_erradas);\n                printf(\"\\tTema: %s\\n\\n\", tema);\n                printf(\"\\t ------------------        QUE PENA, VOC\u00ca N\u00c3O ADVINHOU A PALAVRA OU FRASE\\n\");\n                printf(\"\\t/|\\\\               |\\n\");\n                printf(\"\\t |                | \\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |              OxxO\\n\");\n                printf(\"\\t |               OO\\n\");\n                printf(\"\\t |                |  \\n\");\n                printf(\"\\t |               /|\\\\                %s\\n\", palavra);\n                printf(\"\\t |              / | \\\\\\n\");\n                printf(\"\\t |                |\\n\");\n                printf(\"\\t |               / \\\\\\n\");\n                printf(\"\\t |              /   \\\\\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t |\\n\");\n                printf(\"\\t/ \\\\ \\n\\n\\n\");\n                printf(\"Aperte qualque tecla para voltar: \");\n                scanf(\"%c\", &voltar);\n                getchar();\n                partida = false;\n            }\n        }\n        jogo = 2;\n        while ((jogo != true) && (jogo != false))\n        {\n            system(\"clear\");\n            printf(\"\\tBem vindo ao jogo da forca!\\n\\n\");\n            printf(\"\\t(1) JOGAR\\n\");\n            printf(\"\\t(2) SAIR DO JOGO\\n\\t \");\n            scanf(\"%d\", &menu);\n            switch (menu)\n            {\n            case 1:\n                jogo = true;\n                break;\n            case 2:\n                jogo = false;\n            default:\n                break;\n            }\n        }\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_CLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the list is %d\\n\",c);\n}"}
{"author": "rgautam320", "file": "Data-Structure__main21.4.c", "original_string": "int evaluation()\n{\n    int x, y, temp, value, i;\n    for(i = 0; i<strlen(postfix_expression); i++)\n    {\n        if(postfix_expression[i] <= '9' && postfix_expression[i]>= '0')\n        {\n            push(postfix_expression[i]-'0');\n        }\n        else\n        {\n            x = pop();\n            y = pop();\n            switch(postfix_expression[i])\n            {\n            case '+':\n                temp = y+x;\n                break;\n            case '-':\n                temp = y-x;\n                break;\n            case '*':\n                temp = y*x;\n                break;\n            case '/':\n                temp = y/x;\n                break;\n            case '%':\n                temp = y%x;\n                break;\n            case '^':\n                temp = pow(y,x);\n                break;\n            default:\n                printf(\"Invalid\\n\");\n            }\n            push(temp);\n        }\n    }\n    value = pop();\n    return value;\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_print_combn.1.c", "original_string": "void ft_print_combn(int n)\n{\n    int numeros[10]={ 0, 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9}; \n    int a =0, b =1, c =2,d =3, e =4, f =5, g =6, h =7, i =8;    \n    if(n==1)\n      comb1(numeros,a);\n      else{\n           if(n==2)\n              comb2(numeros,a,b);\n              else{\n                   if(n==3)\n                     comb3(numeros,a,b,c);                      \n                     else{\n                          if(n==4)\n                            comb4(numeros,a,b,c,d);\n                            else{\n                                 if(n==5)\n                                   comb5(numeros,a,b,c,d,e);\n                                   else{\n                                        if(n==6)\n                                          comb6(numeros,a,b,c,d,e,f);\n                                          else{\n                                               if(n==7)\n                                                  comb7(numeros,a,b,c,d,e,f,g);\n                                                  else{\n                                                       if(n==8)\n                                                          comb8(numeros,a,b,c,d,e,f,g,h);\n                                                          else{\n                                                               if(n==9)\n                                                                  comb9(numeros,a,b,c,d,e,f,g,h,i);\n                                                                  else{\n                                                                       printf(\"Valor no procesable\");\n                                                                      }\n                                                              }\n                                                      }\n                                              }\n                                       }\n                                }\n                         }\n                  }\n          }  \n}"}
{"author": "2security", "file": "Matrix__39CheckSparseMatrix.2.c", "original_string": "int main()\n    {\n    int i,j,r,c,mat[20][20];\n    printf(\"Enter the row & col. of the matrix \");\n    scanf(\"%d%d\",&r,&c);    \n    printf(\"\\n Enter the matrix \\n\");\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)\n    scanf(\"%d\",&mat[i][j]);\n    printf(\"The matrix is:\\n\");\n    displayMat(mat,r,c);\n    if(CheckSparse(mat,r,c)==1)\n        printf(\"The matrix is sparse matrix\\n\");\n    else\n        printf(\"The matrix is not sparse matrix\\n\");\n    return 0;\n    }"}
{"author": "augustogunsch", "file": "jackc__vm-translator.10.c", "original_string": "char* mkspeciallab(VMTRANSLATOR* t, char* suffix, int* ind, int* len) {\n    (*ind)++;\n    *len = t->classnamelen + countplaces(*ind) + strlen(suffix) + 2;\n    int sz = ((*len)+1) * sizeof(char);\n    char* lab = (char*)malloc(sz);\n    sprintf(lab, \"%s$%s.%i\", t->classname, suffix, (*ind));\n    togarbage(t, lab);\n    return lab;\n}"}
{"author": "jose120918", "file": "sorting_algorithms__101-cocktail_sort_list.0.c", "original_string": "int swp_fwd(listint_t *current, listint_t **list)\n{\n    listint_t *moving = NULL;\n    moving = current->next;\n    moving->prev = current->prev;\n    if (current->prev)\n        current->prev->next = moving;\n    else\n        *list = current->next;\n    current->next = moving->next;\n    current->prev = moving;\n    moving->next = current;\n    if (current->next)\n        current->next->prev = current;\n    print_list(*list);\n    return (1);\n}"}
{"author": "dishanp", "file": "DSA__q34.7.c", "original_string": "int search(struct node *p, int key)\n{\n    int index = 1;\n    while(p)\n    {\n        if(key == p->data)\n        {\n            return index;\n        }\n        else\n        {\n            p = p->next;\n            index++;\n        }\n    }\n    return 0;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__peekInStack.1.c", "original_string": "int isFull(struct stack*ptr){\n    if(ptr->top == ptr->size-1){\n        printf(\"Stack is Full(overflow)..\\n\");\n        return 1;\n    }\n    else{\n        return 0;\n    }\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es8.2.c", "original_string": "int main() {\n  Triangolo x1;\n  Triangolo x2;\n  printf(\"Inserire angolo alfa: \");\n  scanf(\"%f\", &x1.alfa);\n  printf(\"Inserire angolo beta: \");\n  scanf(\"%f\", &x1.beta);\n  printf(\"Inserire angolo gamma: \");\n  scanf(\"%f\", &x1.gamma);\n  printf(\"Inserire lato AB: \");\n  scanf(\"%d\", &x1.ab);\n  printf(\"Inserire lato BC: \");\n  scanf(\"%d\", &x1.bc);\n  printf(\"Inserire lato AC: \");\n  scanf(\"%d\", &x1.ac);\n  printf(\"Inserire angolo alfa: \");\n  scanf(\"%f\", &x2.alfa);\n  printf(\"Inserire angolo beta: \");\n  scanf(\"%f\", &x2.beta);\n  printf(\"Inserire angolo gamma: \");\n  scanf(\"%f\", &x2.gamma);\n  printf(\"Inserire lato AB: \");\n  scanf(\"%d\", &x2.ab);\n  printf(\"Inserire lato BC: \");\n  scanf(\"%d\", &x2.bc);\n  printf(\"Inserire lato AC: \");\n  scanf(\"%d\", &x2.ac);\n    float primo = calcolo_perimetro(&x1);\n    float secondo = calcolo_perimetro(&x2);\n    printf(\"primo: %f\\nsecondo: %f\", primo, secondo);\n    similitudine(x1, &x2);\n  return(0);\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__SelectionSort.1.c", "original_string": "void getdata(int x[50],int n)\n       {\n        int k;\n        printf(\"enter the value  for sorting\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        } }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_07.7.c", "original_string": "int main(int argc,char *argv[])\n  {     char ch;\n        int n,x,p;\n        int *arr;\n        F1=fopen(argv[1],\"r\");\n        F2=fopen(argv[2],\"w\");\n        if(F1==NULL)\n         printf(\"cant open file\");\n        else\n          {\n          while(1)\n           {\n             fscanf(F1,\"%c\",&ch);\n             if(ch=='r')\n             {\n               fscanf(F1,\" %d\",&n);\n               arr= (int*) malloc(n* sizeof(int));\n               read(arr,n);\n             }\n            else if(ch=='d')\n             {\n               fscanf(F1,\"%d\",&p);\n               display(arr,n);\n             }\n             else if(ch=='s')\n             {\n              bucketSort(arr,n);\n             }\n             else if(ch=='t')\n               break;\n           }\n         }\n   fclose(F1);\n   fclose(F2);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q1_doublylq.5.c", "original_string": "void disp(nptr front)\n{\n    printf(\"NULL <--->\");\n    for(nptr i=front;i;i=i->rlink)\n        printf(\" %d <---> \",i->ele);\n    printf(\"NULL \\n\");\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server.5.c", "original_string": "error_t scpServerSetHomeDir(ScpServerSession *session, const char_t *homeDir)\n{\n   ScpServerContext *context;\n   if(session == NULL || homeDir == NULL)\n      return ERROR_INVALID_PARAMETER;\n   context = session->context;\n   pathCopy(session->homeDir, context->rootDir, SCP_SERVER_MAX_HOME_DIR_LEN);\n   pathCombine(session->homeDir, homeDir, SCP_SERVER_MAX_HOME_DIR_LEN);\n   pathCanonicalize(session->homeDir);\n   pathRemoveSlash(session->homeDir);\n   return NO_ERROR;\n}"}
{"author": "earth429", "file": "mulpre__divBy10.1.c", "original_string": "void clearByZero(struct NUMBER *a){\n    int i;\n    for (i = 0; i < KETA;i++){\n        a->n[i] = 0;\n    }\n    a->sign = 1;\n}"}
{"author": "2security", "file": "Matrix__37DeterminantOfMatrix.1.c", "original_string": "void displayMat(float **mat,int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%f \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }"}
{"author": "behergue", "file": "Operating_Systems__mytar_routines.1.c", "original_string": "char* loadstr(FILE * file){\n    int counter = 0;\n    while(getc(file) != '\\0')\n        counter++;\n    fseek(file, -(counter + 1), SEEK_CUR);\n    char* c = (char*) malloc(counter * sizeof(char));\n    fread(c, sizeof(char), counter + 1, file);\n    return c;\n}"}
{"author": "2security", "file": "If-else__AmountToNoofNotes.0.c", "original_string": "int main()\n    {\n    int amount,tt=0,ot=0,fh=0,h=0,f=0,tw=0,te=0,five=0,to=0,one=0;\n    printf(\"Enter amount\");\n    scanf(\"%d\",&amount);\n    if(amount>=2000)\n        {\n        tt=amount/2000;\n        amount=amount-2000*tt;\n        }\n    if(amount>=1000)\n        {\n        ot=amount/1000;\n        amount=amount-1000*ot;\n        }\n    if(amount>=500)\n        {\n        fh=amount/500;\n        amount=amount-500*fh;\n        }\n    if(amount>=100)\n        {\n        h=amount/100;\n        amount=amount-100*h;\n        }\n    if(amount>=50)\n        {\n        f=amount/50;\n        amount=amount-50*f;\n        }\n    if(amount>=20)\n        {\n        tw=amount/20;\n        amount=amount-20*tw;\n        }\n    if(amount>=10)\n        {\n        te=amount/10;\n        amount=amount-10*te;\n        }\n    if(amount>=5)\n        {\n        five=amount/5;\n        amount=amount-5*five;\n        }\n    if(amount>=2)\n        {\n        to=amount/2;\n        amount=amount-10*to;\n        }\n    else\n        {\n        one=amount;\n        }\n    printf(\"\\n Total number of notes\");\n    printf(\"\\n2000: %d\",tt);\n    printf(\"\\n1000: %d\",ot);\n    printf(\"\\n500: %d\",fh);\n    printf(\"\\n100: %d\",h);\n    printf(\"\\n50: %d\",f);\n    printf(\"\\n20: %d\",tw);\n    printf(\"\\n10: %d\",te);\n    printf(\"\\n5: %d\",five);\n    printf(\"\\n2: %d\",to);\n    printf(\"\\n1: %d\\n\",one);\n    return 0;\n    }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__nonVIC.1.c", "original_string": "void timer_config(void)\n{\n        T0PR = 14;\n        T0MR0 = 3000000;\n        T0MCR = (1<<0)|(1<<1);\n        T1PR = 14;\n        T1MR0 = 3500000;\n        T1MCR = (1<<0)|(1<<1);\n        T1TCR = (1<<0);\n        T0TCR = (1<<0);\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise3.0.c", "original_string": "void BubbleSort(int arr[], const int array_size){\n        int i, j;\n        int temp;\n        for(i=1 ; i<= array_size ; i++){\n            for(j=0 ; j<= (array_size - 1) ; j++){\n                if(arr[j]>arr[j+1]){\n                    temp = arr[j+1];\n                    arr[j+1] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__last_occurence.1.c", "original_string": "int main()\n{\n    char arr[30];\n    char cValue = '\\0';\n    int iRet = 0;\n    printf(\"Please enter the string\\n\");\n    scanf(\"%[^'\\n']s\",arr);\n    printf(\"Please enter the character\\n\");\n    scanf(\" %c\",&cValue);\n    iRet = SearchLastOcc(arr,cValue);\n    if(iRet == -1)\n    {\n        printf(\"There is no such character\\n\");\n    }\n    else\n    {\n        printf(\"Last occurance of character at : %d\\n\",iRet);\n    }\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__queue_using_array.4.c", "original_string": "int main()\n{\n    printf(\"the queue using array\\n\");\n    enqueue(4);\n    enqueue(10);\n    enqueue(41);\n    display();\n    dequeue();\n    peek();\n    enqueue(25);\n    dequeue();\n    peek();\n    display();\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_bdm.1.c", "original_string": "void rstpBdmFsm(RstpBridgePort *port)\n{\n   switch(port->bdmState)\n   {\n   case RSTP_BDM_STATE_EDGE:\n      if((!port->portEnabled && !rstpAdminEdge(port)) || !port->operEdge)\n      {\n         rstpBdmChangeState(port, RSTP_BDM_STATE_NOT_EDGE);\n      }\n      break;\n   case RSTP_BDM_STATE_NOT_EDGE:\n      if((!port->portEnabled && rstpAdminEdge(port)) ||\n         (port->edgeDelayWhile == 0 && rstpAutoEdge(port) &&\n         port->sendRstp && port->proposing))\n      {\n         rstpBdmChangeState(port, RSTP_BDM_STATE_EDGE);\n      }\n      break;\n   default:\n      rstpFsmError(port->context);\n      break;\n   }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__teste0.0.c", "original_string": "int main()\n{\n    int n, primos[10000], aux = 3, k = 0, primo;\n    primos[0] = 2;\n    scanf(\"%i\", &n);\n    for (int i=0; i< n; i++)\n    {\n        primo = true;\n        for (int j=k; j>=0; j--)\n        {\n            if ((aux % primos[j]) == 0)\n            {\n                primo = false;\n            }\n        }\n        if (primo == false)\n        {\n            aux+=2;\n        }\n        if (primo == true)\n        {\n            primos[k+1] = aux;\n            k++;\n        }\n    }\n    for (int i=0; i<=k; i++)\n    {\n        printf(\"%i \", primos[i]);\n    }\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__list-ins-seq-sor_acend_decend.4.c", "original_string": "void print(node** head)\n{\n    if(*head==NULL)\n        printf(\"STACK EMPTY\\n\");\n    else\n    {\n        node* h=*head;\n        printf(\"      STACK      \\n\");\n        while(h!=NULL)\n        {\n            printf(\"\\t%d\\n\",h->data);\n            h=h->next;\n        }\n    }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e80.0.c", "original_string": "char * gerarCaptcha(char valor[CAPTCHA]) {\n    int cont;\n    int randomico;\n    srand(time(NULL));\n    for(cont = 0; cont < CAPTCHA; cont++){\n        randomico = ((rand() % 122) + 1);\n        if ((randomico >= 48 && randomico <= 57) || (randomico >= 65 && randomico <= 90) || (randomico >= 97 && randomico <= 122)) {\n            valor[cont] = randomico;\n        }else{\n            cont--;\n        }\n    }\n    return valor;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-102A-025011-Structured-Programming__juego.0.c", "original_string": "int main(void){\n    srand(time(0));\n    int opcion;\n    while(1){\n        menu();\n        scanf(\"%d\", &opcion);\n        if(opcion == 1){\n            jugar();\n        } else \n            break;\n    }\n    return 0;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Orthogonal_Matrix_Or_Not.2.c", "original_string": "int check_Identity_Matrix(int matrix[R][C])\n{\n    int i, j, flag, output = 0;\n    int rows = R;\n    int columns = C;\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {\n            if((i==j) && (matrix[i][j]==1))\n                continue;\n            else if((i!=j) && (matrix[i][j]==0))\n                continue;\n            else\n            {\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 1)\n        {\n            output = 1;\n            break;\n        }\n    }\n    return output;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__ex01.2.c", "original_string": "void mouse(int botao, int estado, int x, int y)\n{\n    float mx = x;\n    float my = y;\n    float ox = (mx / 200 - 1.0);\n    float oy = -(my / 200 - 1.0);\n    switch (botao)\n    {\n    case GLUT_LEFT_BUTTON:\n        if (estado == GLUT_DOWN){\n            printf(\"x = %f, y = %f\\n\", ox, oy);\n            up = ox;\n            right = oy;\n            point();\n        }\n        break;\n    default:\n        break;\n    }\n    glutPostRedisplay();\n}"}
{"author": "jdes01", "file": "practicassoo__practica2ej1.0.c", "original_string": "void * generarNumeros(){\n    int * z = malloc(sizeof(int)); \n    int x = rand() % 10;\n    printf(\"x = %i \\n\", x);\n    int y = rand() % 10;\n    printf(\"y = %i \\n\", y);\n    *z = x + y;\n    printf(\"x + y = %i \\n\", *z);\n    pthread_exit(z);\n}"}
{"author": "RafaelFelisbino-hub", "file": "VETOR-exercices__Exercicio16VETOR.0.c", "original_string": "int main() \n{\n    int temperaturasOutubro[31], i,somaTemperatura = 0, diaInferior = 0;\n    float media;\n    for (i = 0; i < 31; i++) \n    {\n        printf(\"Digite as temperaturas:  \");\n        scanf_s(\"%i\", &temperaturasOutubro[i]);\n        somaTemperatura += temperaturasOutubro[i];\n    }\n    media = somaTemperatura / i;\n    printf(\"A temperatura media e:  %.2f\\n\", media);\n    for (i = 0; i < 31; i++)\n    {\n        if (temperaturasOutubro[i] < media)\n        {\n            diaInferior++;\n        }\n    }\n    for (i = 0; i < 31; i++)\n    {\n        if (temperaturasOutubro[i] > media)\n        {\n            printf(\"Temperatura maior que a media no dia %i = %i Graus Celsius\\n\\n\",i, temperaturasOutubro[i]);\n        }\n    }\n    printf(\"Quantidade de dias com a temperatura inferior a media:  %i\\n\", diaInferior);\n    system(\"pause\");\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__timer_4MR.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | (0xFF<<17);       \n    T0PR = 14;                                          \n    T0MR0 = 1000000;                                \n    T0MR1 = 2000000;                                \n    T0MR2 = 3000000;                                \n    T0MR3   = 4000000;                              \n    T0MCR   = (1<<0)|(1<<3)|(1<<6)|(1<<9)|(1<<10);      \n    T0TCR   = (1<<0);                                   \n    while(1)\n    {\n        if(T0IR & (1<<0))                           \n        {\n            IOSET1 = (1<<17);\n            T0IR = 1<<0;                                \n        }\n        if(T0IR & (1<<1))                           \n        {\n            IOCLR1 = (1<<17);\n            T0IR = 1<<1;                                \n        }\n        if(T0IR & (1<<2))                           \n        {\n            IOSET1 = (1<<24);\n            T0IR = 1<<2;                                \n        }\n        if(T0IR & (1<<3))                           \n        {\n            IOCLR1 = (1<<24);\n            T0IR = 1<<3;                                \n        }\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSL__tls_ticket.0.c", "original_string": "error_t tlsInitTicketContext(TlsTicketContext *ticketContext)\n{\n   if(ticketContext == NULL)\n      return ERROR_INVALID_PARAMETER;\n   osMemset(ticketContext, 0, sizeof(TlsTicketContext));\n   if(!osCreateMutex(&ticketContext->mutex))\n   {\n      return ERROR_OUT_OF_RESOURCES;\n   }\n   return NO_ERROR;\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_eight_queens_puzzle_2.1.c", "original_string": "void ft_eight_queens_puzzle_2(void){\n    int Tabla[8][8] = {{0,0,0,0,0,0,0,0},     \n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0},\n                       {0,0,0,0,0,0,0,0}}; \n    for(int Col_0 = 0; Col_0 < 8; Col_0++){  \n        Tabla[Col_0][0] = 1; \n        for(int Col_1 = 0; Col_1 < 8; Col_1++){ \n            if(Mov_Queen(Tabla, Col_1, 1) == 0){\n               Tabla[Col_1][1] = 1; \n               for (int Col_2 = 0; Col_2 < 8; Col_2++){ \n                   if(Mov_Queen(Tabla, Col_2, 2) == 0){\n                        Tabla[Col_2][2] = 1; \n                        for (int Col_3 = 0; Col_3 < 8; Col_3++){ \n                            if(Mov_Queen(Tabla, Col_3, 3) == 0){\n                                Tabla[Col_3][3] = 1; \n                                for (int Col_4 = 0; Col_4 < 8; Col_4++){  \n                                    if(Mov_Queen(Tabla, Col_4, 4) == 0){\n                                        Tabla[Col_4][4] = 1; \n                                        for (int Col_5 = 0; Col_5 < 8; Col_5++){ \n                                            if(Mov_Queen(Tabla, Col_5, 5) == 0){\n                                                Tabla[Col_5][5] = 1; \n                                                for (int Col_6 = 0; Col_6 < 8; Col_6++){ \n                                                    if(Mov_Queen(Tabla, Col_6, 6) == 0){\n                                                        Tabla[Col_6][6] = 1; \n                                                        for (int Col_7 = 0; Col_7 < 8; Col_7++) \n                                                        {\n                                                            if(Mov_Queen(Tabla, Col_7, 7) == 0){\n                                                                Tabla[Col_7][7] = 1; \n                                                                printf(\"\\n%i%i%i%i%i%i%i%i\", Col_0+1, Col_1+1, Col_2+1, Col_3+1, Col_4+1, Col_5+1, Col_6+1, Col_7+1);\n                                                            }\n                                                            Tabla[Col_7][7] = 0;  \n                                                        }\n                                                    }\n                                                    Tabla[Col_6][6] = 0;\n                                                }\n                                            }\n                                            Tabla[Col_5][5] = 0;\n                                        }  \n                                    } \n                                    Tabla[Col_4][4] = 0;\n                                }\n                            }\n                            Tabla[Col_3][3] = 0;\n                        }\n                    }\n                    Tabla[Col_2][2] = 0; \n                }\n            }\n            Tabla[Col_1][1] = 0;\n        }\n        Tabla[Col_0][0] = 0;\n    }\n    printf(\"\\n\");\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__check_mate.6.c", "original_string": "int     main(int ac, char **av)\n{\n    if (ac < 2)\n        return (write(1, \"\\n\", 1));\n    if (is_checkmate(av + 1, ac - 1))\n        return (write(1, \"Success\\n\", 8));\n    else\n        return (write(1, \"Fail\\n\", 5));\n}"}
{"author": "augustogunsch", "file": "jack-compiler__util.5.c", "original_string": "char* dotlabel(char* n1, char* n2) {\n    int sz = (strlen(n1) + strlen(n2) + 2) * sizeof(char);\n    char* result = (char*)malloc(sz);\n    sprintf(result, \"%s.%s\", n1, n2);\n    return result;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__i2c_MasterRxMode.2.c", "original_string": "void i2c_Start(void)\n{\n    I2CONCLR = (1<<3);      \n    I2CONSET = (1<<5);          \n    while(!(I2CONSET &(1<<3)));\n    I2CONCLR = (1<<5);          \n    I2CONCLR = (1<<3);          \n}"}
{"author": "ashlyn2002", "file": "programming-using-c__count_the_elem_in_LL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n       if(head==0)\n       {\n            head=temp=newnode;\n       }\n       else\n       {\n            temp->next=newnode;\n            temp=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n           scanf(\"%d\",& choice);\n    }\n}"}
{"author": "254Odeke", "file": "Operating-Systems_Lab__Cyclic_Graph_Detection_Simulation.1.c", "original_string": "bool isCyclic(int cur){\n    if(visited[cur]==1){\n        return true;\n    }\n    visited[cur]=1;\n    bool flag=false;\n    for(i=0;i<n;i++){\n        if(matrix[cur][i]==0) continue;\n        flag=isCyclic(i);\n        if(flag==true)\n            return true;\n    }\n    visited[cur]=0;\n    return false;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__4.1.c", "original_string": "void le_retangulos(rect_t *retangulo_1, rect_t *retangulo_2)\n{\n    printf(\"\\nDigite as coordenadas do 1\u00ba ret\u00e2ngulo:\\n\");\n    printf(\"\\n\\tPonto superior esquerdo:\\n\");\n    printf(\"\\t-> Coordenada x: \");\n    scanf(\"%lf\", &retangulo_1->sup_esq.x);\n    getchar();\n    printf(\"\\t-> Coordenada y: \");\n    scanf(\"%lf\", &retangulo_1->sup_esq.y);\n    getchar();\n    printf(\"\\n\\tPonto inferior direito:\\n\");\n    printf(\"\\t-> Coordenada x: \");\n    scanf(\"%lf\", &retangulo_1->inf_dir.x);\n    getchar();\n    printf(\"\\t-> Coordenada y: \");\n    scanf(\"%lf\", &retangulo_1->inf_dir.y);\n    getchar();\n    printf(\"\\nDigite as coordenadas do 2\u00ba ret\u00e2ngulo:\\n\");\n    printf(\"\\n\\tPonto superior esquerdo:\\n\");\n    printf(\"\\t-> Coordenada x: \");\n    scanf(\"%lf\", &retangulo_2->sup_esq.x);\n    getchar();\n    printf(\"\\t-> Coordenada y: \");\n    scanf(\"%lf\", &retangulo_2->sup_esq.y);\n    getchar();\n    printf(\"\\n\\tPonto inferior direito:\\n\");\n    printf(\"\\t-> Coordenada x: \");\n    scanf(\"%lf\", &retangulo_2->inf_dir.x);\n    getchar();\n    printf(\"\\t-> Coordenada y: \");\n    scanf(\"%lf\", &retangulo_2->inf_dir.y);\n    getchar();\n}"}
{"author": "mehedi9021", "file": "Data_Structure__search_node.1.c", "original_string": "void print(){\nstruct node*temp;\ntemp=head;\nwhile(temp!=NULL)\n{\n    printf(\"%d\\n\", temp->data);\n    temp=temp->next;\n}\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_rtx.5.c", "original_string": "void osDelayTask(systime_t delay)\n{\n   uint16_t n;\n   delay = OS_MS_TO_SYSTICKS(delay);\n   while(delay > 0)\n   {\n      n = MIN(delay, 0xFFFE);\n      os_dly_wait(n);\n      delay -= n;\n   }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__reverse_single_linked_list.3.c", "original_string": "int main()\n{\n    int n;\n    printf(\"Enter the total number of nodes: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    printf(\"display:\\n\");\n    print();\n    printf(\"reverse:\\n\");\n    reverse();\n    print();\n    return 0;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedList-1.0.c", "original_string": "struct Node * insert(struct Node *head, int data, int index){\n     struct Node * ptr = (struct Node *) malloc(sizeof(struct Node));\n     struct Node * p = head;\n     int i = 0;\n     while (i!=index-1)\n     {\n          p = p->next;\n          i++;\n     }\n     ptr->data = data;\n     ptr->next = p->next;\n     p->next = ptr;\n     return head;\n}"}
{"author": "haon1026", "file": "linux-programming__pthread_create.2.c", "original_string": "int main()\n{\n    printf(\"main:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n    pthread_t tid;\n    int ret = pthread_create(&tid, NULL, thread_fun, NULL);\n    if(ret != 0)\n        sys_err(\"pthread_create error\");\n    sleep(1);\n    return 0;    \n}"}
{"author": "dishanp", "file": "DSA__q1.4.c", "original_string": "void displaycolmajor(int **sp)\n{\n    printf(\"\\nColumn Major Representation : \\n\\n\");\n    for(int i = 0 ; i < 3 ; i++)\n    {\n        for(int j = -1 ; j < num + 1 ; j++)\n        {\n            if(i == 0 && j == -1)\n                printf(\"Row\\t\");\n            else if(i == 1 && j == -1)\n                printf(\"Col\\t\");\n            else if(i == 2 && j == -1)\n                printf(\"Val\\t\");\n            else\n                printf(\"\\t%d\\t\", sp[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__i2c_Tx_Rx.1.c", "original_string": "void i2c_init(void)\n{\n    PINSEL0 |= (1<<4)|(1<<6);\n    PINSEL0 &= ~((1<<5)|(1<<7));        \n    I2CONSET = 1<<6;                                \n    I2SCLH = 75;                                        \n    I2SCLL = 75;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__packet_error_rate.4.c", "original_string": "void packet_error_rate_detect_disable(void)\n{\n        NRF_PPI->CHENCLR =  (1 << PPI_CHANNEL_FOR_TX_READY_GPIO_EVT)  |\n                           (1 << PPI_CHANNEL_FOR_RX_CRCOK_GPIO_EVT) |\n                           (1 << PPI_CHANNEL_FOR_TX_READY_TIMER_EVT) |\n                           (1 << PPI_CHANNEL_FOR_RX_CRCOK_TIMER_EVT);\n        NRF_TIMER_TX_READY->TASKS_CLEAR = 1;\n        NRF_TIMER_RX_CRCOK->TASKS_CLEAR = 1;\n        NRF_TIMER_TX_READY->TASKS_STOP = 1;\n        NRF_TIMER_RX_CRCOK->TASKS_STOP = 1;\n        u32_radio_packet_ready_per_interval = 0;\n        u32_radio_packet_crcok_per_interval = 0;\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise4.1.c", "original_string": "int main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n    int i ,j ,k;\n    const int size = 5;\n    int arr[size];\n    printf(\"Enter array elements:\\n\");\n    for(i=0 ; i<size ; i++){\n        scanf(\"%d\",&arr[i]);\n    }\n    printf(\"Array before sorting:\\n\");\n    for(j=0 ; j<size ; j++){\n        printf(\"%d\\t\",arr[j]);\n    }\n    SelectionSorting(arr,size);\n    printf(\"\\n\");\n    printf(\"Array after sorting:\\n\");\n    for(k=0 ; k<size ; k++){\n        printf(\"%d\\t\",arr[k]);\n    }\n    return 0;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es4.1.c", "original_string": "int idk(double x, double y){\n    double randomNumber = pow(1/10, 9);\n        if ((x - y) <= (randomNumber))\n            return 1;\n        else return 0; \n}"}
{"author": "earth429", "file": "mulpre__t.1.c", "original_string": "int neipia(struct NUMBER *a, struct NUMBER *b)\n{\n    struct NUMBER  n, one, divid, divided, quotient, rest;\n    clearByZero(&divided);\n    clearByZero(a);\n    divided.n[KETA-1] = 1;\n    setInt(&n,2);\n    setInt(&divid,2);\n    if(numComp(&n,b) == 1){\n        return -1;\n    }\n    setInt(&one,1);\n    multiple(&n,&divided,a);\n    while(1){\n        quickDivide(&divided,&divid,&quotient,&rest);\n        add(a,&quotient,&rest);\n        copyNumber(&rest, a);\n        if(numComp(b,&n) == 0){\n            break;\n        }\n        add(&n,&one,&rest);\n        copyNumber(&rest, &n);\n        multiple(&divid,&n,&rest);\n        copyNumber(&rest, &divid);\n    }\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__week_1.2.c", "original_string": "void multiply(int a[][10], int b[][10], int m, int n, int p, int q)\n{\n    int f[10][10], sum = 0;\n    if(n != p)\n    {\n        printf(\"Invalid Order\\n\");\n        return;\n    }\n    for(int c = 0 ; c < m ; c++)\n        for(int d = 0 ; d < q ; d++)\n        {\n            for(int k = 0 ; k < p ; k++)\n                sum += a[c][k] * b[k][d];\n            f[c][d] = sum;\n            sum = 0;\n        }\n    printf(\"Product of matrices: \\n\");\n    for(int c = 0 ; c < m ; c++)\n    {\n        for(int d = 0 ; d < q ; d++)\n            printf(\"%d\\t\", f[c][d]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.36.c", "original_string": "ASMBLK* translatefunction(VMTRANSLATOR* t) {\n    t->retind = 0;\n    t->cmpind = 0;\n    tfunction.items[0] = mklab(t);\n    ASMBLK* blk = copytemplate(&tfunction);\n    int nlocals = atoi(t->currln->tokens[2]);\n    for(int i = 0; i < nlocals; i++)\n        mergeasmblks(blk, copytemplate(&tfunctionpush));\n    return blk;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__util.10.c", "original_string": "bool existsinarray(STRINGARRAY* arr, const char* item) {\n    for(int i = 0; i < arr->size; i++)\n        if(!strcmp(arr->items[i], item))\n            return true;\n    return false;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__tokenizer.1.c", "original_string": "void append(STRING* s, char c) {\n    int targsize = sizeof(char) * (s->count + 1);\n    if(s->size <= targsize) {\n        s->size = targsize * 2;\n        s->str = (char*)realloc(s->str, s->size);\n    }\n    s->str[s->count] = c;\n    s->count++;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-del_int-iter_in-pre.8.c", "original_string": "int main()\n{\n    int ch;\n    node* root=NULL;\n    while (1)\n    {\n        printf(\"\\n1. INSERTION OF INTEGER\\n\");\n        printf(\"2. DELETION OF INTEGER\\n\");\n        printf(\"3. DISPLAY TREE\\n\");\n        printf(\"4. IN-ORDER TRAVERSAL\\n\");\n        printf(\"5. PRE-ORDER TRAVERSAL\\n\");\n        printf(\"6. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1)\n        {\n            int n;\n            printf(\"Please enter an element: \");\n            scanf(\"%d\",&n);\n            root=insertion(root,n);\n            printf(\"%d inserted in BINARY SEARCH TREE.\\n\",n);\n        }\n        else if(ch==2)\n        {\n            int n;\n            printf(\"Please enter the element to be deleted: \");\n            scanf(\"%d\",&n);\n            if(search(root,n)==1)\n            {\n                root=deletion(root,n);\n                printf(\"%d deleted from BINARY SEARCH TREE.\\n\",n);\n            }\n            else\n                printf(\"COULDN'T DELETE %d. NOT FOUND IN BS TREE.\\n\");\n        }\n        else if(ch==3)\n        {\n            printf(\"\\n\");\n            display(root,1);\n        }\n        else if(ch==4)\n        {\n            if(root==NULL)\n                printf(\"\\tTREE EMPTY\\n\");\n            else\n            {\n                printf(\"\\n     IN-ORDER\\n\");\n                inorder(root);\n            }\n        }\n        else if(ch==5)\n        {\n            if(root==NULL)\n                printf(\"\\tTREE EMPTY\\n\");\n            else\n            {\n                printf(\"\\n     PRE-ORDER\\n\");\n                preorder(root);\n            }\n        }\n        else if(ch==6)\n        {\n            printf(\"Exitting Program, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"INVALID CHOICE! TRY AGAIN\\n\");\n    }\n    return 0;\n}"}
{"author": "earth429", "file": "mulpre__divBy10.7.c", "original_string": "int mulBy10(struct NUMBER *a, struct NUMBER *b){\n    int i;\n    if(a->n[KETA - 1] != 0){\n        return -1;\n    }\n    for (i = KETA - 2; i >= 0;i--){\n        b->n[i + 1] = a->n[i];\n    }\n    b->n[0] = 0;\n    return 0;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__arreglo_uni_dinamico.1.c", "original_string": "void leer_calorias(int a[], int tam){\n    for (int i = 0; i < tam; i++){\n        printf(\"Ingrese las calorias consumidas en el dia: \");\n        scanf(\"%d\", &a[i]);\n    }\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_1-20.0.c", "original_string": "char** arr(int rows, int cols){\n    char **x;\n    MALLOC(x,rows*sizeof(*x));\n    int i;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n    }\n    return x;\n}"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal_pwr.9.c", "original_string": "void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)\n{\n  UNUSED(Regulator);\n  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));\n  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));\n  if(SLEEPEntry == PWR_SLEEPENTRY_WFI)\n  {\n    __WFI();\n  }\n  else\n  {\n    __SEV();\n    __WFE();\n    __WFE();\n  }\n}"}
{"author": "2security", "file": "Array__RemoveDuplicates.0.c", "original_string": "int main()\n    {\n    int *arr,i,n,sum=0;\n    printf(\"Enter how many numbers you want to store into array\");\n    scanf(\"%d\",&n);\n    arr=(int *)malloc((n)*sizeof(int *));   \n    printf(\"\\nEnter %d elements\",n);\n    for(i=0;i<n;i++)\n    scanf(\"%d\",&arr[i]);\n    n=removeDuplicates(arr,n);\n    printf(\"\\nAfter removing duplicates: \");\n    displayarr(arr,n);\n    return 0;\n    }"}
{"author": "theuwis", "file": "project-euler__main10.0.c", "original_string": "int main(void){\n    int i = 1, j, sum = 0, nr_of_divisors = 0;\n    while(1){\n        for(j = 1; j <= i; j++){\n            sum += j;\n        }\n        for(j = 1; j <= sum; j++){\n            if(sum % j == 0) nr_of_divisors++;\n        }\n        if(nr_of_divisors > 500){\n            printf(\"answer=%d (nr=%d, nr_div=%d)\\n\", sum, i, nr_of_divisors);\n            break;\n        }\n        printf(\"(%10d) %d\\n\", i, nr_of_divisors);\n        i++;\n        sum = 0;\n        nr_of_divisors = 0;\n    }\n    return EXIT_SUCCESS;\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__test.3.c", "original_string": "unsigned int crc32lql(unsigned char *string, unsigned int size) {\n    make_crc32_table();\n    unsigned int crc = 0xffffffff;\n    while(size--)\n        crc = (crc >> 8)^(crc32_table[(crc ^ *string++)&0xff]);\n    return crc;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q3.8.c", "original_string": "node* constructTree(char postfix[])\n{\n    STACK st;\n    st.tos = -1;\n    node *t, *t1, *t2;\n    int i, j;\n    for (j = 0; postfix[j] != '\\0'; j++);\n    for (i = 0; i < j; i++)\n    {\n        if (!isOperator(postfix[i]))\n        {\n            t = newNode(postfix[i]);\n            push(&st, t);\n        }\n        else\n        {\n            t = newNode(postfix[i]);\n            t2 = pop(&st);\n            t1 = pop(&st);\n            t->right = t2;\n            t->left = t1;\n            push(&st, t);\n        }\n    }\n    return t;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__palhaco.3.c", "original_string": "void desenhaNariz(){\n    glPushMatrix();\n    glColor3f(1.0, 0.0, 0.0);\n    glRotatef(angulo,0.0,1.0,0.0);\n    glTranslatef(0.0, 0.0, 2.0);\n    glutWireSphere(0.5, 20, 20);\n    glPopMatrix();\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-structure.7.c", "original_string": "LINEBLOCK* compilemethod(SCOPE* s, CLASS* cl, SUBROUTDEC* m) {\n    LINE* label = mksubdeclabel(cl, m);\n    LINEBLOCK* blk = mklnblk(label);\n    char* pusharg0[] = { \"push\", \"argument\", \"0\" };\n    char* poppointer[] = { \"pop\", \"pointer\", \"0\" };\n    appendln(blk, mkln(pusharg0));\n    appendln(blk, mkln(poppointer));\n    if(m->body != NULL) \n        return mergelnblks(blk, compilefunbody(s, cl, m));\n    else\n        return blk;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.15.c", "original_string": "int main() {\n        int val, ch;\n        while (1) {\n                printf(\"1. Insertion\\t2. Deletion\\n\");\n                printf(\"3. Searching\\t4. Traversal\\n\");\n                printf(\"5. Exit\\nEnter your choice:\");\n                scanf(\"%d\", &ch);\n                switch (ch) {\n                        case 1:\n                                printf(\"Enter your input:\");\n                                scanf(\"%d\", &val);\n                                insertion(val);\n                                break;\n                        case 2:\n                                printf(\"Enter the element to delete:\");\n                                scanf(\"%d\", &val);\n                                deletion(val, root);\n                                break;\n                        case 3:\n                                printf(\"Enter the element to search:\");\n                                scanf(\"%d\", &val);\n                                searching(val, &ch, root);\n                                break;\n                        case 4:\n                                traversal(root);\n                                break;\n                        case 5:\n                                exit(0);\n                        default:\n                                printf(\"U have entered wrong option!!\\n\");\n                                break;\n                }\n                printf(\"\\n\");\n        }\n  }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_6.0.c", "original_string": "node createNode()\n{\n    node t=(node)malloc(sizeof(struct Node));\n    if(t==NULL)\n        {\n            printf(\"Memory not allocated for node\");\n            exit(0);\n        }\n    t->next=NULL;\n    return t;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-expressions.18.c", "original_string": "EXPRESSIONLIST* parseexpressionlist(PARSER* p) {\n    if(!strcmp(p->current->token, \")\"))\n        return NULL;\n    EXPRESSIONLIST* head = (EXPRESSIONLIST*)malloc(sizeof(EXPRESSIONLIST));\n    head->expression = parseexpressionnullified(p);\n    EXPRESSIONLIST* current = head;\n    EXPRESSIONLIST* nextls;\n    while(!strcmp(p->current->token, \",\")) {\n        next(p);\n        nextls = (EXPRESSIONLIST*)malloc(sizeof(EXPRESSIONLIST));\n        nextls->expression = parseexpression(p);\n        current->next = nextls;\n        current = nextls;\n    }\n    if(current != NULL)\n        current->next = NULL;\n    return head;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-central-scanner-with-whitelist__nrf_fstorage.2.c", "original_string": "ret_code_t nrf_fstorage_read(nrf_fstorage_t const * p_fs,\n                             uint32_t               src,\n                             void                 * p_dest,\n                             uint32_t               len)\n{\n    NRF_FSTORAGE_PARAM_CHECK(p_fs,        NRF_ERROR_NULL);\n    NRF_FSTORAGE_PARAM_CHECK(p_dest,      NRF_ERROR_NULL);\n    NRF_FSTORAGE_PARAM_CHECK(p_fs->p_api, NRF_ERROR_INVALID_STATE);\n    NRF_FSTORAGE_PARAM_CHECK(len,         NRF_ERROR_INVALID_LENGTH);\n    NRF_FSTORAGE_PARAM_CHECK(addr_is_aligned32(src),                NRF_ERROR_INVALID_ADDR);\n    NRF_FSTORAGE_PARAM_CHECK(addr_is_within_bounds(p_fs, src, len), NRF_ERROR_INVALID_ADDR);\n    return (p_fs->p_api)->read(p_fs, src, p_dest, len);\n}"}
{"author": "augustogunsch", "file": "jackc__parser-structure.5.c", "original_string": "CLASSVARDEC* parseclassvardec(PARSER* p) {\n    CLASSVARTYPE classvartype = parseclassvartype(p);\n    if(classvartype == -1)\n        return NULL;\n    next(p);\n    CLASSVARDEC* classvardec = (CLASSVARDEC*)malloc(sizeof(CLASSVARDEC));\n    classvardec->type = classvartype;\n    classvardec->base = (VARDEC*)malloc(sizeof(VARDEC));\n    parsevardeccommon(p, classvardec->base);\n    return classvardec;\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__100-shell_sort.0.c", "original_string": "void shell_sort(int *array, size_t size)\n{\n    int value;\n    size_t i, j, gap;\n    if (array == NULL || size < 2)\n        return;\n    gap = 1;\n    while (gap < size / 3)\n    {\n        gap = (gap * 3) + 1;\n    }\n    while (gap > 0)\n    {\n        i = gap;\n        while (i < size)\n        {\n            value = array[i];\n            j = i;\n            while (j > gap - 1 && array[j - gap] >= value)\n            {\n                array[j] = array[j - gap];\n                j -= gap;\n            }\n            array[j] = value;\n            i++;\n        }\n        gap = (gap - 1) / 3;\n        print_array(array, size);\n    }\n}"}
{"author": "RafaelFelisbino-hub", "file": "FUNCOES-exercices__Exercicio8FUNCAO.0.c", "original_string": "int main() \n{\n    int i;\n    for (i = 0; i < 30; i++) \n    {\n        printf(\"Digite os valores de A:  \");\n        scanf_s(\"%f\", &A[i]);\n        metade();\n    }\n    for (i = 0; i < 30; i++)\n        printf(\"Os valores de A pela metade sao:  %.2f\\n\", B[i]);\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc.13.c", "original_string": "void deallocate_space(node* root)\n{\n    if((root)!=NULL)\n    {\n        deallocate_space(root->left);\n        deallocate_space(root->right);\n        printf(\"\\nDeallocating space occupied by element: %d\",root->data);\n        free(root);\n    }\n}"}
{"author": "sdukesameer", "file": "c__sum-of-digits-all-even-odd.0.c", "original_string": "int sum(int n)\n{\n    int ans=0,f;\n    if(n<0)\n        n=-n;\n    if (n>0)\n    {\n        while(n>0)\n        {\n            f=n%10;\n            ans+=f;\n            n=n/10;\n        }\n    }\n    return ans;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_37.1.c", "original_string": "void ordenarVetorDecrescente() {\n    for (int i = 6; i <= 11; i++) {\n        int maiorValorPosicao = buscarMaiorValor(i);\n        int valorPosicaoAnterior = vetor[i];\n        vetor[i] = maiorValorPosicao;\n        vetor[posicaoReporNumero] = valorPosicaoAnterior;\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_DCLL.4.c", "original_string": "void delete_end()\n{\n    struct node *temp,*endnode;\n    temp=head;\n    while(temp->next!=head)\n    {\n        temp=temp->next;\n    }\n    endnode=temp;\n    temp->pre->next=head;\n    head->pre=endnode->pre;\n    free(endnode);\n}"}
{"author": "shengelenge", "file": "wstep-do-programowania__zad30.0.c", "original_string": "bool czy_pierwsza(int n)\n{\n    if (n <2)\n        return false;\n    for (int i = 2; i*i <= n ; i++) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}"}
{"author": "tadeograch", "file": "sorting_algorithms__1-insertion_sort_list.1.c", "original_string": "listint_t **swap(listint_t *temp_sort, listint_t *swapper, listint_t **list)\n{\n    listint_t *aux_prev, *aux_next = temp_sort->next;\n    swapper = temp_sort->prev;\n    if (temp_sort->next == NULL && swapper->prev == NULL)\n    {\n        temp_sort->next = temp_sort->prev;\n        temp_sort->prev = NULL;\n        swapper->prev = swapper->next;\n        swapper->next = NULL;\n        *list = temp_sort;\n    }\n    else if (swapper->prev == NULL)\n    {\n        temp_sort->prev = NULL;\n        temp_sort->next = swapper;\n        swapper->prev = temp_sort;\n        swapper->next = aux_next;\n        aux_next->prev = swapper;\n        *list = temp_sort;\n    }\n    else if (temp_sort->next == NULL)\n    {\n        aux_prev = swapper->prev;\n        aux_prev->next = temp_sort;\n        temp_sort->prev = aux_prev;\n        temp_sort->next = swapper;\n        swapper->prev = temp_sort;\n        swapper->next = NULL;\n    }\n    else\n    {\n        aux_prev = swapper->prev;\n        aux_prev->next = temp_sort;\n        temp_sort->prev = aux_prev;\n        temp_sort->next = swapper;\n        swapper->next = aux_next;\n        swapper->prev = temp_sort;\n        aux_next->prev = swapper;\n    }\n    return (list);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__2.5.c", "original_string": "complex_t subtracao(complex_t a, complex_t b)\n{\n    complex_t c;\n    c.real = a.real - b.real;\n    c.imaginario = a.imaginario - b.imaginario;\n    return c;\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise21.0.c", "original_string": "int * PrintReverseInclusive(int LowerNumber,int UpperNumber,int * result_size)\n{\n    int i;\n    *result_size = 0;\n    if(LowerNumber > UpperNumber)\n    {\n        OutputArray[0] = 0xFF;\n        OutputArray[1] = 0xFF;\n        *result_size = 2;\n    }\n    else\n    {\n        for(i=UpperNumber;i>=LowerNumber;i--)\n        {\n            OutputArray[*result_size] = i;\n            (*result_size)++;\n        }\n    }\n    return OutputArray;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__multiParenthesis.2.c", "original_string": "char push(struct stack*ptr, char val){\n    if(isFull(ptr)){\n        printf(\"Stack Overflow! Cannot push %d to the stack\\n\", val);\n    }\n    else{\n        ptr->top++;\n        ptr->arr[ptr->top]=val;\n    }\n}"}
{"author": "tadeograch", "file": "monty__analize.0.c", "original_string": "int analize(stack_t **stack, unsigned int line_number)\n{\n    int type_i;\n    instruction_t type[] = {\n                {\"push\", push_func},\n                {\"pall\", pall_func},\n                {\"pint\", pint_func},\n                {\"pop\", pop_func},\n                {\"swap\", swap_func},\n                {\"add\", add_func},\n                {\"nop\", nop_func},\n                {\"sub\", sub_func},\n                {\"div\", div_func},\n                {\"mul\", mul_func},\n                {\"mod\", mod_func},\n                {NULL, NULL}\n    };\n    for (type_i = 0; type[type_i].opcode != NULL; type_i++)\n    {\n        if (strcmp(code[0], type[type_i].opcode) == 0)\n        {\n            type[type_i].f(stack, line_number);\n            break;\n        }\n    }\n    if (type[type_i].opcode == NULL)\n    {\n        return (0);\n    }\n    return (1);\n}"}
{"author": "mehedi9021", "file": "Data_Structure__double_list_create.2.c", "original_string": "void displayListFromFirst()\n{\n    struct node * temp;\n        temp = head;\n        printf(\"\\n\\nDATA IN THE LIST From First:\\n\");\n        while(temp != NULL)\n        {\n            printf(\"DATA = %d\\n\", temp->data);\n            temp = temp->next;\n        }\n    }"}
{"author": "shengelenge", "file": "wstep-do-programowania__zad41.0.c", "original_string": "int main()\n{\n    int sum1 = 0;\n    int sum2 = 0;\n    int sum3 = 0;\n    int i = 1;\n    int j = 1;\n    printf(\"Petla for:\\n\");\n    for (int i = 1; i <=100; i +=2)\n    {\n        sum1 += i;\n        printf (\"%d\\n\", sum1 );\n    }\n    printf(\"\\nPetla while:\\n\");\n    while (i <= 100)\n    {\n        sum2 += i;\n        printf(\"%d\\n\", sum2);\n        i += 2;\n    }\n    printf(\"\\nPetla do while:\\n\");\n    do {\n        sum3 += j;\n        printf(\"%d\\n\", sum3);\n        j += 2;\n    } while (j <= 100);\n    return 0;\n}"}
{"author": "zjzj-zz", "file": "1s_programing__pattern.1.c", "original_string": "int main(void) {\n    int i , q;\n    dl_initialize(1.0);\n    for (i = 0; i < 13; i++) {\n                dl_hexagon(-i*i+400 , i*13 , i*30);\n                dl_hexagon(i*i+150 , i*13 , i*30);\n                dl_hexagon(-i*i+500 , i*13 , i*17);\n                dl_hexagon(i*i+50 , i*13 , i*17);\n                dl_circle(13*cos(M_PI/6*i)+150, 13*sin(M_PI/6*i)+300, 7, DL_RGB(200-i*15 , 200+i*i , 30*i*i), 1 , 1);\n                dl_circle(29*cos(M_PI/6*i)+150, 29*sin(M_PI/6*i)+300, 10, DL_RGB(200-i*15 , 200+i*i , 30*i*i), 1 , 1);\n                dl_circle(56*cos(M_PI/6*i)+150, 56*sin(M_PI/6*i)+300, 18, DL_RGB(200-i*15 , 200+i*i , 30*i*i), 1 , 1);\n                dl_circle(100*cos(M_PI/6*i)+150, 100*sin(M_PI/6*i)+300, 27, DL_RGB(200-i*15 , 200+i*i , 30*i*i), 1 , 1);\n  }\n        for (q = 0; q < 51; q++) {\n                dl_circle(50*cos(M_PI*q/25)+500, 50*sin(M_PI*q/25)+300, 50, DL_RGB(50 , 250-q*q , 10), 3 , 0);\n  }\n    while (1) {\n        dl_wait(1.0);\n  } \n    return 0;\n}"}
{"author": "sdukesameer", "file": "c__parity_check.2.c", "original_string": "int main()\n{\n    int t,n,i,j,parity,chk;\n    scanf(\"%d\",&t);\n    for (int i = 0; i < t; i++)\n    {\n        scanf(\"%d\",&n);\n        int arr[n];\n        for (int j = 0; j < n; j++)\n            scanf(\"%d\",arr+j);\n        for (int j = 0; j < n; j++)\n        {\n            chk=check(arr[j]);\n            if(j==0)\n                parity=chk;\n            else if(parity!=chk)\n            {\n                parity=0; \n                break;\n            }\n            else \n                continue;\n        }\n        if(parity==0)\n            printf(\"NO\\n\");\n        else\n            printf(\"YES\\n\");\n    }\n    return 0;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_05.2.c", "original_string": "float findMedian(int X[],int Y[],int m,int n)\n{\n    float median;\n    int s = sizeof(int);\n    int j=0; int k =0;\n    int i=0;\n    while(i<m+n)\n    {\n        if(j<m && k<n)\n        {\n            if(X[j]<=Y[k])\n            {\n                a[i] = X[j];\n                j++;\n            }\n            else\n            {\n                a[i] = Y[k];\n                k++;\n            }\n            i++;\n        }\n        else if(j == m)\n        {\n            a[i]=Y[k];\n            k++;\n            i++;\n        }\n        else if(k == n)\n        {\n            a[i]=X[j];\n            j++;\n            i++;\n        }\n    }\n    if((m+n)%2 != 0)\n    {\n        median = a[(m+n)/2];\n        return median;\n    }\n    else\n    {\n        median = (a[(m+n-1)/2]+a[(m+n-1)/2+1])/2.0;\n        return median;\n    }\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__BA.1.c", "original_string": "void resource_request(int pr)\n{\n    int i,s,flag=-1;\n    for(i=0;i<m;i++)\n    {\n        if(request[pr][i]<=need[pr][i])\n            continue;\n        else\n        {\n            flag=1;\n            break;\n        }\n    }\n    if(flag==1)\n        printf(\"Terminate!\");\n    else\n    {\n        for(i=0;i<m;i++)\n        {\n            if(request[pr][i]<=available[i])\n                continue;\n            else\n            {\n                flag=1;\n                break;\n            }\n        }   \n        if(flag==1)\n            printf(\"Process has to wait\");\n        else\n        {\n            for(i=0;i<m;i++)\n            {\n                available[i]=available[i]-request[pr][i];\n                allocation[pr][i]=allocation[pr][i]+request[pr][i];\n                need[pr][i]=need[pr][i]-request[pr][i];\n            }\n            s=safety_module();\n            if(s==1)\n                printf(\"\\nRequest Granted\");\n            else\n            {\n                printf(\"\\nRestore\");\n                for(i=0;i<m;i++)\n                {\n                    available[i]=available[i]+request[pr][i];\n                    allocation[pr][i]=allocation[pr][i]-request[pr][i];\n                    need[pr][i]=need[pr][i]+request[pr][i];\n                }\n            }\n        }\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__double_linked_list_create.0.c", "original_string": "int main()\n{\n    int n, data;\n    head = NULL;\n    last = NULL;\n    printf(\"Enter the number of nodes you want to create: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    displayListFromFirst();\n    printf(\"Enter node position: \");\n    scanf(\"%d\", &n);\n    printf(\"Enter data you want to insert at %d position: \", n);\n    scanf(\"%d\", &data);\n    insertAtN(data, n);\n    displayListFromFirst();\n    return 0;\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example31.1.c", "original_string": "int fibonacci(int n)\n{\n    if(n==0)\n     return 0;\n    else if (n==1)  \n        return 1;\n    else    \n        return(fibonacci(n-1)+fibonacci(n-2));  \n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__M.0.c", "original_string": "int sistema(int a, int b, int c)\n{\n    int x, y, z;\n    for (y = (-c); y <= c; y++)\n    {\n        for (z = (y+1); z <= c; z++)\n        {\n            x = a - y - z;\n            if (((y * z * x) == b) && (((x * x) + (y * y) + (z * z)) == c) && (z != x) && (y != x))\n            {\n                printf(\"%i %i %i\\n\", y, z, x);\n                return 0;\n            }\n        }\n    }\n    printf(\"Sem solucao\\n\");\n    return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__1,_2.0.c", "original_string": "void imprime_elemento(long int *vet, long int i, long int n, ordem_t ordem)\n{\n    printf(\"%li \", *(vet + i));\n    if (ordem == normal)\n    {\n        return (i < n-1) ? imprime_elemento(vet, i+1, n, ordem) : 0;\n    }\n    else if (ordem == inversa)\n    {\n        return (i > 0) ? imprime_elemento(vet, i-1, NULL, ordem) : 0;\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__nonVIC.5.c", "original_string": "void delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-2new0.6.c", "original_string": "int bfs(char*** maze,int*** d,int sr,int sc,int sh){\n    rear=-1;front=-1;\n    int arrive=0;\n    element position;\n    position.row = sr;\n    position.col = sc;\n    position.hei = sh;\n    addq(position);\n    int i,j,k;\n    for(i=0;i<n/2+1;i++){\n        for(j=0;j<n+2;j++){\n            for(k=0;k<n+2;k++){\n                d[i][j][k]=MAX;\n            }\n        }\n    }\n    d[sh][sr][sc]=0;\n    int nr,nc,nh;\n    int row,col,hei;\n    while(rear!=front){\n        position = deleteq();\n        row = position.row;\n        col = position.col;\n        hei = position.hei;\n        if(maze[hei][row][col]=='F'){\n            if(min>d[hei][row][col]){\n                min = d[hei][row][col];\n            }\n            min = d[hei][row][col];\n            arrive=1;\n        }\n        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='D'){\n            int upanddown=-1;\n            if(maze[hei][row][col]=='U'){\n                upanddown=1;\n            }\n            nr = row;\n            nc = col;\n            nh = hei+upanddown;\n            if(nh>=0){\n                if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){\n                    d[nh][nr][nc]=d[hei][row][col]+1;\n                    if(maze[nh][nr][nc]=='T'){\n                        d[nh][nr][nc]=d[nh][nr][nc]+2;\n                    }\n                    element nextposition;\n                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                    addq(nextposition);\n                }\n            }\n        }\n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            nh = hei+move[i].hei;\n            if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){\n                d[nh][nr][nc]=d[hei][row][col]+1;\n                if(maze[nh][nr][nc]=='T'){\n                    d[nh][nr][nc]=d[nh][nr][nc]+2;\n                }\n                element nextposition;\n                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                addq(nextposition);\n            }\n        }\n    }\n    return arrive;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__43_transpose_of_matrix.0.c", "original_string": "int main()\n{\n  int i,j,k,r1,c1,r2,c2, flag = 0;\n  printf(\"Enter Value of r1, c1, r2, c2\\n\");\n  scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n  int m1[r1][c1], m2[r2][c2], sum = 0, mul[r1][c2];\n  printf(\"Enter value of Matrix1\\n\");\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      scanf(\"%d\",&m1[i][j]);\n    }\n  }\n  printf(\"Value Befor Transpose\\n\"); \n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      printf(\"%d\",m1[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  for(i=0; i<r1; i++)\n  {\n    for(j=0; j<c1; j++)\n    {\n      m2[j][i] = m1[i][j];\n    }\n    printf(\"\\n\");\n  }\n  printf(\"Value after Transpose\\n\"); \n  for(i=0; i<c1; i++)\n  {\n    for(j=0; j<r1; j++)\n    {\n      printf(\"%d \",m2[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_any_pos_DLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__ex01.3.c", "original_string": "int main(int argc, char *argv[])\n{\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n    glutInitWindowPosition(50, 100);\n    glutInitWindowSize(400, 400);\n    glutCreateWindow(\"Exercicio 01\");\n    glutDisplayFunc(desenha);\n    glutMouseFunc(mouse);\n    glutMainLoop();\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__queueOfInt.3.c", "original_string": "int main()\n{\n    int n, ch;\n    que q;\n    q.front = q.rear = -1;\n    do\n    {\n        printf(\"\\nCircular Queue:\\n1. Insert \\n2. Delete\\n3. Display\\n0. Exit\");\n        printf(\"\\nEnter Choice 0-3? : \");\n        scanf(\"%d\", &ch);\n        switch (ch)\n        {\n            case 1:\n                printf(\"\\nEnter number: \");\n                scanf(\"%d\", &n);\n                insertq(&q, n);\n                break;\n            case 2:\n                deleteq(&q);\n                break;\n            case 3:\n                display(&q);\n                break;\n        }\n    }while (ch != 0);\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc.3.c", "original_string": "void rec_inorder(node* root) \n{ \n    if (root != NULL) \n    { \n        rec_inorder(root->left); \n        printf(\"\\t%d\\n\", root->data); \n        rec_inorder(root->right); \n    } \n}"}
{"author": "ashlyn2002", "file": "programming-using-c__queue_using_array.2.c", "original_string": "void peek()\n{\n    if(front==-1 && rear==-1)\n    {\n        printf(\"queue is empty\\n\");\n    }\n    else\n    {\n        printf(\"the peek element is %d\\n\",queue[front]);\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__ca3.5.c", "original_string": "void rec_insert (BS_TREE **aar, int n){\n    if (*aar == NULL){\n       *aar=(BS_TREE *)malloc(sizeof(BS_TREE));\n        (*aar)->data=n;\n        (*aar)->left=(*aar)->right=NULL;\n    } \n    else if (n<(*aar)->data)\n        rec_insert(&((*aar)->left), n); \n    else\n        rec_insert(&((*aar)->right), n); \n}"}
{"author": "earth429", "file": "mulpre__zerosuppress.3.c", "original_string": "int main(int argc, char **argv)\n{\n    srandom(time(NULL));\n    struct NUMBER a;\n    setRnd(&a, 10);\n    printf(\"a = \"); \n    dispNumberZeroSuppress(&a);\n    printf(\"\\n\");\n    printf(\"a\u3042\u308a = \"); \n    dispNumber(&a);\n    printf(\"\\n\");\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__binarySearchTree.3.c", "original_string": "struct Node*findMinimum(struct Node*root){\n     if(root==NULL){\n          return NULL;\n     }\n     else if(root->left!=NULL){\n          return findMinimum(root->left);\n     }\n     return root;\n}"}
{"author": "dle2005", "file": "File_Structure__heapsort.5.c", "original_string": "void pack(char *recordbuf, const Person *p) {\n    sprintf(recordbuf, \"%s#%s#%s#%s#%s#%s#\", p -> sn, p -> name, p -> age,  p -> addr, p -> phone, p -> email);\n    memset(recordbuf + strlen(recordbuf), (char)0xFF, RECORD_SIZE - strlen(recordbuf));\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__Boyre_MooreMethod.2.c", "original_string": "void main()\n{\n    int n,m,i;\n    char S[100],P[100];\n    printf(\"\\nEnter String:\");\n    scanf(\"%s\",S);\n    printf(\"\\nEnter Pattern:\");\n    scanf(\"%s\",P);\n    n=strlen(S);\n    m=strlen(P);\n    i=Boyre_Moore(S,P,n,m);\n    printf(\"\\nThe pattern is found at position %d\",i);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q33.6.c", "original_string": "int main()\n{\n    queue q;\n    q.front = CAPACITY/2;\n    q.rear = CAPACITY/2;\n    char word[20];\n    int isPalin  = 1;          \n    printf(\"Enter word: \");\n    scanf(\"%s\", word);\n    for(int i = 0 ; i < strlen(word) ; i++)\n        enqueueright(&q, word[i]);\n    for(int i = 0 ; i < strlen(word)/2 ; i++)\n        if (dequeueleft(&q) != dequeueright(&q))\n        {\n            isPalin = 0;              \n            break;\n        }\n    isPalin ? printf(\"YES\\n\") : printf(\"NO\\n\");\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__cub2d.4.c", "original_string": "int         key_release(int keycode)\n{\n    if (keycode == 13)\n        g_player.walk_direction = 0;\n    if (keycode == 1)\n        g_player.walk_direction = 0;\n    if (keycode == 0)\n        g_player.turn_direction = 0;\n    if (keycode == 2)\n        g_player.turn_direction = 0;\n    return (0);\n}"}
{"author": "augustogunsch", "file": "jackc__parser-structure.10.c", "original_string": "PARAMETER* parseparameter(PARSER* p) {\n    if(equals(p, \")\"))\n        return NULL;\n    PARAMETER* param = (PARAMETER*)malloc(sizeof(PARAMETER));\n    param->debug = getdebug(p);\n    param->primitive = isprimitive(p->current);\n    param->type = parsetype(p);\n    param->name = parseidentifier(p);\n    return param;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__DemoFOTAUpdateWorkflow.5.c", "original_string": "static bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)\n{\n  switch (instance->__currentState)\n  {\n    case DemoFOTAUpdateWorkflowEngine_idle__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          printf(\"Cannot handle firmware over-the-air update request (missing network connection)\\n\");\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_connected__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) != 0) \n          {\n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;\n            instance->updateInfo.version = (*((char **)((arguments[0]))));\n            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) \n            {\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) \n            {\n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) == 0) \n          {\n            printf(\"Ignoring firmware over-the-air update request to version %s as this version is already running\\n\", (*((char **)((arguments[0])))));\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_downloading__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) \n          {\n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            saveState(DemoFOTAUpdateWorkflowEngine_activating__state);\n            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) \n            {\n              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) \n            {\n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_restarting__state:\n    {\n      switch (event)\n      {\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_activating__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            validateFirmwareUpdateActivation();\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n            }\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_SUCCEEDED) \n          {\n            bool __transitionResult = true;\n            saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n            if (!fotahub_confirmFirmwareUpdate(&instance->updateInfo)) \n            {\n              __transitionResult = false;\n            }\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n            }\n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_ACTIVATION_FAILED) \n          {\n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            saveState(DemoFOTAUpdateWorkflowEngine_reverting__state);\n            if (!fotahub_revertFirmwareUpdate(&instance->updateInfo)) \n            {\n              saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_activating__state) \n            {\n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            if (!__transitionResult) \n            {\n              return false;\n            }\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_reverting__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            validateFirmwareUpdateReversion();\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_reverting__state) \n            {\n            }\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          saveState(DemoFOTAUpdateWorkflowEngine_idle__state);\n          instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n          DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return true;\n}"}
{"author": "earth429", "file": "mulpre__lcm.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a, b, c;\n    int return_val;\n    int x, y;\n    x = 98765;\n    y = 43210;\n    setInt(&a, x);\n    setInt(&b, y);\n    return_val = lcm(&a, &b, &c);\n    dispNumberZeroSuppress(&c);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n    return 0;\n}"}
{"author": "haon1026", "file": "linux-programming__1select.0.c", "original_string": "int main()\n{\n    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);\n    int opt = 1;\n    setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n    struct sockaddr_in serv_adr;\n    bzero(&serv_adr, sizeof(serv_adr));\n    serv_adr.sin_family = AF_INET;\n    serv_adr.sin_port = htons(9999);\n    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);\n    Bind(serv_sock, (struct sockaddr *)&serv_adr, sizeof(serv_adr));\n    Listen(serv_sock, 128);\n    int maxfd = serv_sock;          \n    fd_set rset, allset;            \n    FD_ZERO(&allset);               \n    FD_SET(serv_sock, &allset);     \n    int clnt_sock;\n    struct sockaddr_in clnt_adr;\n    socklen_t clnt_adr_len;\n    char buf[BUFSIZ];\n    int ret, n;\n    while(1)\n    {\n        rset = allset;              \n        ret = select(maxfd+1, &rset, NULL, NULL, NULL);     \n        if (ret < 0)\n        {\n            sys_err(\"select() error\");\n        }\n        if(FD_ISSET(serv_sock, &rset))                      \n        {\n            clnt_adr_len = sizeof(clnt_adr);\n            clnt_sock = Accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_len);      \n            FD_SET(clnt_sock, &allset);                     \n            if(maxfd < clnt_sock)       \n                maxfd = clnt_sock;\n            if(ret == 1)                \n                continue;\n        }\n        for(int i = serv_sock+1; i <= maxfd; i++)   \n        {\n            if(FD_ISSET(i, &rset))\n            {\n                n = Read(i, buf, sizeof(buf));\n                if(n == 0)\n                {\n                    Close(i);\n                    FD_CLR(i, &allset);             \n                }\n                else\n                {\n                    for(int j = 0; j < n; j++)\n                    {\n                        buf[j] = toupper(buf[j]);\n                    }\n                    Write(i, buf, n);\n                    Write(STDOUT_FILENO, buf, n);\n                }\n            }\n        } \n    }\n    Close(serv_sock);\n    return 0;\n}"}
{"author": "andi-s0106", "file": "sorting_algorithms__1-main.0.c", "original_string": "listint_t *create_listint(const int *array, size_t size)\n{\n    listint_t *list;\n    listint_t *node;\n    int *tmp;\n    list = NULL;\n    while (size--)\n    {\n        node = malloc(sizeof(*node));\n        if (!node)\n            return (NULL);\n        tmp = (int *)&node->n;\n        *tmp = array[size];\n        node->next = list;\n        node->prev = NULL;\n        list = node;\n        if (list->next)\n            list->next->prev = list;\n    }\n    return (list);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__queue_using_array.3.c", "original_string": "void display()\n{\n    int i;\n    if(front==-1 && rear==-1)\n    {\n        printf(\"queue is empty\\n\");\n    }\n    else\n    {\n        printf(\"the elements in the queue are\\n\");\n        for(i=front;i<=rear;i++)\n        {\n            printf(\"%d \",queue[i]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__double_linked_list_create.5.c", "original_string": "void insertAtN(int data, int position)\n{\n    int i;\n    struct node * newNode, *temp;\n        if(position == 1)\n        {\n            insertAtBeginning(data);\n}\n        else if(temp!=NULL)\n        {\n             insertAtEnd(data);\n        }\n        else\n        {\n            printf(\"Error, Invalid position\\n\");\n        }\n    }"}
{"author": "ankitraj311", "file": "450_babbar__2_max_min_in_array.0.c", "original_string": "void array_print(int arr[], int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q31.4.c", "original_string": "void display(stack *s)\n{\n    printf(\"\\nStack 1: \");\n    for(int i = 0 ; i <= s->tos1 ; i++)\n        printf(\"%d \", s->a[i]);\n    printf(\"\\nStack 1: \");\n    for(int i = MAX - 1 ; i >= s->tos2 ; i--)\n        printf(\"%d \", s->a[i]);\n    printf(\"\\n\");\n}"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post.3.c", "original_string": "void rec_inorder(node* root) \n{ \n    if (root != NULL) \n    { \n        rec_inorder(root->left); \n        printf(\"\\t%d\\n\", root->data); \n        rec_inorder(root->right); \n    } \n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__23_Dowhile.1.c", "original_string": "double Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    do{\n    Total *= numero;\n    ++i;\n    }while(i < exponente);\n    return Total;\n}"}
{"author": "mandarvu", "file": "msc__problem3.0.c", "original_string": "int main() {\n  int nums[MAX] = {5, 4, 7, 9, 2}, target[MAX + 1], pos, input; \n  printf(\"The array is\\n\");\n  for (int i = 0; i < MAX; i++)\n    printf(\"%d\\t\",  *(nums + i));\n  printf(\"\\nEnter a number and position:\");\n  scanf(\"%d %d\", &input, &pos );\n  insertion(nums, target, input, pos);\n  printf(\"The array is\\n\");\n  for (int i = 0; i < MAX + 1; i++)\n    printf(\"%d\\t\",  *(target + i));\n  return 0;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.6.c", "original_string": "float promedio(float *c){\n    float prom;\n    float acumulador = 0.0;\n    for (int i = 0; i < MAX_CALIFICACIONES - 1; i++)\n    {\n        acumulador += c[i];\n    }\n    prom = acumulador / MAX_CALIFICACIONES - 1;\n    prom = (prom + c[MAX_CALIFICACIONES - 1]) / 2;\n    return prom;\n}"}
{"author": "dle2005", "file": "File_Structure__ftlmgr.7.c", "original_string": "void insertPage(int ppn, char *sectordata, char *sparedata) {\n    memset(pagebuf, (char)0xFF, PAGE_SIZE);\n    memcpy(pagebuf, sectordata, strlen(sectordata));\n    memcpy(pagebuf + SECTOR_SIZE, sparedata, strlen(sparedata));\n    dd_write(ppn, pagebuf);\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example21.0.c", "original_string": "int main()\n{\n    int num,n;\n    printf(\"artt\u0131rmak istedi\u011finiz de\u011feri giriniz:\\n\");\n    scanf(\"%d\",&n);\n    printf(\"hangi de\u011ferden itibaren artt\u0131rmak istedi\u011finizi giriniz:\\n\");\n    scanf(\"%d\",&num);\n    sum(num,n);\n}"}
{"author": "kalpa96", "file": "Struct__store.0.c", "original_string": "int main() {\n    int i;\n    printf(\"Enter information of students:\\n\");\n    for (i=0;i<5;++i) {\n        s[i].no = i+1;\n        printf(\"\\nStudent 0%d\\n\", s[i].no);\n        printf(\"Enter ID number : \");\n        scanf(\"%d\",&s[i].id);\n        printf(\"Enter name : \");\n        scanf(\"%s\",&s[i].name);\n        printf(\"Enter age : \");\n        scanf(\"%d\",&s[i].age);\n        printf(\"Enter address : \");\n        scanf(\"%s\",&s[i].address);\n        printf(\"Enter marks : \");\n        scanf(\"%f\",&s[i].marks);\n    }\n    printf(\"Displaying Information:\\n\\n\");\n    for (i=0;i<5;++i){\n        printf(\"\\nStudent : %d\\n\",i+1);\n        printf(\"ID number : %d\\n\",s[i].id);\n        printf(\"Name : \");\n        puts(s[i].name);\n        printf(\"Age : %d\\n\",s[i].age);\n        printf(\"Address : \");\n        puts(s[i].address);\n        printf(\"Marks: %.1f\",s[i].marks);\n        printf(\"\\n\");\n    }\n    return 0;\n}"}
{"author": "behergue", "file": "Operating_Systems__myFS.7.c", "original_string": "void myFree(MyFileSystem *myFileSystem)\n{\n    int i;\n    close(myFileSystem->fdVirtualDisk);\n    for(i = 0; i < MAX_NODES; i++) {\n        free(myFileSystem->nodes[i]);\n        myFileSystem->nodes[i] = NULL;\n    }\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__carro.6.c", "original_string": "int main(int argc, char **argv)\n{\n  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n  glutInitWindowPosition(50, 100);\n  glutInitWindowSize(400, 400);\n  glutInit(&argc, argv);\n  glutCreateWindow(\"Transforma\u00e7\u00f5es Geom\u00e9tricas - Transla\u00e7\u00e3o\");\n  init();\n  glutDisplayFunc(display_function);\n  glutSpecialFunc(tecladoEspecial);\n  glutMainLoop();\n  return 0;\n}"}
{"author": "2security", "file": "Matrix__37DeterminantOfMatrix.2.c", "original_string": "float deterMat(float **mat,int r,int c)\n    {\n    int i,j,k;\n    float det,ratio;\n    for(i = 0; i < r; i++)\n        {\n            for(j = 0; j < c; j++)\n                {\n                    if(j>i)\n                        {\n                        ratio = mat[j][i]/mat[i][i];\n                        for(k = 0; k < r; k++)\n                                mat[j][k] -= ratio * mat[i][k];\n                        }\n                }\n            }\n        det = 1; \n        for(i = 0; i < r; i++)\n            det *= mat[i][i];\n        return det;\n        }"}
{"author": "mehedi9021", "file": "Data_Structure__delete_node_from_DLL_any_positn.2.c", "original_string": "void displayList()\n{\n    struct node * temp;\n    int n = 1;\n    if(head == NULL)\n    {\n        printf(\"List is empty.\\n\");\n    }\n    else\n    {\n        temp = head;\n        printf(\"DATA IN THE LIST:\\n\");\n        while(temp != NULL)\n        {\n            printf(\"DATA of %d node = %d\\n\", n, temp->data);\n            n++;\n            temp = temp->next;\n        }\n    }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__string_concate.0.c", "original_string": "void StrcatX(char *Src, char *Dest)\n{\n    if( (Src == NULL) || (Dest == NULL)   )\n    {\n        return;\n    }\n    while(*Src != '\\0')    \n    {\n        Src++;               \n    }\n    *Src=' ';\n    Src++;\n   while(*Dest != '\\0')\n   {\n       *Src = *Dest;\n       Dest++;\n       Src++;\n   }\n    *Dest = '\\0';\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__string_concate.1.c", "original_string": "int main()\n{\n    char arr[30] = {'\\0'};   \n    char brr[30] = {'\\0'};   \n    printf(\"Please enter first string\\n\");\n    scanf(\"%[^'\\n']s\",arr);\n    printf(\"Please enter second string\\n\");\n    scanf(\" %[^'\\n']s\",brr);\n    StrcatX(arr,brr);       \n    printf(\"String after concatination %s\\n\",arr);\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__DemoFOTAUpdateWorkflow0.5.c", "original_string": "static bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)\n{\n  switch (instance->__currentState)\n  {\n    case DemoFOTAUpdateWorkflowEngine_idle__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          printf(\"Cannot handle firmware over-the-air update request (missing network connection)\\n\");\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_connected__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) != 0) \n          {\n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;\n            instance->updateInfo.version = (*((char **)((arguments[0]))));\n            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) \n            {\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) \n            {\n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) == 0) \n          {\n            printf(\"Ignoring firmware over-the-air update request to version %s as this version is already running\\n\", (*((char **)((arguments[0])))));\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_downloading__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) \n          {\n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) \n            {\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) \n            {\n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_restarting__state:\n    {\n      switch (event)\n      {\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return true;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_10.2.c", "original_string": "void push(struct stack* stk, char elem){\n    if(StackOverflow(stk))\n    {\n        printf(\"%d\\n\", 999);\n        return;\n    }\n    stk->top++;\n    stk->A[stk->top]=elem;\n}"}
{"author": "0712023", "file": "Arduino-Mood-Light-DIY-kit__Chapter2_Sensor.3.c", "original_string": "void temp_set() {\n  int celsius = dht.readTemperature();  \n  if ( celsius < temp_1 ) {  \n    r = 0;  \n    g = 0;  \n    b = 255;  \n  }\n  else if ( temp_1 <= celsius && celsius < temp_2 ) {  \n    r = 0;\n    g = 255;\n    b = 0;\n  }\n  else if ( celsius >= temp_2 ) {  \n    r = 255;\n    g = 0;\n    b = 0;\n  }\n}"}
{"author": "augustogunsch", "file": "jack-compiler__os.8.c", "original_string": "CLASS* mkmemory(CLASS* os) {\n    CLASS* memclass = mkosclass(os, \"Memory\");\n    adddec(memclass, function, \"int\", \"peek\");\n    adddec(memclass, function, \"void\", \"poke\");\n    adddec(memclass, function, \"Array\", \"alloc\");\n    adddec(memclass, function, \"void\", \"deAlloc\");\n    return memclass;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.9.c", "original_string": "void imprimir_asistencias(const int posicion){\n    printf(\"Asistencias: \");\n    for (int i = 0; i < MAX_ASISTENCIA-1; i++)\n    {\n        if (lista_estudiantes[posicion].asistencias[i] == 1)\n            printf(\"%s\", \"A, \");    \n        else \n            printf(\"%s\", \"F, \");         \n    }\n    (lista_estudiantes[posicion].asistencias[MAX_ASISTENCIA-1] == 1)?printf(\"%s\", \"A\"):printf(\"%s\", \"F\");\n    printf(\"\\n\");\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__MergeSort.4.c", "original_string": "void merge_sort(int a[50],int p,int r)\n        {\n         int q;\n         count++;\n     if(p<r)\n       { \n             count++;\n             q=(p+r)/2;\n             count++;\n             merge_sort(a,p,q);\n             count++;\n             merge_sort(a,q+1,r);\n             count++;\n             merge(a,p,q,r);\n             count++;\n            }\n           }"}
{"author": "dle2005", "file": "Algorithm__Kruskal.6.c", "original_string": "void kruskal(int n, int m, set_of_edges *E, set_of_edges *F) {\n    int i, j;\n    set_pointer p, q;\n    edge e;\n    qsort(E, num_of_Edges, sizeof(edge), compare);\n    initial(num_of_Vertex);\n    while(n < num_of_Vertex) {\n        e.ui = E[m].ui;\n        e.uj = E[m].uj;\n        e.distance = E[m].distance;\n        i = e.ui;\n        j = e.uj;\n        p = find(i);\n        q = find(j);\n        if(!equal(p, q)) {\n            merge(p, q);\n            F[n-1].ui = e.ui;\n            F[n-1].uj = e.uj;\n            F[n-1].distance = e.distance;\n            n++;\n        }\n        m++;\n    }\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__server3.0.c", "original_string": "int main()\n{\n    fd_set master, read_fds;\n    int fdmax, i;\n    int sockfd = 0;\n    struct sockaddr_in server_addr, client_addr;\n    FD_ZERO(&master);\n    FD_ZERO(&read_fds);\n    server_set_up(&sockfd, &server_addr);\n    FD_SET(sockfd, &master);\n    fdmax = sockfd;\n    while (1)\n    {\n        read_fds = master;\n        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)\n        {\n            perror(\"select\");\n            exit(4);\n        }\n        for (i = 0; i <= fdmax; i++)\n        {\n            if (FD_ISSET(i, &read_fds))\n            {\n                if (i == sockfd)\n                    connection_accept(&master, &fdmax, sockfd, &client_addr);\n                else\n                    send_recv(i, &master, sockfd, fdmax);\n            }\n        }\n    }\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-tree.14.c", "original_string": "void freetree(CLASS* c) {\n    free(c->debug);\n    if(c->vardecs != NULL)\n        freeclassvardecs(c->vardecs);\n    if(c->subroutdecs != NULL)\n        freesubroutdecs(c->subroutdecs);\n    CLASS* next = c->next;\n    free(c);\n    if(next != NULL)\n        freetree(next);\n}"}
{"author": "behergue", "file": "Operating_Systems__leds_user.1.c", "original_string": "void rotativo(){\n    char  leds[] = \"0\";\n    FILE * file;\n    int i = 1;\n    while(1){\n        file = fopen(PATH, \"r+\");\n        sprintf(leds, \"%d\", i);\n        fwrite(leds, sizeof(char), strlen(leds), file);\n        printf(\"He encendido el led %s\\n\", leds);\n        fclose(file);\n        sleep(1);\n        i = (i%3) + 1;\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_DLL.0.c", "original_string": "int main()\n{\n    printf(\"Linked list functions\\n\");\n    int choice;\n    printf(\"1.implementation\\n\");\n    printf(\"2.display\\n\");\n    printf(\"3.count\\n\");\n    printf(\"4.delete the element from the beginning position \\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    while(choice!=6)\n    {\n    switch(choice)\n    {\n    case 1:printf(\"implementation \\n\");\n    create();\n    break;\n    case 2:printf(\"display\\n\");\n    display();\n    break;\n    case 3:printf(\"count the element in linked list\\n\");\n    count();\n    break;\n    case 4:printf(\"delete the element from the beginning position \\n\");\n    delete_beg();\n    break;\n    case 5:printf(\"exit\\n\");\n    exit(0);\n    break;\n    default: printf(\"wrong choice \\n\");\n    break;\n    }\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    }\n}"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio1.0.c", "original_string": "void *func1 (void *arg){\n    int suma = 1;\n    int size=(int) arg;\n    for(int i = 1; i < size; i++){\n        suma = suma * (int) arg;\n        arg--;\n    }\n    printf(\"Soy el thread 1 y estoy calculando el factorial de %d que es: %d \\n\", size, suma);\n    pthread_exit(NULL);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler2.0.c", "original_string": "void InsertFirst(PPNODE Head, PPNODE Tail, int value)\n{\n    PNODE newn = NULL;\n    newn = (PNODE)malloc(sizeof(NODE));\n    newn->data = value;\n    newn->next = NULL;\n    if((*Head == NULL) && (*Tail == NULL))\n    {\n        *Head = newn;\n        *Tail = newn;\n    }\n    else\n    {\n        newn->next = *Head;\n        *Head = newn;\n    }\n    (*Tail)->next = *Head;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ili9341_ext.10.c", "original_string": "static void ili9341_rect_draw(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint32_t color)\n{\n    static uint8_t data[32];\n    set_addr_window(x, y, x + width - 1, y + height - 1);\n    for(int i = 0; i < 16; i++)\n    {\n       data[i*2] = color >> 8;\n       data[i*2+1] = color;\n    }\n    nrf_gpio_pin_set(ILI9341_DC_PIN);\n    uint32_t bytes_left = height * width * 2;\n    do\n    {\n        if(bytes_left > 32)\n        {\n            spi_write(data, sizeof(data));\n            bytes_left -= 16;\n        }\n        else\n        {\n           spi_write(data, bytes_left);\n           bytes_left = 0;\n        }\n    }while(bytes_left > 0); \n    nrf_gpio_pin_clear(ILI9341_DC_PIN);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__15_Dowhile.0.c", "original_string": "void Columna(int pibote)\n{\n    int i = 1;\n    do\n    {\n        if(i >= 28){\n            if(i >= (28 + pibote) && i <= 34 - pibote){\n            printf(\" \");\n        }else{\n            printf(\"A\");\n        }\n        }else{\n            printf(\" \");\n        }\n        ++i;\n    }while(i <= 34);\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_37.2.c", "original_string": "int buscarMenorValor(int j) {\n    int valorAAssumirPosicao = vetor[j];\n    posicaoReporNumero = NULL;\n    for (int i = j; i < 11; i++) {\n        if (valorAAssumirPosicao > vetor[i]) {\n            valorAAssumirPosicao = vetor[i];\n            posicaoReporNumero = i;\n        }\n    }\n    return valorAAssumirPosicao;\n}"}
{"author": "dle2005", "file": "Algorithm__Optimal_Binary_Search_Trees_v2.3.c", "original_string": "void main() {\n    int n;\n    float minavg;\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"\\n\");\n    float *p = (float *)malloc(sizeof(float) * (n + 1));\n    int **R = (int **)malloc(sizeof(int *) * (n + 2));\n    for(int i = 0; i < n + 2; i++)\n        R[i] = (int *)malloc(sizeof(int) * (n + 1));\n    for(int i = 1; i <= n; i++) {\n        printf(\"Key[%d] = \", i);\n        scanf(\"%f\", &p[i]);\n    }\n    printf(\"\\n\");\n    optsearchtree(n, p, &minavg, R);\n    printf(\"minavg = %.3f\\n\\n\", minavg);\n    printf(\"R = \\n\");\n    for(int i = 1; i <= n + 1; i++) {\n        for(int j = 0; j <= n; j++)\n            printf(\"%d \", R[i][j]);\n        printf(\"\\n\");\n    }\n}"}
{"author": "sdukesameer", "file": "c__merge_arr_sort.1.c", "original_string": "void merge(int a[], int m, int b[], int n, int sorted[])\n{\n    int i,j,f;\n    for(i=0;i<m;i++)\n        sorted[i]=a[i];\n    for(j=m,i=0;j<m+n;j++,i++)\n        sorted[j]=b[i];\n    for(i=0;i<m+n;i++)\n    {\n        for(j=0;j<(m+n)-i-1;j++)\n        {\n            if(sorted[j]>sorted[j+1])\n            {\n                f=sorted[j];\n                sorted[j]=sorted[j+1];\n                sorted[j+1]=f;\n            }\n        }\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__longadd.4.c", "original_string": "void disp(nptr list)\n{\n    nptr i = list -> rlink;\n    while(i != list)\n    {\n        printf(\"%d\", i -> ele);\n        i = i -> rlink;\n    }\n    printf(\"\\n\");\n}"}
{"author": "paawankohli", "file": "DSA-LAB__createTrees.0.c", "original_string": "void insertNode(nptr root, int x, char path[])\n{\n    int i = 0;\n    nptr parent = NULL, curr = root;\n    while(curr && path[i])\n    {\n        parent = curr;\n        if (path[i] == 'L')\n            curr = parent -> lchild;\n        else if (path[i] == 'R')\n            curr = parent -> rchild;\n        i++;\n    }\n    if (curr == NULL || path[i] == '\\0')\n    {\n        if (path[i - 1] == 'R')\n            parent -> rchild = createNode(x);\n        else if (path[i - 1] == 'L')\n            parent -> lchild = createNode(x);\n    }\n    else\n        printf(\"Path error!\");\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__1-insertion_sort_list.0.c", "original_string": "void insertion_sort_list(listint_t **list)\n{\n    listint_t *p, *c, *aux;\n    if (list == NULL || *list == NULL || (*list)->next == NULL)\n        return;\n    c = (*list)->next;\n    aux = (*list)->next;\n    while (aux != NULL)\n    {\n        aux = aux->next;\n        while (c->prev != NULL)\n        {\n            if (c->prev->n > c->n)\n            {\n                p = c->prev;\n                p->next = c->next;\n                if (c->next)\n                    c->next->prev = p;\n                c->next = p;\n                c->prev = p->prev;\n                if (p->prev)\n                    p->prev->next = c;\n                p->prev = c;\n                if (p == *list)\n                    *list = c;\n                print_list(*list);\n            }\n            else\n                break;\n        }\n        c = aux;\n    }\n}"}
{"author": "sdukesameer", "file": "c__seq_search.1.c", "original_string": "int search(int arr[],int n,int val)\n{\n    for(int i=0;i<n;i++)\n    {\n        printf(\"Pass %d: Comparing %d with %d\\n\",i,arr[i],val);\n        if(arr[i]==val)\n            return i;\n    }\n    return -1;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__check_multiplebit_on_off.1.c", "original_string": "int main()\n{\n    int iNo = 0;\n    BOOL bRet = FALSE;\n    printf(\"Enter number\\n\");\n    scanf(\"%d\",&iNo);\n    bRet = CheckBit(iNo);\n    if(bRet == TRUE)\n    {\n        printf(\"10th,11th and 12th bit is on\\n\");\n    }\n    else\n    {\n        printf(\"One of the bit or all bits are Off\\n\");\n    }\n    return 0;\n}"}
{"author": "dle2005", "file": "Algorithm__Knapsack.0.c", "original_string": "void knapsack(index i, int profit, int weight) {\n    printf(\"index\\t = %d\\n\", i);\n    printf(\"profit\\t = %d\\n\", profit);\n    printf(\"weight\\t = %d\\n\", weight);\n    if((weight <= W) && (profit > maxprofit)) {\n        maxprofit = profit;\n        numbest = i;\n        for(int j = 1; j <= n; j++)\n            bestset[j] = include[j];\n        printf(\"maxprofit = %d\\n\", maxprofit);\n    }\n    if(promising(i, profit, weight)) {\n        include[i+1] = YES;\n        knapsack(i+1, profit+p[i+1], weight+w[i+1]);\n        include[i+1] = NO;\n        knapsack(i+1, profit, weight);\n    }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-central-scanner-with-whitelist__nrf_fstorage.8.c", "original_string": "static bool addr_is_within_bounds(nrf_fstorage_t const * p_fs,\n                                  uint32_t               addr,\n                                  uint32_t               len)\n{\n    return (   (addr           >= p_fs->start_addr)\n            && (addr + len - 1 <= p_fs->end_addr));\n}"}
{"author": "augustogunsch", "file": "jackc__vm-lines.4.c", "original_string": "void freeln(LINE* ln) {\n    for(int i = 0; i < ln->count; i++)\n        free(ln->tokens[i]);\n    free(ln->tokens);\n    free(ln);\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__tcpechoiterativeserver.0.c", "original_string": "void main(int argc,char*argv[])\n{\n    int sid,sid1,rval,itr,i;\n    struct sockaddr_in s,c;\n    char buffer[20];\n    int clen; \n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    printf(\"\\nEnter the number of clients to serve/ server iterations : \");\n    scanf(\"%d\",&itr);\n    sid=socket(AF_INET,SOCK_STREAM,6);\n    if(sid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=bind(sid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)\n    {\n        perror(\"BIND-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    rval=listen(sid,5);\n    if(rval==-1)\n    {\n        perror(\"LISTEN-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    for(i=1;i<=itr;i++)\n    {\n        clen=sizeof(c);\n        sid1=accept(sid,(struct sockaddr*)&c,&clen);\n        rval=recv(sid1,buffer,sizeof(buffer),0);\n        if(rval==-1)\n        {\n            perror(\"MSG-RCV-ERR:\");\n        }\n        else\n        {\n            printf(\"\\nClient request is %s\\n\",buffer);\n        }\n        rval=send(sid1,buffer,sizeof(buffer),0);\n        if(rval==-1)\n        {\n            perror(\"MSG-SND-ERR:\");\n        }\n        else    \n        {\n            printf(\"\\nResponse sent\\n\");\n        }\n        close(sid1);\n    }\n    close(sid);\n}"}
{"author": "davibernardos", "file": "DB-PJ__e20.4.c", "original_string": "int real(char caractere){\n    int numero;\n    switch(caractere){\n        case 48:\n        numero=0;\n        break;\n        case 49:\n        numero=1;\n        break;\n        case 50:\n        numero=2;\n        break;\n        case 51:\n        numero=3;\n        break;\n        case 52:\n        numero=4;\n        break;\n        case 53:\n        numero=5;\n        break;\n        case 54:\n        numero=6;\n        break;\n        case 55:\n        numero=7;\n        break;\n        case 56:\n        numero=8;\n        break;\n        case 57:\n        numero=9;\n        break;\n    }\n    return numero;\n}"}
{"author": "sdukesameer", "file": "dsa__list-del-rev.5.c", "original_string": "node* print(node* head)\n{\n    if(head==NULL)\n        return NULL;\n    else if(head->next==NULL)\n    {\n        printf(\"      STACK      \\n\");\n        return head;\n    }\n    else\n    {\n        printf(\"\\t%d\\n\",(print(head->next))->data);\n        return head;\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLL.2.c", "original_string": "nptr insertRight(nptr head, int x)\n{\n    if (head == NULL)\n        return createNode(x);\n    else\n    {\n        nptr curr = head;\n        while(curr -> right != NULL)\n            curr = curr -> right;\n        nptr temp = createNode(x);\n        curr -> right = temp;\n        temp -> left = curr;\n        return head;\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_end_DCLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Indexed.1.c", "original_string": "void add_file(int id,int size)\n{\n    int ct=ispossible(),i,j;\n    if(ct>=size)\n    {\n        d_array[pos][0]=id;\n        j=1;\n        for(i=1;i<16 && size>0;i++)\n        {\n            if(disk[i]==0)\n            {\n                disk[i]=id;\n                size--;\n                d_array[pos][j]=i;\n                j++;\n            }\n        }\n        pos++;\n    }\n    else\n    {\n        printf(\"\\nNot possible\");\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q3_reverselq.1.c", "original_string": "void insertf(nptr list,char* x)\n{\n    nptr temp=createNode();\n    strcpy(temp->ele,x);\n    if(!list->rlink)\n    {\n        list->rlink=temp;\n        temp->llink=list;\n        temp->rlink=NULL;\n        return;\n    }\n    (list->rlink)->llink=temp;\n    temp->llink=list;\n    temp->rlink=list->rlink;\n    list->rlink=temp;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es22.1.c", "original_string": "int minimo(int a[], int dim)\n    {\n    int valoreMinimo = a[0], locazione = 0, i;\n    for(i=0; i < dim; i++)\n    {\n        if ( a[i] < valoreMinimo ) \n        {\n            valoreMinimo = a[i];\n            locazione = i;\n        }\n    } \n    return locazione;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica3-2.1.c", "original_string": "void * suma(void * n){               \n    int *indiceLocal= (int *)n;            \n    int *suma = malloc(sizeof(int *));    \n    for (int i = 0; i < 5 ; i++){                               \n        int x = rand()%11;      \n        *suma = *suma + x; \n    }\n    if (pthread_mutex_lock(&mutex)){                  \n        printf(\"Error %d\", errno);\n        exit(EXIT_FAILURE);\n    }\n    indiceGlobal++; \n    printf(\"Hebra %ld con indice %d\\n\", pthread_self(), *indiceLocal);\n    printf(\"La suma en %d es %d\\n\", *indiceLocal, *suma); \n    if(*indiceLocal%2==0){ par = par + *suma; }                                              \n    else{ impar = impar + *suma; }                                                               \n    if (pthread_mutex_unlock(&mutex)){      \n        printf(\"Error %d\", errno);\n        exit(EXIT_FAILURE);\n    }\n    pthread_exit((void *)suma);                                           \n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__L.0.c", "original_string": "int main()\n{\n    int qtd, n, qtd_total, qtd100 = 0, qtd50 = 0, qtd25 = 0, qtd10 = 0, qtd5 = 0, qtd2 = 0, qtd1 = 0;\n    scanf (\"%i\", &qtd);\n    for (int i=0; i<qtd; i++)\n    {\n        scanf (\"%i\", &n);\n        while (n>=100)\n        {\n            n -= 100;\n            qtd100++;\n        }\n        if ((50<=n)&&(n<=99))\n        {\n            n -= 50;\n            qtd50++;\n        } \n        if ((25<=n)&&(n<=49))\n        {\n            n -= 25;\n            qtd25++;\n        }\n        while ((10<=n)&&(n<=24))\n        {\n            n -= 10;\n            qtd10++;\n        }\n        if ((5<=n)&&(n<=9))\n        {\n            n -= 5;\n            qtd5++;\n        }\n        while ((2<=n)&&(n<=4))\n        {\n            n -= 2;\n            qtd2++;\n        }\n        if (n==1)\n        {\n            n--;\n            qtd1++;\n        }\n        qtd_total = qtd100+qtd50+qtd25+qtd10+qtd5+qtd2+qtd1;\n        printf (\"%i notas\\n%i notas de 100\\n%i notas de 50\\n%i notas de 25\\n%i notas de 10\\n%i notas de 5\\n%i notas de 2\\n%i notas de 1\\n\", qtd_total, qtd100, qtd50, qtd25, qtd10, qtd5, qtd2, qtd1);\n        qtd_total = 0;\n        qtd100 = 0;\n        qtd50 = 0;\n        qtd25 = 0;\n        qtd10 = 0;\n        qtd5 = 0;\n        qtd2 = 0;\n        qtd1 = 0;\n    }\n    return 0;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__estructuras_dos.0.c", "original_string": "int main(){\n    e1.matricula = 123;\n    strcpy(e1.nombre, \"Juan Carlos\");\n    strcpy(e1.direccion_estudiante.calle, \"Vicente Guerrero\");\n    strcpy(e1.direccion_estudiante.numer_interior, \"2A\");\n    strcpy(e1.direccion_estudiante.numero_exterior, \"234\");\n    strcpy(e1.direccion_estudiante.colonia, \"Centro Historico\");\n    strcpy(e1.direccion_estudiante.municipio, \"Huajuapan\");\n    strcpy(e1.direccion_estudiante.entidad,\"Oaxaca\");\n    e1.direccion_estudiante.cp = 67000;\n    e1.calificaciones[0] = 10.0;\n    e1.asistencias[0] = 1;\n    printf(\"Datos del estudiante:\\n\");\n    printf(\"Direcci\u00f3n, calle: %s\", e1.direccion_estudiante.calle);\n    lista_estudiantes[0] = e1;\n    return 0;\n}"}
{"author": "DanielSalis", "file": "AED1__teste6.1.c", "original_string": "void remover(TipoLista* l){\n    if(l->tamanho == 0){\n        printf(\"lista vazia\\n\");\n    }else{\n        TipoElemento* aux = l->primeiro;\n        l->primeiro = l->primeiro->prox;\n        free(aux);\n        l->tamanho--;\n    }\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__StrassenMatrixMultiplication.0.c", "original_string": "void main()\n{\n  int a[2][2], b[2][2], c[2][2], i, j, p1, p2, p3, p4 , p5, p6, p7,az,bz,cz,d,e,f,g,h;\n  printf(\"Enter elements of first matrix: \");\n  for(i = 0;i < 2; i++)\n  {\n      for(j = 0;j < 2; j++)\n      {\n           scanf(\"%d\", &a[i][j]);\n      }\n  }\n  printf(\"Enter elements of second matrix: \");\n  for(i = 0; i < 2; i++)\n  {\n      for(j = 0;j < 2; j++)\n      {\n           scanf(\"%d\", &b[i][j]);\n      }\n  }\n  az=a[0][0];\n  bz=a[0][1];\n  cz=a[1][0];\n  d=a[1][1];\n  e=b[0][0];\n  f=b[0][1];\n  g=b[1][0];\n  h=b[1][1];\n  p1=az*(f-h);\n  p2=(az+bz)*h;\n  p3=(cz+d)*e;\n  p4=d*(g-e);\n  p5=(az+d)*(e+h);\n  p6=(bz-d)*(g+h);\n  p7=(az-cz)*(e+f);\n  c[0][0] = p5+p4-p2+p6;\n  c[0][1] = p1+p2;\n  c[1][0] = p3+p4;\n  c[1][1] = p1+p5-p3-p7;\n   printf(\"\\nAfter multiplication\\n\");\n   for(i = 0; i < 2 ; i++){\n      printf(\"\\n\");\n      for(j = 0;j < 2; j++)\n           printf(\"%d\\t\", c[i][j]);\n   }\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica2-3.3.c", "original_string": "int main(int argc, char const *argv[]){\n    Vector *v = malloc(sizeof(Vector));                 \n    if (argc != 2){                                     \n        printf(\"Error, llame al programa asi:\\n\");\n        printf(\"./ej3 2 o /ej3 5\\n\");\n        exit(EXIT_FAILURE);\n    }\n    v->hebras = atoi(argv[1]);                          \n    v->i = 0;                                           \n    if (v->hebras != 2 && v->hebras != 5){              \n        printf(\"Error, llame al programa asi:\\n\");\n        printf(\"./ej3 2 o /ej3 5\\n\");\n        exit(EXIT_FAILURE);\n    }\n    v->vector = (int *)malloc (10*sizeof(int));         \n    rellenaVector(v->vector);                           \n    imprimeVector(v->vector);                           \n    pthread_t thread[v->hebras];                        \n    int *sumaLinea, suma = 0;                           \n    printf(\"Se pasaran a crear %d hebras para sumar los valores del vector\\n\", v->hebras);\n    for (int i = 0; i < v->hebras; i++){                \n        if(pthread_create(&(thread[i]), NULL, (void*) sumaVector, (void*) v)){\n            printf(\"Error en la creacion de la hebra. Codigo de error %d\\n\", errno);\n            exit(EXIT_FAILURE);\n        }\n        if(pthread_join(thread[i], (void**) &sumaLinea)){\n            printf(\"Error al esperar la hebra. Codigo de error %d\\n\", errno);\n            exit(EXIT_FAILURE);\n        } \n        suma = suma + *sumaLinea;                       \n    }\n    printf(\"La suma de los numeros de todos los valores es: %d\\n\", suma);\n    exit(EXIT_SUCCESS);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader0.8.c", "original_string": "static bool loadFirmwareUpdateInfoFile(char *updateInfoString, size_t updateInfoStringSize)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"r\");\n  if (updateInfoFile == NULL) \n  {\n    return false;\n  }\n  memset(updateInfoString, 0, updateInfoStringSize);\n  while (isWhitespace(updateInfoString))\n  {\n    if (fgets(updateInfoString, ((int32_t) updateInfoStringSize), updateInfoFile) == NULL) \n    {\n      fclose(updateInfoFile);\n      return false;\n    }\n  }\n  fclose(updateInfoFile);\n  return true;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__double_insert_at_any_position.1.c", "original_string": "void createList(int n)\n{\n    int i, data;\n    struct node *newNode;\n            head = (struct node *)malloc(sizeof(struct node));\n            printf(\"Enter data of 1 node: \");\n            scanf(\"%d\", &data);\n            head->data = data;\n            head->prev = NULL;\n            head->next = NULL;\n            last = head;\n            for(i=2; i<=n; i++)\n            {\n                newNode = (struct node *)malloc(sizeof(struct node));\n                    printf(\"Enter data of %d node: \", i);\n                    scanf(\"%d\", &data);\n                    newNode->data = data;\n                    newNode->prev = last;\n                    newNode->next = NULL;\n                    last->next = newNode;\n                    last = newNode;\n            }\n        printf(\"\\nDOUBLY LINKED LIST CREATED SUCCESSFULLY\\n\");\n    }"}
{"author": "SugumaranEvil", "file": "Datastructure__stack.2.c", "original_string": "int pop(void)\n{\n    int data_input;\n    if(stack.data == -1){\n        printf(\"...............Stack is empty.............\\n\");\n        return 0;\n    }else{\n        data_input = stack.stack[stack.data];\n        printf(\"Deleted Data = %d\\n\",stack.stack[stack.data]);\n        stack.data = stack.data - 1;\n    }\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__adivina.3.c", "original_string": "void jugar(){\n    int alea = generar_aleatorio(INI, FIN);\n    printf(\"Adivina el n\u00famero entre %d - %d: \", INI, FIN);\n    while(1) {\n        int respuesta;\n        scanf(\"%d\", &respuesta);\n        if( respuesta == alea){\n            printf(\"Felicidades!!! Adivinaste...\\n\");\n            printf(\"Presione una tecla para continuar...\");\n            fflush(stdin);\n            getchar();\n            break;\n        } else {\n            if( respuesta < alea){\n                printf(\"El valor es m\u00e1s grande\\n\");\n            } else {\n                printf(\"El valor es m\u00e1s peque\u00f1o\\n\");\n            }\n        }\n        printf(\"Intenta de nuevo adivinar el n\u00famero entre %d - %d: \", INI, FIN);\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__bfs.0.c", "original_string": "void input(graph* g){\n    int i,j,f,x=1;\n    while(x){\n        printf(\"\\nEnter the number of vertices: \");\n        scanf(\"%d\",&g->n);\n        if(g->n>0)\n            x=0;\n        else\n            printf(\"Invalid input. Try again.\\n\");\n    }\n    g->arr=(int**) malloc(sizeof(int*)*g->n);\n    for(i=0;i<g->n;i++)\n        g->arr[i]=(int*)malloc(sizeof(int)*g->n);\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++)\n            g->arr[i][j]=-1;\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++){\n            if(g->arr[i][j]==1 || g->arr[i][j]==0)\n                continue;\n            if(i==j){\n                g->arr[i][j]=0;\n                continue;\n            }\n            x=1;\n            while(x){\n                printf(\"Is there an edge between %c and %c (Yes=1 & No=0): \",'A'+i,'A'+j);\n                scanf(\"%d\",&f);\n                if(f==0 || f==1){\n                    g->arr[i][j]=f;\n                    g->arr[j][i]=f;\n                    x=0;\n                }\n                else\n                    printf(\"Invalid input. Try again.\\n\");\n            }\n        }\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_pwr_ex.5.c", "original_string": "HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)\n{\n  uint32_t tickstart = 0U;\n  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));\n  __HAL_RCC_PWR_CLK_ENABLE();\n  __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);\n  tickstart = HAL_GetTick();\n  while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))\n  {\n    if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)\n    {\n      return HAL_TIMEOUT;\n    } \n  }\n  return HAL_OK;\n}"}
{"author": "Mr-JoE1", "file": "C-Tasks-for-newbies__main6.0.c", "original_string": "int main()\n{\n    int num;\n    int count_sevens = 0;\n    int units;\n    printf(\"Enter A Number : \");\n    scanf(\"%d\" , &num);\n    while(num != 0)\n    {\n        units = abs(num % 10);                                          \n        if(units == 7)                                                  \n            count_sevens++;                                             \n        num /= 10;                                                      \n    }\n    printf(\"\\nNumber Of Sevens = %d\\n\" , count_sevens);\n    return 0;\n}"}
{"author": "earth429", "file": "mulpre__numComp.1.c", "original_string": "int numComp(struct NUMBER *a, struct NUMBER *b) {\n    int sa = getSign(a);\n    int sb = getSign(b);\n    int i;\n    if(sa > sb){ \n        return 1;\n    }\n    if(sa < sb){ \n        return -1;\n    }\n    if(sa == 1 && sb == 1){ \n        for (i = KETA - 1; i >= 0;i--){\n            if(a->n[i] > b->n[i]){ \n                return 1;\n            } else if(a->n[i] < b->n[i]){\n                return -1;\n            }\n        }\n        return 0; \n    }\n    if(sa == -1 && sb == -1){ \n        for (i = KETA - 1; i >= 0;i--){\n            if(a->n[i] > b->n[i]){ \n                return -1;\n            } else if(a->n[i] < b->n[i]){\n                return 1;\n            }\n        }\n        return 0; \n    }\n    return 100;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CDLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n}"}
{"author": "fikepaci", "file": "binary_trees__121-avl_insert.0.c", "original_string": "size_t height(const binary_tree_t *tree)\n{\n    if (tree != NULL)\n    {\n        size_t l = 0, r = 0;\n        l = tree->left ? 1 + binary_tree_height(tree->left) : 1;\n        r = tree->right ? 1 + binary_tree_height(tree->right) : 1;\n        return ((l > r) ? l : r);\n    }\n    return (0);\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example21.1.c", "original_string": "void sum (int num,int n)\n{   \n    num++;\n    i++;\n    if(i <= n)\n    {\n       sum(num,n);    \n    }\n    else\n    {\n         printf(\"\\nSum is %d\\n\",num);\n    }   \n}"}
{"author": "paawankohli", "file": "DSA-LAB__q32.1.c", "original_string": "void add(int e,QUEUE* q)\n{\n    if(q->rear==MAX-1)\n    {\n        printf(\"QUEUE FULL\\n\");\n        return;\n    }\n    q->rear+=1;\n    q->arr[q->rear]=e;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__circularLinkedList.4.c", "original_string": "struct Node *deleteFirst(struct Node *head)\n{\n     struct Node *ptr = head;\n     struct Node *p = head->next;\n     while (p->next != head)\n     {\n          p = p->next;\n     }\n     head = head->next; \n     p->next = head;    \n     free(ptr);         \n     return head;       \n}"}
{"author": "andi-s0106", "file": "binary_trees__12-binary_tree_leaves.0.c", "original_string": "size_t binary_tree_leaves(const binary_tree_t *tree)\n{\n    size_t leaves;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    leaves = 0;\n    leaves = count_leaves(tree, leaves);\n    return (leaves);\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__robo.7.c", "original_string": "int main(int argc, char **argv)\n{\n  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n  glutInitWindowPosition(50, 100);\n  glutInitWindowSize(400, 400);\n  glutInit(&argc, argv);\n  glutCreateWindow(\"Transforma\u00e7\u00f5es Geom\u00e9tricas - Transla\u00e7\u00e3o\");\n  init();\n  glutDisplayFunc(display_function);\n  glutSpecialFunc(tecladoEspecial);\n  glutMainLoop();\n  return 0;\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Calculates_the_Length_of_A_Single_Linked_List.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"Press 1 for Creation or else Press 0 for Termination:\");\n    scanf(\"%d\",&choice);\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the Data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->ptr = NULL;\n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->ptr = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want ot enter more?(1/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_nodes(temp);\n    length(temp);\n    getch();\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__display_LL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "earth429", "file": "mulpre__gcd.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a, b, c;\n    int return_val;\n    int x, y;\n    x = 1357911;\n    y = 246810;\n    setInt(&a, x);\n    setInt(&b, y);\n    return_val = gcd(&a, &b, &c);\n    dispNumberZeroSuppress(&c);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n    return 0;\n}"}
{"author": "dishanp", "file": "DSA__q6.1.c", "original_string": "int main()\n{\n   printf(\"Enter 1st distance\\n\");\n   printf(\"Enter Kilometres: \");\n   scanf(\"%d\", &d1.km);\n   printf(\"Enter Metres: \");\n   scanf(\"%f\", &d1.m);\n   printf(\"\\nEnter 2nd distance\\n\");\n   printf(\"Enter Kilometres: \");\n   scanf(\"%d\", &d2.km);\n   printf(\"Enter Metres: \");\n   scanf(\"%f\", &d2.m);\n   result.km = d1.km + d2.km;\n   result.m = d1.m + d2.m;\n   convert(&result);\n   printf(\"\\nSum of distances = %dkm %.1fm\\n\", result.km, result.m);\n   return 0;\n}"}
{"author": "behergue", "file": "Computer_Structure__timer1.0.c", "original_string": "int tmr_set_prescaler(int p, int  value)\n{\n    int offset = p*8;\n    value &= 0xFF;\n    if (p < 0 || p > 3)\n        return -1;\n    rTCFG0 &= ~(0xFF << offset);\n    value <<= offset;\n    rTCFG0 |= value;\n    return 0;\n}"}
{"author": "mandarvu", "file": "msc__problem104.2.c", "original_string": "int main() {\n  char origin[MAX], reverse[MAX];\n  printf(\"Enter a string (20): \");\n  scanf(\"%[^\\n]%*c\", origin);\n  string_reverse(origin, reverse);\n  if (pal_chk(origin, reverse))\n    printf(\"The string ' %s ' is a Palindrome\\n\", origin);\n  else\n    printf(\"The string ' %s ' is not a Palindrome\\n\", origin);\n  return 0;\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__stack.1.c", "original_string": "int push(void)\n{\n    int data_input;\n    if(stack.data == (MAXSIZE - 1)){\n        printf(\"..........Stack is full...........\\n\");\n        return 0;\n    }else{\n        printf(\"Enter the Data to push\\n\");\n        scanf(\"%d\",&data_input);\n        stack.data = stack.data + 1;\n        stack.stack[stack.data] = data_input;\n    }\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_chibios.17.c", "original_string": "bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   msg_t msg;\n   if(timeout == 0)\n   {\n      msg = chSemWaitTimeout(semaphore, TIME_IMMEDIATE);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      msg = chSemWaitTimeout(semaphore, TIME_INFINITE);\n   }\n   else\n   {\n      msg = chSemWaitTimeout(semaphore, OS_MS_TO_SYSTICKS(timeout));\n   }\n   if(msg == MSG_OK)\n      return TRUE;\n   else\n      return FALSE;\n}"}
{"author": "sdukesameer", "file": "c__rec_merge_sort.2.c", "original_string": "void merge_sort(int i, int j) {\n    int m;\n    if (i < j) {\n        m = (i + j) / 2;\n        merge_sort(i, m);\n        merge_sort(m + 1, j);\n        merge_array(i, m, m + 1, j);\n        printf(\"%d: \",c++);\n        printArray();\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CDLL.0.c", "original_string": "int main()\n{\n    int  choice;\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.insert the element at the beginning position in the linked list\\n\");\n    printf(\"5.insert the element at the last position in the linked list\\n\");\n    printf(\"6.insert the element at any position in the linked list\\n\");\n    printf(\"7.delete the element from the beginning position of linked list\\n\");\n    printf(\"8.delete the element from the last position of linked list\\n\");\n    printf(\"9.delete the element from any position of linked list\\n\");\n    printf(\"10.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=11)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4: printf(\"insert the element at the beginning position in the linked list\\n\");\n            insert_beg();\n            break;\n            case 5:printf(\"insert the element at the last position in the linked list\\n\");\n            insert_end();\n            break;\n            case 6:printf(\"insert the element at any position in the linked list\\n\");\n            insert_at_pos();\n            break;\n            case 7:printf(\"delete the element from the beginning position of linked list\\n\");\n            delete_beg();\n            break;\n            case 8:printf(\"delete the element from the last position of linked list\\n\");\n            delete_end();\n            break;\n            case 9:printf(\"delete the element from any position of linked list\\n\");\n            delete_at_pos();\n            break;\n            case 10:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "ankitraj311", "file": "450_babbar__13_kadanes_algorithms.2.c", "original_string": "int main()\n{\n  int arr1[] = {-2,-3,4,-1,-2,1,5,-3}, no,j=0;\n  int size_arr1 = sizeof(arr1)/sizeof(int);\n  array_print(arr1,size_arr1);\n  int sum = cyclic_rotate(arr1,size_arr1);\n  printf(\"Sum is %d\",sum);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__stack.0.c", "original_string": "void Push(PPNODE Head, int value)   \n{\n    PNODE newn = (PNODE) malloc(sizeof(NODE));\n    newn->data = value;\n    newn->next = NULL;\n    if(*Head == NULL)\n    {\n        *Head = newn;\n    }\n    else\n    {\n        newn->next = *Head;\n        *Head = newn;\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__3.3.c", "original_string": "double perimetro(pontos_t *poligono, int n)\n{\n    double perimetro = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (i == n-1)\n        {\n            perimetro += sqrtf(powf(poligono[i].x - poligono[0].x,2) + powf(poligono[i].y - poligono[0].y,2));\n        }\n        else\n        {\n            perimetro += sqrtf(powf(poligono[i].x - poligono[i+1].x,2) + powf(poligono[i].y - poligono[i+1].y,2));\n        }\n    }\n    return perimetro;\n}"}
{"author": "deessee0", "file": "Appunti-C__terzo0.0.c", "original_string": "void rimuoviDuplicati(int a[], int* dim_a)\n{\n    for(int i=0;i<*dim_a;i++)\n    {\n        for(int j=i+1; j<*dim_a; j++)\n        {\n            if(a[i]==a[j])\n            {\n                for(int k=j; k<*dim_a-1;j++)\n                {\n                    a[k] = a[k+1];\n                }\n                *dim_a -= 1;\n                j--;\n            }\n        }\n    }\n}"}
{"author": "dishanp", "file": "DSA__q72.5.c", "original_string": "int main()\n{\n    int n, key;\n    printf(\"Number of elements : \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n    {\n        scanf(\"%d\", &A[i]);\n    }\n    first = create(A, n);\n    convert(first);\n    display(first);\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__Boyre_MooreMethod.0.c", "original_string": "int Last_Occurence(char P[],int m,char c)\n{\n    int i,k=0;\n    for(i=m-1;i>=0;i--)\n    {\n        if(P[i]==c)\n        k=i;\n    }\n    return(k);\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__4menu_driven.1.c", "original_string": "void sumofdigits(void)\n{\n    int n,sum=0,d;\n    printf(\"enter a number\");\n    scanf(\"%d\",&n);\n    while(n>0)\n    {\n        d=n%10;\n        sum+=d;\n        n=n/10;\n    }\n    printf(\"%d\",sum);\n}"}
{"author": "zjzj-zz", "file": "4s_Numerical__Gauss_Seidel_General.3.c", "original_string": "int main(){ \n    double a[N][N] = { { 5.0, 1.0, 1.0 }, { 1.0, 4.0, 1.0 }, { 2.0, 1.0, 3.0 } }; \n    double b[N] = { 10.0, 12.0, 13.0 };\n    double x[N], y[N];\n    int c = 0;\n    initial_value( x );\n    while( Convergence_test( x, y) ){ \n        Seidel( x, y, a, b );\n        c++; \n    }\n    printf(\"[%3d\u9031\u76ee] \", c ); \n    for( i = 0; i < N; i++) printf(\" x%d = %.10f \", i+1, x[i] );\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "SugumaranEvil", "file": "TLPI__rcv_shm.0.c", "original_string": "int main()\n{\n    char string[100];\n    int shmid;\n    char *data;\n    shmid = shmget(1000, 100, 0);\n    perror(\"shmget \");\n    data = shmat(shmid, NULL, 0);\n    perror(\"shmat\");\n    strcpy(string, data);\n    perror(\"strcpy\");\n    printf(\"Data ==> %s\\n\",string);\n    shmdt(data);\n    perror(\"shmat\");\n}"}
{"author": "jose120918", "file": "binary_trees__16-binary_tree_is_perfect.3.c", "original_string": "int binary_tree_is_perfect(const binary_tree_t *tree)\n{\n    int height;\n    int _nodes;\n    if (tree == NULL)\n        return (0);\n    height = scale(tree);\n    _nodes = tree_size(tree);\n    if (_pow(2, height + 1) - 1 == _nodes)\n        return (1);\n    return (0);\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.4.c", "original_string": "void insertion(int val) {\n        int flag, i;\n        struct btreeNode *child;\n        flag = setValueInNode(val, &i, root, &child);\n        if (flag)\n                root = createNode(i, child);\n  }"}
{"author": "augustogunsch", "file": "jack-compiler__os.1.c", "original_string": "void adddec(CLASS* c, SUBROUTCLASS subroutclass, char* type, const char* name) {\n    SUBROUTDEC* dec = (SUBROUTDEC*)malloc(sizeof(SUBROUTDEC));\n    dec->class = c;\n    dec->subroutclass = subroutclass;\n    dec->name = ezheapstr(name);\n    dec->type = ezheapstr(type);\n    dec->next = c->subroutdecs;\n    c->subroutdecs = dec;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_DCLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad30.1.c", "original_string": "int czyTrojkat(float a, float b, float c){\n    float max;\n    float middle;\n    float min;\n    if(a <= 0 || b <= 0 || c <= 0){\n        return 0;\n    }\n    if(a >= b && a >= c ) {\n        max = a;\n        if(b >= c) {\n            min = c;\n            middle = b;\n        } else {\n            min = b;\n            middle = c;\n        }\n    } else if ( b >= c) {\n        max = b;\n        if(a >= c) {\n             min = c;\n             middle = b;\n        } else {\n             min = a;\n             middle = c;\n        }\n    } else {\n        max = c;\n        if(a >= b) {\n             min = b;\n             middle = a;\n        } else {\n             min = a;\n             middle = b;\n        }\n    }\n    if(min + middle <= max){\n        return 0;\n    }\n    return 1;\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__if-else.0.c", "original_string": "int main ()\n{\n    int a,b,c;\n    printf(\"bir say\u0131 giriniz:\");\n    scanf(\"%d\",&a);\n    printf(\"bir say\u0131 giriniz:\");\n    scanf(\"%d\",&b);\n    printf(\"bir say\u0131 giriniz:\");\n    scanf(\"%d\",&c); \n    if(a<=b && a<=c) \n    {\n            printf(\"a b ve c ye e\u015fit veya k\u00fc\u00e7\u00fckt\u00fcr\");\n        }\n    if(a>=b && a>=c)\n        {\n            printf(\"a b ve c ye e\u015fit veya b\u00fcy\u00fckt\u00fcr\");\n        }\n    return 0;\n    }"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sum_Of_All_Diagonals.2.c", "original_string": "int find_sum_counter(int matrix[R][C])\n{\n    int rows = R;\n    int columns = C;\n    int i, j, sum_counter = 0;\n    for(i=0; i<rows; i++)\n    {\n        for(j=columns-1; j>=0; j--)\n        {\n            if((i+j) == (columns-1))\n                sum_counter += matrix[i][j];\n            else\n                continue;\n        }\n    }\n    return sum_counter;\n}"}
{"author": "sdukesameer", "file": "dsa__cll-ins-sor-seq-del.3.c", "original_string": "node* search(node* head, int n)\n{\n    node* cll=head;\n    do\n    {\n        if(cll->data==n)\n            return cll;\n        cll=cll->next;\n    }\n    while(cll!=head);\n    return NULL;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_nus_c.1.c", "original_string": "void ble_nus_c_on_db_disc_evt(ble_nus_c_t * p_ble_nus_c, ble_db_discovery_evt_t * p_evt)\n{\n        ble_nus_c_evt_t nus_c_evt;\n        memset(&nus_c_evt,0,sizeof(ble_nus_c_evt_t));\n        ble_gatt_db_char_t * p_chars = p_evt->params.discovered_db.charateristics;\n        if (    (p_evt->evt_type == BLE_DB_DISCOVERY_COMPLETE)\n                &&  (p_evt->params.discovered_db.srv_uuid.uuid == BLE_UUID_NUS_SERVICE)\n                &&  (p_evt->params.discovered_db.srv_uuid.type == p_ble_nus_c->uuid_type))\n        {\n                for (uint32_t i = 0; i < p_evt->params.discovered_db.char_count; i++)\n                {\n                        switch (p_chars[i].characteristic.uuid.uuid)\n                        {\n                        case BLE_UUID_NUS_RX_CHARACTERISTIC:\n                                nus_c_evt.handles.nus_rx_handle = p_chars[i].characteristic.handle_value;\n                                break;\n                        case BLE_UUID_NUS_TX_CHARACTERISTIC:\n                                nus_c_evt.handles.nus_tx_handle = p_chars[i].characteristic.handle_value;\n                                nus_c_evt.handles.nus_tx_cccd_handle = p_chars[i].cccd_handle;\n                                break;\n                        default:\n                                break;\n                        }\n                }\n                NRF_LOG_DEBUG(\"NUS Service discovered at peer.\");\n                if (p_ble_nus_c->evt_handler != NULL)\n                {\n                        if (p_ble_nus_c->conn_handle != BLE_CONN_HANDLE_INVALID)\n                        {\n                                nus_c_evt.conn_handle = p_evt->conn_handle;\n                                nus_c_evt.evt_type    = BLE_NUS_C_EVT_DISCOVERY_COMPLETE;\n                                p_ble_nus_c->evt_handler(p_ble_nus_c, &nus_c_evt);\n                        }\n                }\n        }\n}"}
{"author": "ankitraj311", "file": "450_babbar__5_mv_-ive_one_side_with_failur.0.c", "original_string": "int main()\n{\n  int arr[100],no,j=0,temp=0,mid=0;\n  printf(\"Enter length of array\");\n  scanf(\"%d\",&no);\n  for(int i = 0; i<no; i++)\n  {\n    scanf(\"%d\",&arr[i]);\n  }\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n  if(no%2 == 0)\n  {\n   mid = no/2;\n  }\n  else\n  {\n    mid = (no-1)/2;\n  }\n  for(int i = no-1; i>=mid; i--)\n  {\n    if(arr[i]<0)\n    {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      j++;\n    }\n  }\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListDelete.5.c", "original_string": "int main(){\n     struct Node*head;\n     struct Node*second;\n     struct Node*third;\n     struct Node*fourth;\n     struct Node*fifth;\n     struct Node*sixth;\n     struct Node*seventh;\n     head = (struct Node *) malloc(sizeof(struct Node));\n     second = (struct Node *) malloc(sizeof(struct Node));\n     third = (struct Node *) malloc(sizeof(struct Node));\n     fourth = (struct Node *) malloc(sizeof(struct Node));\n     fifth = (struct Node *) malloc(sizeof(struct Node));\n     sixth = (struct Node *) malloc(sizeof(struct Node));\n     seventh = (struct Node *) malloc(sizeof(struct Node));\n     head->data=7;\n     head->next=second;\n     second->data=11;\n     second->next=third;\n     third->data=70;\n     third->next=fourth;\n     fourth->data=22;\n     fourth->next=fifth;\n     fifth->data=44;\n     fifth->next=sixth;\n     sixth->data=20;\n     sixth->next=seventh; \n     seventh->data=100;\n     seventh->next=NULL;\n     linkedListTraversal(head);\n     head = deleteByGivenKey(head, 70);\n     printf(\"---After deletion---\\n\");\n     linkedListTraversal(head);\n     return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__DemoFOTAUpdateWorkflow.1.c", "original_string": "void fotahub_onConnectionStatusChanged(ConnectionStatus_t status)\n{\n  ConnectionStatus_t ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__args);\n}"}
{"author": "ankitraj311", "file": "450_babbar__7_intersection_array_Geek_usorted_array.1.c", "original_string": "int ispresent(int arr1[], int size_arr1, int arr2[], int index_val) \n{\n  for(int i = 0; i<size_arr1; i++)\n  {\n    if(arr1[i] == arr2[index_val])\n    {\n      return 1;\n    }\n  }\n  return 0;\n}"}
{"author": "dishanp", "file": "DSA__q72.4.c", "original_string": "void convert(struct node *p)\n{\n    int ce = 0, co = 0;\n    while(p)\n    {\n        if(p->data%2 == 0)\n        {\n            inserteven(even, ce, p->data);\n            ce++;\n        }\n        else\n        {\n            insertodd(odd, co, p->data);\n            co++;\n        }\n        p = p->next;\n    }\n    first = even;\n    p = first;\n    while(p->next != NULL)\n        p = p->next;\n    p->next = odd;\n}"}
{"author": "ankitraj311", "file": "450_babbar__2_max_min_in_array.1.c", "original_string": "void max_min_array(int arr[], int max, int min, int no)\n{\n  for(int i = 0; i<no; i++)\n  {\n    if(min>arr[i])\n    {\n      min = arr[i];\n    }\n    else\n    {\n      max = arr[i];\n    }\n  }\n  printf(\"Max is %d Min is %d\",max,min);\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__27_no_happy_no_all_2.0.c", "original_string": "int main()\n{\n  int i,j,k,x,y,no,sum=0,dummy1=0;\n  printf(\"Enter the number to find out happy or not\");\n  for(j=1; j<=1000; j++)\n  {\n    sum = 0;\n    dummy1 = j;\n    while( sum != 1 && sum != 4 )\n    {\n      sum = 0;\n      while(dummy1>0)\n      {\n        i = dummy1 % 10;\n        sum = sum + (i*i);\n        dummy1 = dummy1 / 10;\n      }\n      dummy1 = sum ;\n    }\n    if( sum == 1)\n    {\n      printf(\"%d \",j);\n    }\n  }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__MergeSort.1.c", "original_string": "void MergeSort(int ARR[],int BEG,int END)\n{\n    int MID;\n    if(BEG<END)\n    {\n        MID=(BEG+END)/2;\n        MergeSort(ARR,BEG,MID);\n        MergeSort(ARR,MID+1,END);\n        Merge(ARR,BEG,MID,END);\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__timer_2match.2.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__count_the_elem_in_CLL.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=5)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_05.3.c", "original_string": "int main(int argc, char* argv[])\n{\n        int num; char s;int size1, size2;\n        int* arr1;\n        int* arr2;\n        F1 = fopen(argv[1], \"r\");\n        F2 = fopen(argv[2], \"w\");\n        while(1)\n        {\n        fscanf(F1 ,\"%c %d\",&s, &num);\n        if(s == 'r')\n        {\n            if(flag%2==0)\n            {\n                size1 = num;\n                arr1 = read(num);\n            }\n            else if(flag%2==1)\n            {\n                size2 = num;\n                arr2 = read(num);\n            }\n        }\n        else if(s == 'f')\n        {\n                float p = findMedian(arr1,arr2,size1,size2);\n        if((size1+size2)%2 == 0)\n        {\n                fprintf(F2,\"%0.2f\\n\", p);\n        }\n        else\n            fprintf(F2, \"%d\\n\", (int)p);\n        }\n        else if(s == 'd')\n        {\n        float med = findMedian(arr1, arr2, size1, size2);\n                display(a, size1+size2);\n                fprintf(F2, \"\\n\");\n        }\n        else if(s == 't')\n                return 0;\n        }\n        fclose(F1);\n        fclose(F2);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__arrayADT.2.c", "original_string": "void setVal(struct myArray *a){\n     int n;\n     for (int i = 0; i < a->usedSize; i++)\n     {\n          printf(\"Enter element %d: \", i);\n          scanf(\"%d\", &n);\n          (a->ptr)[i] = n;\n     }\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_9.0.c", "original_string": "int main()\n{\n    printf(\"Implementation of Kruskal's Algorithm\\n\");\n    printf(\"Enter the number of vertices: \");\n    scanf(\"%d\", &n);\n    printf(\"\\nEnter the cost adjacency matrix: \\n\");\n    for (i = 1; i <= n; i++)\n    {\n        for (j = 1; j<= n; j++)\n        {\n            scanf(\"%d\", &cost[i][j]);\n            if (i == j)\n            {\n                cost[i][j] = 0;\n            }\n            else if(cost[i][j]==0)\n            {\n                cost[i][j] = 999;\n            }\n        }\n    }\n    printf(\"The Adjacency Matrix is:\\n\");\n    for(i = 1; i <= n; i++)\n    {\n        for(j = 1; j <= n; j++)\n        {\n            printf(\"%d\\t\", cost[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"The edges of Minimum Cost Spanning Tree are: \");\n    while(m < n)\n    {\n        for(i = 1, min = 999; i <= n; i++)\n        {\n            for(j = 1; j <= n; j++)\n            {\n                if(cost[i][j] < min)\n                {\n                    min = cost[i][j];\n                    a = i;\n                    b = j;\n                }\n            }\n        }\n        if(uni(find(a), find(b)))\n        {\n            printf(\"\\n%d. edge (%d, %d) = %d\\n\", m++, a, b, min);\n            mincost += min;\n        }\n        cost[a][b] = cost[b][a] = 999;\n    }\n    printf(\"\\nMinimum Cost = %d\\n\", mincost);\n    return 0;\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-2new0.7.c", "original_string": "void dfs(char*** maze,char*** mark,char*** road,int row,int col,int hei,int count){\n    int i,j,k;\n    if(count>=(min+5)){\n        return;\n    }\n    else{\n        int i;\n        int nh,nr,nc;\n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            nh = hei+move[i].hei;\n            if(mark[nh][nr][nc]!='X'){\n                mark[nh][nr][nc]='X';\n                road[nh][nr][nc]='*';\n                if(maze[nh][nr][nc]=='T'){\n                    dfs(maze,mark,road,nr,nc,nh,count+3);\n                }\n                else{\n                    dfs(maze,mark,road,nr,nc,nh,count+1);\n                }\n                mark[nh][nr][nc]=maze[nh][nr][nc];\n                road[nh][nr][nc]=maze[nh][nr][nc];\n            }\n        }\n        if(maze[hei][row][col]=='U'){\n            if(mark[hei+1][row][col]!='X'){\n                mark[hei+1][row][col]='X';\n                road[hei+1][row][col]='*';\n                if(maze[hei+1][row][col]=='T'){\n                    dfs(maze,mark,road,row,col,hei+1,count+3);\n                }\n                else if(maze[hei+1][row][col]=='F'){\n                    pathnum++;\n                }\n                else{\n                    dfs(maze,mark,road,row,col,hei+1,count+1);\n                }\n                mark[hei+1][row][col]=maze[hei+1][row][col];\n                road[hei+1][row][col]=maze[hei+1][row][col];\n            }\n        }\n        else if(maze[hei][row][col]=='D' && hei>0){\n            if(mark[hei-1][row][col]!='X'){\n                mark[hei-1][row][col]='X';\n                road[hei-1][row][col]='*';\n                if(mark[hei-1][row][col]='T'){\n                    dfs(maze,mark,road,row,col,hei-1,count+3);\n                }\n                else{\n                    dfs(maze,mark,road,row,col,hei-1,count+1);\n                }\n                mark[hei-1][row][col]=maze[hei-1][row][col];\n                road[hei-1][row][col]=maze[hei-1][row][col];\n            }\n        }\n    }\n}"}
{"author": "DanielSalis", "file": "AED1__teste4.3.c", "original_string": "int jaPercorri(TipoLista*l ,int IDcidade){\n    int existe = existeNaLista(l, IDcidade);\n    if(existe){\n        int somaDistancia = 0;\n        int contCidades = 0;\n        TipoElemento* aux = l->primeiro;\n        while(aux->IDcidade != IDcidade){\n            somaDistancia = somaDistancia + aux->distancia;\n            contCidades++;\n            aux = aux->prox;\n        }\n        printf(\"estou na cidade %d:\\n\", IDcidade);\n        printf(\"ja percorri %d km, passando por %d cidades\", somaDistancia, contCidades);\n        return 1;\n    }else{\n        printf(\"cidade nao existe no percurso\");\n        return 0;\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__io.5.c", "original_string": "bool isdotjack(char* f, int len) {\n    const char* ext = \".jack\";\n    return strcmp(strtail(f, len, strlen(ext)), ext) == 0;\n}"}
{"author": "Oryx-Embedded", "file": "Common__str.3.c", "original_string": "void strReplaceChar(char_t *s, char_t oldChar, char_t newChar)\n{\n   while(*s != '\\0')\n   {\n      if(*s == oldChar)\n         *s = newChar;\n      s++;\n   }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__BK.0.c", "original_string": "void sequencia(int seq[], int print)\n{\n    int tam[10000], seq_aux[10000], qtd, k = 0, tam_s;\n    for (int i = 0; seq[i] != 0; i++)\n    {\n        qtd = 0;\n        for (int j = i; seq[j] == seq[i]; j++)\n        {\n            qtd++;\n        }\n        i += qtd - 1;\n        tam[k] = qtd;\n        seq_aux[k] = seq[i];\n        k++;\n    }\n    for (int i = 0, j = 0, a = 0; j < k; a++)\n    {\n        if (a % 2 == 0)\n        {\n            seq[a] = tam[i];\n            i++;\n        }\n        else if (a % 2 != 0)\n        {\n            seq[a] = seq_aux[j];\n            j++;\n        }\n        if (print == true)\n        {\n            printf(\"%i\", seq[a]);\n        }\n    }\n}"}
{"author": "SugumaranEvil", "file": "TLPI__socket_unixTCP_client.0.c", "original_string": "int main()\n{\n    int soc_fd, bind_fd;\n    int connect_fd;\n    ssize_t write_fd;\n    char buff[]=\"data from client\\n\";\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    strcpy(addr.sun_path, PATHNAME);\n    perror(\"strcpy\");\n    soc_fd = socket(AF_UNIX, SOCK_STREAM, 0);\n    perror(\"socket\");\n    printf(\"Return value of Socket = %d\\n\",soc_fd);\n    connect_fd = connect(soc_fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_un));\n    perror(\"connect\");\n    write_fd = write(soc_fd, buff, sizeof(buff));\n    perror(\"write\");\n    close(soc_fd);\n}"}
{"author": "haon1026", "file": "linux-programming__3ET_LT_server.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    int serv_sock = Socket(AF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in serv_adr;\n    bzero(&serv_adr, sizeof(serv_adr));\n    serv_adr.sin_family = AF_INET;\n    serv_adr.sin_port = htons(9999);\n    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);\n    Bind(serv_sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr));\n    Listen(serv_sock, 128);\n    struct epoll_event event;               \n    struct epoll_event resevent[10];        \n    int efd = epoll_create(10);\n    event.events = EPOLLIN|EPOLLET;       \n    printf(\"Accepting connection ...\\n\");\n    struct sockaddr_in clnt_adr;\n    socklen_t clnt_adr_len = sizeof(clnt_adr);\n    int clnt_sock = Accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_len);\n    char str[INET_ADDRSTRLEN];\n    printf(\"receive from %s at PORT %d\\n\", inet_ntop(AF_INET, &clnt_adr.sin_addr, str, sizeof(str)), ntohs(clnt_adr.sin_port));\n    event.data.fd = clnt_sock;\n    epoll_ctl(efd, EPOLL_CTL_ADD, clnt_sock, &event);\n    int res, len;\n    char buf[MAXLINE];\n    while(1)\n    {\n        res = epoll_wait(efd, resevent, 10, -1);\n        if(resevent[0].data.fd == clnt_sock)\n        {\n            len = read(clnt_sock, buf, MAXLINE/2);\n            write(STDOUT_FILENO, buf, len);\n        }\n    }\n    Close(serv_sock);\n    Close(efd);\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_end_DCLL.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.insert the element at the last position in the linked list\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4: printf(\"insert the element at the last position in the linked list\\n\");\n            insert_end();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__sparse_matrix.0.c", "original_string": "int main()\n{\n    int row,column;\n    printf(\"Enter the row value\\n\");\n    scanf(\"%d\",&row);\n    printf(\"Enter the column value\\n\");\n    scanf(\"%d\",&column);\n    if(row == 0 | column == 0) {\n        printf(\"Invalid row or column value\\n\");\n        exit(0);\n    }\n    int sparse_matrix[row][column];\n    int i, j, size = 0;\n    printf(\"Enter the values for Sparse matrix\\n\");\n    for(i = 0; i < row; i++ ) {\n        for(j = 0; j < column; j++) {\n            printf(\"Enter the value of Row %d\\t Column %d\\n\",i,j);\n            scanf(\"%d\",&sparse_matrix[i][j]);\n            if(sparse_matrix[i][j] != 0)\n                size = size + 1;\n        }\n    }\n    int new_matrix[row][size]; \n    int k = 0;\n    for(i = 0; i < row; i++ ) {\n        for(j = 0; j < column; j++) {\n            if( sparse_matrix[i][j] != 0) {\n                new_matrix[0][k] = i;\n                new_matrix[1][k] = j;\n                new_matrix[2][k] = sparse_matrix[i][j];\n                k++;\n            }\n        }\n    }\n    for(i = 0; i < row; i++ ) {\n        i==0 ? printf(\"Row   \\t\") : i==1 ? printf(\"column\\t\"):printf(\"Value \\t\");\n        for(j = 0; j < size; j++) {\n            printf(\"%d \",new_matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__goal_server.2.c", "original_string": "void print_client_addr(struct sockaddr_in addr){\n    printf(\"%d.%d.%d.%d\",\n        addr.sin_addr.s_addr & 0xff,\n        (addr.sin_addr.s_addr & 0xff00) >> 8,\n        (addr.sin_addr.s_addr & 0xff0000) >> 16,\n        (addr.sin_addr.s_addr & 0xff000000) >> 24);\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__shmq.0.c", "original_string": "void main()\n{\n    int mqid,pid,rval,msgid;\n    system(\"clear\");\n    printf(\"\\nBasic operations on message queues\\n\");\n    printf(\"\\nPP : process id is %d\\n\",getpid());\n    mqid=msgget((key_t)80,IPC_CREAT|0666);\n    if(mqid==-1)\n    {\n        perror(\"PP : MQ-CRE-ERR\");\n        exit(1);\n    }\n    system(\"ipcs -q\");\n    pid=fork();\n    if(pid==-1)\n    {\n        perror(\"PP : FRK-ERR\");\n        msgctl(mqid,IPC_RMID,0);\n        system(\"ipcs -q\");\n        exit(1);\n    }   \n    if(pid==0)\n    {\n        message m1;\n        printf(\"\\nCP : In child process\\tpid=%d\\n\",getpid());\n        printf(\"\\nCP : Parent process id\\tppid=%d\\n\",getppid());\n        printf(\"\\nEnter the message : \");\n        scanf(\"%s\",m1.txt);\n        rval=msgsnd(mqid,(message*)&m1,sizeof(m1),0);\n        if(rval==-1)\n        perror(\"\\nCP : Unable to send message\\n\");\n        else\n        printf(\"\\nCP : message successfully sent\\n\");\n    }\n    else\n    {\n        message m2;\n        rval=msgrcv(mqid,(message*)&m2,sizeof(m2),msgid,0);\n        if(rval==-1)\n        perror(\"\\nPP : No message read\\n\");\n        else\n        printf(\"\\n PP : Client message read from queue is %s\\n\",m2.txt);\n        rval=msgctl(mqid,IPC_RMID,0);\n        system(\"ipcs -q\");\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__search_an_element_by_key.2.c", "original_string": "void displayList()\n{\n    struct node *temp;\n        temp = head;\n        while(temp != NULL)\n        {\n            printf(\"Data = %d\\n\", temp->data);\n            temp = temp->next;\n        }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler2.3.c", "original_string": "int Count(PNODE Head, PNODE Tail)\n{\n    int iCnt = 0;\n    if((Head == NULL) && (Tail == NULL))\n    {\n        return 0;\n    }\n    do\n    {\n        iCnt++;\n        Head = Head->next;\n    }while(Head!= Tail->next);\n    return iCnt;\n}"}
{"author": "earth429", "file": "mulpre__zerosuppress.1.c", "original_string": "void clearByZero(struct NUMBER *a){\n    int i;\n    for (i = 0; i < KETA;i++){\n        a->n[i] = 0;\n    }\n    a->sign = 1;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__keypad.1.c", "original_string": "void rows(void)\n{\n    int val;\n    IODIR1 = IODIR1 & ~ROWS;        \n    IODIR1 = IODIR1 | COLS;         \n    val = IOPIN1 & ROWS;        \n    val = val >> 21;\n    switch(val)\n    {\n        case 0x0E:   col_1();   delay(200); break;\n        case 0x0D:   col_2();   delay(200); break;\n        case 0x0B:   col_3();   delay(200); break;\n        case 0x07:   col_4();   delay(200); break;\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__4ET_LT_client.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    int sockfd = Socket(AF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in serv_adr;\n    bzero(&serv_adr, sizeof(serv_adr));\n    serv_adr.sin_family = AF_INET;\n    serv_adr.sin_port = htons(9999);\n    inet_pton(AF_INET, \"127.0.0.1\", &serv_adr.sin_addr.s_addr);\n    Connect(sockfd, (struct sockaddr*)&serv_adr, sizeof(serv_adr));\n    char ch = 'a';\n    char buf[MAXLINE];\n    int i;\n    while(1)\n    {\n        for(i = 0; i < MAXLINE/2; i++)\n        {\n            buf[i] = ch;\n        }\n        buf[i-1] = '\\n';\n        ch++;\n        for(; i < MAXLINE; i++)\n        {\n            buf[i] = ch;\n        }\n        buf[i-1] = '\\n';\n        ch++;\n        write(sockfd, buf, sizeof(buf));\n        sleep(5);\n    }\n    Close(sockfd);\n    return 0;\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise19.0.c", "original_string": "int CheckIdentical(int array_A[], int array_B[] ,int size){\n    int i;\n    for(i=0 ; i<size ; i++){\n        if(array_A[i] != array_B[i]){\n            return 1;\n        }\n    }\n    return 0;\n}"}
{"author": "2security", "file": "Matrix__25ScalarMultiplication.1.c", "original_string": "void ScalarProduct(int mat[][20],int r,int c,int s)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            mat[i][j]=s*mat[i][j];\n        }\n    displayMat(mat,r,c);\n    }"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__reverse_concat.1.c", "original_string": "int main()\n{\n    char arr[30] = {'\\0'};   \n    char brr[30] = {'\\0'};   \n    printf(\"Please enter first string\\n\");\n    scanf(\"%[^'\\n']s\",arr);\n    printf(\"Please enter second string\\n\");\n    scanf(\" %[^'\\n']s\",brr);\n    StrcatXX(arr,brr);       \n    printf(\"String after concatination %s\\n\",brr);\n    return 0;\n}"}
{"author": "2security", "file": "String__10NoOfWord.0.c", "original_string": "int Noofword(char *str)\n    {\n    int i=0,word=0;\n    char prevchar='\\0';\n    while(1)\n        {\n        if(str[i]==' '||str[i]=='\\n'||str[i]=='\\t'||str[i]=='\\0')   \n            {\n                if(prevchar!=' ' && prevchar!='\\n'&&prevchar!='\\t'&&prevchar!='\\0')\n                word++;\n            }\n        prevchar=str[i];\n        if(str[i]=='\\0')\n            break;\n        else \n            i++;\n        }\n    return word;\n    }"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes2.13.c", "original_string": "void imprimir_alumnos_en_tabla(){\n    system(\"clear\");\n    printf(\"----------------------------------------------\\n\");\n    printf(\"Matricula\\tNombre\\t 1er\\t2o\\t3er\\t Ord\\n\");\n    printf(\"----------------------------------------------\\n\");\n    for (int i = 0; i < siguiente_alumno; i++){\n        imprimir_alumno_por_fila(i);\n    }\n    puts(\"Presione una tecla para continuar...\");\n    fflush(stdin);\n    getchar();\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-structure.11.c", "original_string": "PARAMETER* parseparameters(PARSER* p) {\n    PARAMETER* head = parseparameter(p);\n    PARAMETER* curr = head;\n    PARAMETER* nextp;\n    while(equals(p, \",\")) {\n        next(p);\n        nextp = parseparameter(p);\n        if(nextp == NULL)\n            unexpected(p);\n        curr->next = nextp;\n        curr = curr->next;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}"}
{"author": "flora0110", "file": "hw01git__check2-3.2.c", "original_string": "int main(){\n    FILE *ans;\n    FILE *myans;\n    char name[50];\n    ans=fopen(\"output_20201011.txt\",\"r\");\n    myans=fopen(\"4108056029output.txt\",\"r\");\n    if(NULL==ans || NULL == myans){\n        printf(\"Open failure\\n\");\n        if(NULL == myans){\n            printf(\"my ans Open failure\\n\");\n        }\n        if(NULL == ans){\n            printf(\"ans Open failure\\n\");\n        }\n        return 1;\n    }\n    else{\n        int nans,nmy,i;\n        int ansmin,ansLimit,anspathnum;\n        int min,Limit,pathnum;\n        for(i=0;i<100;i++){\n            fscanf(ans,\"test %d starts now.\",&nans);\n            char y=fgetc(ans);\n            fscanf(ans,\"Shortest path: %d, The number of different paths: %d\",&ansmin,&anspathnum);\n            y=fgetc(ans);\n            y=fgetc(ans);\n            fscanf(myans,\"test %d starts now.\",&nmy);\n            char x =fgetc(myans);\n            fscanf(myans,\"Shortest path: %d, The number of different paths: %d\",&min,&pathnum);\n            x=fgetc(myans);\n            x=fgetc(myans);\n            if(min!=ansmin){\n                printf(\"Shortest path error in test%d\\n\",nmy);\n                printf(\"ans's min : %d   my min : %d\\n\\n\",ansmin,min );\n            }\n            if(pathnum!=anspathnum){\n                printf(\"pathnum error in test%d\\n\",nmy);\n                printf(\"ans's  : %d   my  : %d\\n\\n\",anspathnum,pathnum );\n            }\n        }\n    }\n    fclose(ans);\n    fclose(myans);\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__server2.0.c", "original_string": "int main()\n{\n    fd_set master, read_fds;\n    int fdmax, i;\n    int sockfd = 0;\n    struct sockaddr_in server_addr, client_addr;\n    FD_ZERO(&master);\n    FD_ZERO(&read_fds);\n    server_set_up(&sockfd, &server_addr);\n    FD_SET(sockfd, &master);\n    fdmax = sockfd;\n    memset(name_directory, '\\0', sizeof(name_directory));\n    while (1)\n    {\n        read_fds = master;\n        if (select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)\n        {\n            perror(\"select\");\n            exit(4);\n        }\n       for (i = 0; i <= fdmax; i++)\n        {\n            if (FD_ISSET(i, &read_fds))\n            {\n                if (i == sockfd)\n                    connection_accept(&master, &fdmax, sockfd, &client_addr);\n                else\n                    send_recv(i, &master, sockfd, fdmax);\n            }\n        }\n    }\n    return 0;\n}"}
{"author": "Dhruvik-Chevli", "file": "DAALab__bfs.0.c", "original_string": "struct Queue* createQueue(int cap)\n{\n    struct Queue* queue=(struct Queue*)malloc(sizeof(struct Queue));\n    queue->front=-1;\n    queue->rear=-1;\n    queue->cap=cap;\n    queue->size=0;\n    queue->arr=(int*)malloc(cap*sizeof(int));\n    return queue;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__io.6.c", "original_string": "bool isdir(char* f, int len) {\n    bool readsmt = false;\n    for(int i = len-1; i >= 0; i--) {\n        if(f[i] == '.') {\n            if(readsmt)\n                return false;\n            else\n                continue;\n        }\n        if(f[i] == '/')\n            return 1;\n        readsmt = true;\n    }\n    return true;\n}"}
{"author": "TSN-SHINGENN", "file": "libmddl__mddl_malloc.1.c", "original_string": "void *mddl_realloc_align(void *memblk, const size_t alignment,\n                const size_t size)\n{\n    int result;\n    void *mem;\n    result = mddl_malloc_align(&mem, alignment, size);\n    if (result) {\n    return NULL;\n    }\n    memcpy(mem, memblk, size);\n    mddl_mfree(memblk);\n    return mem;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__2.2.c", "original_string": "void imprime_complex(complex_t *c)\n{\n    if (c->imaginario < 0)\n    {\n        printf(\"\\nRes = %.2f %.2fi\\n\", c->real, c->imaginario);\n    }\n    else\n    {\n        printf(\"\\nRes = %.2f +%.2fi\\n\", c->real, c->imaginario);\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_any_pos_CLL.3.c", "original_string": "int count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the list is %d\\n\",c);\n    return c;\n}"}
{"author": "DanielSalis", "file": "AED1__teste8.0.c", "original_string": "node* createNode(int key){\n    node* newElement = (node*)malloc(sizeof(node));\n    newElement->key = key;\n    newElement->right = NULL;\n    newElement->left = NULL;\n    return (newElement);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__20_e.2.c", "original_string": "int main()\n{\n        double X;\n    int Numero_iteraciones;\n        printf(\"Programa para calcular Euler elevado a X me diante sumas de Taylor\\nIngresa X: \");\n        scanf(\"%lf\", &X);\n        E(1,30,0,X);\n        return 0;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__LRU.0.c", "original_string": "int find_pos(int pg,int pos)\n{\n    int i,set=0;\n    for(i=pos;i>=0;i--)\n    {\n        if(page[i]==pg)\n        {\n            set=i;\n            break;\n        }\n    }\n    return(set);\n}"}
{"author": "haon1026", "file": "linux-programming__waitpid.0.c", "original_string": "int main()\n{\n    int i;\n    pid_t pid, wpid, temp;\n    for(i = 0; i < 5; i++)\n    {\n        temp = fork();\n        if(temp == 0)\n            break;\n        if(i == 2)\n        {\n            pid = temp;\n            printf(\"2th child pid = %d\\n\", pid);\n        }\n    }\n    if(i == 5)\n    {\n        sleep(5);\n        wpid = waitpid(pid, NULL, WNOHANG);         \n        if(wpid == -1)\n        {\n            perror(\"waitpid error\");\n            exit(1);\n        }\n        printf(\"I'm parent, wait a child finish : %d\\n\", wpid);\n    }\n    else\n    {\n        sleep(i);\n        printf(\"I'm %dth child, pid = %d\\n\", i+1, getpid());\n    }\n    return 0;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad10.2.c", "original_string": "int Push(stackPointer head, char sign)\n{\n    stackPointer newStackElement = AllocateMemoryForStackElement(head, sign);\n    newStackElement->next = head->next;\n    head->next = newStackElement;\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader0.1.c", "original_string": "static char *separator(void)\n{\n  char *os = getenv(\"OS\");\n  if (os != NULL && strcmp(os, \"Windows_NT\") == 0) \n  {\n    return \"\\\\\";\n  }\n  else\n  {\n    return \"/\";\n  }\n}"}
{"author": "2security", "file": "String__18FindNoOfHighOccurrence.0.c", "original_string": "int MyMax(int a[],int n)\n    {\n        int i,max=0;\n        for(i=0;i<n;i++)\n            {\n                if(a[i]>a[max])\n                    {\n                        max=i;\n                    }   \n            }\n        printf(\"%d\",max);\n        return max;\n    }"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__carro.3.c", "original_string": "void display_function()\n{\n  glClearColor(0, 0, 0, 0);\n  glClear(GL_COLOR_BUFFER_BIT);\n  glLoadIdentity();\n  glPushMatrix();\n    glTranslatef(-0.35+tx, 0+ty, 0.0);\n    glRotatef(theta, 0.0, 0.0, 1.0);\n    glColor3f(1.0, 1.0, 1.0);\n    circulo();\n  glPopMatrix();\n  glPushMatrix();\n    glTranslatef(0.35+tx, 0+ty, 0.0);\n    glRotatef(theta, 0.0, 0.0, 1.0);\n    glColor3f(1.0, 1.0, 0);\n    circulo();\n  glPopMatrix();\n  glPushMatrix();\n    glTranslatef(0.0+tx, 0.32+ty, 0);\n    glColor3f(0.0, 1.0, 0.0);\n    glRectf(-0.4, 0.2, 0.4, -0.2);\n  glPopMatrix();\n  glFlush();\n}"}
{"author": "theuwis", "file": "AdventOfCode2017__main1.1.c", "original_string": "int main(void){\n    int current_ring_multiplier = 1;\n    int col = 1, row = 0;\n    int i = 2;\n    while(1){\n        for(int j = 0; j < current_ring_multiplier; j++){\n            row++; i++;\n            check_end(&i, &col, &row);\n        }\n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            col--; i++;\n            check_end(&i, &col, &row);\n        }\n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            row--; i++;\n            check_end(&i, &col, &row);\n        }\n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            col++; i++;\n            check_end(&i, &col, &row);\n        }\n        current_ring_multiplier += 2;\n        col++; i++;\n        check_end(&i, &col, &row);\n    }\n    return EXIT_SUCCESS;\n}"}
{"author": "flora0110", "file": "hw01git__4108056041-hw1.4.c", "original_string": "int main() {\n    char a[1000]={};\n    int x=0,i,j=1,n=0,row=0,col=0;\n    char maze[n+2][n+2],mark[n+2][n+2];\n    int num_maze[n+2][n+2];\n    p1=fopen(\"test.txt\",\"r\");\n    if(p1==NULL)\n    {\n        printf(\"p1 error\");\n    }\n        fscanf(p1,\"%d\\n\",&n);\n    printf(\"n:%d\\n\",n);\n    for(i=0; i<n*n ;i++)\n    {\n        a[i]=fgetc(p1);\n        printf(\"%c \", a[i]);\n        fgetc(p1);\n        if(i%n==n-1){\n            fgetc(p1);\n            printf(\"\\n\");\n        }\n    }\n    printf(\"----------------\\n\");\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<n;j++)\n        {\n            printf(\"%c \", a[i*n+j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    printf(\"----------------\\n\");\n    char ans[n+2][n+2];\n    for(i =0;i<n+2;i++)\n    {\n        for( j=0;j<n+2;j++)\n        {\n            if(i == 0  || i == n+1 || j == 0  || j == n+1 )\n            {\n                mark[i][j] = 'X';\n                maze[i][j] = 'X';\n            }\n            else\n            {\n                mark[i][j] = a[x];\n                maze[i][j] = a[x];\n                x++;\n            }\n            printf(\"%c \", maze[i][j]);\n            ans[i][j]=maze[i][j];\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    for(i=0;i<n+2;i++)\n    {\n        for(j=0;j<n+2;j++)\n        {\n            printf(\"%c \", ans[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    for(i=0; i<n+2 ;i++)\n    {\n        for( j=0;j<n+2;j++)\n        {\n            if(mark[i][j]== 'S')\n            {\n                mark[i][j] = '*';\n                maze[i][j] = '*';\n                position.row = i;\n                position.col = j;\n                row = position.row;\n                col = position.col;\n                addq(position);\n                printf(\"rear %d \",rear);\n            }\n        }\n    }\n    if(bfs(&maze[0][0],&num_maze[0][0],n+2)==1){\n        for(i=0;i<n+2;i++)\n        {\n            for(j=0;j<n+2;j++)\n            {\n                printf(\"%3d \", num_maze[i][j]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else{\n        printf(\"not exit\");\n    }\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__i2c_read.1.c", "original_string": "void i2c_config(void)\n{\n    PINSEL0 |= (1<<4)|(1<<6);           \n    PINSEL0 &= ~((1<<5)|(1<<7));\n    I2CONSET    = 1<<6;     \n    I2SCLH = 75;                \n    I2SCLL = 75;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q4_dupl.1.c", "original_string": "void del(nodeptr a)\n{\n    nodeptr t;\n    for(t=a->link;t;)\n    {\n        if(a->data==t->data)\n        {\n            a->link=t->link;\n            free(t);\n            t=a->link;\n        }\n        else\n        {\n            a=a->link;\n            t=t->link;\n        }\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__lcd.6.c", "original_string": "void delay(int ct)\n{\n    for(int i =0 ;i<ct; i++)\n    {\n        for(int j=0;j<6000;++j)\n        {\n        }\n    }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListAllOperations.4.c", "original_string": "struct Node *insertAfterNode(struct Node *head, struct Node *previousNode, int data)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     ptr->data = data;\n     ptr->next = previousNode->next;\n     previousNode->next = ptr;\n     return head; \n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica33.3.c", "original_string": "void * consumidor(){                                        \n    sem_wait(&full);                                        \n    sem_wait(&mutex);                                       \n    hebraConsumidor++;                                      \n    int numero = consumirDato();                            \n    printf(\"---->Consumidor %d, Dato: %d\\n\", hebraConsumidor, numero);\n    sem_post(&mutex);                                       \n    sem_post(&empty);                                       \n    pthread_exit(NULL);                                     \n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__4.4.c", "original_string": "int contido(rect_t retangulo_1, rect_t retangulo_2)\n{\n    if (((retangulo_2.sup_esq.x > retangulo_1.sup_esq.x && retangulo_2.sup_esq.x < retangulo_1.inf_dir.x) && (retangulo_2.sup_esq.y < retangulo_1.sup_esq.y && retangulo_2.sup_esq.y > retangulo_1.inf_dir.y)) &&\\\n        ((retangulo_2.inf_dir.x < retangulo_1.inf_dir.x && retangulo_2.inf_dir.x > retangulo_1.sup_esq.x) && (retangulo_2.inf_dir.y > retangulo_1.inf_dir.y && retangulo_2.inf_dir.y < retangulo_1.sup_esq.y)) == true)\n    {\n        return 2;\n    }\n    else if (((retangulo_1.sup_esq.x > retangulo_2.sup_esq.x && retangulo_1.sup_esq.x < retangulo_2.inf_dir.x) && (retangulo_1.sup_esq.y < retangulo_2.sup_esq.y && retangulo_1.sup_esq.y > retangulo_2.inf_dir.y)) &&\\\n             ((retangulo_1.inf_dir.x < retangulo_2.inf_dir.x && retangulo_1.inf_dir.x > retangulo_2.sup_esq.x) && (retangulo_1.inf_dir.y > retangulo_2.inf_dir.y && retangulo_1.inf_dir.y < retangulo_2.sup_esq.y)) == true)\n    {\n        return 1;\n    }\n    else if (((retangulo_1.sup_esq.x == retangulo_2.sup_esq.x && retangulo_1.sup_esq.y == retangulo_2.sup_esq.y) && (retangulo_1.inf_dir.x == retangulo_2.inf_dir.x && retangulo_1.inf_dir.y == retangulo_2.inf_dir.y)) == true)\n    {\n        return 3;\n    }\n    else return 0;\n}"}
{"author": "Dhruvik-Chevli", "file": "DAALab__midSchool.1.c", "original_string": "int main()\n{\n    int sieve[10000];\n    for(int i=0;i<10001;i++)\n    {\n        sieve[i]=0;\n    }\n    sieve[1]=1;\n    sieve[0]=1;\n    int count=0;\n    for(int i=2;i<10001;i++)\n    {\n        if(sieve[i]==0)\n        {\n            count+=1;\n            for(int j=i*i;j<10001;j+=i)\n            {\n                sieve[j]=1;\n            }\n        }\n    }\n    int primes[count];\n    int j=0;\n    for(int i=0;i<10001;i++)\n    {\n        if(sieve[i]==0)\n        {\n            primes[j]=i;\n            j+=1;\n        }\n    }\n    int a[count];\n    int b[count];\n    int c,d;\n    scanf(\"%d %d\",&c,&d);\n    int x,y;\n    x=c;\n    y=d;\n    int count1=0;\n    while(c>0)\n    {\n        int counts=0;\n        while(c>0)\n        {\n            if(c%primes[count1]!=0)\n            {\n                a[count1]=counts;\n                count1+=1;\n                break;\n            }\n            else\n            {\n                c/=primes[count1];\n                counts+=1;\n            }\n        }\n        if(count1==count)\n        {\n            break;\n        }\n    }\n    int count2=0;\n    while(d>0)\n    {\n        int counts=0;\n        while(d>0)\n        {\n            if(d%primes[count2]!=0)\n            {\n                b[count2]=counts;\n                count2+=1;\n                break;\n            }\n            else\n            {\n                d/=primes[count2];\n                counts+=1;\n            }\n        }\n        if(count2==count)\n        {\n            break;\n        }\n    }\n    int pow;\n    int gcd=1;\n    for(int i=0;i<count;i++)\n    {\n        if(b[i]<a[i])\n        {\n            pow=b[i];\n        }\n        else\n        {\n            pow=a[i];\n        }\n        gcd*=(power(primes[i],pow));\n    }\n    printf(\"The GCD is %d \\n\",gcd);\n    return 0;\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__create_and_traverse_SINGLE_linked_list.0.c", "original_string": "int main()\n{\n    int choice = 1;\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->link = NULL;\n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->link = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want to enter more node?(1/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_node(temp);\n    getch();\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__timer_interrupt.5.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio11.1.c", "original_string": "void *consumidor(void *arg){\nint i = 0;\n    printf(\"Voy a esperar a que se llenen los datos\\n\");\n    pthread_mutex_lock(&count_mutex);\n    pthread_cond_wait(&count_threshold_cv, &count_mutex); \n    printf(\"Voy a leer los datos y limpiar el buffer\\n\");\n    for(i; i < 10;i++ ){\n        printf(\"%d, \",buffer[i]);\n        buffer[i]=0;\n        pthread_mutex_unlock(&count_mutex);\n    }\n    printf(\"\\n\");\n    sleep(2);\n    pthread_exit(NULL);\n}"}
{"author": "jdes01", "file": "practicassoo__practica1ej5.0.c", "original_string": "int main(){\n    int n=5, status;\n    printf(\"Padre con ID %d \\n\", getpid());\n    printf(\"\\n\");\n    for (int i=0; i<n; i++){\n        switch (fork()){ \n        case -1:\n            printf(\"Error en la creaci\u00f3n \\n\");\n            exit(EXIT_FAILURE);\n        case 0:\n            printf(\"Hijo %d con ID %d, padre: %d \\n\", i+1, getpid(), getppid());\n            variableGlobal++;\n            printf(\"%i\\n\", variableGlobal);\n            exit(EXIT_SUCCESS); \n        default:\n            printf(\"Esperando hijo numero %d \\n\", i+1);\n            wait(&status); \n            printf(\"Hijo %d termindo con ID %d, codigo de salida: %d \\n\", i+1, getpid(), WEXITSTATUS(status)); \n            printf(\"\\n\");\n        }\n    } \n    printf(\"%i\\n\", variableGlobal);\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "Common__path.8.c", "original_string": "void pathCombine(char_t *path, const char_t *more, size_t maxLen)\n{\n   size_t n1;\n   size_t n2;\n   if(*path != '\\0')\n      pathAddSlash(path, maxLen);\n   while(*more == '/' || *more == '\\\\') more++;\n   n1 = osStrlen(path);\n   n2 = osStrlen(more);\n   if(n1 < maxLen)\n   {\n      n2 = MIN(n2, maxLen - n1);\n      osStrncpy(path + n1, more, n2);\n      path[n1 + n2] = '\\0';\n   }\n}"}
{"author": "jose120918", "file": "binary_trees__102-binary_tree_is_complete.1.c", "original_string": "int is_complete(binary_tree_t *tree, int pos, int nodes)\n{\n    int left, right;\n    if (tree == NULL)\n    {\n        return (1);\n    }\n    if (pos >= nodes)\n    {\n        return (0);\n    }\n    left = is_complete((*tree).left, 2 * pos + 1, nodes);\n    right = is_complete((*tree).right, 2 * pos + 2, nodes);\n    return (left * right);\n}"}
{"author": "haon1026", "file": "linux-programming__client2.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    int clnt_sock = Socket(AF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9999);\n    inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr.s_addr);\n    Connect(clnt_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n    int ret;\n    int counter = 10;\n    char buf[BUFSIZ];\n    while(counter--)\n    {\n        Write(clnt_sock, \"hello\\n\", 6);\n        ret = Read(clnt_sock, buf, sizeof(buf));\n        if(ret == 0)\n        {\n            break;\n        }\n        Write(STDOUT_FILENO, buf, ret);\n        sleep(1);\n    }\n    Close(clnt_sock);\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_DLL.4.c", "original_string": "void insert_beg()\n{\n    struct node *newnode;\n    newnode=(struct node *)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    newnode->pre=0;\n    newnode->next=head;\n    head=newnode;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__Main0.0.c", "original_string": "void app_main(void)\n{\n  nvs_init();\n  uart_init(UART_UNIT, &UART_CONFIG, UART_TX_PIN, UART_RX_PIN);\n  blink_init(BLINK_PERIOD);\n  wifi_init();\n  printf(\"\\n--------------------------------------------------------------------------\\n\");\n  printf(\"Running %s %s firmware\\n\", DEMO_PRODUCT_NAME, DEMO_PRODUCT_FIRMWARE_VERSION);\n  printf(\"--------------------------------------------------------------------------\\n\\n\");\n  firmwareUpdateInfoReader_init();\n  fotaUpdateWorkflow_init();\n  fotahub_init(DEMO_PRODUCT_ID, DEMO_PRODUCT_NAME, &ESP32_FOTA_UPDATE_CLIENT_CONFIG);\n  wifiStation_connect(WIFI_STATION_SSID, WIFI_STATION_PASSPHRASE);\n  xTaskCreate(&demoTasks,\"demoTasks\",TASK_DEFAULT_STACK_SIZE * 5,NULL,10,NULL);\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_31.1.c", "original_string": "int verificarValorRepetido(int valorComparar) {\n    for (int i = 0; i < 10; i++) {\n        if (vet1[i] == valorComparar) {\n            return valorComparar;\n        }\n        if (vet2[i] == valorComparar) {\n            return valorComparar;\n        }\n    }\n    return 0;\n}"}
{"author": "dishanp", "file": "DSA__q72.2.c", "original_string": "void inserteven(struct node *p, int index, int key)\n{\n    struct node *t = (struct node *)malloc(sizeof(struct node));\n    t->data = key;\n    if(index == 0)\n    {\n        t->next = even;\n        even = t;\n    }\n    else\n    {\n        for(int i = 0 ; i < index - 1 ; i++)\n        {\n            p = p->next;\n        }\n        t->next = p->next;\n        p->next = t;\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__DemoFOTAUpdateWorkflowFilePersistence.1.c", "original_string": "int16_t loadState(void)\n{\n  FILE *file = fopen(DEMO_PRODUCT_UPDATE_STATE_FILE_NAME, \"rb\");\n  if (file == NULL) \n  {\n    return 0;\n  }\n  int16_t state = 0;\n  if (fread(&state, sizeof(state), 1, file) != 1) \n  {\n    fclose(file);\n    return 0;\n  }\n  fclose(file);\n  return state;\n}"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal_cortex.10.c", "original_string": "void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)\n{\n  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));\n  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__41.0.c", "original_string": "int main()\n{\n    int vetor[tamanho];\n    int qtd1 = 0, qtd0, i, j;\n    printf(\"\\nInforme os n\u00fameros do vetor:\\n\");\n    for (i = 0; i < tamanho; i++)\n    {\n        scanf(\"%i\", &vetor[i]);\n    }\n    for (i = 0; i < tamanho; i++)\n    {\n        if (vetor[i] != 0)\n        {\n            vetor[i] = 1;\n            qtd1++;\n        }\n    }\n    qtd0 = tamanho - qtd1;\n    printf(\"\\nVetor: \");\n    for (j = 0; j < tamanho; j++)\n    {\n        printf(\"%i \", vetor[j]);\n    }\n    printf(\"\\nQuantidade de zeros: %i\\nQuantidade de uns: %i\\n\\n\", qtd0, qtd1);\n    return 0;\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__queue0.4.c", "original_string": "void insert(int data)\n{\n    if(full()==0)\n    {\n        if(rear == MAX-1)\n            rear = -1;\n        arr[++rear] = data;\n        count++;\n    }\n    else\n        printf(\"Queue is full\\n\");\n}"}
{"author": "mehedi9021", "file": "Data_Structure__insert_a_node_in_circular_linked_list.2.c", "original_string": "void displayList()\n{\n    struct node *current;\n    int n = 1;\n    if(head == NULL)\n    {\n        printf(\"List is empty.\\n\");\n    }\n    else\n    {\n        current = head;\n        printf(\"DATA IN THE LIST:\\n\");\n        do {\n            printf(\"Data %d = %d\\n\", n, current->data);\n            current = current->next;\n            n++;\n        }while(current != head);\n    }\n}"}
{"author": "ankitraj311", "file": "450_babbar__7_intersection_array_Geek_soted_array.1.c", "original_string": "void intersection_array(int arr1[], int arr2[], int size_arr1, int size_arr2)\n{\n  int i = 0, j = 0;\n  while(i<size_arr1 && j<size_arr2)\n  {\n    if(arr1[i] < arr2[j])\n      i++;  \n    if(arr1[i] > arr2[j])\n      j++;\n    if(arr1[i] == arr2[j])\n    {\n      printf(\"%d \",arr2[j]); \n      j++;\n      i++;\n    }\n  }\n}"}
{"author": "dle2005", "file": "Algorithm__Chained_Matrix_Multiplication_v2.1.c", "original_string": "int minimum(int i, int j, int **M, int *d) {\n    int min = 999, index = 0;\n    for(int k = i; k <= j -1; k++) {\n        if(M[i][k] + M[k+1][j] + d[i-1] * d[k] * d[j] < min) {\n            min = M[i][k] + M[k+1][j] + d[i-1] * d[k] * d[j];\n            index = k;\n        }\n    }\n    return index;\n}"}
{"author": "mandarvu", "file": "msc__problem90.0.c", "original_string": "void findRoots(int a, int b, int c)\n{\n    if (a == 0) {\n        printf(\"Invalid input, as a has to be non-zero.\\n\");\n        return;\n    }\n    int d = b * b - 4 * a * c;\n    double sqrt_val = sqrt(abs(d));\n    if (d > 0) {\n        printf(\"Roots are real and different \\n\");\n        printf(\"%f\\n%f\", (double)(-b + sqrt_val) / (2 * a),\n            (double)(-b - sqrt_val) / (2 * a));\n    }\n    else if (d == 0) {\n        printf(\"Roots are real and same \\n\");\n        printf(\"%f\", -(double)b / (2 * a));\n    }\n    else \n    {\n        printf(\"Roots are complex \\n\");\n        printf(\"%f + i(%f)\\n%f - i(%f)\", -(double)b / (2 * a),\n            sqrt_val, -(double)b / (2 * a), sqrt_val);\n    }\n}"}
{"author": "sdukesameer", "file": "c__mult_mat.1.c", "original_string": "void readMat(int mat[NROWS][NCOLS],int r,int c)\n{\n    for(int i=0;i<r;i++)\n    {\n        for(int j=0;j<c;j++)\n            scanf(\"%d\",&mat[i][j]);\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CDLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__doublylinkedlist.4.c", "original_string": "void main()\n{\n    int ch;\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the value and position to insert:\");\n                scanf(\"%d%d\",&value,&pos);\n                insert(value,pos);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter the value to delete:\");\n                scanf(\"%d\",&value);\n                delete(value);\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the value to search:\");\n                scanf(\"%d\",&value);\n                search(value);\n                break;\n            }\n            case 4:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__bfs.5.c", "original_string": "void free_graph(graph* g){\n    for(int i=0; i<g->n; i++)\n        free(g->arr[i]);\n    free(g->arr);\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__LP.1.c", "original_string": "void insert(int key,int value)\n{\n    int index=H(key);\n    int i;\n    if(HASH[index]==-1)\n    {\n        HASH[index]=value;\n    }\n    else\n    {\n        for(i=index+1;i<10;i++)\n        {\n            if(HASH[i]==-1)\n            {\n                HASH[i]=value;\n                break;\n            }\n        }\n    }\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__19.1.c", "original_string": "void sumofrows(int a[][90],int r,int c)\n{\n    int i,j,sumofrows;\n    for(i=0;i<r;i++)\n    {\n        sumofrows=0;\n        for(j=0;j<c;j++)\n        {\n            sumofrows=sumofrows+a[i][j];\n        }\n        printf(\"%d\",sumofrows);\n    }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e21.0.c", "original_string": "int main(int argc, char *argv[]) {\n    char nomeEvento[50];\n    int capacidadeMax;\n    float valorEntradaInteira;\n    float valorEntradaMeia;\n    int ingressosInteiros;\n    int ingressosMeios;\n    int iInteirosVendidos;\n    int iMeiosVendidos;\n    int verificaCompra;\n    int tipoIngresso;\n    float valorPagamento;\n    float valorPagamentoFaltante;\n    float valorPagamentoFaltPago;\n    int ingressosInteirosSobrantes;\n    int ingressosMeiosSobrantes;\n    float troco;\n    float arrecadadoMeios;\n    float arrecadadoInteiros;\n    int tolalIngressosVendidos;\n    float totalArrecadado;\n    printf(\"Insira o Nome do evento \\n\");\n    scanf(\"%s\",&nomeEvento);\n    printf(\"Insira a capacidade maxima \\n\");\n    scanf(\"%d\",&capacidadeMax);\n    printf(\"Insira o valor da entrada inteira \\n\");\n    scanf(\"%f\",&valorEntradaInteira);\n    valorEntradaMeia = valorEntradaInteira / 2;\n    ingressosMeios =  capacidadeMax*0.4;\n    ingressosInteiros = capacidadeMax - ingressosMeios;\n    verificaCompra = 1;\n    while(verificaCompra == 1){\n        if(ingressosMeios == 0 && ingressosInteiros == 0){\n            printf(\"Acabou os ingressos, fim do evento\\n\");\n            verificaCompra++;\n        }else{\n            printf(\"-----------------------------------------------------------------------------\\n\");\n            printf(\"Bem Vindo a compra de ingressos para o %s \\n\\n\", nomeEvento);\n            printf(\"Digite 1 para ingressos inteiros(%i) e 2 para meias(\",ingressosInteiros);printf(\"%i) e 3 para cancelar\\n\", ingressosMeios);\n            printf(\"-----------------------------------------------------------------------------\\n\");\n            scanf(\"%d\",&tipoIngresso);\n            if(tipoIngresso == 1){\n                if(ingressosInteiros == 0){\n                    printf(\"Os ingressos inteiros estao esgotados\\n\");\n                }else{\n                    printf(\"Voce escolheu o ingresso inteiro que custa %.2f, favor indicar o valor que voce pagara\\n\", valorEntradaInteira);\n                    scanf(\"%f\",&valorPagamento);\n                    while(valorPagamento < valorEntradaInteira){\n                    valorPagamentoFaltante = valorEntradaInteira - valorPagamento;\n                    printf(\"Favor pagar o total do ingresso, faltam R$%.2f\\n\", valorPagamentoFaltante);\n                    scanf(\"%f\",&valorPagamentoFaltPago);\n                    valorPagamento = valorPagamentoFaltPago + valorPagamento;\n                    }\n                    if(valorPagamento > valorEntradaInteira){\n                        troco = valorPagamento - valorEntradaInteira;\n                        printf(\"O troco e de %.2f\\n\", troco);\n                    }\n                    ingressosInteiros = ingressosInteiros - 1;\n                }\n            }else{\n                if(tipoIngresso == 2){\n                    if(ingressosMeios == 0){\n                        printf(\"Os ingressos meios estao esgotados\\n\");\n                    }else{\n                        printf(\"Voce escolheu o ingresso meio que custa %.2f, favor indicar o valor que voce pagara\\n\", valorEntradaMeia);\n                        scanf(\"%f\",&valorPagamento);\n                        while(valorPagamento < valorEntradaMeia){\n                        valorPagamentoFaltante = valorEntradaMeia - valorPagamento;\n                        printf(\"Favor pagar o total do ingresso, faltam R$%.2f\\n\", valorPagamentoFaltante);\n                        scanf(\"%f\",&valorPagamentoFaltPago);\n                        valorPagamento = valorPagamentoFaltPago + valorPagamento;\n                        }\n                        if(valorPagamento > valorEntradaMeia){\n                            troco = valorPagamento - valorEntradaMeia;\n                            printf(\"O troco e de %.2f\\n\", troco);\n                        }\n                        ingressosMeios = ingressosMeios - 1;\n                    }\n                }else{\n                    if(tipoIngresso == 3){\n                        break;\n                    }else{\n                    printf(\"Digite uma opcao valida \\n\");\n                    }\n                }\n            }\n            printf(\"Digite 1 para comprar mais um ingresso e 2 para finalizar as compras\\n\");\n            scanf(\"%i\", &verificaCompra);\n            if(verificaCompra != 1 && verificaCompra != 2){\n                printf(\"Digite uma opcao valida \\n\");\n                verificaCompra = 1;\n            }\n        }\n    }\n    ingressosMeiosSobrantes =  capacidadeMax*0.4;\n    ingressosInteirosSobrantes = capacidadeMax - ingressosMeiosSobrantes;\n    ingressosMeiosSobrantes = ingressosMeiosSobrantes - ingressosMeios;\n    ingressosInteirosSobrantes = ingressosInteirosSobrantes - ingressosInteiros;\n    arrecadadoMeios = ingressosMeiosSobrantes * valorEntradaMeia;\n    arrecadadoInteiros = ingressosInteirosSobrantes * valorEntradaInteira;\n    tolalIngressosVendidos = ingressosInteirosSobrantes + ingressosMeiosSobrantes;\n    totalArrecadado = arrecadadoMeios + arrecadadoInteiros;\n    printf(\"-------------------------------------------------\\n\");\n    printf(\"\\nEvento %s \", nomeEvento);\n    printf(\"finalizado.\\n\\nO total de ingressos inteiros vendidos foi de: %i;\\nSobraram %i;\\nTotal arrecadado R$%.2f.\\n\\nO total de ingressos meios vendidos foi de %i;\\nSobraram %i;\\nTotal arrecadado R$%.2f.\\n\\n\", ingressosInteirosSobrantes,ingressosInteiros,arrecadadoInteiros,ingressosMeiosSobrantes,ingressosMeios,arrecadadoMeios);\n    printf(\"O total de ingressos vendidos foi de %i.\\nO total de dinheiro arrecadado foi de R$%.2f\",tolalIngressosVendidos,totalArrecadado);\n    return 0;\n}"}
{"author": "SugumaranEvil", "file": "Linux_programming__ftruncate.0.c", "original_string": "int main()\n{\n    int ftr,file_des;\n    char buf[10],snp[30],snp1[30];\n    char buf1[8]=\"sugukavi\";\n    ssize_t rd,wt;\n    file_des = open(\"./ftext\",O_CREAT | O_RDWR,0644); \n    perror(\"open\");                  \n    wt = write(file_des,buf1,8);     \n    perror(\"write\");\n    ftr = ftruncate(file_des,4);     \n    perror(\"ftruncate\");\n    printf(\"ftruncate %d\\n\",ftr);    \n    lseek(file_des,0,SEEK_SET);      \n    rd = read(file_des,buf,5);       \n    perror(\"read\");\n    snprintf(snp1,5,\"%s\",buf);       \n    printf(\"%s\",snp1);\n    close(file_des);                 \n}"}
{"author": "SugumaranEvil", "file": "TLPI__sem2.0.c", "original_string": "int main()\n{\n    int open_fd;\n        ssize_t write_fd,read_fd;\n    struct sembuf sem_buf;\n    sem_buf.sem_num = 3;\n    sem_buf.sem_op  = -1;\n    int semid;\n    semid = semget(93, 5,IPC_CREAT | 0600);\n    perror(\"semget\");\n    semop(semid, &sem_buf, 1); \n    perror(\"semop\");\n        open_fd = open(\"test.txt\",O_CREAT | O_RDONLY, 0644);\n        perror(\"open\");\n        read_fd = read(open_fd, buff, 1024);\n        perror(\"read\");\n        close(open_fd);\n        perror(\"close\");\n        for(int i=0; i<10; i++) {\n              printf(\"%s\\n\",buff);\n              sleep(1);\n        }\n    sem_buf.sem_op = 1;\n    semop(semid, &sem_buf, 1);\n    perror(\"semop\");\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_any_pos_CLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "jdes01", "file": "practicassoo__practica1ej6.1.c", "original_string": "int main(int argc, char const *argv[]){\n    signal(SIGALRM, RING);  \n    alarm(5);     \n    pause();      \n    alarm(3);     \n    pause();      \n    while (1){    \n        alarm(1);   \n        pause();    \n    } \n    exit(EXIT_SUCCESS);     \n}"}
{"author": "paawankohli", "file": "DSA-LAB__studentStruct.1.c", "original_string": "void printData(STUDENT* s)\n{\n    printf(\"Name: %s \\n\", (s->name)); \n    printf(\"Roll number: %d \\n\", s->rollNum);\n    printf(\"GPA: %f \\n\", s->gpa);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLL.4.c", "original_string": "nptr deleteRight(nptr head)\n{\n    if(head == NULL)\n        return head;\n    if(head -> left == NULL && head -> right == NULL)\n    {\n        printf(\"%d deleted\\n\", head -> data);\n        free(head);\n        return NULL;\n    }\n    nptr curr = head;\n    while(curr -> right != NULL)\n        curr = curr -> right;\n    (curr -> left) -> right = NULL;\n    printf(\"%d deleted\\n\", curr -> data);\n    free(curr);\n    return head;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__bridge_mib_impl_base.3.c", "original_string": "error_t bridgeMibGetDot1dBasePortEntry(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, MibVariant *value, size_t *valueLen)\n{\n   error_t error;\n   size_t n;\n   uint_t portIndex;\n   uint16_t dot1dBasePort;\n   n = object->oidLen;\n   error = mibDecodePort(oid, oidLen, &n, &dot1dBasePort);\n   if(error)\n      return error;\n   if(n != oidLen)\n      return ERROR_INSTANCE_NOT_FOUND;\n   portIndex = bridgeMibGetPortIndex(dot1dBasePort);\n   if(portIndex == 0)\n      return ERROR_INSTANCE_NOT_FOUND;\n   if(!strcmp(object->name, \"dot1dBasePort\"))\n   {\n      value->integer = dot1dBasePort;\n   }\n   else if(!strcmp(object->name, \"dot1dBasePortIfIndex\"))\n   {\n      value->integer = portIndex;\n   }\n   else if(!strcmp(object->name, \"dot1dBasePortCircuit\"))\n   {\n      if(*valueLen >= sizeof(uint8_t))\n      {\n         value->oid[0] = 0;\n         *valueLen = sizeof(uint8_t);\n      }\n      else\n      {\n         error = ERROR_BUFFER_OVERFLOW;\n      }\n   }\n   else if(!strcmp(object->name, \"dot1dBasePortDelayExceededDiscards\"))\n   {\n      value->counter32 = 0;\n   }\n   else if(!strcmp(object->name, \"dot1dBasePortMtuExceededDiscards\"))\n   {\n      value->counter32 = 0;\n   }\n   else\n   {\n      error = ERROR_OBJECT_NOT_FOUND;\n   }\n   return error;\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_1-20.5.c", "original_string": "int bfs(char** maze,int **d,int num,int sx,int sy){\n    int arrive=0;\n    queue[0].row = sx; queue[0].col = sy;\n    rear++;\n    int i,j;\n    for(i=0;i<num+2;i++){\n        for(j=0;j<num+2;j++){\n            d[i][j]=MAX;\n        }\n    }\n    d[sx][sy]=0;\n    element position;\n    int nr,nc;\n    int row,col;\n    while (rear!=front){\n        position = deleteq();\n        row = position.row;\n        col = position.col;\n        if(maze[row][col]=='F'){\n            if(min>d[row][col]){\n                min=d[row][col];\n            }\n            arrive=1;\n            break;\n        }\n        for(i=0;i<4;i++){\n            nr = position.row+move[i].vert;\n            nc = position.col+move[i].horiz;\n            if (maze[nr][nc]!='X' && d[nr][nc]>d[row][col]+1){\n                d[nr][nc]=d[row][col]+1;;\n                element nextposition;\n                nextposition.row=nr;nextposition.col=nc;\n                addq(nextposition);\n            }\n        }\n    }\n    return arrive;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__DemoFOTAUpdateWorkflow.4.c", "original_string": "static void DemoFOTAUpdateWorkflowEngine__init(DemoFOTAUpdateWorkflowEngine__data_t *instance, bool postponeInitialExecution)\n{\n  instance->updateInfo.binaryKind = BINARY_KIND_DEFAULT;\n  instance->updateInfo.binaryName = BINARY_NAME_DEFAULT;\n  instance->updateInfo.version = NULL;\n  instance->updateInfo.partitionIdx = PARTITION_IDX_NONE;\n  if (!postponeInitialExecution) \n  {\n    instance->__currentState = loadState();\n    switch (instance->__currentState)\n    {\n      case DemoFOTAUpdateWorkflowEngine_connected__state:\n      {\n        DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n        break;\n      }\n      case DemoFOTAUpdateWorkflowEngine_restarting__state:\n      {\n        DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n  }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__reverse_the_DLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.7.c", "original_string": "char* mktempind(VMTRANSLATOR* t) {\n    int index = atoi(t->currln->tokens[2]);\n    char* actualind = itoa(index+5);    \n    togarbage(t, actualind);\n    return at(t, actualind);\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-tree.13.c", "original_string": "void freeclassvardecs(CLASSVARDEC* cvd) {\n    freevardec(cvd->base);\n    CLASSVARDEC* next = cvd->next;\n    free(cvd);\n    if(next != NULL)\n        freeclassvardecs(next);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_certificate.4.c", "original_string": "error_t acmeClientFormatRevokeCertRequest(AcmeClientContext *context,\n   const char_t *cert, size_t certLen, AcmeReasonCode reason)\n{\n   error_t error;\n   int_t ret;\n   size_t n;\n   char_t *protected;\n   char_t *payload;\n   json_t *payloadObj;\n   error = pemImportCertificate(cert, certLen, (uint8_t *) context->buffer,\n      &n, NULL);\n   if(error)\n      return error;\n   base64urlEncode(context->buffer, n, context->buffer, &n);\n   payloadObj = json_object();\n   ret = json_object_set_new(payloadObj, \"certificate\",\n      json_string(context->buffer));\n   ret |= json_object_set_new(payloadObj, \"reason\",\n      json_integer((json_int_t) reason));\n   if(ret == 0)\n   {\n      payload = json_dumps(payloadObj, JSON_COMPACT);\n   }\n   else\n   {\n      payload = NULL;\n   }\n   if(payload != NULL)\n   {\n      protected = context->buffer;\n      error = acmeClientFormatJwsProtectedHeader(&context->accountKey,\n         context->account.url, context->nonce, context->directory.revokeCert,\n         protected, &n);\n      if(!error)\n      {\n         error = jwsCreate(context->prngAlgo, context->prngContext, protected,\n            payload, context->accountKey.alg, context->accountKey.crv,\n            context->accountKey.privateKey, context->buffer, &context->bufferLen);\n      }\n      jsonp_free(payload);\n   }\n   else\n   {\n      error = ERROR_FAILURE;\n   }\n   json_decref(payloadObj);\n   return error;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__enter_value_to_node.2.c", "original_string": "void print(){\nstruct node*temp;\ntemp=head;\nwhile(temp!=NULL)\n{\n    printf(\"%d\\n\", temp->data);\n    temp=temp->next;\n}\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__timer_polling.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | (0xFF<<17);       \n    T0PR = 14;                  \n    T0MR0 = 5000000;        \n    T0MCR   = (1<<0)|(1<<1);            \n    T0TCR   = (1<<0);           \n    while(1)\n    {\n        blink_LED(24);\n        while(!(T0IR & (1<<0)))         \n        {}\n        blink_LED(17);\n        T0IR = 1<<0;            \n    }\n}"}
{"author": "sahadipanjan6", "file": "Programs-in-C__Perfect_Number.0.c", "original_string": "void main()\n{\n    int number = 0;\n    printf(\"\\nEnter any number: \");\n    scanf(\"%d\", &number);\n    if(isPerfect(number) == 1)\n        printf(\"%d is a Perfect Number\\n\", number);\n    else\n        printf(\"%d is NOT a Perfect Number\\n\", number);\n}"}
{"author": "haon1026", "file": "linux-programming__orphan.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    pid_t pid = fork();\n    if(pid == -1)\n    {\n        perror(\"fork error\");\n        exit(1);\n    }\n    else if(pid == 0)\n    {\n        while(1)\n        {\n            printf(\"I'm child, my parent pid = %d\\n\", getppid());\n            sleep(1);\n        }\n    }\n    else if(pid > 0)\n    {\n        printf(\"I'm parent, my pid = %d\\n\", getpid());\n        sleep(9);\n        printf(\"--------parent process going to die---------\\n\");\n    }\n    return 0;\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad10-PointerFunctions.0.c", "original_string": "int main()\n{\n    const float deszcz[LATA][MIESIACE] = {\n        {10.2, 8.1, 6.8, 4.2, 2.1, 1.8, 0.2, 0.3, 1.1, 2.3, 6.1, 7.4},\n        {9.2, 9.8, 4.8, 3.2, 2.5, 4.8, 1.2, 0.5, 1.6, 1.3, 7.1, 7.4},\n        {10.6, 5.6, 6.7, 4.4, 3.8, 1.8, 2.2, 7.3, 2.6, 4.3, 4.6, 4.6},\n        {12.5, 3.7, 4.3, 0.2, 2.1, 1.7, 4.6, 0.5, 1.6, 0.3, 9.1, 2.4},\n        {12.2, 9.1, 7.8, 1.2, 8.4, 1.5, 0.2, 3.5, 3.8, 1.3, 7.1, 4.4}\n    };\n    printAvgYear(deszcz);\n    printAvgMonth(deszcz);\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "ankitraj311", "file": "450_babbar__7_intersection_array_Geek_usorted_array.3.c", "original_string": "void intersection_array(int arr1[], int arr2[], int size_arr1, int size_arr2)\n{\n  int total_size = size_arr1+size_arr2, arr3[total_size], index_val = 0, k = 0i, last_count = 0;\n  for(int i = 0; i<size_arr2; i++)\n  {\n    int val = ispresent(arr1,size_arr1,arr2,i); \n    if(val == 1)\n    {\n      arr3[k] = arr2[i];\n      k++;\n    }\n  }\n  printf(\"Array after Union :-\");\n  array_print(arr3,k);\n}"}
{"author": "behergue", "file": "Operating_Systems__myFS.15.c", "original_string": "int updateSuperBlock(MyFileSystem *myFileSystem)\n{\n    if(lseek(myFileSystem->fdVirtualDisk, BLOCK_SIZE_BYTES * SUPERBLOCK_IDX, SEEK_SET) == (off_t) - 1) {\n        perror(\"Failed lseek in updateSuperBlock\");\n        return -1;\n    }\n    if(write(myFileSystem->fdVirtualDisk, &(myFileSystem->superBlock), sizeof(SuperBlockStruct)) == -1) {\n        perror(\"Failed write in updateSuperBlock\");\n        return -1;\n    }\n    sync();\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__DemoFOTAUpdateWorkflowNVSFlashPersistence.0.c", "original_string": "void saveState(int16_t state)\n{\n  nvs_handle *nvsHandle = ((nvs_handle *)(malloc(sizeof(nvs_handle))));\n  if (nvsHandle == NULL) \n  {\n    return;\n  }\n  if (nvs_open(DEMO_PRODUCT_STORAGE_NAMESPACE, NVS_READWRITE, nvsHandle) == ESP_OK) \n  {\n    nvs_set_u8(*nvsHandle, DEMO_PRODUCT_FLASH_STORE_KEY, ((uint8_t) state));\n    nvs_commit(*nvsHandle);\n    nvs_close(*nvsHandle);\n    free(nvsHandle);\n    return;\n  }\n  free(nvsHandle);\n  printf(\"Failed write statemachine state to NVS\\n\");\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_nus_c.3.c", "original_string": "static void on_hvx(ble_nus_c_t * p_ble_nus_c, ble_evt_t const * p_ble_evt)\n{\n        if (p_ble_nus_c->conn_handle != p_ble_evt->evt.gattc_evt.conn_handle)\n        {\n                return;\n        }\n        if ((p_ble_evt->evt.gattc_evt.params.hvx.handle == p_ble_nus_c->handles.nus_tx_handle) \\\n            && (p_ble_nus_c->evt_handler != NULL))\n        {\n                {\n                        ble_nus_c_evt_t ble_nus_c_evt;\n                        ble_nus_c_evt.evt_type                   = BLE_NUS_C_EVT_NUS_TX_EVT;\n                        ble_nus_c_evt.conn_handle                = p_ble_nus_c->conn_handle;\n                        ble_nus_c_evt.p_data   = (uint8_t *)p_ble_evt->evt.gattc_evt.params.hvx.data;\n                        ble_nus_c_evt.data_len = p_ble_evt->evt.gattc_evt.params.hvx.len;\n                        p_ble_nus_c->evt_handler(p_ble_nus_c, &ble_nus_c_evt);\n                        NRF_LOG_DEBUG(\"Client sending data.\");\n                }\n        }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler.4.c", "original_string": "void DeleteFirst(PPNODE Head, PPNODE Tail)\n{\n    if(*Head == NULL && *Tail == NULL)  \n    {\n        return;\n    }\n    if(*Head == *Tail)  \n    {\n        free(*Head);\n        *Head = NULL;\n        *Tail = NULL;\n    }\n    else    \n    {\n        *Head = (*Head)->next;\n        free((*Tail)->next);    \n        (*Head)->prev = *Tail;\n        (*Tail)->next = *Head;\n    }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_9.0.c", "original_string": "int isFull(queue Q)\n{\n    if( (Q.front == Q.rear + 1) || (Q.front == 0 && Q.rear == Q.size-1))\n        return 1;\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__io.9.c", "original_string": "FILELIST* getfilesfromdir(char* dir) {\n    FILELIST* filelist = NULL;\n    DIR* d = opendir(dir);\n    if(d == NULL) {\n        eprintf(\"Error while opening directory '%s': %s\\n\", dir, strerror(errno));\n        exit(errno);\n    }\n    int len = strlen(dir);\n    struct dirent* thisfile;\n    while(thisfile = readdir(d), thisfile != NULL) {\n        int thislen = strlen(thisfile->d_name);\n        if(isdotjack(thisfile->d_name, thislen)) {\n            char* fullname = getfullname(thisfile->d_name, thislen, dir, len);\n            char* name = ezheapstr(thisfile->d_name);\n            filelist = addfile(filelist, fullname, name);\n        }\n    }\n    closedir(d);\n    if(filelist == NULL) {\n        eprintf(\"Directory '%s' doesn't have any .jack file\\n\", dir);\n        exit(1);\n    }\n    return filelist;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.12.c", "original_string": "void pase_asistencia(){\n    int dia;\n    printf(\"Pase de asistencia...\\n\");\n    int posicion = posicion_alumno();\n    printf(\"Indicar dia de asistencia [1 - %d]: \", MAX_ASISTENCIA);\n    scanf(\"%d\", &dia);\n    printf(\"[0]=Falta o [1]=Asistencia: \");\n    scanf(\"%d\", &lista_estudiantes[posicion].asistencias[dia - 1]);\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-statements.4.c", "original_string": "CONDSTATEMENT* parsecond(PARSER* p) {\n    checkcontent(p, \"(\");\n    CONDSTATEMENT* st = (CONDSTATEMENT*)malloc(sizeof(CONDSTATEMENT));\n    st->expression = parseexpression(p);\n    checkcontent(p, \")\");\n    checkcontent(p, \"{\");\n    st->statements = parsestatements(p);\n    checkcontent(p, \"}\");\n    return st;\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__fibonacci.0.c", "original_string": "int main ()\n{\n int num1=1 , num2=1 , sum=0;   \n int n,i;\n printf(\"fibonacci dizisinin ka\u00e7 eleman\u0131n\u0131 yazd\u0131rmak istersiniz:\");\n scanf(\"%d\",&n);\n if(n<0)\n {\n     printf(\"hatal\u0131 giri\u015f\\n\");\n     return 1;\n }\n for(i=0;i<n;i++)\n {\n        if(n==1)\n    { printf(\"%d\\n\",num1);}\n    else if(i==0)\n    { printf(\"%d %d \",num1,num2);\n      if(n==2)\n            return 0;\n    }\n    else \n    {\n     sum=num1+num2;\n     num1=num2;\n     num2=sum;\n     printf(\"%d \",sum);\n    }\n}   \n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_CLL.4.c", "original_string": "void delete_end()\n{\n    struct node *temp,*endnode;\n    temp =head;\n    while(temp->next!=head)\n    {\n        endnode=temp;\n        temp=temp->next;\n    }\n    endnode->next=head;\n    free(temp);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__count_the_elem_in_LL.0.c", "original_string": "int main()\n{\n    printf(\"Linked list functions\\n\");\n    int choice;\n    printf(\"1.implementation\\n\");\n    printf(\"2.display\\n\");\n    printf(\"3.count\\n\");\n    printf(\"4.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    while(choice!=5)\n    {\n    switch(choice)\n    {\n    case 1:printf(\"implementation \\n\");\n    create();\n    break;\n    case 2:printf(\"display\\n\");\n    display();\n    break;\n    case 3:printf(\"count the element in linked list\\n\");\n    count();\n    break;\n    case 4:exit(0);\n    break;\n    default: printf(\"wrong choice \\n\");\n    break;\n    }\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    }\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example4.0.c", "original_string": "int main() \n{ \n    int array[2]; \n    printf(\"element 0: %d\\n\",array[0]); \n    printf(\"element 1: %d\\n\",array[1]);\n    printf(\"%p\\n\",&array[0]);\n    printf(\"%p\\n\",&array[1]);\n    printf(\"element 2: %d\\n\", array[2]);\n    printf(\"%p\\n\",&array[2]);\n    printf(\"element 3: %d\\n\", array[3]);\n    printf(\"%p\\n\",&array[3]);\n    printf(\"element -1: %d\\n\", array[-1]);\n    printf(\"%p\\n\",&array[-1]);\n    return 0; \n}"}
{"author": "ria3999", "file": "Basic-C-Programs__19.2.c", "original_string": "void sumofcolumns(int a[][90],int r,int c)\n{\n    int i,j,sumofcolumns;\n    for(i=0;i<r;i++)\n    {\n        sumofcolumns=0;\n        for(j=0;j<c;j++)\n        {\n            sumofcolumns=sumofcolumns+a[j][i];\n        }\n        printf(\"%d\",sumofcolumns);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q2.5.c", "original_string": "node* create()\n{\n    node *p;\n    int x;\n    printf(\"Enter data(-1 for no data):\");\n    scanf(\"%d\", &x);\n    if (x == -1)\n        return NULL;\n    p = (node*)malloc(sizeof(node));\n    p->data = x;\n    printf(\"Enter left child of %d:\\n\", x);\n    p->left = create();\n    printf(\"Enter right child of %d:\\n\", x);\n    p->right = create();\n    return p;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_DLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\");\n    }\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__get_next_line.0.c", "original_string": "int pre_work(int fd, char **rest, char **line)\n{\n    char            *tmp;\n    if (BUFFER_SIZE < 0 || !line || read(fd, NULL, 0) < 0)\n        return (-1);\n    *line = ft_strdup(\"\");\n    if (rest[fd] != '\\0')\n    {\n        if (!has_nl(rest[fd]))\n        {\n            *line = ft_strjoin(*line, rest[fd]);\n            rest[fd] = NULL;\n        }\n        else\n        {\n            *line = ft_strjoin(*line, ft_substr(rest[fd], 0,\n                has_nl(rest[fd]) - rest[fd]));\n            tmp = rest[fd];\n            rest[fd] = ft_strdup(&rest[fd][has_nl(rest[fd]) - rest[fd] + 1]);\n            free(tmp);\n            return (1);\n        }\n    }\n    return (2);\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__planetas.10.c", "original_string": "void rotacionarPlaneta(int key, int x, int y){\n     switch (key){\n        case GLUT_KEY_UP :\n            glMatrixMode(GL_MODELVIEW);\n            glLoadIdentity();\n            gluLookAt(0.0, 2.0, 6.0,\n                        0.0, 0.0, 0.0,\n                        0.0, 1.0, 0.0);\n            glMatrixMode(GL_PROJECTION);\n            glLoadIdentity();\n            gluPerspective(45.0, 1.0, 2.0, 8.0);\n           break ;\n        case GLUT_KEY_DOWN :\n            glMatrixMode(GL_MODELVIEW);\n            glLoadIdentity();\n            gluLookAt(0.0, -7.0, 3.0,\n                    0.0, 0.0, 0.0,\n                    0.0, 1.0, 0.0);\n            glMatrixMode(GL_PROJECTION);\n            glLoadIdentity();\n            gluPerspective(45.0, 1.0, 2.0, 8.0);\n           break ;\n        case GLUT_KEY_LEFT :\n           angulo-=15;\n           break ;\n        case GLUT_KEY_RIGHT :\n           angulo+=15;\n           break ;\n        default:\n           break;\n     }\n     glutPostRedisplay() ;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__infixToPostfix.3.c", "original_string": "char push(struct stack*ptr, char val){\n    if(isFull(ptr)){\n        printf(\"Stack Overflow! Cannot push %d to the stack\\n\", val);\n    }\n    else{\n        ptr->top++;\n        ptr->arr[ptr->top]=val;\n    }\n}"}
{"author": "SugumaranEvil", "file": "Linux_programming__mp3_snd.0.c", "original_string": "int main()\n{\n   int create_pipe;\n   int fd,fd_1;\n   ssize_t ret_read,ret_write;\n   char buffer[9000000];\n   create_pipe = mknod(\"fifo\" , S_IFIFO | 0764,0);\n   fd = open(\"/home/sugu/Downloads/baby.mp3\",O_RDONLY);\n   ret_read = read(fd,buffer,9000000);\n   fd_1 = open(\"fifo\",O_WRONLY);\n   ret_write = write(fd_1,buffer,9000000);\n   close(fd);\n   close(fd_1);\n}"}
{"author": "tadeograch", "file": "sorting_algorithms__101-cocktail_sort_list.0.c", "original_string": "void cocktail_sort_list(listint_t **list)\n{\n    listint_t *recorro, *temp;\n    if (!list || *list == NULL)\n        return;\n    if ((*list)->next == NULL)\n        return;\n    temp = (*list)->next;\n    while (temp != NULL)\n    {\n        recorro = *list;\n        while (recorro->next != NULL)\n        {\n            if (recorro->n > recorro->next->n)\n            {\n                swap(recorro->next, recorro, list);\n                print_list(*list);\n            }\n            else\n                recorro = recorro->next;\n        }\n        while (recorro->prev != NULL)\n        {\n            if (recorro->n < recorro->prev->n)\n            {\n                swap(recorro, recorro->prev, list);\n                print_list(*list);\n            }\n            else\n                recorro = recorro->prev;\n        }\n        temp = temp->next;\n    }\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__num_words.0.c", "original_string": "int main()\n{\n    FILE *f;\n    int pid,c_cnt,fd[2];\n    pipe(fd);\n    printf(\"enter the source file path\\n\");\n    scanf(\"%s\",s);\n    pid=fork();\n    if(pid==0)\n    {\n        int c_cnt=0;\n        printf(\"------inside the child process--------\\n\");\n        close(fd[0]);\n        c_cnt=read_char();\n        printf(\"readed the character\\n\");\n        printf(\"character :%d\\n\",c_cnt);\n        write(fd[1],&c_cnt,sizeof(c_cnt));\n        close(fd[1]);\n    }\n    else\n    {\n        wait(NULL);\n        printf(\"-----back to parent process-----\\n\");\n        int cnt;\n        read_lines(s);\n        close(fd[1]);\n        read(fd[0],&cnt,sizeof(cnt));\n        printf(\"The count of character in the file is :%d\\n\",cnt);\n        close(fd[0]);\n    }\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__ssh_server.9.c", "original_string": "error_t sshServerStop(SshServerContext *context)\n{\n   uint_t i;\n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n   TRACE_INFO(\"Stopping SSH server...\\r\\n\");\n   if(context->running)\n   {\n      context->stop = TRUE;\n      sshNotifyEvent(&context->sshContext);\n      while(context->running)\n      {\n         osDelayTask(1);\n      }\n      for(i = 0; i < context->sshContext.numConnections; i++)\n      {\n         if(context->sshContext.connections[i].state != SSH_CONN_STATE_CLOSED)\n         {\n            sshCloseConnection(&context->sshContext.connections[i]);\n         }\n      }\n      socketClose(context->socket);\n      context->socket = NULL;\n   }\n   return NO_ERROR;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__vm-lines.8.c", "original_string": "LINEBLOCK* mergelnblks(LINEBLOCK* head, LINEBLOCK* tail) {\n    if(head == NULL)\n        return tail;\n    head->tail->next = tail->head;\n    head->tail = tail->tail;\n    free(tail);\n    return head;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es32.0.c", "original_string": "int minimo(int a[], int dim)\n    {\n    int valoreMinimo = a[0], locazione = 0;\n    for(int i=0; i < dim; i++)\n    {\n        if ( a[i] < valoreMinimo ) \n        {\n            valoreMinimo = a[i];\n            locazione = i;\n        }\n    } \n    return locazione;\n}"}
{"author": "DanielSalis", "file": "AED1__teste5.5.c", "original_string": "void sortear(TipoLista *l, char nome){\n  int rodada = 1;\n  char nomeAux = nome;\n  while(l->tamanho != 1){\n    int contador = rand() % 10;\n    int contadorAux = contador;\n    TipoElemento *p = l->primeiro;\n    printf(\"-> rodada %d: soldado %c, contagem %d\\n\", rodada, nomeAux, contador);\n    while(p->nome != nomeAux){\n      p = p->prox;\n    }\n    while(contadorAux != 0){\n      p = p->prox;\n      contadorAux--;\n      nomeAux = p->nome;\n    }\n    imprimeLista(l);\n    printf(\"\\nremovido: soldado %c\\n\", nomeAux);\n    if(p == l->primeiro){\n      l->primeiro = p->prox;\n    }\n    nomeAux = p->prox->nome;\n    p->ant->prox = p->prox;\n    p->prox->ant = p->ant;\n    p = NULL;\n    free(p);\n    l->tamanho--;\n    rodada++;\n  }\n  TipoElemento *n = l->primeiro;\n  if(n->agilidade < 7)\n    printf(\"soldado %c escolhido - ele nao tem agilidade suficiente -> vamos morrer!!\", n->nome);\n  else\n    printf(\"soldado %c escolhido e vai nos salvar!\",n->nome);\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__3-quick_sort.0.c", "original_string": "int partition(int *array, int lo, int hi, size_t size)\n{\n    int i, j, pivot, tmp;\n    pivot = array[hi];\n    i = lo;\n    j = lo;\n    while (j < hi)\n    {\n        if (array[j] <= pivot)\n        {\n            if (i != j)\n            {\n                tmp = array[i];\n                array[i] = array[j];\n                array[j] = tmp;\n                print_array(array, size);\n            }\n            i++;\n        }\n        j++;\n    }\n    if (i != hi)\n    {\n        tmp = array[i];\n        array[i] = array[hi];\n        array[hi] = tmp;\n        print_array(array, size);\n    }\n    return (i);\n}"}
{"author": "SugumaranEvil", "file": "TLPI__fork.0.c", "original_string": "int main()\n{\n    pid_t pid;\n    pid = fork();\n    if(pid == 0) {\n        printf(\"child process....\\n\");\n        printf(\"PID = %d\\nPPID = %d\\n\",getpid(),getppid());\n        printf(\"child process exit......\\n\");\n    }\n    else if(pid > 0 ){\n        int status;\n        printf(\"Before child process creation\\n\");\n        pid_t wt_rv = wait(&status);\n        printf(\"Parent process....\\n\");\n        printf(\"PID = %d\\nPPID = %d\\n\",getpid(),getppid());\n        printf(\"Status %d\\n\",WIFEXITED(status));  \n        printf(\"Wait ret value %d\\n\",wt_rv);\n        printf(\"Parent process exit......\\n\");\n    }\n    else{\n        printf(\"Fork failed\\n\");\n    }\n}"}
{"author": "fikepaci", "file": "monty__int_to_string.2.c", "original_string": "int get_numbase_len(unsigned int num, unsigned int base)\n{\n    int len = 1; \n    while (num > base - 1)\n    {\n        len++;\n        num /= base;\n    }\n    return (len);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__dequeue.5.c", "original_string": "int main()\n{\n    int z=0,k,e;\n    queue q;\n    q.front=10;\n    q.rear=10;\n    while (z==0)\n    {\n        printf(\"1. Enqueue Right\\t2. Enqueue Left\\t3. Dequeue Left\\t4. Dequeue Right\\t5. Display \\t6. Exit\\n\");\n        scanf(\"%d\",&k);\n        switch(k)\n        {\n            case 1:\n            {\n                scanf(\"%d\",&e);\n                enqueueright(&q,e);\n                break;\n            }\n            case 2:\n            {\n                scanf(\"%d\",&e);\n                enqueueleft(&q,e);\n                break;\n            }\n            case 3:\n            {\n                printf (\"%d\\n\",dequeueleft(&q));\n                break;\n            }\n            case 4:\n            {\n                printf (\"%d\\n\",dequeueright(&q));\n                break;\n            }\n            case 5:\n            {\n                display(&q);\n                break;\n            }\n            case 6:\n            {\n                z=1;\n            }\n        }\n    }\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Seg.4.c", "original_string": "void main()\n{\n    int ch,id,size,temp;\n    while(1)\n    {\n        printf(\"\\nEnter choice : \");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter program id : \");\n                scanf(\"%d\",&id);\n                printf(\"\\nEnter program size in terms of no of segments : \");\n                scanf(\"%d\",&size);\n                add_program(id,size);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter program id : \");\n                scanf(\"%d\",&id);\n                rem_program(id);\n                break;\n            }\n            case 3:\n            {\n                display_Mem();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes2.14.c", "original_string": "void imprimir_alumno_por_fila(int posicion){\n    printf(\"%d\\t\\t%s\\t\", lista_estudiantes[posicion].matricula, lista_estudiantes[posicion].nombre);\n    for (int i = 0; i < MAX_CALIFICACIONES; i++){\n        printf(\"%.2f\\t\", lista_estudiantes[posicion].calificaciones[i]);\n    }\n    printf(\"\\n\");\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__all_interrupts.8.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__DFS1.3.c", "original_string": "void display(struct graph* G[],int n)\n{\n    int i,j;\n    for(i=0;i<n;i++)\n    {\n        last=G[i];\n        printf(\"\\nThe vertices adjacent to %d are :\\n\",i);\n        while(last->next!=NULL)\n        {\n            printf(\"\\t%d\",last->val);\n            last=last->next;\n        }\n        printf(\"\\t%d\",last->val);\n    }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__infixToPostfix.6.c", "original_string": "int isOperator(char ch){\n     if(ch=='+' || ch=='-' || ch=='*' || ch=='/'){\n          return 1;\n     }\n     else\n          return 0;\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_5.8.c", "original_string": "int length()\n{\n    int count = 0;\n    struct node* temp;\n    temp = root;\n    while(temp != NULL)\n    {\n        count++;\n        temp = temp->link;\n    }\n    printf(\"The length of the linked list is : %d\\n\\n\", count);\n    return count;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q2_longadd.5.c", "original_string": "int main()\n{\n    char num1[50],num2[50];\n    printf(\"Enter the first number: \");\n    scanf(\"%s\",num1);\n    printf(\"Enter the second number: \");\n    scanf(\"%s\",num2);\n    nptr n1=getnum(num1);\n    nptr n2=getnum(num2);\n    nptr sum=add(n1,n2);\n    printf(\"The sum of the given numbers is \");\n    disp(sum);\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-2new.1.c", "original_string": "char*** make3darr(int rows, int cols,int hei){\n    char ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__ledRUN.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | (0xFF<<17);\n    while(1)\n    {\n        for(int led =17;led <= 24; led++)\n        {\n            IOSET1 = 1<<led;\n            delay(100);\n            IOCLR1 = 1<<led;\n            delay(100);\n        }\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_SLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n            printf(\"enter the data = \");\n            scanf(\"%d\",& newnode->data);\n            newnode->next=0;\n       if(head==0)\n       {\n            head=temp=newnode;\n       }\n       else\n       {\n            temp->next=newnode;\n            temp=newnode;\n       }\n       printf(\"do you need to continue (0,1)?\\n0 to stop 1 to continue the element in the linked list =\");\n           scanf(\"%d\",& choice);\n    }\n}"}
{"author": "Oryx-Embedded", "file": "Common__path.2.c", "original_string": "const char_t *pathGetFilename(const char_t *path)\n{\n   size_t n;\n   n = osStrlen(path);\n   while(n > 0)\n   {\n      if(path[n - 1] != '/' && path[n - 1] != '\\\\')\n         break;\n      n--;\n   }\n   while(n > 0)\n   {\n      if(path[n - 1] == '/' || path[n - 1] == '\\\\')\n         break;\n      n--;\n   }\n   return path + n;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q41.3.c", "original_string": "int main()\n{\n    stack s;\n    s.tos = -1;\n    char pre[20], pos[20], t;\n    printf(\"Enter prefix: \");\n    scanf(\"%s\", pre);\n    int i, j;\n    int l = strlen(pre);\n    for(int i = 0 ; i < l ; i++)\n    {\n        t = pre[i];\n        char temp[2] = {t, '\\0'};\n        push(&s, temp);\n        while (alnum(s.a[s.tos][0]) && alnum(s.a[(s.tos - 1)][0]) && s.tos != 0)\n        {\n            char temp1[20], temp2[20], temp3[20];\n            pop(&s, temp1);\n            pop(&s, temp2);\n            pop(&s, temp3);\n            strcat(temp2, temp1);\n            strcat(temp2, temp3);\n            push(&s, temp2);\n        }\n    }\n    strcpy(pos, s.a[0]);\n    printf(\"Postfix expression is %s\", pos);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__BJ.0.c", "original_string": "void fill_letters(char str[], char letters[])\n{\n    int busca, tam;\n    letters[0] = str[0];\n    for (int i = 0; str[i] != '\\0'; i++)\n    {\n        busca = false;\n        for (int j = 0; (letters[j] != '\\0') && (busca == false); j++)\n        {\n            if (letters[j] == str[i])\n            {\n                busca = true;\n            }\n        }\n        if (busca == false)\n        {\n            tam = strlen(letters);\n            letters[tam] = str[i];\n            letters[tam + 1] = '\\0';\n        }\n    }\n}"}
{"author": "rgautam320", "file": "Data-Structure__main18.4.c", "original_string": "int main()\n{\n    char infix[CAPACITY], postfix[CAPACITY], item, temp;\n    int i = 0, j = 0;\n    printf(\"Enter an Infix Expression to Convert into Postfix : \");\n    gets(infix);\n    while(infix[i]!='\\0')\n    {\n        item = infix[i];\n        if(item == '(')\n        {\n            push(item);\n        }\n        else if((item >= 'A' && item <= 'Z') || (item >= 'a' && item <= 'z'))\n        {\n            postfix[j] = item;\n            j++;\n        }\n        else if(is_operator(item) == 1)\n        {\n            temp = pop();\n            while(is_operator(temp) == 1 && precedence(temp) >= precedence(item))\n            {\n                postfix[j] = temp;\n                j++;\n                temp = pop();\n            }\n            push(temp);\n            push(item);\n        }\n        else if(item == ')')\n        {\n            temp = pop();\n            while(temp != '(')\n            {\n                postfix[j] = temp;\n                j++;\n                temp = pop();\n            }\n        }\n        else\n        {\n            printf(\"\\nInvalid Expression\");\n        }\n        i++;\n    }\n    while(top > -1)\n    {\n        postfix[j] = pop();\n        j++;\n    }\n    printf(\"\\nArithmetic Expression in Postfix form is : \");\n    puts(postfix);\n    return 0;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__check_multiplebit_on_off.0.c", "original_string": "BOOL CheckBit(int iNo)\n{\n    int iMask = 0X00000860;\n    int iResult = 0;\n    if(iNo < 0)\n    {\n        iNo = -iNo;\n    }\n    iResult = iNo & iMask;\n    if(iResult == iMask)\n    {\n        return TRUE;\n    }\n    else\n    {\n        return FALSE;\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__search_an_element_by_key.3.c", "original_string": "int main()\n{\n    int n, data,key;\n    printf(\"Enter the total number of nodes: \");\n    scanf(\"%d\", &n);\n    createList(n);\n    printf(\"\\nData in the list :\\n\");\n    displayList();\n     printf(\"\\nEnter key to search: \");\n    scanf(\"%d\", &key);\n    search(key);\n    return 0;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__planetas.12.c", "original_string": "void mouse(int botao, int estado, int x, int y)\n{\n    switch (botao)\n    {\n    case GLUT_LEFT_BUTTON:\n        stop = 1;\n        break;\n    case GLUT_RIGHT_BUTTON:\n        stop = 0;\n                glutTimerFunc(100, executaAnimacao, 1);\n        glutPostRedisplay();\n        break;\n    default:\n        break;\n    }\n    glutPostRedisplay();\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__i2c.0.c", "original_string": "int main()\n{\n    lcd_config();\n    i2c_config();\n    i2c_start();\n    i2c_data(0xA0);     \n    i2c_data(0x00);     \n    i2c_data('D');\n    i2c_data('E');\n    i2c_data('F');\n    i2c_stop();\n}"}
{"author": "2security", "file": "Pointer__17ArraySorting.0.c", "original_string": "void Mysort(int *a,int n)\n    {\n    int i,j,temp;\n    for(i=0;i<n-1;i++)\n        {\n        for(j=0;j<n-i-1;j++)\n            {\n            if(*(a+j)>*(a+j+1)) \n                {\n                    temp=*(a+j);\n                    *(a+j)=*(a+j+1);\n                    *(a+j+1)=temp;\n                }\n            }\n        }\n    }"}
{"author": "sdukesameer", "file": "c__rec_quick_sort.2.c", "original_string": "int partition (int arr[], int low, int high)\n{\n    int pivot = high;\n    int i = low,j=high;\n    while (i < j) {\n        while (arr[i] < arr[pivot] && i <= high)\n            i++;\n        while (arr[j] >= arr[pivot] && j >= low)\n            j--;\n        if(i<j)\n            swap(&arr[i],&arr[j]);\n    }\n    swap(&arr[i],&arr[pivot]);\n    return (i);\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__potenza.0.c", "original_string": "int main(void) {\n  int a, b;\n  int risultato;\n  printf(\"Base: \");\n  scanf(\"%d\", &a);\n  printf(\"Esponente: \");\n  scanf(\"%d\", &b);\n  if (b > 0) {\n    risultato = pot_ricorsivo(a,b);\n    printf( \"Risultato: %d\\n\", risultato ); \n  } else {\n    printf(\"Inserisci una potenza maggiore di 0\");\n  }\n  return 0;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__palhaco.0.c", "original_string": "void init(){\n     glClearColor(0.0,0.0,0.0,0.0);\n     glEnable(GL_DEPTH_TEST); \n     glMatrixMode(GL_MODELVIEW);\n     glLoadIdentity();\n     glOrtho(-7.0,7.0,-7.0,7.0,-7.0,7.0);\n     glPushMatrix();\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_9.3.c", "original_string": "int dequeue(queue *Qref)\n{\n    int element;\n    if(isEmpty(*Qref))\n        return(-1);\n    else\n      {\n        element = (*Qref).arr[(*Qref).front];\n        if ((*Qref).front == (*Qref).rear)\n        {\n            (*Qref).front = -1;\n            (*Qref).rear = -1;\n        } \n        else\n            (*Qref).front = ((*Qref).front + 1) % (*Qref).size;\n        return(element);\n      }\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Two.1.c", "original_string": "void add_file(int d,char name)\n{\n    struct Dir* p=(struct Dir*)malloc(sizeof(struct Dir));\n    p->file=name;\n    p->next=NULL;\n    if(isthere(d,name)==-1)\n    {\n        if(dir[d]==NULL)\n            dir[d]=p;\n        else\n        {\n            temp=dir[d];\n            while(temp->next!=NULL)\n                temp=temp->next;\n            temp->next=p;\n        }\n    }   \n    else\n        printf(\"file already exists in that directory\");\n}"}
{"author": "paawankohli", "file": "DSA-LAB__cNum.4.c", "original_string": "int main()\n{\n    cNum a, b, c;\n    printf(\"Enter real and imaginary part of first number: \");\n    scanf(\"%d %d\", &a.real, &a.imag);\n    printf(\"Enter real and imaginary part of second number: \");\n    scanf(\"%d %d\", &b.real, &b.imag);\n    printf(\"Addition: \");\n    display(add(a, b));\n    printf(\"Subtract: \");\n    display(subtract(a, b));\n    printf(\"Multiply: \");\n    display(multiply(a, b));\n}"}
{"author": "paawankohli", "file": "DSA-LAB__LLqueue.2.c", "original_string": "int pop(nptr &head)\n{\n    if (head == NULL)\n        return -1;\n    nptr rear2 = head;\n    nptr rear = head -> next;\n    while(rear -> next != NULL)\n    {\n        rear2 = rear2 -> next;\n        rear = rear -> next;\n    }\n    rear2 -> next = NULL;\n    int x = rear -> data;\n    free(rear);\n    return x;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__CB.0.c", "original_string": "int main()\n{\n    float A[100][100];\n    int n, m;\n    scanf(\"%i %i\", &n, &m);\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            scanf(\"%f\", &A[i][j]);\n        }\n    }\n    for (int j = 0; j < m; j++)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            if (i == (n-1)) printf(\"%.2f\", A[i][j]);\n            else printf(\"%.2f \", A[i][j]);\n        }\n        putchar('\\n');\n    }\n    return 0;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad6.5.c", "original_string": "int pop(pozicija p)\n{ \n    pozicija q = NULL;\n    if (p->next == NULL)\n        printf(\"Nisi jos dodao niti jedan element!\\n\");\n    else\n    {\n        printf(\"Skidamo element:%d\\n\", p->next->el);\n        q = p->next;\n        p->next = q->next;\n        free(q);\n    }\n    return 0;\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__sw-case_2.0.c", "original_string": "int main ()\n{\n        int secim ;\n        printf(\"\\t---MENU---\\t\\n1-selamla\\n2-toplama\\n3-teklik kontrol\u00fc\\n0-\u00e7\u0131k\u0131\u015f\\nsecim:\");\n        scanf(\"%d\",&secim);\n        switch (secim)\n        {\n            case (0):\n                return 0;\n                break;\n            case (1):\n                printf(\"helllo world\\n\");\n                break;\n            case (2):\n                {\n                    int s1,s2;\n                    printf(\"iki say\u0131 giriniz:\");\n                    scanf(\"%d %d\",&s1,&s2);\n                    printf(\"toplam: %d\\n\",s1+s2);\n                }\n                break;\n            case(3):\n                {\n                    int s1;\n                    printf(\"bir say\u0131 giriniz\");\n                    scanf(\"%d\",&s1);\n                    if(s1%2==1)\n                        printf(\"say\u0131 tektir\\n\");\n                    else \n                        printf(\"say\u0131 \u00e7ifttir\\n\");\n                }\n                break;\n            default:\n            {\n                printf(\"girilen i\u015flem ge\u00e7ersiz\\n\");\n                return 1;\n            }\n        }\n    return 0;\n    }"}
{"author": "DanielSalis", "file": "AED1__teste4.2.c", "original_string": "void inserir(TipoLista*l , int IDcidade, int distancia){\n    TipoElemento* novoElemento = (TipoElemento*)malloc(sizeof(TipoElemento));\n    novoElemento->IDcidade = IDcidade;\n    novoElemento->distancia = distancia;\n    if(l->tamanho == 0){\n        l->primeiro = novoElemento;\n        l->ultimo = novoElemento;\n        novoElemento->prox = NULL;\n        novoElemento->ant = NULL;               \n    }else{\n        l->ultimo->prox = novoElemento;\n        novoElemento->ant = l->ultimo;\n        l->ultimo = novoElemento;\n        novoElemento->prox = NULL;\n    }\n    l->tamanho++;\n}"}
{"author": "jdes01", "file": "practicassoo__practica2ej3.3.c", "original_string": "void imprimeVector (int *vector, int numeroElementos){\n    printf(\"[\");\n    printf(\" %d \", vector[0]);\n    for (int i = 1; i < numeroElementos; ++i){ printf(\", %d \", vector[i]); }\n    printf(\"]\\n\");\n    printf(\"\\n\");\n}"}
{"author": "mandarvu", "file": "msc__problem71.1.c", "original_string": "int Armstrong(int num) {\n    int sum = 0, target = 0, tmp;\n    tmp = num;\n    while (num > 0)\n    {\n        sum += pow(num%10, 3);\n        num /= 10;\n    }\n    return  (tmp == sum ? 1 : 0);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__6.0.c", "original_string": "int main(int argc, char **argv)\n{\n    FILE *arq;\n    char aux, *texto;\n    float res = 0;\n    if (argc < 2)\n    {\n        printf(\"\\nErro! N\u00e3o foi informado o nome do arquivo.\\n\\n\");\n        return 0;\n    }\n    arq = fopen(argv[1], \"r\");\n    if (arq == NULL)\n    {\n        printf(\"\\nErro ao abrir o arquivo.\\n\\n\");\n        return 0;\n    }\n    int i = 0;\n    while (fscanf(arq, \"%c\", &aux) != EOF)\n    {\n        i++;\n    }\n    rewind(arq);\n    texto = malloc(i * sizeof(char));\n    for (int j = 0; j < i; j++)\n    {\n        fscanf(arq, \"%c\", texto+j);\n    }\n    for (int j = 0; j < i; j++)\n    {\n        if (texto[j] == 'R' && texto[j+1] == '$')\n        {\n            res += atof(texto + j+2);\n        }\n    }\n    printf(\"\\nLista de compras: R$%.2f\\n\\n\", res);\n    return 0;\n}"}
{"author": "2security", "file": "Star__HollowRhombusstar.0.c", "original_string": "int main()\n    {\n    int n,i,j;\n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    for(i=1; i<=n; i++)\n            {\n            for(j=1; j<=n-i; j++)\n                    printf(\" \");\n            for(j=1;j<=n;j++)\n                {\n                if(i==1||i==n||j==1||j==n)\n                    printf(\"*\");\n                else    \n                    printf(\" \");\n                }\n            printf(\"\\n\");\n            }\n    printf(\"\\n\\n\");\n        return 0;\n    }"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__timer_assign1.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | LED_ALL ;  \n    T0PR = 14;\n    T0MR0 = 3000000;\n    T0MCR = (1<<0)|(1<<1);  \n    T0TCR = (1<<1);     \n    T0TCR = (1<<0);  \n    while(1)\n    {\n        blink_led(17);\n        while(!(T0IR & (1<<0))) \n        {}\n            blink_led(24);\n            T0IR = (1<<0); \n        blink_led(18);\n        blink_led(19);\n        blink_led(20);\n        blink_led(21);\n    }\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__strcmp_ser.1.c", "original_string": "void choice_one(char b[10])\n{\n    char p[10]=\"SIOSFFF\";\n        if (strcmp(b,p)==0)\n        {printf(\"the value is matching with SIOS\\n\");}\n        else{\n        printf(\"the  string is not matching with SIOS\\n\");\n        }\n}"}
{"author": "rgautam320", "file": "Data-Structure__main18.2.c", "original_string": "int precedence(char symbol)\n{\n    if(symbol == '^')\n        return 3;\n    else if(symbol == '*' || symbol == '/')\n        return 2;\n    else if(symbol == '+' || symbol == '-')\n        return 1;\n    else\n        return 0;\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__tree.4.c", "original_string": "void postorder(struct database *node){\n    if(node == NULL) {\n        return;\n    } else {\n        postorder(node->left);\n        postorder(node->right);\n        printf(\"%d\\n\",node->roll_no);\n    }\n}"}
{"author": "2security", "file": "Matrix__27CheckTwoMatrixEqual.0.c", "original_string": "int main()\n    {\n        int mat1[20][20],mat2[20][20],i,j,n,flag=0;\n        printf(\"\\nEnter the order of matrix\");\n        scanf(\"%d\",&n);\n        printf(\"\\n Enter first matrix\");\n        for(i=0;i<n;i++)\n        for(j=0;j<n;j++)\n        scanf(\"%d\",&mat1[i][j]);\n        printf(\"\\n Enter second matrix\");\n        for(i=0;i<n;i++)\n        for(j=0;j<n;j++)\n        scanf(\"%d\",&mat2[i][j]);\n        for(i=0;i<n;i++)\n            {\n                for(j=0;j<n;j++)\n                    {\n                        if(mat1[i][j]!=mat2[i][j])\n                        {\n                        flag=1;\n                        break;  \n                        }       \n                    }\n            }\n        if(flag==0)\n            printf(\"\\n Two matrix are equal\");\n        else\n            printf(\"\\n Two matrix are different\");\n        return 0;\n    }"}
{"author": "earth429", "file": "mulpre__increment.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a, b;\n    int return_val;\n    setInt(&a, 1);\n    return_val = increment(&a, &b);\n    dispNumberZeroSuppress(&a);\n    dispNumberZeroSuppress(&b);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__BinHexConverter.5.c", "original_string": "size_t convertHexString8ToBinData(char *inputStr, size_t inputStrLength, uint8_t *pOutputData, size_t outputDataSize)\n{\n  if (outputDataSize < inputStrLength >> 1) \n  {\n    return 0;\n  }\n  if ((inputStrLength & 0x01u) != 0) \n  {\n    return 0;\n  }\n  memset(pOutputData, 0x00u, outputDataSize);\n  for ( size_t i = 0 ; i < inputStrLength; i = i + 2 )\n  {\n    pOutputData[i >> 1] = convertHexString8ToBinValue(inputStr + i, 2);\n  }\n  return inputStrLength >> 1;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_last_DLL.0.c", "original_string": "int main()\n{\n    printf(\"function of double linked list \\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of element in the linked list\\n\");\n    printf(\"4.insert an element at the last position\\n\");\n    printf(\"5.exit\\n\");\n    int choice;\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=5)\n    {\n        switch(choice)\n        {\n            case 1: printf(\"implementation\\n\");\n            creat();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of element in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"inserting the element at the last\\n\");\n            insert_at_last();\n            break;\n            case 5:printf(\"exit \\n\");\n            exit(0);\n            break;\n            default:printf(\"invalied choice \\n\");\n            break;\n        }\n         printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post.1.c", "original_string": "node* rec_insertion(node* root, int n)\n{\n    if(root==NULL) return createNode(n);\n    else if(n<root->data) root->left=rec_insertion(root->left,n);\n    else if(n>root->data) root->right=rec_insertion(root->right,n);\n    return root;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_pos_DCLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.8.c", "original_string": "void initsymbols(SYMBOLARRAY* s) {\n    s->size = 150 * sizeof(SYMBOL*);\n    s->items = (SYMBOL**)malloc(s->size);\n    s->count = 0;\n}"}
{"author": "bgmanuel99", "file": "PracticasArquitecturaDeComputadores__ejercicio2Parte1.0.c", "original_string": "int main(int argc, char** argv){\n    int size, rank, value;\n    MPI_Status status;\n    MPI_Init(&argc,&argv);\n    MPI_Comm_size (MPI_COMM_WORLD, &size);\n    MPI_Comm_rank (MPI_COMM_WORLD, &rank);\n    if(rank == 0){\n        printf(\"Introduce el valor que quieres que se comunique: \");\n        scanf(\"%d\", &value);\n        printf(\"[%d]: envio el dato: %d a [%d]\\n\", rank, value, rank+1);\n        MPI_Send(&value, 1, MPI_INT, rank+1, size, MPI_COMM_WORLD);\n    }else{\n        MPI_Recv(&value, 1, MPI_INT, rank-1, size, MPI_COMM_WORLD, &status);\n        if(rank < size-1) {\n            printf(\"[%d]: recibo el dato: %d de [%d] y lo envio a [%d]\\n\", rank, value, rank-1, rank+1);\n            MPI_Send(&value, 1, MPI_INT, rank+1, size, MPI_COMM_WORLD);\n        }else{\n            printf(\"[%d]: recibo el dato: %d de [%d] y termino\\n\", rank, value, rank-1);\n        }\n    }\n    MPI_Finalize();\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_in_SLL.0.c", "original_string": "int main()\n{\n    printf(\"Linked list functions\\n\");\n    int choice;\n    printf(\"1.implementation\\n\");\n    printf(\"2.display\\n\");\n    printf(\"3.count\\n\");\n    printf(\"4.inserst at the begining \\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    while(choice!=6)\n    {\n    switch(choice)\n    {\n    case 1:printf(\"implementation \\n\");\n    create();\n    break;\n    case 2:printf(\"display\\n\");\n    display();\n    break;\n    case 3:printf(\"count the element in linked list\\n\");\n    count();\n    break;\n    case 4:printf(\"inserting the element at the begining \\n\");\n    insert_beg();\n    break;\n    case 5:exit(0);\n    break;\n    default: printf(\"wrong choice \\n\");\n    break;\n    }\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    }\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client.2.c", "original_string": "void send_recv(int i, int sockfd, char name[32], fd_set* master)\n{\n    char in_buf[BUFSIZE];\n    char send_buf[BUFSIZE+32]=\"\";\n    char recv_buf[BUFSIZE];\n    char disconnect_mssge[32];\n    int nbyte_recvd;\n    if (i == 0)\n    {\n        fgets(in_buf, BUFSIZE, stdin);\n        str_trim_lf(in_buf, BUFSIZE);\n        sprintf(send_buf, \"%s > %s\", name, in_buf);\n        if (strncmp(in_buf,\"tata\", 4) == 0)\n        {\n            sprintf(disconnect_mssge,\"%s left the chat.\", name);\n            send(sockfd, disconnect_mssge, strlen(disconnect_mssge), 0);\n            FD_CLR(i, master);\n            close(i);\n            close(sockfd);\n            exit(0);\n        }\n        else\n            send(sockfd, send_buf, strlen(send_buf), 0);\n        bzero(send_buf, BUFSIZE);\n    }\n    else\n    {\n        nbyte_recvd = recv(sockfd, recv_buf, BUFSIZE, 0);\n        recv_buf[nbyte_recvd] = '\\0';\n        printf(\"%s\\n\", recv_buf);\n    }\n}"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__routing2.3.c", "original_string": "void    get_f(char *line)\n{\n    char    **par;\n    char    **colors;\n    int     cc;\n    int     cw;\n    cw = 0;\n    par = ft_split(line, ' ');\n    cc = 0;\n    colors = ft_split(&par[1][0], ',');\n    while (line[cc])\n    {\n        if (line[cc] == ',')\n            cw++;\n        cc++;\n    }\n    if (cw != 2)\n    {\n        ft_putstr(\"Error:\\n Wrong floor RGB\");\n        exit(0);\n    }\n    cw = c_w(line, ' ');\n    cc = c_w(&par[1][0], ',');\n    freethenipples(par);\n    check_frgb(colors, cc, cw);\n    freethenipples(colors);\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_2_2_21.0.c", "original_string": "int main()\n{\n    int userNumber;\n    printf(\"Podaj nieujemna liczbe calkowita 'n': \");\n    scanf(\"%d\", &userNumber);\n    while(userNumber < 0 ){\n        printf(\"Podano nieprawidlowe dane!\\n\");\n        printf(\"Podaj nieujemna liczbe calkowita 'n': \");\n        scanf(\"%d\", &userNumber);\n    }\n    printf(\"Wyraz '%d' ciagu wynosi: %d\\n\", userNumber, sequenceA(userNumber));\n    getchar();\n    return 0;\n}"}
{"author": "2security", "file": "Pointer__10AddTwoMatrix.0.c", "original_string": "void Display(int **mat3)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n            printf(\"%-3d \",mat3[i][j]);\n        printf(\"\\n\");\n        }\n    }"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__first_occurence.1.c", "original_string": "int main()\n{\n    char arr[30];\n    char cValue = '\\0';\n    int iRet = 0;\n    printf(\"Please enter the string\\n\");\n    scanf(\"%[^'\\n']s\",arr);\n    printf(\"Please enter the character\\n\");\n    scanf(\" %c\",&cValue);\n    iRet = SearchFirstOcc(arr,cValue);\n    if(iRet == -1)\n    {\n        printf(\"There is no such character\\n\");\n    }\n    else\n    {\n        printf(\"First occurance of character at : %d\\n\",iRet);\n    }\n    return 0;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__a.1.c", "original_string": "int     ft_to_upper(char c, char d)\n{\n    if (c >= 'a' && c <= 'z')\n    {\n        if (d == ' ' || d == '\\t' || d == '\\0')\n            return (1);\n    }\n    return (0);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__AA.2.c", "original_string": "int main()\n{\n    long int num[100000], maior;\n    int n, k;\n    scanf(\"%i\", &n);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%li\", &num[i]);\n        if (i == 0)\n        {\n            maior = num[i];\n        }\n        else if (num[i] > maior)\n        {\n            maior = num[i];\n        }\n    }\n    k = primov(maior);\n    for (int i = 0; i < n; i++)\n    {\n        if (num[i] == 1)\n        {\n            printf(\"composto\\n\");\n        }\n        else if (num[i] == 2)\n        {\n            printf(\"primo\\n\");\n        }\n        else\n        {\n            busca(num[i], k);\n        }\n    }\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_any_pos_SLL.0.c", "original_string": "int main()\n{\n    printf(\"Linked list functions\\n\");\n    int choice;\n    printf(\"1.implementation\\n\");\n    printf(\"2.display\\n\");\n    printf(\"3.count\\n\");\n    printf(\"4.inserst the element at any position\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    while(choice!=6)\n    {\n    switch(choice)\n    {\n    case 1:printf(\"implementation \\n\");\n    create();\n    break;\n    case 2:printf(\"display\\n\");\n    display();\n    break;\n    case 3:printf(\"count the element in linked list\\n\");\n    count();\n    break;\n    case 4:printf(\"inserting the element at any position \\n\");\n    insert_pos();\n    break;\n    case 5:exit(0);\n    break;\n    default: printf(\"wrong choice \\n\");\n    break;\n    }\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    }\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_1-20.1.c", "original_string": "int** arrc(int rows, int cols){\n    int **x;\n    MALLOC(x,rows*sizeof(*x));\n    int i;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n    }\n    return x;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__LLunion.2.c", "original_string": "void display(nptr head)\n{\n    nptr temp = head;\n    while (temp)\n    {\n        printf(\"%d --> \", temp -> data);\n        temp = temp -> next;\n    }\n    printf(\"NULL\\n\");\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad8-NumeralSystems.0.c", "original_string": "int main()\n{\n    int liczba;\n    int systemLiczbowy;\n    printf(\"Podaj liczb\\251 ca\\210kowit\\245 (q ko\\344czy program):\\n\");\n    while(scanf(\"%d\", &liczba) == 1){\n        printf(\"Podaj system liczbowy z zakresu od 2 do 10:\\n\");\n        scanf(\"%d\", &systemLiczbowy);\n        printf(\"Odpowiednik w podanym systemie: \");\n        do_binar(liczba, systemLiczbowy);\n        putchar('\\n');\n        printf(\"Podaj liczb\\251 ca\\210kowit\\245 (q ko\\344czy program):\\n\");\n    }\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q1_queue.5.c", "original_string": "void display(queue* q)\n{\n    queue temp;\n    init(&temp);\n    int i;\n    while(q->front!=NULL)\n    {\n        i=deletee(q);\n        printf(\" %d --> \",i);\n        insert(&temp,i);\n    }\n    printf(\" NULL\\n\");\n    *q=temp;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__delete_node_manually.3.c", "original_string": "int main()\n{\n    head=NULL;\n    create(10);\n    create(20);\n    create(30);\n    create(4);\n    printf(\"display:\\n\");\n    print();\n    deletenode(2);\n    printf(\"display:\\n\");\n    print();\n    return 0;\n}"}
{"author": "jdes01", "file": "practicassoo__practica2ej2.0.c", "original_string": "void * cuentaLineas( void * argv ){\n    int * numeroLineas = malloc(sizeof(int));\n    * numeroLineas = 0;\n    char const * fichero;\n    char aux[256];\n    fichero = (char*) argv;\n    FILE* f = fopen(fichero, \"r\"); \n    if (f==NULL){\n        printf(\"Error al abrir el archivo\\n\"); \n        EXIT_FAILURE;\n    }\n    while(fgets(aux, 256, f)!=NULL){ ++*numeroLineas; } \n    fclose(f);\n    pthread_exit( (void**) numeroLineas);\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes2.5.c", "original_string": "void imprimir_alumno(){\n    int posicion = posicion_alumno();\n    printf(\"Matr\u00edcula: %d\\n\", lista_estudiantes[posicion].matricula);\n    printf(\"Nombre del alumno: %s\\n\", lista_estudiantes[posicion].nombre);\n    printf(\"Calificaci\u00f3n 1: %.2f\\n\", lista_estudiantes[posicion].calificaciones[0]); \n    printf(\"Calificaci\u00f3n 2: %.2f\\n\", lista_estudiantes[posicion].calificaciones[1]); \n    printf(\"Calificaci\u00f3n 3: %.2f\\n\", lista_estudiantes[posicion].calificaciones[2]); \n    printf(\"Calificaci\u00f3n f: %.2f\\n\", lista_estudiantes[posicion].calificaciones[3]); \n    float prom = promedio(lista_estudiantes[posicion].calificaciones);\n    printf(\"Promedio : %.2f\\n\", prom);\n    float m;\n    m = minimo(lista_estudiantes[posicion].calificaciones);\n    printf(\"Calificaci\u00f3n m\u00ednima: %.2f\\n\", m);\n    m = maximo(lista_estudiantes[posicion].calificaciones);\n    printf(\"Calificaci\u00f3n m\u00e1xima: %.2f\\n\", m);\n    imprimir_asistencias(posicion);\n    fflush(stdin);\n    getchar();\n}"}
{"author": "2security", "file": "If-else__Roots.0.c", "original_string": "int main()\n    {\n    float a,b,c,t,t1,t2,real,ima;\n    printf(\"Enter the co-efficients of the quadratic equation\");\n    scanf(\"%f%f%f\",&a,&b,&c);\n    t=sqrt(b*b-4*a*c);\n    printf(\"%f\",t);\n    if(t>0)\n        {\n        t1=(-b+t)/(2*a);\n        t2=(-b-t)/(2*a);\n        printf(\"\\nRoots are unequal and roots are %.2f %.2f\\n\",t1,t2);\n        }\n    else if(t==0)   \n        {\n        printf(\"\\nTwo roots are equal and roots are %.2f %.2f\\n\",-b/(2*a),-b/(2*a));\n        }\n    else\n        {\n        real=-b/(2*a);\n        ima=sqrt(4*a*c-b*b)/(2*a);\n        printf(\"\\nTwo distinct complex Roots are %.2f+i%.2f and %.2f-i%.2f \\n\",real,ima,real,ima);\n        }\n    return 0;\n    }"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_8_a.1.c", "original_string": "void connectArrays(unsigned int n, int * array1, int * array2, double * array3){\n    int i = 0;\n    for(i; i < 2*n; i++){\n        if(i < n){\n            array3[i] = array1[i];\n        } else {\n            array3[i] = array2[-n+i];\n        }\n    }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__print_hex.2.c", "original_string": "void    ft_print_hex(int nb)\n{\n    if (nb > 16)\n    {\n        ft_print_hex(nb / 16);\n        ft_print_hex(nb % 16);\n    }\n    if (nb < 10)\n        ft_putchar(nb + 48);\n    else if (nb < 16)\n        ft_putchar(nb + 87);\n}"}
{"author": "andi-s0106", "file": "sorting_algorithms__100-shell_sort.1.c", "original_string": "void swap(int *array, int gap, int idx)\n{\n    int tmp;\n    tmp = array[idx];\n    array[idx] = array[idx + gap];\n    array[idx + gap] = tmp;\n    idx = idx - gap;\n    while (idx >= 0)\n    {\n        if (array[idx] > array[idx + gap])\n        {\n            tmp = array[idx];\n            array[idx] = array[idx + gap];\n            array[idx + gap] = tmp;\n        }\n        idx = idx - gap;\n    }\n}"}
{"author": "dishanp", "file": "DSA__q63.4.c", "original_string": "int main()\n{\n    int n, key;\n    printf(\"Number of elements : \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n    {\n        scanf(\"%d\", &A[i]);\n    }\n    create(A, n);\n    frequency(first);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__24_Dowhile.0.c", "original_string": "double Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    do{\n    Total *= numero;\n    ++i;\n    }while(i < exponente);\n    return Total;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__lcd_func.4.c", "original_string": "void lcd_str(char str[])\n{\n    int i;\n    for(i=0;str[i]!='\\0';++i)\n        {\n            lcd_data(str[i]);\n        }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q20.1.c", "original_string": "int main()\n{\n    int arr[20];\n    int n;\n    int toSearch;\n    printf(\"Enter array size: \");\n    scanf(\"%d\", &n);\n    printf(\"Enter array elements in sorted order: \");\n    for(int i = 0; i < n; i++)\n        scanf(\"%d\", &arr[i]);\n    printf(\"Enter element to be searched: \");\n    scanf(\"%d\", &toSearch);\n    if(bsearch(arr, n, toSearch) != NULL)\n    {\n        int pos = bsearch(arr, n, toSearch) - arr + 1;\n        printf(\"Element found at %dth position. \\n \\n\", pos);\n    }\n    else\n        printf(\"Element not found \\n\\n\");\n    printf(\"Use of Double pointers. Enter a two numbers:\");\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    int *p1 = &a;\n    int **p2 = &p1;\n    int *p3 = &b;\n    int **p4 = &p3;\n    printf(\"Product = %d \\n \\n\", **p2 * **p4);\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "2lista_de_C__main12.0.c", "original_string": "int main()\n{\n    int a;\n    int b;\n    int c = 2;\n    int d;\n    printf(\"Digite um numero: \");\n    scanf(\"%d\",&a);\n    for(b = 0; b <= a; b++)\n    {\n        if(a>=0)\n        {\n            d = a / c;\n            c++;\n        }if(a % c == 0)\n        {\n            printf(\"%d / %d = %d\\n\",a,c,d);\n        }\n    }\n}"}
{"author": "flora0110", "file": "hw03git__4108056029_1-1.1.c", "original_string": "node* build(int l,int r,int* arr){\n    node* ptr=(node*)malloc(sizeof(node));\n    if(r==l){\n        ptr->sum=arr[l];\n        ptr->ls=arr[l];\n        ptr->rs=arr[l];\n        ptr->max=arr[l];\n        return ptr;\n    }\n    else{\n        int m=(l+r)/2;\n        node* leftn=build(l,m,arr);\n        node* rightn=build(m+1,r,arr);\n        ptr->sum=leftn->sum+rightn->sum;\n        ptr->ls=max(leftn->ls,leftn->sum+rightn->ls);\n        ptr->rs=max(rightn->rs,rightn->sum+leftn->rs);\n        ptr->max=max(max(rightn->max,leftn->max),leftn->rs+rightn->ls);\n        ptr->left=leftn;\n        ptr->right=rightn;\n        return ptr;\n    }\n}"}
{"author": "Theemiss", "file": "simple_shell__memory_mangment.3.c", "original_string": "void *fill_an_array(void *a, int el, unsigned int len)\n{\n    char *p = a;\n    unsigned int i = 0;\n    while (i < len)\n    {\n        *p = el;\n        p++;\n        i++;\n    }\n    return (a);\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_cmsis_rtos2.23.c", "original_string": "void *osAllocMem(size_t size)\n{\n   void *p;\n   osSuspendAllTasks();\n   p = malloc(size);\n   osResumeAllTasks();\n   TRACE_DEBUG(\"Allocating %u bytes at 0x%08X\\r\\n\", size, (uint_t) p);\n   return p;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_nus.3.c", "original_string": "void ble_nus_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context)\n{\n    if ((p_context == NULL) || (p_ble_evt == NULL))\n    {\n        return;\n    }\n    ble_nus_t * p_nus = (ble_nus_t *)p_context;\n    switch (p_ble_evt->header.evt_id)\n    {\n        case BLE_GAP_EVT_CONNECTED:\n            on_connect(p_nus, p_ble_evt);\n            break;\n        case BLE_GATTS_EVT_WRITE:\n            on_write(p_nus, p_ble_evt);\n            break;\n        case BLE_GATTS_EVT_HVN_TX_COMPLETE:\n            on_hvx_tx_complete(p_nus, p_ble_evt);\n            break;\n        default:\n            break;\n    }\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad7-RecurrencePowerFunction.0.c", "original_string": "int main()\n{\n    double userNumber;\n    int userPower;\n    printf(\"Podaj liczb\\251: \");\n    scanf(\"%lf\", &userNumber);\n    printf(\"Podaj pot\\251g\\251 ca\\210kowit\\245: \");\n    scanf(\"%d\", &userPower);\n    printf(\"%.3lf do pot\\251gi %d wynosi %.3lf\\n\", userNumber, userPower, power(userNumber, userPower));\n    return 0;\n}"}
{"author": "DanielSalis", "file": "AED1__teste8.7.c", "original_string": "int main(){\n    node *root;\n    node *aux;\n    int key;\n    int cont = 0; \n    int operacoes = 0;\n    char opcao;\n    scanf(\"%d\", &operacoes);\n    while(cont < operacoes){\n        scanf(\" %c\", &opcao);\n        if(opcao == 'I'){\n            scanf(\"%d\", &key);\n            if(cont == 0){\n                root = createNode(key);\n            }else{\n                insert(root, key);\n            }\n            cont++;\n        }\n        else if(opcao == 'B'){\n            scanf(\"%d\", &key);\n            aux = search(root, key);\n            if(aux == NULL){\n                printf(\"N\");\n                printf(\"\\n\");\n            }else{\n                printf(\"S\");\n                printf(\"\\n\");\n            }\n            cont++;\n        }\n        else if(opcao == 'M'){\n            printTree(root);\n            printf(\"\\n\");\n            cont++;\n        }\n        else if(opcao == 'R'){\n            scanf(\"%d\", &key);\n            root = deleteNode(root, key);\n            cont++;\n        }\n    }\n    return 0;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica1-4b.0.c", "original_string": "int main(int argc, char * argv[]){\n    int n;\n    int status;\n    pid_t pid; \n    for (int i = 1; i < argc; i++){\n        switch ( fork() ){\n            case -1: \n                perror(\"fork error:\\n\");\n                fprintf(stderr, \"errno:  %i\\n\", errno); \n                exit(EXIT_FAILURE);\n            case 0: \n                printf(\"soy un proceso hijo con PID: %i; el PID de mi proceso padre es: %i\\n\", getpid(), getppid());\n                execlp(\"./a.out\", \"./a.out\", argv[i], NULL);                \n                exit(EXIT_SUCCESS); \n        }\n        pid=wait(&status);\n    }\n   pid=wait(&status);\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Transpose_Matrix.1.c", "original_string": "void transpose_and_display(int matrix[R][C])\n{\n    int rows = R;\n    int columns = C;\n    int i, j, temp = 0;\n    int output_matrix[R][C];\n    temp = columns;\n    columns = rows;\n    rows = temp;\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {   \n            output_matrix[i][j] = matrix[j][i];\n        }\n    }\n    printf(\"\\nTransposed Matrix is as follows:- \\n\");\n    display(output_matrix);\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.0.c", "original_string": "struct btreeNode * createNode(int val, struct btreeNode *child) {\n        struct btreeNode *newNode;\n        newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));\n        newNode->val[1] = val;\n        newNode->count = 1;\n        newNode->link[0] = root;\n        newNode->link[1] = child;\n        return newNode;\n  }"}
{"author": "ashlyn2002", "file": "programming-using-c__implementation_of_CLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__DemoFOTAUpdateWorkflow.2.c", "original_string": "void fotahub_onFirmwareUpdateStatusChanged(FOTAUpdateStatus_t status)\n{\n  FOTAUpdateStatus_t ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg = status;\n  void *___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateStatusChanged_status__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateStatusChanged__args);\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__70.0.c", "original_string": "int main()\n{\n    int n;\n    float nota, notafinal = 0, denominador = 0, fator, notamedia;\n    printf(\"\\nInforme a quantidade de notas do aluno: \");\n    scanf(\"%i\", &n);\n    for (int qtd = 1; qtd <= n; qtd++)\n    {\n        printf(\"\\nInforme a %i\u00aa nota: \", qtd);\n        scanf(\"%f\", &nota);\n        if ((qtd % 2) == 0)\n        {\n            fator = 3;\n            nota = fator * nota;\n        }\n        else\n        {\n            fator = 2;\n            nota = fator * nota;\n        }\n        notafinal = notafinal + nota;\n        denominador = denominador + fator;\n    }\n    notamedia = notafinal / denominador;\n    printf(\"\\nNota m\u00e9dia = %.2f\\n\\n\", notamedia);\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.5.c", "original_string": "void copySuccessor(struct btreeNode *myNode, int pos) {\n        struct btreeNode *dummy;\n        dummy = myNode->link[pos];\n        for (;dummy->link[0] != NULL;)\n                dummy = dummy->link[0];\n        myNode->val[pos] = dummy->val[1];\n  }"}
{"author": "RafaelFelisbino-hub", "file": "FOR-exercices__Exercicio3FOR.0.c", "original_string": "int main() \n{\n    int i;\n    int num = 0;\n    int inter1=0, inter2=0, inter3=0, inter4=0;\n    system(\"color 17\");\n    for (i = 1; i <= 10; i++) {\n        printf(\"\\n%d - Digite os numeros:  \", i);\n        scanf_s(\"%i\", &num);\n        if (num < 0) \n        {\n            printf(\"Numero invalido\\n\");\n            break;\n        }\n        if ((num > 0) && (num <= 25))\n        {\n            inter1++;\n        }\n        if ((num > 25) && (num <= 50))\n        {\n            inter2++;\n        }\n        if ((num > 50) && (num <= 75))\n        {\n            inter3++;\n        }\n        if ((num > 75) && (num <= 100))\n        {\n            inter4++;\n        }\n    }\n    printf(\"Os numeros no 1 intervalo sao:  %i\\n\", inter1);\n    printf(\"Os numeros no 2 intervalo sao:  %i\\n\", inter2);\n    printf(\"Os numeros no 3 intervalo sao:  %i\\n\", inter3);\n    printf(\"Os numeros no 4 intervalo sao:  %i\\n\", inter4);\n    system(\"pause\");\n}"}
{"author": "ankitraj311", "file": "Socket-thread__test.1.c", "original_string": "int main()\n{\n  int i = 0;\n  pthread_t thread_id;\n  for(i = 0; i<3; i++)\n  {\n    pthread_create(&thread_id,NULL,fun_thread,(void *)&i);\n  }\n  pthread_exit(NULL);\n    return 0;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sparse_Matrix_Or_Not.1.c", "original_string": "void display(int matrix[R][C])\n{\n    int i, j = 0;\n    int rows = R;\n    int columns = C;\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__enter_value_to_node.1.c", "original_string": "void deletenode(int position)\n{\n        int i;\n        struct node*temp1;\n        temp1=head;\n        for(i=1;i<=position-2;i++)\n        {\n            temp1=temp1->next;\n        }\n        struct node*temp2;\n        temp2=temp1->next;\n        temp1->next=temp2->next;\n        free(temp2);\n    }"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal.8.c", "original_string": "HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)\n{\n  HAL_StatusTypeDef status  = HAL_OK;\n  assert_param(IS_TICKFREQ(Freq));\n  if (uwTickFreq != Freq)\n  {\n    uwTickFreq = Freq;\n    status = HAL_InitTick(uwTickPrio);\n  }\n  return status;\n}"}
{"author": "earth429", "file": "mulpre__newton_test.0.c", "original_string": "int main(int argc, char *argv)\n{\n    double x;\n    double x0;\n    int i;\n    for (i = -5; i <= 5;i++){\n        x0 = (double)i;\n        x = newton(x0);\n        printf(\"x0 = %10.6lf, x = %10.6lf\\n\", x0, x); \n    }\n    return 0;\n}"}
{"author": "earth429", "file": "mulpre__curt.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER r1, ans, tmp;\n    int j, r;\n    srandom(time(NULL));\n    r = 27;\n    setInt(&r1, r);\n    curt(&r1, &ans);\n    printf(\"r:%d\\nr1:\", r);\n    dispNumberZeroSuppress(&ans);\n    puts(\"\");\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__pre-eva.6.c", "original_string": "float operation(float f, char x, float s)\n{\n    if (x=='+')\n        return f+s;\n    if (x=='-')\n        return f-s;\n    if (x=='*')\n        return f*s;\n    else\n        return f/s;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sparse_Matrix_Or_Not.2.c", "original_string": "int check_sparse(int matrix[R][C])\n{\n    int i, j, output = 0;\n    int size, count_zeros = 0;\n    int rows = R;\n    int columns = C;\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {\n            if(matrix[i][j] == 0)\n                count_zeros++;\n            else\n                continue;\n        }\n    }\n    size = rows * columns;\n    if(count_zeros > (size/2))\n        output = 1;\n    return output;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__ssh_server.1.c", "original_string": "error_t sshServerInit(SshServerContext *context,\n   const SshServerSettings *settings)\n{\n   error_t error;\n   TRACE_INFO(\"Initializing SSH server...\\r\\n\");\n   if(context == NULL || settings == NULL)\n      return ERROR_INVALID_PARAMETER;\n   if(settings->numConnections < 1 ||\n      settings->numConnections > SSH_MAX_CONNECTIONS)\n   {\n      return ERROR_INVALID_PARAMETER;\n   }\n   if(settings->numChannels < settings->numConnections)\n      return ERROR_INVALID_PARAMETER;\n   error = sshInit(&context->sshContext, settings->connections,\n      settings->numConnections, settings->channels, settings->numChannels);\n   if(error)\n      return error;\n   context->interface = settings->interface;\n   context->port = settings->port;\n   do\n   {\n      error = sshSetOperationMode(&context->sshContext,\n         SSH_OPERATION_MODE_SERVER);\n      if(error)\n         break;\n      error = sshSetPrng(&context->sshContext, settings->prngAlgo,\n         settings->prngContext);\n      if(error)\n         break;\n      if(settings->passwordAuthCallback != NULL)\n      {\n         error = sshRegisterPasswordAuthCallback(&context->sshContext,\n            settings->passwordAuthCallback);\n         if(error)\n            break;\n      }\n      if(settings->publicKeyAuthCallback != NULL)\n      {\n         error = sshRegisterPublicKeyAuthCallback(&context->sshContext,\n            settings->publicKeyAuthCallback);\n         if(error)\n            break;\n      }\n   } while(0);\n   if(error)\n   {\n      sshServerDeinit(context);\n   }\n   return error;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e150.0.c", "original_string": "char validarDados (char vetorUsuario[TAM])\n{\n    int resultado = 0;\n    if (strlen(vetorUsuario) > TAM)\n    {\n        system (\"COLOR C\");\n        printf (\"\\n\\nERRO! Caracteres digitados em excesso. Tente novamente.\");\n        sleep(3);\n        resultado = 1;\n        system(\"cls\");\n    }\n    return resultado;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__19_.2.c", "original_string": "void Filas(int contador, int contador2)\n{\n    printf(\"\\n\");\n    if(contador < 11){\n        if(contador > 5){\n            Columnas(1,contador2);\n            Filas(++contador, --contador2);\n        }else{\n            Columnas(1,contador);\n            Filas(++contador,--contador2);\n        }\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__dfs-a.5.c", "original_string": "void dfs(gph g, int x){\n    stk s;\n    initialise(&s,g.n);\n    int visited[g.n],i,f,t;\n    for(i=0;i<g.n;i++)\n        visited[i]=0;\n    printf(\"\\nFollowing is the DFS Traversal (starting from %c): \\n\",'A'+x);\n    visited[x]=1;\n    printf(\"%c\\t\",'A'+x);\n    push(&s,x);\n    while(s.top!=-1){\n        f=peek(&s);\n        t=1;\n        for(i=0; i<g.n; i++)\n            if(g.mat[f][i])\n                if(!visited[i]){\n                    visited[i]=1;\n                    printf(\"%c\\t\",'A'+i);\n                    push(&s,i);\n                    t=0;\n                    break;\n                }\n        if(t)\n            pop(&s);\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__bfs-a.5.c", "original_string": "void free_graph(gph* g){\n    for(int i=0; i<g->n; i++)\n        free(g->mat[i]);\n    free(g->mat);\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.37.c", "original_string": "ASMBLK* pushframe(VMTRANSLATOR* t, char* retlab, int retlablen, int* framesize) {\n    tcallstart.items[1] = atraw(t, retlab, retlablen);\n    ASMBLK* blk = copytemplate(&tcallstart);\n    for(int i = 0; i < tframevars.count; i++) {\n        tcallpush.items[0] = tframevars.items[i];\n        mergeasmblks(blk, copytemplate((&tcallpush)));\n    }\n    *framesize = tframevars.count + 1;\n    return blk;\n}"}
{"author": "Oryx-Embedded", "file": "Common__date_time.4.c", "original_string": "void convertUnixTimeToDate(time_t t, DateTime *date)\n{\n   uint32_t a;\n   uint32_t b;\n   uint32_t c;\n   uint32_t d;\n   uint32_t e;\n   uint32_t f;\n   if(t < 1)\n      t = 0;\n   date->milliseconds = 0;\n   date->seconds = t % 60;\n   t /= 60;\n   date->minutes = t % 60;\n   t /= 60;\n   date->hours = t % 24;\n   t /= 24;\n   a = (uint32_t) ((4 * t + 102032) / 146097 + 15);\n   b = (uint32_t) (t + 2442113 + a - (a / 4));\n   c = (20 * b - 2442) / 7305;\n   d = b - 365 * c - (c / 4);\n   e = d * 1000 / 30601;\n   f = d - e * 30 - e * 601 / 1000;\n   if(e <= 13)\n   {\n      c -= 4716;\n      e -= 1;\n   }\n   else\n   {\n      c -= 4715;\n      e -= 13;\n   }\n   date->year = c;\n   date->month = e;\n   date->day = f;\n   date->dayOfWeek = computeDayOfWeek(c, e, f);\n}"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__rounting_utils1.0.c", "original_string": "int     all_params(void)\n{\n    if (g_width != 0 && g_height != 0 && g_we != NULL && g_no != NULL\n        && g_no != NULL && g_ea != NULL && g_fr != -1 &&\n        g_fr != -1 && g_fg != -1 && g_fb != -1 && g_cr != -1 &&\n        g_cg != -1 && g_cb != -1)\n        return (1);\n    return (0);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__i2c_MasterRxMode.0.c", "original_string": "int main()\n{   \n    char i2c_rdata;\n    lcd_config();\n    i2c_init();\n    i2c_Start();\n    i2c_tx_data(0xA0);          \n    i2c_tx_data(0x01);          \n    I2CONSET = (1<<2);          \n    i2c_Start();                        \n    i2c_tx_data(0xA1);          \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_rdata = i2c_rx_data();\n    lcd_data(i2c_rdata);        \n    i2c_stop();\n    lcd_cmd(0xC0);\n    lcd_str(\"Data from EEPROM\");\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q31.5.c", "original_string": "int main()\n{\n    stack s;\n    s.tos2 = MAX;\n    s.tos1 = -1;\n    int z = 0, k;\n    while (z == 0)\n    {\n        printf(\"1. Push1   2. Push2   3. Pop1    4. Pop2    5. Display    6. Exit \\n\");\n        scanf(\"%d\", &k);\n        switch(k)\n        {\n            case 1: push1(&s); break;\n            case 2: push2(&s); break;\n            case 3: pop1(&s); break;\n            case 4: pop2(&s); break;\n            case 5: display(&s); break;\n            case 6: z = 1;\n        }\n    }\n}"}
{"author": "dishanp", "file": "DSA__q44.0.c", "original_string": "void create(int A[], int n)\n{\n    struct node *t, *last;\n    int i;\n    first = (struct node*)malloc(sizeof(struct node));\n    first->data = A[0];\n    first->next = NULL;\n    last = first;\n    for(i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__elephant.0.c", "original_string": "int main(){\n  int n, aux;\n  int cont = 0;\n  scanf(\"%d\", &n);\n  if(n < 1 || n > 1000000)\n    return 0;\n  while(n>0){\n    if(n - 5  >= 0)\n      aux = 5;\n    else if(n - 4 >= 0)\n      aux = 4;\n    else if(n - 3 >= 0)\n      aux = 3;\n    else if(n - 2 >= 0)\n      aux = 2;\n    else if(n - 1 >= 0)\n      aux = 1;\n    n -= aux;\n    cont++;\n  }\n  printf(\"%d\\n\", cont);\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__tic-tac-toe.2.c", "original_string": "void board()\n{\n    printf(\"\\n\\n\\tTic Tac Toe\\n\\n\");\n    printf(\"Player 1 (X)  -  Player 2 (O)\\n\\n\\n\");\n    printf(\"     |     |     \\n\");\n    printf(\"  %c  |  %c  |  %c \\n\", square[1], square[2], square[3]);\n    printf(\"__|_|__\\n\");\n    printf(\"     |     |     \\n\");\n    printf(\"  %c  |  %c  |  %c \\n\", square[4], square[5], square[6]);\n    printf(\"__|_|__\\n\");\n    printf(\"     |     |     \\n\");\n    printf(\"  %c  |  %c  |  %c \\n\", square[7], square[8], square[9]);\n    printf(\"     |     |     \\n\\n\");\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_print_comb.1.c", "original_string": "void ft_print_comb(){\n    int datos[10] = {0,1,2,3,4,5,6,7,8,9};\n    comb(0, 1,2, datos);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linearBinarySearch.1.c", "original_string": "int binarySearch(int arr[], int size, int element){\n     int low,mid,high;\n     low=0;\n     high = size-1;\n     while(low<=high){\n          mid = (low+high)/2; \n          if(arr[mid]==element){\n               return mid;\n          }\n          if(arr[mid]<element){\n               low=mid+1;\n          }\n          else{\n               high = mid-1;\n          }\n     }\n     return -1;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__timer0_1_int.7.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__selection_sort.2.c", "original_string": "int main(void) {\n    printf(\"sorting the elements in the array \\n\"); \n    printf(\"selection sort \\n \");\n    int a[5]={65,47,4,80,12};\n    int n=5;\n    printf(\"the elements in the array are :\\n \");\n    printarray(a,n);\n    printf(\"\\n after sorting elements in the array are :\\n\");\n    selection(a,n);\n    printarray(a,n);\n    return EXIT_SUCCESS;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__ssh_key_verify.0.c", "original_string": "error_t sshVerifyHostKey(const uint8_t *hostKey, size_t hostKeyLen,\n   const char_t *trustedKey, size_t trustedKeyLen)\n{\n   error_t error;\n   size_t n;\n   uint8_t *buffer;\n   error = sshDecodePublicKeyFile(trustedKey, trustedKeyLen, NULL, &n);\n   if(!error)\n   {\n      buffer = sshAllocMem(n);\n      if(buffer != NULL)\n      {\n         error = sshDecodePublicKeyFile(trustedKey, trustedKeyLen, buffer, &n);\n         if(hostKeyLen == n && !osMemcmp(hostKey, buffer, n))\n         {\n            error = NO_ERROR;\n         }\n         else\n         {\n            error = ERROR_INVALID_KEY;\n         }\n         sshFreeMem(buffer);\n      }\n      else\n      {\n         error = ERROR_OUT_OF_MEMORY;\n      }\n   }\n   return error;\n}"}
{"author": "sdukesameer", "file": "c__min_largest.2.c", "original_string": "int main(){\n    int n;\n    int* arr;\n    printf(\"Enter the size of the dynamic array: \");\n    scanf(\"%d\",&n);\n    arr=(int*) malloc(sizeof(int)*n);\n    for (int i = 0; i < n; i++){\n        printf(\"Enter the %dth element: \",i+1);\n        scanf(\"%d\",&arr[i]);\n    }\n    printf(\"\\nMaximum Element = %d\\n\",max(arr,n));\n    printf(\"Minimum Element = %d\\n\",min(arr,n));\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__receiver.1.c", "original_string": "int addr_check(unsigned char des_addr[6]){\n    int flag = 1;\n    int i =0;\n    for(i = 0;i<6;i++){\n        if(des_addr[i] != my_addr[i]) flag = 0;\n    }\n    if(flag){\n        printf(\"[INFO] Address check success!\\n\");\n    }else {\n        printf(\"[Error] Address check error!\\n\");\n    }\n    return flag;\n}"}
{"author": "2security", "file": "File__20FileOrDirectoryExitOrNot.0.c", "original_string": "int main()\n{\n    char path[100];\n    printf(\"Enter source file path: \");\n    scanf(\"%s\", path);\n    if (isFileExistsAccess(path))\n    {\n        printf(\"File exists at path '%s'\\n\", path);\n    }\n    else\n    {\n        printf(\"File does not exists at path '%s'\\n\", path);\n    }\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__BinHexConverter0.1.c", "original_string": "uint8_t convertHexDigitToBinValue(char inputChr)\n{\n  if (inputChr >= '0' && inputChr <= '9') \n  {\n    return ((uint8_t)(inputChr - '0'));\n  }\n  else if (inputChr >= 'a' && inputChr <= 'f') {\n    return 10 + ((uint8_t)(inputChr - 'a'));\n  }\n  else if (inputChr >= 'A' && inputChr <= 'F') {\n    return 10 + ((uint8_t)(inputChr - 'A'));\n  }\n  return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q3_reverselq.3.c", "original_string": "void rev(nptr list)\n{\n    nptr trv=list;\n    while(trv->rlink)\n        trv=trv->rlink;\n    nptr last=trv;\n    while(trv!=list)\n    {\n        nptr temp=trv->llink;\n        trv->llink=trv->rlink;\n        trv->rlink=temp;\n        trv=temp;\n    }\n    (list->rlink)->rlink=NULL;\n    list->rlink=last;\n    last->llink=list;\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b4.0.c", "original_string": "size_t count_yes(size_t *yes, size_t num) {\n    size_t count = 0;\n    for (size_t i = 0; i < 26; i++)\n        if (yes[i] == num) count++;\n    return count;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__circularqueue.4.c", "original_string": "void main()\n{\n    int ch;\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter value to insert:\");\n                scanf(\"%d\",&value);\n                enqueue(value);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nthe popped value is %d\",dequeue()); \n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the value to search\");\n                scanf(\"%d\",&value);\n                search(value);\n                break;\n            }\n            case 4:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"author": "fikepaci", "file": "monty__tokenize_string.2.c", "original_string": "int get_word_length(char *str, char *delims)\n{\n    int wLen = 0, pending = 1, i = 0;\n    while (*(str + i))\n    {\n        if (is_delim(str[i], delims))\n            pending = 1;\n        else if (pending)\n        {\n            wLen++;\n        }\n        if (wLen > 0 && is_delim(str[i], delims))\n            break;\n        i++;\n    }\n    return (wLen);\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__decToBin.0.c", "original_string": "void decToBin(int dec)\n{\n    float resto;\n    int numeriBinari[100], i = 0;\n    while(dec > 0)\n    {\n        numeriBinari[i] = dec % 2;\n        dec = dec/2;\n        i++;\n    }\n    for(int j = i-1; j>=0; j--)\n    {\n        printf(\"%d\",numeriBinari[j]);\n    }\n}"}
{"author": "2security", "file": "Pointer__9Access2DArray.0.c", "original_string": "void Display(int **a,int m,int n)\n    {\n        int i,j;\n        for(i=0;i<m;i++)\n            {\n                for(j=0;j<n;j++)\n                    printf(\"%d \",*(*(a+i)+j));\n                printf(\"\\n\");\n            }\n    }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__25_sen.2.c", "original_string": "int main(){\n        double X;\n        printf(\"Programa para calcular el sen(X) por medio de sumas de Taylor\\nValor de X:\");\n        scanf(\"%lf\", &X);\n        Sen(1,50,0,X);\n        return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__BinHexConverter0.3.c", "original_string": "uint8_t convertHexString8ToBinValue(char *inputStr, size_t inputStrLength)\n{\n  if (inputStrLength != 2) \n  {\n    return 0;\n  }\n  uint8_t outputValue = convertHexDigitToBinValue(inputStr[0]) << 4;\n  outputValue |= convertHexDigitToBinValue(inputStr[1]);\n  return outputValue;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__QuickSort.0.c", "original_string": "int Partition(int ARR[],int BEG,int END)\n{\n    int Left=BEG,Right=END,LOC=BEG,FLAG=0,temp;\n    while(FLAG!=1)\n    {\n        while(ARR[LOC]<=ARR[Right] && LOC!=Right)\n        {\n            Right=Right-1;\n        }\n        if(LOC==Right)\n        {\n            FLAG=1;\n        }\n        else if(ARR[LOC]>ARR[Right])\n        {\n            temp=ARR[LOC];\n            ARR[LOC]=ARR[Right];\n            ARR[Right]=temp;\n            LOC=Right;\n        }\n        if(FLAG!=1)\n        {\n            while(ARR[LOC]>=ARR[Left] && LOC!=Left)\n            {\n                Left=Left+1;\n            }\n            if(LOC==Left)\n            {\n                FLAG=1;\n            }\n            else if(ARR[LOC]<ARR[Left])\n            {\n                temp=ARR[LOC];\n                ARR[LOC]=ARR[Left];\n                ARR[Left]=temp;\n                LOC=Left;\n            }\n        }\n    }\n    return(LOC);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_any_pos_CLL.4.c", "original_string": "void delete_at_pos()\n{\n    struct node *temp,*nextnode;\n    int i=1;\n    int pos;\n    int leg=count();\n    printf(\"enter the position in between 1 to %d\\n\",leg);\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    temp=head;\n    while(i<pos-1)\n    {\n        temp=temp->next;\n        i++;\n    }\n    nextnode=temp->next;\n    temp->next=nextnode->next;\n    free(nextnode);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__CC.0.c", "original_string": "int popstar(int N[][1000], int j, int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        if (N[i][j] != 1) return false;\n    }\n    return true;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__QuickSort.1.c", "original_string": "void QuickSort(int ARR[],int BEG,int END)\n{\n    int LOC;\n    if(BEG<END)\n    {\n        LOC=Partition(ARR,BEG,END);\n        QuickSort(ARR,BEG,LOC-1);\n        QuickSort(ARR,LOC+1,END);\n    }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_12.0.c", "original_string": "int evaluatepostfix(int a,int b, char c,FILE* F2)\n{\nint res=1;\nif(c=='+')\n    return a+b;\nif(c=='-')\n        return b-a;\nif(c=='*')\n        return a*b;\nif(c=='/')\n        return b/a;\nif(c=='^')\n{\nfor(int i=1;i<=a;i++)\n{\nres*=b;\n}\nreturn res;\n}\nprintf(\"invalid operator\");\nfprintf(F2,\"-999\");\nexit(0);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q32.5.c", "original_string": "int main()\n{\n    QUEUE q;\n    QUEUE* q1=&q;\n    init(q1);\n    add(1,q1);\n    add(2,q1);\n    add(3,q1);\n    add(4,q1);\n    add(5,q1);\n    add(6,q1);\n    add(7,q1);\n    if(find(q1,9))\n        printf(\"Found\\n\");\n    else\n        printf(\"Not Found\\n\");\n    if(find(q1,5))\n        printf(\"Found\\n\");\n    else\n        printf(\"Not Found\\n\");\n    display(q1);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler2.8.c", "original_string": "int main()\n{\n    PNODE First = NULL;\n    PNODE Last = NULL;\n    int choice = 1, no = 0, pos = 0;\n    printf(\"-----------------------------\\n\");\n    printf(\"Singly Circular Linked List\\n\");\n    printf(\"-----------------------------\\n\");\n    while(choice!= 0)   \n    {\n        printf(\"-----------------------------\\n\");\n        printf(\"Enter your choice : \\n\");\n        printf(\"1: Inser first\\n2: Insert Last\\n3: Insert at position \\n4: Delete first: \\n5: Delete Last\\n\");\n        printf(\"6: Delete at position \\n7: Display \\n8: Count: \\n0: Exit\\n\");\n        scanf(\"%d\", &choice);\n        printf(\"-----------------------------\\n\");\n        switch(choice)\n        {\n            case 1:\n                printf(\"Enter number : \\n\");\n                scanf(\"%d\",&no);\n                InsertFirst(&First, &Last,no);\n                break;\n            case 2:\n                printf(\"Enter number : \\n\");\n                scanf(\"%d\",&no);\n                InsertLast(&First, &Last,no);\n                break;\n            case 3 :\n                printf(\"Enter number : \\n\");\n                scanf(\"%d\",&no);\n                printf(\"Enter position : \\n\");\n                scanf(\"%d\",&pos);\n                InsertAtPos(&First, &Last,no,pos);\n                break;\n            case 4:\n                DeleteFirst(&First, &Last);\n                break;\n            case 5 :\n                DeleteLast(&First,&Last);\n                break;\n            case 6:\n                 printf(\"Enter position : \\n\");\n                 scanf(\"%d\",&pos);\n                 DeleteAtPos(&First, &Last,pos);\n                 break;\n            case 7:\n                Display(First, Last);\n                break;\n            case 8:\n                printf(\"Number of node are %d\\n\", Count(First, Last));\n                break;\n            case 0:\n                printf(\"Thank you for using the application...\\n\");\n                break;\n            default:\n                printf(\"Error : Wrong choice..\\n\");\n        }\n    }\n    return 0;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__31_find_pair_sum_equal_a.0.c", "original_string": "int main()\n{\n  int i=0,j=0,k=0,array[100]={0},array2[100] = {0}, no=0,insert_no=0,insert_index=0,flag=0,pair_sum = 0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array[i]);\n  }\n  printf(\"\\nEnter Element, whose you want to find pair\");\n  scanf(\"%d\",&pair_sum);\n  printf(\"\\nPair_sum is %d\\n\",pair_sum);\n  for(i=0; i<no; i++)\n  {\n    for(j=i+1; j<no; j++)\n    {\n     if(array[i] + array[j] == pair_sum)\n     {\n       printf(\"Pair for %d are (%d,%d) found at (%d,%d) position\\n\",pair_sum,array[i],array[j],i,j);\n     }\n    }\n  }\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__tree.6.c", "original_string": "void preorder_1(struct database *node){\n    if(node == NULL) {\n        return;\n    } else {\n        printf(\"%d\\n\",node->roll_no);\n        preorder_1(node->right);\n        preorder_1(node->left);\n    }\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__sender.3.c", "original_string": "int send_frame(unsigned char *frame, unsigned int frame_len){\n    FILE *file = fopen(\"pipe.bin\", \"wb+\");\n    if(file == NULL)\n    {\n        printf(\"[INFO] File open error!\\n\");\n        return 0;\n    }\n    fwrite(&frame_len,sizeof(frame_len),1,file);\n    fwrite(frame, sizeof(char), frame_len, file);\n    fclose(file);\n    printf(\"[INFO] Frame send success!\\n\");\n    return 0;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__functions.0.c", "original_string": "pointerHash InitializeHashTable(int size)\n{\n    pointerHash table;\n    table = (pointerHash)malloc(sizeof(HashTable));\n    if (!table)\n    {\n        printf(\"Problem with memory allocation!\\n\");\n        return table;\n    }\n    table->size = size;\n    table->hashList = (position*)malloc(sizeof(position) * size);\n    if (!table->hashList)\n    {\n        printf(\"Problem with memory allocation!\\n\");\n        return table->hashList;\n    }\n    for (int i = 0; i < table->size; i++)\n        table->hashList[i] = NULL;\n    return table;\n}"}
{"author": "andi-s0106", "file": "sorting_algorithms__2-selection_sort.0.c", "original_string": "void selection_sort(int *array, size_t size)\n{\n    int min;\n    size_t i;\n    size_t j;\n    size_t position;\n    if (array == NULL)\n        return;\n    for (i = 0; i < size; i++)\n    {\n        min = array[i];\n        position = i;\n        for (j = i + 1; j < size; j++)\n        {\n            if (min > array[j])\n            {\n                position = j;\n                min = array[j];\n            }\n        }\n        if (position != i)\n        {\n            array[position] = array[i];\n            array[i] = min;\n            print_array(array, size);\n        }\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__string_in_stack.2.c", "original_string": "void push(int num) {\n    if (isFull())\n        printf(\"Stack is Full...\\n\");\n    else {\n        string.array[string.top + 1] = num;\n        string.top++;\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__funcoes.3.c", "original_string": "void vetor_taylor(int n, double a[], double x, double xf)\n{\n    double at[7];\n    for (int i = 0; i <= n; i++)\n    {\n        at[i] = a[i]; \n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = i; j > 0; j--)\n        {\n            at[i] *= j; \n        }\n    }\n    f_de_x_taylor(n, at, x, xf); \n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Delete_At_The_Beginning_Of_A_Single_Linked_List.0.c", "original_string": "int main()\n{\n    int choice = 1;\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->ptr = NULL;\n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->ptr = newnode;\n            temp = newnode;\n        }\n        printf(\"Do you want to enter more nodes?(1/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_node(temp);\n    delete_at_start(head,temp);\n    getch();\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica3-3a.2.c", "original_string": "void * consumidor(){  \n    for (int i=0; i<10; i++){ \n        sem_wait(&full);                                    \n        sem_wait(&mutex);    \n        int numero = consumirDato();\n        printf(\"Consumidor:\\n\");\n        printf(\"---->Consumidor, Dato %d: %d\\n\", i+1, numero);\n        sem_post(&mutex);                             \n        sem_post(&empty);                                                \n    }\n    pthread_exit(NULL);                 \n}"}
{"author": "paawankohli", "file": "DSA-LAB__q20.0.c", "original_string": "int* bsearch(int* first, int size, int x)\n{\n    int* last = first + size - 1;\n    while(first <= last)\n    {\n        int *mid = first + (last - first)/2;\n        if(*mid == x)\n            return mid;\n        else if(*mid > x)\n            last = mid - 1;\n        else if(*mid < x)\n            first = mid + 1;\n    }\n    return NULL;\n}"}
{"author": "behergue", "file": "Operating_Systems__myFS.4.c", "original_string": "int findNodeByPos(int nodeNum)\n{\n    int whichInodeBlock;\n    int whichInodeInBlock;\n    int inodeLocation;\n    whichInodeBlock = nodeNum / NODES_PER_BLOCK;\n    whichInodeInBlock = nodeNum % NODES_PER_BLOCK;\n    inodeLocation = (NODES_IDX + whichInodeBlock) * BLOCK_SIZE_BYTES + whichInodeInBlock * sizeof(NodeStruct);\n    return inodeLocation;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_common.1.c", "original_string": "error_t scpParseDirective(const char_t *buffer, ScpDirective *directive)\n{\n   error_t error;\n   char_t *p;\n   error = NO_ERROR;\n   osMemset(directive, 0, sizeof(ScpDirective));\n   directive->opcode = (ScpOpcode) buffer[0];\n   if(directive->opcode == SCP_OPCODE_OK)\n   {\n      TRACE_DEBUG(\"SCP success directive received...\\r\\n\");\n   }\n   else if(directive->opcode == SCP_OPCODE_WARNING ||\n      directive->opcode == SCP_OPCODE_ERROR)\n   {\n      TRACE_DEBUG(\"SCP error directive received...\\r\\n\");\n      directive->message = (char_t *) buffer + 1;\n   }\n   else if(directive->opcode == SCP_OPCODE_FILE ||\n      directive->opcode == SCP_OPCODE_DIR)\n   {\n      TRACE_DEBUG(\"SCP '%c' directive received...\\r\\n\", directive->opcode);\n      do\n      {\n         directive->mode = osStrtoul(buffer + 1, &p, 8);\n         if(!osIsblank(*p))\n         {\n            error = ERROR_INVALID_SYNTAX;\n            break;\n         }\n         while(osIsblank(*p))\n         {\n            p++;\n         }\n         directive->size = osStrtoull(p, &p, 10);\n         if(!osIsblank(*p))\n         {\n            error = ERROR_INVALID_SYNTAX;\n            break;\n         }\n         while(osIsblank(*p))\n         {\n            p++;\n         }\n         directive->filename = p;\n      } while(0);\n   }\n   else if(directive->opcode == SCP_OPCODE_END)\n   {\n      TRACE_DEBUG(\"SCP '%c' directive received...\\r\\n\", directive->opcode);\n   }\n   else if(directive->opcode == SCP_OPCODE_TIME)\n   {\n      TRACE_DEBUG(\"SCP '%c' directive received...\\r\\n\", directive->opcode);\n      do\n      {\n         directive->mtime = osStrtoul(buffer + 1, &p, 10);\n         if(!osIsblank(*p))\n         {\n            error = ERROR_INVALID_SYNTAX;\n            break;\n         }\n         osStrtoul(p, &p, 10);\n         if(!osIsblank(*p))\n         {\n            error = ERROR_INVALID_SYNTAX;\n            break;\n         }\n         directive->atime = osStrtoul(p, &p, 10);\n         if(!osIsblank(*p))\n         {\n            error = ERROR_INVALID_SYNTAX;\n            break;\n         }\n         osStrtoul(p, &p, 10);\n         if(*p != '\\0')\n         {\n            error = ERROR_INVALID_SYNTAX;\n            break;\n         }\n      } while(0);\n   }\n   else\n   {\n      TRACE_WARNING(\"SCP unknown directive received...\\r\\n\");\n      error = ERROR_INVALID_COMMAND;\n   }\n   return error;\n}"}
{"author": "jose120918", "file": "binary_trees__15-binary_tree_is_full.2.c", "original_string": "size_t tree_size(const binary_tree_t *tree)\n{\n    int count = 0;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    count = 1 + tree_size((*tree).left) + tree_size((*tree).right);\n    return (count);\n}"}
{"author": "augustogunsch", "file": "jackc__tokenizer.4.c", "original_string": "void freetokens(TOKEN* t) {\n    free(t->token);\n    TOKEN* next = t->next;\n    free(t);\n    if(next != NULL)\n        freetokens(next);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__11_.1.c", "original_string": "void Columnas(int contador, int pibote)\n{\n    if(contador < 80){\n        if(contador > (80 - pibote))\n            printf(\"A\");\n        else\n            printf(\" \");\n        Columnas(++contador,pibote);\n    }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler.3.c", "original_string": "int Count(PNODE Head, PNODE Tail)\n{\n    int iCnt = 0;\n        if((Head == NULL) && (Tail == NULL))\n        {\n            return 0;\n        }\n        do\n        {\n            iCnt++;\n            Head = Head->next;\n        }while(Head != Tail->next);\n    return iCnt;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__BA.0.c", "original_string": "int main()\n{\n    char string[81], stringinv[81], aux;\n    int tam, tam1, busca;\n    fgets(string, 81, stdin);\n    for (int i=0; string[i] != '\\0'; i++)\n    {\n        if (string[i] == '\\n')\n        {\n            string[i] = '\\0';\n        }\n    }\n    for (int i = 0; string[i] != '\\0'; i++)\n    {\n        if (string[i] == ' ')\n        {\n            for (int j = i; string[j] != '\\0'; j++)\n            {\n                string[j] = string[j + 1];\n            }\n        }\n    }\n    tam = strlen(string);\n    for (int i = 0; string[i] != '\\0'; i++)\n    {\n        stringinv[i] = string[(tam - 1) - i];\n    }\n    busca = true;\n    for (int i = 0; string[i] != '\\0'; i++)\n    {\n        if (string[i] != stringinv[i])\n        {\n            busca = false;\n            break;\n        }\n    }\n    if (busca == true)\n    {\n        printf(\"S\\n\");\n    }\n    else if (busca == false)\n    {\n        printf(\"N\\n\");\n    }\n    return 0;\n}"}
{"author": "SugumaranEvil", "file": "Linux_programming__prc4.0.c", "original_string": "int main()\n{\n   int msgid;\n   int size;\n   int ret_msgsnd;\n   struct my_message msg_buffer;\n   msgid = msgget(1004,IPC_CREAT | 0644);\n   perror(\"msgget\");\n   strcpy(msg_buffer.buffer,string1);\n   msg_buffer.mtype = 14; \n   size = strlen(string1)+1;\n   ret_msgsnd = msgsnd(msgid,&msg_buffer,size,0);\n   perror(\"msgget\");\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q3_reverselq.4.c", "original_string": "void disp(nptr list)\n{\n    nptr i=list->rlink;\n    while(i)\n    {\n        printf(\"%s  \",i->ele);\n        i=i->rlink;\n    }\n    printf(\"\\n\");\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__AI.0.c", "original_string": "void potencia(float x, int n, float xp[])\n{\n    float x0 = 1;\n    xp[0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        x0 *= x;\n        xp[i] = x0;\n    }\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad80.0.c", "original_string": "int main()\n{\n    int userBasicHour;\n    int workHours;\n    float brutto;\n    float podatek;\n    int userChoice;\n    int valueOK = 0;\n    int endProgram = 0;\n    while(!valueOK) {\n        printf(\"********************************************************************\\n\");\n        printf(\"Podaj liczb\\251 odpowiadaj\\245c\\245 zadanej stawce wynagrodzenia lub opcji:\\n\");\n        printf(\"1) 35zl/godz.\\t\\t2) 37zl/godz.\\n\");\n        printf(\"3) 40zl/godz.\\t\\t4) 45zl/godz.\\n\");\n        printf(\"5) wyjscie\\n\");\n        printf(\"********************************************************************\\n\");\n        userChoice = getchar();\n        switch (userChoice) {\n            case '1' : {\n                userBasicHour = BASICHOUR1;\n                printf(\"Wybrano stawk\\251 45zl/godz.\\n\");\n                valueOK = 1;\n                break;\n            }\n            case '2' : {\n                userBasicHour = BASICHOUR2;\n                printf(\"Wybrano stawk\\251 45zl/godz.\\n\");\n                valueOK = 1;\n                break;\n            }\n            case '3' : {\n                userBasicHour = BASICHOUR3;\n                printf(\"Wybrano stawk\\251 45zl/godz.\\n\");\n                valueOK = 1;\n                break;\n            }\n            case '4' : {\n                userBasicHour = BASICHOUR4;\n                printf(\"Wybrano stawk\\251 45zl/godz.\\n\");\n                valueOK = 1;\n                break;\n            }\n            case '5' : {\n                valueOK = 1;\n                endProgram = 1;\n                break;\n            }\n            default : fflush(stdin);\n        }\n    }\n    if (!endProgram) {\n        printf(\"Podaj liczb\\251 przepracowanych godzin w tygodniu: \");\n        scanf(\"%d\", &workHours);\n        if(workHours >= 40) {\n            brutto = 40 * userBasicHour + (workHours - 40) * userBasicHour * OVERTIME;\n        } else {\n            brutto = workHours * userBasicHour;\n        }\n        if (brutto <= 1200) {\n            podatek = brutto * TAX1;\n        } else if (brutto > 1200 && brutto <= 1800) {\n            podatek = 1200 * TAX1 + (brutto - 1200) * TAX2;\n        } else {\n            podatek = 1200 * TAX1 + (600) * TAX2 + (brutto - 1800) * TAX3;\n        }\n        printf(\"\\nWynagrodzenie brutto: %.2fz\\210\\n\", brutto);\n        printf(\"Podatek: %.2fz\\210\\n\", podatek);\n        printf(\"Wynagrodzenie netto: %.2fz\\210\\n\", brutto - podatek);\n        getchar();\n    }\n    return 0;\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__TowerOfHanoi.1.c", "original_string": "int main()\n{\nint n = 0;\nchar A='A',B='B',C='C';\nprintf(\"Enter the number of disc:\");\nscanf(\"%d\",&n);\nTOH(n,A,B,C);\nprintf(\"\\n\\nCount=%ld\",count);\nprintf(\"\\n\");\nreturn 0;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad9.3.c", "original_string": "int InOrderPrint(treePointer root)\n{\n    if (root)\n    {\n        InOrderPrint(root->left);\n        printf(\"%d\\n\", root->data);\n        InOrderPrint(root->right);\n    }\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-structure.12.c", "original_string": "SUBROUTBODY* parsesubroutbody(PARSER* p) {\n    SUBROUTBODY* subroutbody = (SUBROUTBODY*)malloc(sizeof(SUBROUTBODY));\n    subroutbody->vardecs = parsevardecs(p);\n    subroutbody->statements = parsestatements(p);\n    return subroutbody;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__AI.1.c", "original_string": "int main()\n{\n    int n;\n    long int q;\n    float x[100000], av[6], soma = 0, xp[5];\n    scanf(\"%i\", &n);\n    for (int i = 0; i <= n; i++)\n    {\n        scanf(\"%f\", &av[i]);\n    }\n    scanf(\"%li\", &q);\n    for (int i = 0; i < q; i++)\n    {\n        scanf(\"%f\", &x[i]);\n    }\n    for (int i = 0; i < q; i++)\n    {\n        potencia(x[i], n, xp);\n        for (int j = 0; j <= n; j++)\n        {\n            soma += av[j] * xp[j];\n        }\n        printf(\"%f\\n\", soma);\n        soma = 0;\n    }\n    return 0;\n}"}
{"author": "sdukesameer", "file": "c__merge_arr_sort.0.c", "original_string": "int main()\n{\n  int a[100], b[100], m, n, c, sorted[200];\n  scanf(\"%d\", &m); \n  for (c = 0; c < m; c++){\n    scanf(\"%d\", &a[c]); \n  }\n  scanf(\"%d\", &n); \n  for (c = 0; c < n; c++){\n    scanf(\"%d\", &b[c]); \n  }\n  merge(a, m, b, n, sorted);\n  printf(\"Sorted array:\\n\");\n  for (c = 0; c < m + n; c++) {\n    printf(\"%d\\n\", sorted[c]);\n  }\n  return 0;\n}"}
{"author": "MartinMarinovich", "file": "ParcialLaboratorio1GCompleto__marca.2.c", "original_string": "int listarMarcas(eMarca listaDeMarcas[], int tamanio)\n{\n    int error = -1;\n    if(listaDeMarcas !=NULL && tamanio>0)\n    {\n        system(\"cls\");\n        printf(\"\\n****  LISTADO DE MARCAS  ****\\n\");\n        printf(\" Id       Descripcion\\n\");\n        printf(\"----------------------------------\\n\");\n        for(int i = 0 ; i<tamanio; i++)\n        {\n            mostrarMarca(listaDeMarcas[i]);\n        }\n        error = 0;\n    }\n    return error;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__AD.0.c", "original_string": "int main()\n{\n    double x[1000], y[1000], d, menor;\n    int n, p1, p2;\n    scanf (\"%i\", &n);\n    for (int i=0; i<n; i++)\n    {\n        scanf (\"%lf\", &x[i]);\n    }\n    for (int i=0; i<n; i++)\n    {\n        scanf (\"%lf\", &y[i]);\n    }\n    for (int i=0; i<n; i++)\n    {\n        for (int j=(i+1); j<n; j++)\n        {\n            d = pow((x[i]-x[j]),2) + pow((y[i]-y[j]),2);\n            d = sqrt(d);\n            if ((i==0)&&(j==1))\n            {\n                menor = d;\n                p1 = i;\n                p2 = j;\n            }\n            else\n            {\n                if (d < menor)\n                {\n                    menor = d;\n                    p1 = i;\n                    p2 = j;\n                }\n            }\n        }\n    }\n    printf (\"Pontos: %i e %i\\nDistancia: %lf\\n\", p1, p2, menor);\n    return 0;\n}"}
{"author": "earth429", "file": "mulpre__mulprec.20.c", "original_string": "int divide(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c, struct NUMBER *d) {\n    struct NUMBER m, n, p, q;\n    clearByZero(c);\n    clearByZero(d);\n    if(isZero(b) != -1){ \n        return -1;\n    }\n    copyNumber(a, &n);\n    while(1){\n        if(numComp(&n, b) != -1){ \n            increment(c, &m);\n            copyNumber(&m, c);\n            sub(&n, b, &m);\n            copyNumber(&m, &n);\n        } else { \n            copyNumber(&n, d);\n            break;\n        }\n    }\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__BToperations.0.c", "original_string": "nptr copy(nptr original)\n{\n    if (original == NULL)\n        return NULL;\n    temp = createNode(original -> data);\n    temp -> lchild = copy(original -> lchild);\n    temp -> rchild = copy(original -> rchild);\n    return temp;\n}"}
{"author": "Oryx-Embedded", "file": "Common__path.6.c", "original_string": "void pathAddSlash(char_t *path, size_t maxLen)\n{\n   size_t n;\n   n = osStrlen(path);\n   if(!n)\n   {\n      if(maxLen >= 1)\n         osStrcpy(path, \"/\");\n   }\n   else if(path[n - 1] != '/' && path[n - 1] != '\\\\')\n   {\n      if(maxLen >= (n + 1))\n         osStrcat(path, \"/\");\n   }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__keypad_assign.3.c", "original_string": "void col_key2(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(COL);  \n        IODIR1 = IODIR1 | (ROW);  \n        val = (IOPIN1 & COL); \n        val = val >> 17;\n        switch(val)\n        {\n            case 0x0E: \n                lcd_data('4');\n                delay(500);\n                break;\n            case 0x0D:\n                lcd_data('5');\n                delay(500);\n                break;\n            case 0x0B:\n                lcd_data('6');\n                delay(500);\n                break;\n            case 0x07:\n                lcd_data('-');\n                delay(500);\n                break;\n        }\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__DD.0.c", "original_string": "int safety_module()\n{\n    int work[m],finish[n],i,j,flag=0,set;\n    for(i=0;i<m;i++)\n        work[i]=available[i];\n    for(i=0;i<n;i++)\n    {\n        flag=0;\n        for(j=0;j<m;j++)\n        {\n            if(allocation[i][j]!=0)\n            {\n                flag=1;\n                break;\n            }\n            else\n                continue;\n        }\n        if(flag==1)\n            finish[i]=0;\n        else\n            finish[i]=1;\n    }\n    while(1)\n    {\n        set=-1;\n        for(i=0;i<n;i++)\n        {\n            flag=0;\n            for(j=0;j<m;j++)\n            {\n                if(request[i][j]<=work[j])\n                    continue;\n                else\n                {\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0 && finish[i]==0)\n            {\n                set=i;\n                finish[i]=1;\n                for(j=0;j<m;j++)\n                    work[j]=work[j]+allocation[i][j];\n                break;\n            }\n        }\n        if(set==-1)\n            break;\n        else\n            continue;\n    }\n    flag=0;\n    printf(\"\\nProcessess in deadlock are : \\n\");\n    for(i=0;i<n;i++)\n    {\n        if(finish[i]!=1)\n        {\n            printf(\"%d\\t\",i);\n            flag=-1;\n        }\n    }\n    if(flag==0)\n        return(1);\n    else\n        return(0);\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_03.1.c", "original_string": "void checkSubset(int X[],int m,int Y[],int n)\n{\n    int i,j,flag=0;\n    for(i=0;i<n;i++)\n     {\n         for(j=0;j<m;j++)\n         {\n             if(Y[i]==X[j])\n              {\n                  flag++;\n                  break;\n              }\n         }  \n     }\n     if(flag==n)\n       fprintf(F2,\"true\");\n     else\n       fprintf(F2,\"false\");\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__readmap.3.c", "original_string": "int     begins_by_nl(char **mapline)\n{\n    int i;\n    i = 0;\n    while (mapline[i] != '\\0')\n    {\n        if (mapline[i][0] == '\\n')\n            return (1);\n        i++;\n    }\n    return (0);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q13.3.c", "original_string": "int main()\n{\n    int ch;\n    que q;\n    q.front = q.rear = -1;\n    do\n    {\n        printf(\"\\nCircular Queue:\\n1. Insert \\n2. Delete\\n3. Display\\n0. Exit\");\n        printf(\"\\nEnter Choice 0-3? : \");\n        scanf(\"%d\", &ch);\n        switch (ch)\n        {\n            case 1:\n                printf(\"\\nEnter String: \");\n                char *n = malloc(30);\n                scanf(\"%s\", n);\n                insertq(&q, n);\n                break;\n            case 2:\n                deleteq(&q);\n                break;\n            case 3:\n                display(&q);\n                break;\n        }\n    }while (ch != 0);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler.1.c", "original_string": "void InsertFirst(PPNODE Head, PPNODE Tail, int value)\n{\n    PNODE newn = NULL;\n    newn = (PNODE)malloc(sizeof(NODE));\n    newn->data = value;\n    newn->next = NULL;\n    newn->prev = NULL;\n    if((*Head ==NULL) && (*Tail == NULL))       \n    {\n        *Head = newn;\n        *Tail = newn;\n    }\n    else            \n    {\n        newn->next = *Head;\n        (*Head)->prev = newn;\n        *Head = (*Head)->prev;\n    }\n    (*Tail)->next = *Head;\n    (*Head)->prev = *Tail;\n}"}
{"author": "Theemiss", "file": "simple_shell__bulltin.1.c", "original_string": "int echo_bul(char **cmd, int st)\n{\n    char *path;\n    unsigned int  pid = getppid();\n    if (_strncmp(cmd[1], \"$?\", 2) == 0)\n    {\n        print_number_in(st);\n        PRINTER(\"\\n\");\n    }\n    else if (_strncmp(cmd[1], \"$$\", 2) == 0)\n    {\n        print_number(pid);\n        PRINTER(\"\\n\");\n    }\n    else if (_strncmp(cmd[1], \"$PATH\", 5) == 0)\n    {\n        path = _getenv(\"PATH\");\n        PRINTER(path);\n        PRINTER(\"\\n\");\n        free(path);\n    }\n    else\n        return (print_echo(cmd));\n    return (1);\n}"}
{"author": "bgmanuel99", "file": "PracticasArquitecturaDeComputadores__ejercicio10.0.c", "original_string": "int main(int argc, char **argv){\n int rank, count;\n char msg[20];\n MPI_Status status;   \n MPI_Init( &argc , &argv);\n MPI_Comm_rank( MPI_COMM_WORLD ,&rank);\n int i= 0;\n while(i<10){\n     if(rank==0){\n     strcpy(msg,\"Hello World\");\n     MPI_Send( msg , 13 , MPI_CHAR , 1 , 100 , MPI_COMM_WORLD);\n    MPI_Recv( msg , 13 , MPI_CHAR , 1 , 100 , MPI_COMM_WORLD , &status);\n            printf(\"Master: El mensaje es: %s\\n\",msg);\n    }else\n    {\n        MPI_Recv( msg , 13 , MPI_CHAR , 0 , 100 , MPI_COMM_WORLD , &status);\n        printf(\"Secundario: El mensaje es: %s\\n\",msg);\n        strcpy(msg,\"Bye World\");\n        MPI_Send( msg , 13 , MPI_CHAR , 0 , 100 , MPI_COMM_WORLD);\n    }\n    i++;\n }\n    MPI_Finalize();\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__10_While.0.c", "original_string": "int main()\n{\n    system(\"cls\"); \n    int contador = 1;\n    int X_1 = 1;\n    int X_2 = 80;\n    while(X_1 != 41){\n        if(contador <= 80){\n            if(contador == X_1)\n                printf(\"X\");\n            else if(contador == X_2)\n                printf(\"X\");\n            else\n                printf(\" \");\n         }else{\n             sleep(0.4);\n             system(\"cls\");\n             ++X_1;\n             --X_2;\n            contador = 1;\n         }\n    ++contador;\n    }\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.5.c", "original_string": "static bool createFirmwareUpdateInfoFile(void)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"wb\");\n  if (updateInfoFile == NULL) \n  {\n    printf(\"Failed to create %s: %s (error code: %i)\\n\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, strerror(errno), errno);\n    return false;\n  }\n  fclose(updateInfoFile);\n  return true;\n}"}
{"author": "earth429", "file": "mulpre__gcd.1.c", "original_string": "int gcd(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    struct NUMBER tmp, at, bt;\n    getAbs(a, &tmp);\n    copyNumber(&tmp, a);\n    copyNumber(&tmp, &at);\n    getAbs(b, &tmp);\n    copyNumber(&tmp, b);\n    copyNumber(&tmp, &bt);\n    clearByZero(c);\n    if(isZero(a) != -1 && isZero(b) != -1){ \n        return 0;\n    } else if(isZero(b) != -1) { \n        copyNumber(a, c);\n        return 0;\n    }\n    while(isZero(&tmp) == -1){\n        divide(a, b, c, &tmp);\n        copyNumber(b, a);\n        copyNumber(&tmp, b);\n    }\n    copyNumber(a, c);\n    copyNumber(&at, a);\n    copyNumber(&bt, b);\n    return 0;\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__utils.0.c", "original_string": "void    global_init(void)\n{\n    g_no = NULL;\n    g_so = NULL;\n    g_we = NULL;\n    g_ea = NULL;\n    g_width = 0;\n    g_height = 0;\n    g_fr = -1;\n    g_fg = -1;\n    g_fb = -1;\n    g_cr = -1;\n    g_cg = -1;\n    g_cb = -1;\n    g_map_started = 0;\n    g_map = ft_strdup(\"\");\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__12.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    FILE *arq_1, *arq_2, *arq_3;\n    char aux;\n    if (argc < 4)\n    {\n        printf(\"\\nErro! N\u00e3o foram informados arquivos o suficiente\\n\\n\");\n        return 0;\n    }\n    arq_1 = fopen(argv[1], \"r\");\n    arq_2 = fopen(argv[2], \"r\");\n    arq_3 = fopen(argv[3], \"w\");\n    if (arq_1 == NULL || arq_2 == NULL || arq_3 == NULL)\n    {\n        printf(\"\\nErro ao abrir algum arquivo\\n\\n\");\n        return 0;\n    }\n    while ((fscanf(arq_1, \"%c\", &aux) != EOF))\n    {        \n        fprintf(arq_3, \"%c\", aux);   \n    }\n    while ((fscanf(arq_2, \"%c\", &aux) != EOF))\n    {        \n        fprintf(arq_3, \"%c\", aux);   \n    }\n    fclose(arq_1);\n    fclose(arq_2);\n    fclose(arq_3);\n    return 0;\n}"}
{"author": "MFarid94", "file": "Assignment-2__Exercise16.0.c", "original_string": "int countOnes(unsigned char number){\n    unsigned char mask = 0x80;                          \n    int ones = 0;\n    for(int i = 0; i<8 ; i++){\n        if((number<<i) & mask){\n            ++ones;\n        }\n    }\n    return ones;\n}"}
{"author": "earth429", "file": "mulpre__doubleLog.0.c", "original_string": "int main(int argc, char **argv)\n{\n    double a;\n    double x = 4.0;\n    int n = 1000;\n    int return_val;\n    return_val = doubleLog(&a, x, n);\n    printf(\"a = %f\\nx = %f\\n\", a, x);\n    printf(\"log = %f\\n\", log(x));\n    printf(\"\u623b\u308a\u5024 = %d\", return_val);\n    return 0;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__stack.2.c", "original_string": "int Peep(PNODE Head)    \n{\n    int no = 0;\n    if(Head == NULL)\n    {\n        printf(\"Stack is empty\\n\");\n        return -1;\n    }\n    else\n    {\n        no = Head->data;\n        return no;\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q2_longadd.1.c", "original_string": "void insert(nptr list,int x)\n{\n    nptr temp=createNode();\n    temp->ele=x;\n    temp->llink=list;\n    temp->rlink=list->rlink;\n    list->rlink=temp;\n    (temp->rlink)->llink=temp;\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client2.2.c", "original_string": "void send_recv(int i, int sockfd, char name[32], fd_set *master)\n{\n    char in_buf[BUFSIZE];\n    char send_buf[BUFSIZE + 32] = \"\";\n    char recv_buf[BUFSIZE];\n    char disconnect_mssge[32];\n    struct message send_message, recv_message;\n    int nbyte_recvd;\n    if (i == 0)\n    {\n        fgets(in_buf, BUFSIZE, stdin);\n        trim_newline(in_buf, BUFSIZE);\n        send_message.type = 0;\n        strcpy(send_message.name, name);\n        sprintf(send_message.data, \"%s\", in_buf);\n        if (strncmp(in_buf, \"bye\", 3) == 0)\n        {\n            send_message.type = 2;\n            sprintf(send_message.data, \"left the discussion\");\n            send(sockfd, &send_message, sizeof(struct message), 0);\n            FD_CLR(i, master);\n            close(i);\n            close(sockfd);\n            exit(0);\n        }\n        else\n            send(sockfd, &send_message, sizeof(struct message), 0);\n        bzero(in_buf, BUFSIZE);\n    }\n    else\n    {\n        nbyte_recvd = recv(sockfd, &recv_message, sizeof(struct message), 0);\n        if (nbyte_recvd == 0) {\n            close(sockfd);\n            exit(1);\n        }\n        if (recv_message.type == 0)\n        {\n            printf(\"[%s]: %s\\n\", recv_message.name, recv_message.data);\n        }\n        else if (recv_message.type == 1)\n        {\n            printf(\"%s joined the chat!\\n\", recv_message.name);\n        }\n        else if (recv_message.type == 2)\n        {\n            printf(\"%s left the chat!\\n\", recv_message.name);\n        }\n        else if (recv_message.type == 3)\n        {\n            printf(\"%d. %s is present\\n\", ++cnt, recv_message.name);\n        }\n        else if (recv_message.type == 4) \n        {\n            printf(\"Sorry Wrong Password. Try Again to Enter\\n\");\n            close(sockfd);\n            exit(0);\n        }\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__insert_element_at_begining_single_linked_list.2.c", "original_string": "void inab(int data)\n{\n    struct node*peloon;\n    peloon=(struct node*)malloc(sizeof(struct node));\n    peloon->data=data;\n    peloon->next=head;\n    head=peloon;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_29.0.c", "original_string": "void calcularTotal(int numero[6]) {\n    for (int i = 0; i < 6; i++) {\n        if (numero[i] % 2 == 0) {\n            quantidadeTotalPar = quantidadeTotalPar + numero[i];\n            pares[i] = numero[i];\n        } else {\n            quantidadeTotalImpar = quantidadeTotalImpar + numero[i];\n            impares[i] = numero[i];\n        }\n    }\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-tree.2.c", "original_string": "void freeparameters(PARAMETER* p) {\n    free(p->debug);\n    PARAMETER* next = p->next;\n    free(p);\n    if(next != NULL)\n        freeparameters(next);\n}"}
{"author": "fikepaci", "file": "monty__tokenize_string.0.c", "original_string": "char **strtow(char *str, char *delims)\n{\n    char **words = NULL;\n    int wc, wordLen, n, i = 0;\n    if (str == NULL || !*str)\n        return (NULL);\n    wc = get_word_count(str, delims);\n    if (wc == 0)\n        return (NULL);\n    words = malloc((wc + 1) * sizeof(char *));\n    if (words == NULL)\n        return (NULL);\n    while (i < wc)\n    {\n        wordLen = get_word_length(str, delims);\n        if (is_delim(*str, delims))\n        {\n            str = get_next_word(str, delims);\n        }\n        words[i] = malloc((wordLen + 1) * sizeof(char));\n        if (words[i] == NULL)\n        {\n            while (i >= 0)\n            {\n                i--;\n                free(words[i]);\n            }\n            free(words);\n            return (NULL);\n        }\n        n = 0;\n        while (n < wordLen)\n        {\n            words[i][n] = *(str + n);\n            n++;\n        }\n        words[i][n] = '\\0'; \n        str = get_next_word(str, delims);\n        i++;\n    }\n    words[i] = NULL; \n    return (words);\n}"}
{"author": "DanielSalis", "file": "AED1__teste6.2.c", "original_string": "int existeNalista(TipoLista* l, int id){\n    TipoElemento* aux = l->primeiro;\n    while(aux!=NULL){\n        if(aux->id == id){\n            return 1;\n        }\n        aux = aux->prox;\n    }\n    return 0;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_02.3.c", "original_string": "int main(int argc, char* argv[])\n{\n    int search_shift(int a[], int);\n    int num; char s;int size;\n        int* arr;\n        F1 = fopen(argv[1], \"r\");\n        F2 = fopen(argv[2], \"w\");\n        while(1)\n        {\n        fscanf(F1 ,\"%c\",&s);\n        if(s == 'r')\n        {\n        fscanf(F1, \"%d\", &num);\n                size = num;\n                arr = read(num);\n        }\n        else if(s == 's')\n        {\n                int p = search_shift(arr, size);\n                fprintf(F2,\"%d\\n\", p);\n        }\n        else if(s == 'd')\n        {\n                display(arr, size);\n                fprintf(F2, \"\\n\");\n        }\n    else if(s == 't')\n        return 0;\n    }\n    fclose(F1);\n    fclose(F2);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__stack_using_array.1.c", "original_string": "void push()\n{\n    int x;\n    printf(\"enter the data =\");\n    scanf(\"%d\",&x);\n    if(top==N-1)\n    {\n        printf(\"stack overflow\\n\");\n    }\n    else\n    {\n        top++;\n        stack[top]=x;\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server_file.3.c", "original_string": "error_t scpServerReadData(ScpServerSession *session)\n{\n   error_t error;\n   size_t n;\n   size_t length;\n   error = NO_ERROR;\n   if(session->bufferPos < session->bufferLen)\n   {\n      error = sshWriteChannel(session->channel,\n         session->buffer + session->bufferPos,\n         session->bufferLen - session->bufferPos, &n, 0);\n      if(error == NO_ERROR || error == ERROR_TIMEOUT)\n      {\n         session->bufferPos += n;\n      }\n   }\n   else if(session->fileOffset < session->fileSize)\n   {\n      if((session->fileSize - session->fileOffset) < SCP_SERVER_BUFFER_SIZE)\n      {\n         length = (size_t) (session->fileSize - session->fileOffset);\n      }\n      else\n      {\n         length = SCP_SERVER_BUFFER_SIZE;\n      }\n      error = fsReadFile(session->file, session->buffer, length, &n);\n      if(!error)\n      {\n         if(n == length)\n         {\n            session->fileOffset += n;\n            session->bufferLen = n;\n            session->bufferPos = 0;\n         }\n         else\n         {\n            error = ERROR_READ_FAILED;\n         }\n      }\n   }\n   else\n   {\n      fsCloseFile(session->file);\n      session->file = NULL;\n      if(session->recursive)\n      {\n         pathRemoveFilename(session->path);\n         pathRemoveSlash(session->path);\n      }\n      session->bufferLen = 0;\n      session->bufferPos = 0;\n      session->state = SCP_SERVER_SESSION_STATE_READ_STATUS;\n   }\n   return error;\n}"}
{"author": "jose120918", "file": "sorting_algorithms__1-insertion_sort_list.0.c", "original_string": "void insertion_sort_list(listint_t **list)\n{\n    listint_t *cur, *t, *t2;\n    if (list == NULL || *list == NULL || (*list)->next == NULL)\n        return;\n    for (cur = *list; cur != NULL; cur = cur->next)\n    {\n        t = cur;\n        for (t2 = t->prev; t2 != NULL && t2->n > t->n; t2 = t->prev)\n        {\n            if (t2->prev != NULL && t->next != NULL)\n            {\n                t2->prev->next = t;\n                t->next->prev = t2;\n                t2->next = t->next;\n                t->prev = t2->prev;\n                t->next = t2;\n                t2->prev = t;\n                print_list(*list);\n                continue;\n            }\n            if (t2->prev == NULL)\n            {\n                t->prev = NULL;\n                t2->next = t->next;\n                t2->prev = t;\n                if (t->next != NULL)\n                    t->next->prev = t2;\n                t->next = t2;\n                *list = t;\n                print_list(*list);\n                continue;\n            }\n            if (t->next == NULL)\n            {\n                t->prev = t2->prev;\n                t->next = t2;\n                t2->next = NULL;\n                t2->prev->next = t;\n                t2->prev = t;\n                print_list(*list);\n                continue;\n            }\n        }\n    }\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad1.0.c", "original_string": "int main()\n{\n    char userMonth[MAXNAME];\n    printf(\"Podaj nazwe miesiaca.\\n\");\n    printf(\"Program wyswietli liczbe dni od poczatku roku do podanego miesiaca: \");\n    scanf(\"%s\", &userMonth);\n    printf(\"Liczba dni: %d\", numberOfDays(userMonth));\n    getchar();\n    return 0;\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__RandomizedQuickSort.3.c", "original_string": "int myrandom(int lower,int upper)\n      {\n          int num;\n          srand(time(0));\n          num = (rand() % (upper - lower + 1) + lower);\n          return num;\n      }"}
{"author": "sdukesameer", "file": "dsa__dll-ins-seq-sor-del.4.c", "original_string": "void printforward(node* head)\n{\n    node* dll=head;\n    while (dll!=NULL)\n    {\n        printf(\"%d  \",dll->data);\n        dll=dll->next;\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__timer1_isr.2.c", "original_string": "void intr_config(void)\n{\n        VICIntSelect = VICIntSelect & ~((1<<4)|(1<<5)); \n        VICVectCntl1 = (1<<5)|5;   \n        VICVectAddr1 = (long)&timer1_isr;       \n        VICIntEnable = (1<<4)|(1<<5);   \n}"}
{"author": "augustogunsch", "file": "jackc__parser-structure.9.c", "original_string": "SUBROUTDEC* parsesubroutdecs(PARSER* p, CLASS* c) {\n    SUBROUTDEC* head = parsesubroutdec(p, c);\n    SUBROUTDEC* curr = head;\n    SUBROUTDEC* nexts;\n    while(nexts = parsesubroutdec(p, c), nexts != NULL) {\n        curr->next = nexts;\n        curr = nexts;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_SLL.0.c", "original_string": "int main()\n{\n    printf(\"Linked list functions\\n\");\n    int choice;\n    printf(\"1.implementation\\n\");\n    printf(\"2.display\\n\");\n    printf(\"3.count\\n\");\n    printf(\"4.delete the element at the end  positon\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    while(choice!=6)\n    {\n    switch(choice)\n    {\n    case 1:printf(\"implementation \\n\");\n    create();\n    break;\n    case 2:printf(\"display\\n\");\n    display();\n    break;\n    case 3:printf(\"count the element in linked list\\n\");\n    count();\n    break;\n    case 4:printf(\"delete the element from the end\\n\");\n    delete_at_end();\n    break;\n    case 5:exit(0);\n    break;\n    default: printf(\"wrong choice \\n\");\n    break;\n    }\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__circularLinkedList.2.c", "original_string": "struct Node *insertAtTheIndex(struct Node *head, int data, int index)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     struct Node *q = head;\n     int i = 0;\n     while (i != index - 1)\n     {\n          q = q->next;\n          i++;\n     }\n     ptr->data = data;\n     ptr->next = q->next;\n     q->next = ptr;\n     return head;\n}"}
{"author": "mehedi9021", "file": "C_Programming__practice5.0.c", "original_string": "int main()\n{\n    int\n    a[5][5], b[5][5], sum=0;\n    int r, c;\n    for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                scanf(\"%d\", &a[r][c]);\n            }\n        }\n        printf(\"\\n\");\n        for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                scanf(\"%d\", &b[100][100]);\n            }\n        }\n        printf(\"\\n\");\n        for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                sum=a[r][c];\n            }\n            printf(\"%d\", sum);\n        }\n        return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__tokenizer.15.c", "original_string": "bool handlecomment(FILE* input, int* lnscount) {\n    unsigned char nextc = fgetc(input);\n    if(nextc == '/') {\n        skipln(input);\n        (*lnscount)++;\n        return true;\n    }\n    else if(nextc == '*') {\n        unsigned char furtherc = fgetc(input);\n        if(furtherc == '*') {\n            skipmultiln(input, lnscount);\n            return true;\n        }\n        ungetc(furtherc, input);\n    }\n    ungetc(nextc, input);\n    return false;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__quick_sort.1.c", "original_string": "int sort(int a[],int l,int r)\n{\n    int key,start,end;\n    key=a[l];\n    start=l;\n    end=r;\n    if(start<end)\n    {\n        if(a[start]<=key)\n        {\n            start++;\n        }\n        if(a[end]>key)\n        {\n            end--;\n        }\n        if(start<end)\n        {\n            elemswap(&a[start],&a[end]);\n        }\n    }\n    elemswap(&a[end],&a[l]);\n    return end;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e41.0.c", "original_string": "void main(){\n    char nome[50];\n    int capacidade,operacao,capacidadeMeiaEntrada,confirmacao,vendidoMeia,vendidoInteira;\n    float valorInteira,meiaEntrada,valorPago,troco;\n    vendidoMeia = 0;\n    vendidoInteira = 0;\n    printf(\"Ingressos++\");\n    printf(\"\\nCadastre um evento\");\n    printf(\"\\nNome do evento: \\n\");\n    gets(nome);\n    printf(\"\\nCapacidade maxima: \\n\");\n    scanf(\"%d\", &capacidade);\n    capacidadeMeiaEntrada = capacidade*0.4;\n    printf(\"\\nValor da entrada: \\n\");\n    scanf(\"%g\", &valorInteira);\n    meiaEntrada = valorInteira/2;\n    printf(\"\\nEvento: %s\", nome);\n    printf(\"\\nCapacidade maxima de %d\", capacidade);\n    printf(\"\\nValor da entrada(Inteira): %g\",valorInteira);\n    printf(\"\\nValor da entrada(Meia): %g\",meiaEntrada);\n    sleep(4);\n    system(\"cls\"); \n    while(operacao != 3){\n    printf(\"\\nComprar ingresso\");\n    printf(\"\\n[1] - Valor inteiro\");\n    printf(\"\\n[2] - Meia entrada\");\n    printf(\"\\n[3] - Finalizar vendas\\n\");\n    scanf(\"%d\", &operacao);\n    switch(operacao){\n        case 1:\n            printf(\"\\nValor da compra: %g\", valorInteira);\n                printf(\"\\n Confirmar:\");\n                printf(\"\\n[1] - SIM\");\n                printf(\"\\n[2] - NAO\\n\");\n                scanf(\"%d\", &confirmacao);\n                if(confirmacao == 1){\n                    printf(\"\\nValor do ingresso: %g\", valorInteira);\n                    printf(\"\\nValor pago\\n\");\n                    scanf(\"%g\", &valorPago);\n                    if(valorPago >= valorInteira){\n                    troco = valorPago - valorInteira;\n                    printf(\"\\nTroco: %g\", troco);\n                    printf(\"\\nIngresso comprado com sucesso!\");\n                    capacidade = capacidade - 1;\n                    vendidoInteira++;\n                    printf(\"\\nValor do ingresso: %g \\nvalor pago: %g \\ntroco: %g\",valorInteira,valorPago,troco);\n                    break;\n                }else{\n                    printf(\"\\nQuantia insuficiente!\");\n                    break;\n                }\n                }else{\n                    printf(\"\\nOperacao finalizada!\");\n                    break;\n                }\n        case 2:\n            if(capacidadeMeiaEntrada > 0 ){\n                printf(\"\\nValor do ingresso: %g\", meiaEntrada);\n                printf(\"\\nConfirmar:\");\n                printf(\"\\n[1] - SIM\");\n                printf(\"\\n[2] - NAO\\n\");\n                scanf(\"%d\", &confirmacao);\n                if(confirmacao == 1){\n                    printf(\"\\nValor do ingresso: %g\",meiaEntrada);\n                    printf(\"\\nValor pago:\\n\");\n                    scanf(\"%g\", &valorPago);\n                    if(valorPago>=meiaEntrada){\n                    troco = valorPago - meiaEntrada;\n                    printf(\"\\nTroco: %g\", troco);\n                    printf(\"\\nIngresso comprado com sucesso!\");\n                    capacidadeMeiaEntrada = capacidadeMeiaEntrada - 1;\n                    capacidade = capacidade - 1;\n                    vendidoMeia++;\n                    printf(\"\\nValor do ingresso: %g \\nValor pago: %g \\nTroco: %g\",meiaEntrada,valorPago,troco);\n                    break;\n                    }else{\n                        printf(\"\\nQuantia insuficiente!\");\n                        break;\n                    }\n                }else{\n                    printf(\"\\nOperacao finalizada!\");\n                    break;\n                }\n            }else{\n                printf(\"\\nIngressos de meia entrada esgotados!\");\n                break;\n            }\n        case 3: \n            printf(\"\\nTotal de ingressos vendidos tipo inteira: %d\", vendidoInteira);\n            printf(\"\\nTotal de ingressos vendidos tipo meia: %d\", vendidoMeia);\n            printf(\"\\nIngressos disponiveis inteira: %d\", capacidade);\n            printf(\"\\nIngressos disponiveis meia: %d\", capacidadeMeiaEntrada);\n            break;\n        default: \n            printf(\"\\nIngressos esgotados\");    \n            sleep(5);\n            break;\n    }\n}\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q3_reverselq.5.c", "original_string": "int main()\n{\n    int n;\n    printf(\"Enter no. of elemnts: \");\n    scanf(\"%d\", &n);\n    char str[SIZE];\n    nptr list=createNode();\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter word to insert: \"); \n        scanf(\"%s\", str);\n        insertf(list, str);\n    }\n    disp(list);\n    rev(list);\n    disp(list);\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-structure.0.c", "original_string": "int countlocalvars(VARDEC* decs) {\n    int i = 0;\n    while(decs != NULL) {\n        STRINGLIST* curr = decs->names;\n        while(curr != NULL) {\n            i++;\n            curr = curr->next;\n        }\n        decs = decs->next;\n    }\n    return i;\n}"}
{"author": "revathy16296", "file": "rtos_lab_asssignment_1__1_sum.3.c", "original_string": "float product_of_num(int array[])\n{\n    float product=1;\n    for(i=0;i<SI;i++)\n    {\n        product*=array[i];\n    }\n    return product;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.17.c", "original_string": "SUBROUTCALL* parsesubroutcall(PARSER* p) {\n    SUBROUTCALL* c = (SUBROUTCALL*)malloc(sizeof(SUBROUTCALL));\n    c->debug = getdebug(p);\n    if(nextequals(p, \".\")) {\n        c->parentname = parseidentifier(p);\n        next(p);\n    }\n    else\n        c->parentname = NULL;\n    c->name = parseidentifier(p);\n    checkcontent(p, \"(\");\n    c->parameters = parseexpressionlist(p);\n    checkcontent(p, \")\");\n    return c;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server.1.c", "original_string": "error_t scpServerInit(ScpServerContext *context,\n   const ScpServerSettings *settings)\n{\n   uint_t i;\n   TRACE_INFO(\"Initializing SCP server...\\r\\n\");\n   if(context == NULL || settings == NULL)\n      return ERROR_INVALID_PARAMETER;\n   if(settings->sessions == NULL || settings->numSessions < 1 ||\n      settings->numSessions > SCP_SERVER_MAX_SESSIONS)\n   {\n      return ERROR_INVALID_PARAMETER;\n   }\n   if(settings->rootDir == NULL ||\n      osStrlen(settings->rootDir) > SCP_SERVER_MAX_ROOT_DIR_LEN)\n   {\n      return ERROR_INVALID_PARAMETER;\n   }\n   osMemset(context, 0, sizeof(ScpServerContext));\n   context->sshServerContext = settings->sshServerContext;\n   context->numSessions = settings->numSessions;\n   context->sessions = settings->sessions;\n   context->checkUserCallback = settings->checkUserCallback;\n   context->getFilePermCallback = settings->getFilePermCallback;\n   osStrcpy(context->rootDir, settings->rootDir);\n   pathCanonicalize(context->rootDir);\n   pathRemoveSlash(context->rootDir);\n   for(i = 0; i < context->numSessions; i++)\n   {\n      osMemset(&context->sessions[i], 0, sizeof(ScpServerSession));\n   }\n   if(!osCreateEvent(&context->event))\n   {\n      scpServerDeinit(context);\n   }\n   return NO_ERROR;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__PassingStructureToFunction.1.c", "original_string": "void displayBookDetails(struct Book b1)\n{\n    printf(\"\\nGetting the Book Details....\\n\");\n    printf(\"\\nBook_ID: %d\", b1.book_id);\n    printf(\"\\nBook_Price: %f\", b1.book_price);\n    printf(\"\\nBook_Name: %s\", b1.book_name);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_last_CLL.3.c", "original_string": "void count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the list is %d\\n\",c);\n}"}
{"author": "MartinMarinovich", "file": "ParcialLaboratorio1GCompleto__cliente.0.c", "original_string": "int hardCodearClientes(eCliente listadoClientes[], int tamanioClientes)\n{\n    int error = -1;\n    int id[10] ={1,2,3,4,5,6,7,8,9,10};\n    char nombres [10][20] = {\"Juan\",\"Carlos\",\"Martin\",\"Lucas\",\"Daniel\",\"Ana\",\"Julia\",\"Daniela\",\"Maria\",\"Pedro\"};\n    char sexos [10] = {'m','m','m','m','m','f','f','f','f','m'};\n    if(listadoClientes != NULL && tamanioClientes>0)\n    {\n        for(int i = 0; i<tamanioClientes; i++)\n        {\n            listadoClientes[i].idCliente = id[i];\n            strcpy(listadoClientes[i].nombre,nombres[i]);\n            listadoClientes[i].sexo = sexos[i];\n        }\n        error = 0;\n    }\n    return error;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__queue1.2.c", "original_string": "void search(int queue[],int val)\n{\n    int i,c=0;\n    if(front==-1 || front>rear)\n    printf(\"\\nqueue is empty\");\n    else\n    {\n        for(i=front;i<=rear;i++)\n        {\n            if(queue[i]==val)\n            {\n                printf(\"\\nvalue found\");\n                c=c+1;\n                break;\n            }\n        }\n        if(c==0)\n        printf(\"\\nvalue not found\");\n    }\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__single_link_list.3.c", "original_string": "void print_list()\n{\n    int i=0;\n    print_ptr = head;\n    while(print_ptr != NULL)\n    {\n        i++;\n        printf(\"node %d regno %d name %s\\n\",i,print_ptr->regno,print_ptr->name);\n        print_ptr = print_ptr->next;\n    }\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad10-PointerFunctions.2.c", "original_string": "void printAvgMonth(float pointer[][0]){\n    float * rok;        \n    float * miesiac;    \n    float podsuma, suma;\n    printf(\"SREDNIE MIESIECZNE:\\n\\n\");\n    printf(\" Sty  Lut  Mar  Kwi  Maj  Cze  Lip  Sie  Wrz  Paz \");\n    printf(\" Lis  Gru\\n\");\n    for (miesiac = *pointer; miesiac <= *pointer + 11; miesiac++){\n        for(rok = miesiac, podsuma = 0; rok <= *pointer + 48 + 11; rok = rok + 12){ \n            podsuma += *rok;\n        }\n        printf(\"%4.1f \", podsuma/LATA);\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__sftp_server.5.c", "original_string": "error_t sftpServerSetHomeDir(SftpServerSession *session, const char_t *homeDir)\n{\n   SftpServerContext *context;\n   if(session == NULL || homeDir == NULL)\n      return ERROR_INVALID_PARAMETER;\n   context = session->context;\n   pathCopy(session->homeDir, context->rootDir, SFTP_SERVER_MAX_HOME_DIR_LEN);\n   pathCombine(session->homeDir, homeDir, SFTP_SERVER_MAX_HOME_DIR_LEN);\n   pathCanonicalize(session->homeDir);\n   pathRemoveSlash(session->homeDir);\n   return NO_ERROR;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__threads.2.c", "original_string": "void waitthreads(pthread_t* threads, int amount) {\n    void* status;\n    int code;\n    for(int i = 0; i < amount; i++) {\n        code = pthread_join(threads[i], &status);\n        if(code) {\n            eprintf(\"Error while joining thread %i: %s\\n\", i, strerror(code));\n            exit(code);\n        }\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__pthread_attr_detach.1.c", "original_string": "int main()\n{\n    pthread_attr_t attr;\n    int ret = pthread_attr_init(&attr);\n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_attr_init error:%s\\n\", strerror(ret));\n        exit(1);\n    }\n    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);      \n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_attr_init error:%s\\n\", strerror(ret));\n        exit(1);\n    }\n    pthread_t tid;\n    ret = pthread_create(&tid, &attr, thread_fun, NULL);\n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_create error:%s\\n\", strerror(ret));\n        exit(1);\n    }\n    ret = pthread_attr_destroy(&attr);\n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_attr_destroy error:%s\\n\", strerror(ret));\n        exit(1);\n    }\n    ret = pthread_join(tid, NULL);\n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_join error:%s\\n\", strerror(ret));\n        exit(1);\n    }\n    printf(\"main:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n    return 0;    \n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-2new.2.c", "original_string": "int*** make3darrint(int rows, int cols,int hei){\n    int ***x;\n    MALLOC(x,rows*sizeof(**x));\n    int i,j;\n    for(i=0;i<rows;i++){\n        MALLOC(x[i],cols*sizeof(**x));\n        for(j=0;j<hei;j++){\n            MALLOC(x[i][j],hei*sizeof(***x));\n        }\n    }\n    return x;\n}"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__map_manager.0.c", "original_string": "void        player_init(char c, int x, int y)\n{\n    if (g_player.x != -1 || g_player.y != -1)\n    {\n        ft_putstr(\"Error:\\nthe map has more than one player\\n\");\n        exit(0);\n    }\n    else\n    {\n        g_player.x = (x * 32) + 16;\n        g_player.y = (y * 32) + 16;\n        if (c == 'N')\n            g_player.rotation_angle = M_PI / 2;\n        else if (c == 'S')\n            g_player.rotation_angle = M_PI / 2;\n        else if (c == 'E')\n            g_player.rotation_angle = M_PI / 2;\n        else if (c == 'W')\n            g_player.rotation_angle = M_PI / 2;\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CLL.6.c", "original_string": "void insert_at_pos()\n{\n    struct node *newnode,*temp;\n    int i=1;\n    int pos;\n    int leg=count();\n    printf(\"enter the position in between 1 to %d\\n\",leg);\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    if(pos>leg)\n    {\n        printf(\"Invalid position\\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=temp->next;\n        temp->next=newnode;\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__all_interrupts.1.c", "original_string": "void interrupt_config(void)\n{\n    PINSEL0 |= (1<<29);\n    PINSEL0 &= ~(1<<28);                                                    \n    VICIntSelect &= ~((1<<4)|(1<<5)|(1<<15));           \n    VICVectCntl1    = (1<<5)| 15;                                       \n    VICVectAddr1    =   (long)eint1_isr;\n    VICVectCntl4    = (1<<5)|4;                                             \n    VICVectAddr4    = (long)timer0_isr1;                                \n    VICVectCntl5    = (1<<5)|5;                                                 \n    VICVectAddr5    = (long)timer1_isr2;\n    VICIntEnable    = (1<<4)|(1<<5)|(1<<15) ;               \n    EXTMODE = (1<<1);                                                       \n    EXTPOLAR    = (1<<1);                                                       \n}"}
{"author": "augustogunsch", "file": "jackc__tokenizer.3.c", "original_string": "TOKEN* appendtokenraw(TOKEN* curitem, STRING* token, int definedat, TOKENTYPE type) {\n    curitem->token = (char*)malloc(sizeof(char)*token->count);\n    strcpy(curitem->token, token->str);\n    curitem->definedat = definedat;\n    curitem->type = type;\n    TOKEN* nextitem = mktoken();\n    curitem->next = nextitem;\n    token->count = 0;\n    return nextitem;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__BG.0.c", "original_string": "int main()\n{\n    char str[1001], aux;\n    int qtd = 1;\n    fgets(str, 1001, stdin);\n    for (int i = 0; str[i] != '\\0'; i++)\n    {\n        if (str[i] == '\\n')\n        {\n            str[i] = '\\0';\n        }\n    }\n    for (int i = 0; str[i] != '\\0';)\n    {\n        aux = str[i];\n        for (int k = 1; str[k] != '\\0'; k++)\n        {\n            if (aux != str[i + k])\n            {\n                break;\n            }\n            else\n            {\n                qtd++;\n            }\n        }\n        i += qtd;\n        if (qtd == 1)\n        {\n            printf(\"%c\", aux);\n        }\n        else\n        {\n            printf(\"%i%c\", qtd, aux);\n        }\n        qtd = 1;\n    }\n    putchar('\\n');\n    return 0;\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-1.11.c", "original_string": "int bfs(char*** maze,int*** d,int sr,int sc,int sh){\n    rear=-1;front=-1;\n    int arrive=0;\n    element position;\n    position.row = sr;\n    position.col = sc;\n    position.hei = sh;\n    addq(position);\n    int i,j,k;\n    for(i=0;i<n/2+1;i++){\n        for(j=0;j<n+2;j++){\n            for(k=0;k<n+2;k++){\n                d[i][j][k]=MAX;\n            }\n        }\n    }\n    d[sh][sr][sc]=0;\n    int nr,nc,nh;\n    int row,col,hei;\n    while(rear!=front){\n        position = deleteq();\n        row = position.row;\n        col = position.col;\n        hei = position.hei;\n        if(maze[hei][row][col]=='F'){\n            if(min>d[hei][row][col]){\n                min = d[hei][row][col];\n            }\n            arrive=1;\n        }\n        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='D'){\n            int upanddown=-1;\n            if(maze[hei][row][col]=='U'){\n                upanddown=1;\n            }\n            nr = row;\n            nc = col;\n            nh = hei+upanddown;\n            if(nh>=0){\n                if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){\n                    d[nh][nr][nc]=d[hei][row][col]+1;\n                    if(maze[nh][nr][nc]=='T'){\n                        d[nh][nr][nc]=d[nh][nr][nc]+2;\n                    }\n                    element nextposition;\n                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                    addq(nextposition);\n                }\n            }\n        }\n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            nh = hei+move[i].hei;\n            if (maze[nh][nr][nc]!='X' && d[nh][nr][nc]>d[hei][row][col]+1){\n                d[nh][nr][nc]=d[hei][row][col]+1;\n                if(maze[nh][nr][nc]=='T'){\n                    d[nh][nr][nc]=d[nh][nr][nc]+2;\n                }\n                element nextposition;\n                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                addq(nextposition);\n            }\n        }\n    }\n    return arrive;\n}"}
{"author": "SugumaranEvil", "file": "TLPI__msg_q_crt.0.c", "original_string": "int main(){\n    printf(\"\\033[1;31mSystem V Message queue Creating a message\\033[0m\\n\");\n    int mesg_id,msgsnd_return;\n    struct mymsg my_data1,my_data2,my_data3;\n    my_data1.mtype  = 1; \n    my_data2.mtype  = 2;\n    my_data3.mtype  = 3;\n    strncpy(my_data1.mtext,str1,strlen(str1)+1);\n    strncpy(my_data2.mtext,str2,strlen(str2)+1);\n    strncpy(my_data3.mtext,str3,strlen(str3)+1);\n    mesg_id = msgget(103,IPC_CREAT|0644);\n    perror(\"msgget\");\n    msgsnd_return = msgsnd(mesg_id, &my_data1, strlen(str1)+1, 1);\n    perror(\"msgsnd\");\n    msgsnd_return = msgsnd(mesg_id, &my_data2, strlen(str2)+1, 2);\n    perror(\"msgsnd\");\n    msgsnd_return = msgsnd(mesg_id, &my_data3, strlen(str3)+1, 3);\n    perror(\"msgsnd\");\n}"}
{"author": "christiane-millan", "file": "UTM2020B-102A-025011-Structured-Programming__juego.1.c", "original_string": "void jugar(){\n    int respuesta;\n    int numero = aleatorio(INICIO, FIN);\n    int intentos = 1;\n    system(\"clear\");\n    do {\n        printf(\"N\u00famero de intentos: %d\\n\", intentos);\n        printf(\"Adiviana un n\u00famero entero entre [%d - %d]\", INICIO, FIN);\n        scanf(\"%d\", &respuesta );\n        intentos++;\n        if(respuesta > numero) {\n            printf(\"N\u00famero muy alto\\n\");\n        } else {\n            if (respuesta < numero)\n                printf(\"Numero muy bajo\\n\");\n            else{\n                printf(\"Excelente!! Adivinaste el n\u00famero!!\\n\");  \n                fflush(stdin); \n                printf(\"Presiona una tecla para continuar...\");\n                getchar();\n            }\n        }\n    } while (respuesta != numero );\n}"}
{"author": "davibernardos", "file": "DB-PJ__e92.0.c", "original_string": "void cadastrarEvento(struct evento show[])\n{   \n    printf(\"Informe o nome do evento:\\n\");\n    fflush(stdin);\n    gets(show[contShow].nome);\n    printf(\"Informe o valor do ingresso: \\n\");\n    scanf(\"%g\", &show[contShow].valorIngresso);\n    printf(\"Informe a quantidade de lugares disponiveis: \\n\");\n    scanf(\"%d\", &show[contShow].cadeiras);\n    show[contShow].disponiveis = show[contShow].cadeiras;\n    show[contShow].lucro = 0;\n    show[contShow].meia = 0;\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__mqserver.0.c", "original_string": "void main()\n{\n    int mqid,rval,msgid;\n    message m2;\n    mqid=msgget((key_t)80,IPC_CREAT|0666);\n    if(mqid==-1)\n    {\n        perror(\"MQ-CRE-ERR\");\n        exit(1);\n    }\n    system(\"ipcs -q\");\n    printf(\"\\nEnter the msgid :\");\n    scanf(\"%d\",&msgid);\n    rval=msgrcv(mqid,(message*)&m2,sizeof(m2),msgid,0);\n    if(rval==-1)\n    {\n        perror(\"No message read\");\n        msgctl(mqid,IPC_RMID,0);\n        system(\"ipcs -q\");\n        exit(1);\n    }\n    printf(\"\\nMessage entered : %s\\n\",m2.txt);\n    msgctl(mqid,IPC_RMID,0);\n    system(\"ipcs -q\");\n}"}
{"author": "2security", "file": "File__20FileOrDirectoryExitOrNot.1.c", "original_string": "int isFileExists(const char *path)\n{\n    FILE *fptr = fopen(path, \"r\");\n    if (fptr == NULL)\n        return 0;\n    fclose(fptr);\n    return 1;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__i2c_MasterRxMode.1.c", "original_string": "void i2c_init(void)\n{\n    PINSEL0 |= (1<<4)|(1<<6);\n    PINSEL0 &= ~((1<<5)|(1<<7));        \n    I2CONSET = 1<<6;                                \n    I2SCLH = 75;                                        \n    I2SCLL = 75;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Linked.4.c", "original_string": "void main()\n{\n    int ch,id,size,i;\n    for(i=0;i<16;i++)\n    {\n        disk[i].id=0;\n        disk[i].next_index=-1;\n    }\n    while(1)\n    {\n        printf(\"\\nEnter choice : \");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1: \n            {\n                printf(\"\\nEnter file id : \");\n                scanf(\"%d\",&id);\n                printf(\"\\nEnter size : \");\n                scanf(\"%d\",&size);\n                add_file(id,size);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter file id : \");\n                scanf(\"%d\",&id);\n                rem_file(id);\n                break;\n            }\n            case 3:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__9.0.c", "original_string": "double exponencial(int a, long long int n)\n{\n    if (n == 0) return 1;\n    else if (n == 1) return a;\n    else if (n % 2 == 0) return exponencial(a, n/2) * exponencial(a, n/2);\n    else return exponencial(a, n-1) * exponencial(a, 1);\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__planetas.3.c", "original_string": "void lightning(){\n    GLfloat light0_pos[] = {2.0f, 2.0f, 2.0f, 1.0f};\n    GLfloat white[] = {1.0f, 1.0f, 1.0f, 1.0f};\n    GLfloat black[] = {0.0f, 0.0f, 0.0f, 1.0f};\n    glLightfv(GL_LIGHT0,GL_POSITION,light0_pos);\n    glLightfv(GL_LIGHT0,GL_AMBIENT,black);\n    glLightfv(GL_LIGHT0,GL_DIFFUSE,white);\n    glLightfv(GL_LIGHT0,GL_SPECULAR,white);\n    GLfloat light1_pos[] = {-2.0f, 0.0f, 0.0f, 1.0f};\n    glLightfv(GL_LIGHT1,GL_POSITION,light1_pos);\n    glLightfv(GL_LIGHT1,GL_DIFFUSE, white);\n    glLightfv(GL_LIGHT1,GL_SPECULAR, white);\n    GLfloat direction[] = {1.0f, 0.0f, 0.0f};\n    glLightfv(GL_LIGHT1,GL_SPOT_DIRECTION,direction);\n    glLightf(GL_LIGHT1,GL_SPOT_CUTOFF,45.0f);          \n    glLightf(GL_LIGHT1,GL_SPOT_EXPONENT,0.1f);             \n    glEnable(GL_LIGHTING);\n    glEnable(GL_LIGHT0);\n    glEnable(GL_LIGHT1);\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__tab_mlt.3.c", "original_string": "int     main(int    ac,char **av)\n{\n    int     n;\n    int     i;\n    if (ac == 2)\n    {\n        n = ft_atoi(av[1]);\n        i = 1;\n        while (i <= 9)\n        {\n            ft_putnbr(i);\n            write(1, \" x \", 3);\n            ft_putnbr(n);\n            write(1, \" = \", 3); \n            ft_putnbr(i * n);\n            write(1, \"\\n\", 1);\n            i++;\n        }\n    }\n    else\n        write(1 , \"\\n\", 1);\n    return (0);\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Deletion_At_The_End_of_A_Single_Linked_List.2.c", "original_string": "void delete_at_end(struct node*head1, struct node*temp1)\n{\n    struct node*prevnode;\n    while(temp1->ptr!=NULL)\n    {\n        prevnode = temp1;\n        temp1 = temp1->ptr;\n    }\n    prevnode->ptr = NULL;\n    free(temp1);\n    prevnode = head1;\n    printf(\"\\nAfter Deletion:\");\n    while(prevnode!=NULL)\n    {\n        printf(\"%d\\t\",prevnode->data);\n        prevnode = prevnode->ptr;\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader0.6.c", "original_string": "static bool parseFirmwareUpdateInfo(char *updateInfoString)\n{\n  memset(updateVersion, 0, sizeof(updateVersion));\n  memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n  if (strstr(updateInfoString, UPDATE_INFO_SEPARATOR) == NULL) \n  {\n    printf(\"Firmware update request with missing version and/or verification data entered\\n\");\n    return false;\n  }\n  char *parsedVersion = strtok(updateInfoString, UPDATE_INFO_DELIMITERS);\n  if (parsedVersion == NULL) \n  {\n    printf(\"Firmware update request with missing version and verification data entered\\n\");\n    return false;\n  }\n  if (strlen(parsedVersion) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) \n  {\n    printf(\"Received firmware update version too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH);\n    return false;\n  }\n  strncpy(updateVersion, parsedVersion, sizeof(updateVersion));\n  char *parsedVerificationData = strtok(NULL, UPDATE_INFO_DELIMITERS);\n  if (parsedVerificationData == NULL) \n  {\n    printf(\"Firmware update request with missing version or verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (strlen(parsedVerificationData) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n  {\n    printf(\"Received firmware update verification data too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH << 1);\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (convertHexString8ToBinData(parsedVerificationData, strlen(parsedVerificationData), updateVerificationData, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) == 0) \n  {\n    printf(\"Firmware update request with invalid verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n    return false;\n  }\n  return true;\n}"}
{"author": "RafaelFelisbino-hub", "file": "FUNCOES-exercices__Exercicio5FUNCAO.1.c", "original_string": "float cubo(float N)\n{\n    float resultado;\n    printf(\"Digite o numero para saber seu cubo:  \");\n    scanf_s(\"%f\", &N);\n    resultado = N * N * N;\n    return(resultado);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__15_.1.c", "original_string": "void Columnas(int contador, int pibote)\n{\n    if(contador <= 34){\n        if(contador >= 28){\n            if(contador >= (28 + pibote) && contador <= (34 - pibote))\n                printf(\" \");\n            else\n                printf(\"A\");\n            Columnas(++contador, pibote);\n        }else{\n            printf(\" \");\n            Columnas(++contador, pibote);\n        }\n    }\n}"}
{"author": "2security", "file": "String__30SearchAlloccurrence.0.c", "original_string": "void prefixSuffixArray(char* pat, int M, int* pps) {\n   int length = 0;\n   pps[0] = 0;\n   int i = 1;\n   while (i < M) {\n      if (pat[i] == pat[length]) {\n         length++;\n         pps[i] = length;\n         i++;\n      } else {\n         if (length != 0)\n         length = pps[length - 1];\n         else {\n            pps[i] = 0;\n            i++;\n         }\n      }\n   }\n}"}
{"author": "2security", "file": "Star__Hollowsquarediagonal.0.c", "original_string": "int main()\n    {\n    int n,i,j;\n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<=n;j++)   \n            {\n            if(i==1||i==n||j==1||j==n||i==j||i+j==n+1)\n                {\n                printf(\"*\");\n                }\n            else \n                printf(\" \");\n            }   \n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__funcoes.1.c", "original_string": "double f_de_x(int n, double a[], double x) \n{\n    double soma = 0;\n    for (int i = 0; i <= n; i++)\n    {\n        soma += a[i] * pow(x, i); \n    }\n    return soma; \n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__7.1.c", "original_string": "int main()\n{\n    int m, n;\n    do\n    {\n        printf(\"\\nFun\u00e7\u00e3o de Ackermann:\\n\");\n        printf(\"\\t-> m: \");\n        scanf(\"%i\", &m);\n        getchar();\n        printf(\"\\t-> n: \");\n        scanf(\"%i\", &n);\n        getchar();\n        system(\"clear\");\n    } while (n < 0 || m < 0);\n    printf(\"\\nA(%i,%i) = %li\\n\\n\", m, n, ackermann(m,n));\n    return 0;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es5.1.c", "original_string": "int main(void) {\n    int dim_a;\n    printf(\"Inserire dimensione a: \");\n    scanf(\"%d\", &dim_a);\n    int *a = malloc(sizeof(int)*dim_a);\n    for(int i=0; i<dim_a; i++){\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\n\");\n    rimuovi(a, &dim_a);\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__OPR.0.c", "original_string": "int find_pos(int pg,int x)\n{\n    int i,set=0;\n    for(i=x;i<n;i++)\n    {\n        if(page[i]==pg)\n        {\n            set=i;\n            break;\n        }\n    }\n    return(set);\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc.7.c", "original_string": "void mirror_image(node** root)\n{\n    node* temp;\n    if((*root)!=NULL)\n    {\n        mirror_image(&(*root)->left);\n        mirror_image(&(*root)->right);\n        temp=(*root)->left;\n        (*root)->left=(*root)->right;\n        (*root)->right=temp;\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_DCLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__Md_Sameer_13000119114.5.c", "original_string": "void push(stack* stk, int n){\n    if(is_full(stk))\n        printf(\"OVERFLOW OCCURRED!\\n\");\n    else{\n        stk->arr[++stk->top]=n;\n        printf(\"%d pushed to stack.\\n\",stk->arr[stk->top]);\n    }\n}"}
{"author": "DanielSalis", "file": "AED1__teste8.6.c", "original_string": "void printTree(node* root){\n    if(root == NULL){\n        return;\n    }\n    else{\n        printTree(root->left);\n            printf(\"%d \",root->key);\n        printTree(root->right);\n    }\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__17_.2.c", "original_string": "void Filas(int contador)\n{\n    if(contador < 11){\n        Columnas(1, (contador - 1));\n        printf(\"\\n\");\n        Filas(++contador);      \n    }\n}"}
{"author": "behergue", "file": "Operating_Systems__leds_user.0.c", "original_string": "int main(int argc, char * argv[]){\n    if (argc!=2){\n        fprintf(stderr, \"Uso: %s cont_binario/rotativo (Elegir uno de los dos modos)\\n\", argv[0]);\n        exit(1);\n    }\n    FILE * file = fopen(PATH, \"r+\");\n    if (file == NULL){\n        printf(\"No se puede abrir el archivo\\n\");\n        exit(1);\n    }\n    fclose(file);\n    if(strcmp(argv[1], \"cont_binario\") == 0){\n        cont_binario();\n    }\n    else if(strcmp(argv[1], \"rotativo\") == 0){\n        rotativo();\n    }\n    else{\n        fprintf(stderr, \"Modo: %s no valido\\n\", argv[1]);\n        exit(1);\n    }\n    return 0;\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__map_utils.2.c", "original_string": "void        longuest_line(void)\n{\n    int i;\n    int j;\n    int max;\n    i = 0;\n    j = 0;\n    max = 0;\n    while (g_map_array[i])\n    {\n        while (g_map_array[i][j] != '\\0')\n            j++;\n        i++;\n        if (j > max)\n            max = j;\n        j = 0;\n    }\n    g_map_width = max;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e62.6.c", "original_string": "int main(int argc, char *argv[]) \n{\n    int opcao, loop;\n    contEvento = 0;\n    loop = 0;   \n    cabecalho();\n    while(loop == 0)\n    {\n        printf(\"\\n\");           \n        printf(\"\\n1) Cadastro de Evento.\\n\");       \n        printf(\"2) Compre seu ingresso.\\n\");    \n        printf(\"3) Sair.\\n\");\n        printf(\"\\n\");       \n        printf(\"Digite a opcao desejada: \");\n        scanf(\"%d\", &opcao);\n        printf(\"\\n\");\n        switch (opcao)\n        {\n            case 1:\n                cadastrarEvento();\n            break;\n            case 2: \n                menuIngresso();\n            break;\n            case 3:\n                loop = 1;\n            break;\n            default:\n                printf(\"Opcao invalida!\\n\");\n            break;\n        }   \n    }\n    return 0;\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__next_round.0.c", "original_string": "int main(){\n  int n, k, aux, aux2;\n  int cont = 0;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &k);\n  if(k < 1 || k > 50 ||n < 1\n     || n > 50 || k > n)\n    return 0;\n  for(int i = 1; i <= n; i++){\n    if(i <= k){\n      scanf(\"%d\", &aux);\n      if(aux >0)\n    cont++;\n      else\n    break;\n    }\n    else if(i>k){\n      scanf(\"%d\", &aux2);\n      if(aux2 == aux)\n    cont++;\n    }\n  }\n  printf(\"%d\\n\", cont);\n}"}
{"author": "sdukesameer", "file": "c__rec_binary_search.0.c", "original_string": "int bSearch(int arr[],int n,int val,int* p){\n    static int c=0;\n    static int l=0;\n    if(n==0){\n        printf(\"ERROR: Empty list\\n\");\n        exit(1);\n    }\n    if(n<l){\n        printf(\"ERROR:Not found\\n\");\n        exit(1);\n    }\n    int m=(l+n)/2;\n    if(arr[m]==val){\n        *p=m;\n        return c;\n    }\n    c++;\n    if(arr[m]>val)\n        return bSearch(arr, m-1, val, p);\n    else\n    {\n        l=m+1;\n        return bSearch(arr, n, val, p);\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__keypad_assign.4.c", "original_string": "void col_key3(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(COL);  \n        IODIR1 = IODIR1 | (ROW);  \n        val = (IOPIN1 & COL); \n        val = val >> 17;\n        switch(val)\n        {\n            case 0x0E: \n                lcd_data('7');\n                delay(500);\n                break;\n            case 0x0D:\n                lcd_data('8');\n                delay(500);\n                break;\n            case 0x0B:\n                lcd_data('9');\n                delay(500);\n                break;\n            case 0x07:\n                lcd_data('*');\n                delay(500);\n                break;\n        }\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__13_.1.c", "original_string": "void Columnas(int contador, int pibote){\n    if(contador <= 46){\n        if(contador >= (34 + pibote) && contador <= (46 - pibote))\n            printf(\"P\");\n        else\n            printf(\" \");\n        Columnas(++contador, pibote);\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__timer0_timer1_isr.6.c", "original_string": "void delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.8.c", "original_string": "void doLeftShift(struct btreeNode *myNode, int pos) {\n        int j = 1;\n        struct btreeNode *x = myNode->link[pos - 1];\n        x->count++;\n        x->val[x->count] = myNode->val[pos];\n        x->link[x->count] = myNode->link[pos]->link[0];\n        x = myNode->link[pos];\n        myNode->val[pos] = x->val[1];\n        x->link[0] = x->link[1];\n        x->count--;\n        while (j <= x->count) {\n                x->val[j] = x->val[j + 1];\n                x->link[j] = x->link[j + 1];\n                j++;\n        }\n        return;\n  }"}
{"author": "fikepaci", "file": "monty__monty_funcs_3.1.c", "original_string": "void monty_pchar(stack_t **stack, unsigned int line_number)\n{\n    if ((*stack)->next == NULL)\n    {\n        set_op_tok_error(pchar_error(line_number, \"stack empty\"));\n        return;\n    }\n    if ((*stack)->next->n < 0 || (*stack)->next->n > 127)\n    {\n        set_op_tok_error(pchar_error(line_number,\n                    \"value out of range\"));\n        return;\n    }\n    printf(\"%c\\n\", (*stack)->next->n);\n}"}
{"author": "haon1026", "file": "linux-programming__cond_produce_multconsumer.0.c", "original_string": "void err_thread(int ret, char *str)\n{\n    if(ret != 0)\n    {\n        fprintf(stderr, \"%s:%s\\n\", str, strerror(ret));\n        pthread_exit(NULL);\n    }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__singly_circuler2.2.c", "original_string": "void Display(PNODE Head, PNODE Tail)\n{\n    if((Head == NULL) && (Tail == NULL))\n    {\n        return;\n    }\n    do\n    {\n        printf(\"|%d|<->\",Head->data);\n        Head = Head->next;\n    }while(Head!= Tail->next);\n    printf(\"\\n\");\n}"}
{"author": "fikepaci", "file": "monty__monty_funcs_1.3.c", "original_string": "void monty_pop(stack_t **stack, unsigned int line_number)\n{\n    stack_t *next = NULL;\n    if ((*stack)->next == NULL)\n    {\n        set_op_tok_error(pop_error(line_number));\n        return;\n    }\n    next = (*stack)->next->next;\n    free((*stack)->next);\n    if (next)\n        next->prev = *stack;\n    (*stack)->next = next;\n}"}
{"author": "fikepaci", "file": "monty__run_monty.2.c", "original_string": "int is_empty_line(char *line, char *delims)\n{\n    int i, j;\n    for (i = 0; line[i]; i++)\n    {\n        for (j = 0; delims[j]; j++)\n        {\n            if (line[i] == delims[j])\n                break;\n        }\n        if (delims[j] == '\\0')\n            return (0);\n    }\n    return (1);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_any_pos_CLL.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.delete the element from any position\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"delete the element from any position\\n\");\n            delete_at_pos();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "theuwis", "file": "AdventOfCode2017__main21.0.c", "original_string": "int get_value(int * row, int * col){\n    int value = 0;\n    for(int i = *row - 1; i <= *row + 1; i++){\n        for(int j = *col - 1; j <= *col + 1; j++){\n            value += grid[i][j];\n        }\n    }\n    if(value > input){\n        printf(\"answer=%d\\n\", value);\n        exit(EXIT_SUCCESS);\n    }\n    return value;\n}"}
{"author": "bgmanuel99", "file": "PracticasArquitecturaDeComputadores__ejercicio11.0.c", "original_string": "int main(int argc, char* argv[]){\n    int size, rank, buffer[16];\n    MPI_Init(&argc, &argv);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    int my_row[4];\n    for(int i = 0; i < 4; i++ ){\n        my_row[i] = matriz[i][rank];\n    }\n    MPI_Allgather(&my_row, 4, MPI_INT, buffer, 4, MPI_INT, MPI_COMM_WORLD);\n    MPI_Allgather(&my_row, 4, MPI_INT, buffer, 4, MPI_INT, MPI_COMM_WORLD);\n    MPI_Allgather(&my_row, 4, MPI_INT, buffer, 4, MPI_INT, MPI_COMM_WORLD);\n    MPI_Allgather(&my_row, 4, MPI_INT, buffer, 4, MPI_INT, MPI_COMM_WORLD);\n    if(rank==0){\n        for(int j = 0; j < 16; j++){\n            printf(\"%d \", buffer[j]);\n            if(j == 3 || j == 7 || j == 11) printf(\"\\n\");\n        }\n        printf(\"\\n\");\n    }\n    MPI_Finalize();\n    return 0;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_31.3.c", "original_string": "int main() {\n    setlocale(LC_ALL, \"\");\n    for (int i = 0; i < 10; i++) {\n        int valorAlocar = 0;\n        printf(\"Preencha o valor do vetor1 numero %d\\n\", i);\n        scanf(\"%d\", &valorAlocar);\n        int retorno = verificarValorRepetido(valorAlocar);\n        if (retorno != 0) {\n            printf(\"O valor %d nao pode ser inserido pois esta repetido, por favor informe outro numero.\", retorno);\n            i--;\n            continue;\n        } else {\n            vet1[i] = valorAlocar;\n        }\n    }\n    for (int i = 0; i < 10; i++) {\n        int valorAlocar = 0;\n        printf(\"Preencha o valor do vetor2 numero %d\\n\", i);\n        scanf(\"%d\", &valorAlocar);\n        int retorno = verificarValorRepetido(valorAlocar);\n        if (retorno != 0) {\n            printf(\"O valor %d nao pode ser inserido pois esta repetido, por favor informe outro numero.\\n\", retorno);\n            i--;\n            continue;\n        } else {\n            vet2[i] = valorAlocar;\n        }\n    }\n    system(\"cls\");\n    printf(\"\\n ------------------------------ \\n\");\n    populaVetorUniao();\n    printf(\"--- Uniao entre vetores ---\\n\");\n    imprimirVetores(uniao, 10);\n    printf(\"--------------------------------\\n\");\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q1.2.c", "original_string": "void inorder(nptr root)\n{\n    if (root == NULL)\n        return;\n    inorder(root->lchild);\n    printf(\"%d \", root->data);\n    inorder(root->rchild);\n}"}
{"author": "Dhruvik-Chevli", "file": "PPLab__p3.0.c", "original_string": "int main(int argc, char* argv[])\n{\n    int rank, size;\n    int k;\n    int buff_size=MPI_BSEND_OVERHEAD+sizeof(int);\n    char* buff=(char*)malloc(buff_size*sizeof(int));\n    MPI_Init(&argc, &argv);\n    MPI_Comm_rank(MPI_COMM_WORLD,&rank);\n    MPI_Comm_size(MPI_COMM_WORLD,&size);\n    int arr[7];\n    if(size!=8)\n    {\n        printf(\"\\nUse 8 processes\\n\");\n        MPI_Abort(MPI_COMM_WORLD,EXIT_FAILURE);\n    }\n    if(rank==0)\n    {\n        MPI_Buffer_attach(buff,buff_size);\n        printf(\"Please enter 7 integers.\\n\");\n        for(int i=0;i<7;i++)\n        {\n            scanf(\"%d\",&arr[i]);\n        }\n        printf(\"Process[%d] sending the elements.\\n\",rank);\n        for(int i=1;i<8;i++)\n        {\n            MPI_Bsend(&arr[i-1],1,MPI_INT,i,0,MPI_COMM_WORLD);\n        }\n    }\n    else\n    {\n        MPI_Recv(&k,1,MPI_INT,0,0,MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        if(rank%2==0)\n        {\n            printf(\"Process[%d] recieved: %d and the square is: %d \\n\",rank, k,k*k);\n        }\n        else\n        {\n            printf(\"Process[%d] recieved: %d and the cube is: %d \\n\",rank, k,k*k*k);\n        }\n    }\n    MPI_Buffer_detach(buff, &buff_size);\n    MPI_Finalize();\n}"}
{"author": "sdukesameer", "file": "dsa__dll-ins-seq-sor-del-a.4.c", "original_string": "void printfwd(list* head)\n{\n    list* dll=head;\n    while (dll!=NULL)\n    {\n        printf(\"%d  \",dll->key);\n        dll=dll->next;\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__signalset-op.1.c", "original_string": "void print_set(sigset_t *pset)\n{\n    for(int i = 1; i < 32; i++)\n    {\n        if(sigismember(pset, i))\n            putchar('1');\n        else\n            putchar('0');\n    }\n    printf(\"\\n\");\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__circularlinkedlist.2.c", "original_string": "void search(int tar)\n{\n    if(rear==NULL)\n    {\n        printf(\"\\nlist is empty\");\n    }\n    else\n    {\n        for(temp=front;temp!=rear;temp=temp->next)\n        {\n            if(temp->val==tar)\n            {\n                printf(\"\\nvalue found\");\n                i++;\n            }\n        }\n        if(temp->val==tar)\n        {\n            printf(\"\\nvalue found\");\n            i++;\n        }\n    }\n    if(i==0)\n    printf(\"\\nvalue not found in the list\");\n}"}
{"author": "mehedi9021", "file": "Data_Structure__insert_value_at_doule_linked_list.1.c", "original_string": "void createList(int n)\n{\n    int i, data;\n    struct node *prevNode, *newNode;\n    if(n >= 1)\n    {\n        head = (struct node *)malloc(sizeof(struct node));\n        printf(\"Enter data of 1 node: \");\n        scanf(\"%d\", &data);\n        head->data = data;\n        head->next = NULL;\n        prevNode = head;\n        for(i=2; i<=n; i++)\n        {\n            newNode = (struct node *)malloc(sizeof(struct node));\n            printf(\"Enter data of %d node: \", i);\n            scanf(\"%d\", &data);\n            newNode->data = data;\n            newNode->next = NULL;\n            prevNode->next = newNode;\n            prevNode = newNode;\n        }\n        prevNode->next = head;\n        printf(\"\\nCIRCULAR LINKED LIST CREATED SUCCESSFULLY\\n\");\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.13.c", "original_string": "char* enclosingparenthesis(VMTRANSLATOR* t, char* content, int len) {\n    int sz = sizeof(char) * (len + 3);\n    char* str = (char*)malloc(sz);\n    sprintf(str, \"(%s)\", content);\n    togarbage(t, str);\n    return str;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__duplicateLL.2.c", "original_string": "void display(nptr head)\n{\n    nptr temp = head;\n    while (temp)\n    {\n        printf(\"%d --> \", temp -> data);\n        temp = temp -> next;\n    }\n    printf(\"NULL\\n\");\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad5.0.c", "original_string": "int main()\n{\n    struct lista Head1;\n    struct lista Head2;\n    struct lista HeadU;\n    struct lista HeadP;\n    Head1.next = NULL;\n    Head2.next = NULL;\n    HeadU.next = NULL;\n    HeadP.next = NULL;\n    unosPrvi(&Head1);\n    unosDrugi(&Head2);\n    printf(\"Prva lista:\\n\");\n    ispis(Head1.next);\n    printf(\"Druga lista:\\n\");\n    ispis(Head2.next);\n    unija(&Head1, &Head2, &HeadU);\n    printf(\"Ispis unije listi:\\n\");\n    ispis(HeadU.next);\n    presjek(&Head1, &Head2, &HeadP);\n    printf(\"Ispis presjeka listi:\\n\");\n    ispis(HeadP.next);\n    return 0;\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__cub2d_utils.0.c", "original_string": "void        my_mlx_pixel_put(t_data *data, int x, int y, int color)\n{\n    char    *dst;\n    dst = data->addr + (y * data->line_length + x * (data->bits_per_pixel / 8));\n    *(unsigned int*)dst = color;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-statements.5.c", "original_string": "STATEMENT* parseif(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, ifstatement);\n    IFSTATEMENT* ifst = (IFSTATEMENT*)malloc(sizeof(IFSTATEMENT));\n    ifst->base = parsecond(p);\n    if(equals(p, \"else\")) {\n        next(p);\n        checkcontent(p, \"{\");\n        ifst->elsestatements = parsestatements(p);\n        checkcontent(p, \"}\");\n    }\n    else\n        ifst->elsestatements = NULL;\n    s->type = ifstatement;\n    s->ifstatement = ifst;\n    return s;\n}"}
{"author": "earth429", "file": "mulpre__quickDivide.1.c", "original_string": "int quickDivide(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c, struct NUMBER *d) {\n    struct NUMBER tmp1, tmp2, a_tmp, e;\n    if(isZero(b) != -1){ \n        return -1;\n    }\n    if(getSign(a) > 0 && getSign(b) < 0){ \n        getAbs(b, &tmp1);\n        divide(a, &tmp1, c, d);\n        setSign(c, -1);\n        return 0; \n    } else if(getSign(a) < 0 && getSign(b) > 0){ \n        getAbs(a, &tmp1);\n        divide(&tmp1, b, c, d);\n        setSign(c, -1);\n        setSign(d, -1);\n        return 0; \n    } else if(getSign(a) < 0 && getSign(b) < 0) { \n        getAbs(a, &tmp1);\n        getAbs(b, &tmp2);\n        divide(&tmp1, &tmp2, c, d);\n        setSign(d, -1);\n        return 0; \n    }\n    clearByZero(c); \n    copyNumber(a, &a_tmp);\n    clearByZero(d);\n    while(1){\n        if(numComp(&a_tmp, b) >= 0){ \n            copyNumber(b, d); \n            setInt(&e, 1); \n            while(1){ \n                if(numComp(&a_tmp, d) >= 0){\n                    mulBy10(d, &tmp1);\n                    copyNumber(&tmp1, d);\n                    mulBy10(&e, &tmp2);\n                    copyNumber(&tmp2, &e);\n                } else { \n                    divBy10(d, &tmp1); \n                    copyNumber(&tmp1, d);\n                    divBy10(&e, &tmp2);\n                    copyNumber(&tmp2, &e);\n                    break;\n                }\n            }\n            sub(&a_tmp, d, &tmp1); \n            copyNumber(&tmp1, &a_tmp);\n            add(c, &e, &tmp2); \n            copyNumber(&tmp2, c);\n            printf(\"c:\");\n            dispNumberZeroSuppress(c);\n            puts(\"\");\n            printf(\"d:\");\n            dispNumberZeroSuppress(d);\n            puts(\"\");\n            printf(\"a_tmp:\");\n            dispNumberZeroSuppress(&a_tmp);\n            puts(\"\");\n        } else if(numComp(&a_tmp, b) < 0){ \n            copyNumber(&a_tmp, d);\n            break; \n        }\n    }\n    return 0;\n}"}
{"author": "Ana-Morales", "file": "binary_trees__16-binary_tree_is_perfect.1.c", "original_string": "int binary_tree_balance(const binary_tree_t *tree)\n{\n    size_t height_left = 0;\n    size_t height_right = 0;\n    if (tree == NULL)\n        return (0);\n    height_left = binary_tree_height(tree->left);\n    height_right = binary_tree_height(tree->right);\n    return (height_left - height_right);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_auth.2.c", "original_string": "error_t acmeClientParseAuthorizationResponse(AcmeClientContext *context,\n   AcmeAuthorization *authorization)\n{\n   error_t error;\n   uint_t i;\n   uint_t n;\n   const char_t *status;\n   const char_t *value;\n   const char_t *type;\n   const char_t *url;\n   const char_t *token;\n   json_t *rootObj;\n   json_t *statusObj;\n   json_t *identifierObj;\n   json_t *valueObj;\n   json_t *wildcardObj;\n   json_t *arrayObj;\n   json_t *challengeObj;\n   json_t *typeObj;\n   json_t *urlObj;\n   json_t *tokenObj;\n   AcmeChallenge *challenge;\n   AcmeChallengeType challengeType;\n   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))\n      return ERROR_UNEXPECTED_STATUS;\n   if(context->nonce[0] == '\\0')\n      return ERROR_INVALID_RESPONSE;\n   if(osStrcasecmp(context->contentType, \"application/json\"))\n      return ERROR_INVALID_RESPONSE;\n   if(context->bufferLen >= ACME_CLIENT_BUFFER_SIZE)\n      return ERROR_RESPONSE_TOO_LARGE;\n   error = ERROR_INVALID_RESPONSE;\n   rootObj = json_loads(context->buffer, 0, NULL);\n   do\n   {\n      if(!json_is_object(rootObj))\n         break;\n      statusObj = json_object_get(rootObj, \"status\");\n      if(!json_is_string(statusObj))\n         break;\n      status = json_string_value(statusObj);\n      authorization->status = acmeClientParseAuthorizationStatus(status);\n      identifierObj = json_object_get(rootObj, \"identifier\");\n      if(!json_is_object(identifierObj))\n         break;\n      valueObj = json_object_get(identifierObj, \"value\");\n      if(!json_is_string(valueObj))\n         break;\n      value = json_string_value(valueObj);\n      if(osStrlen(value) > ACME_CLIENT_MAX_URL_LEN)\n         break;\n      wildcardObj = json_object_get(rootObj, \"wildcard\");\n      if(json_is_boolean(wildcardObj))\n      {\n         authorization->wildcard = json_boolean_value(wildcardObj);\n      }\n      challengeType = acmeClientGetChallengeType(context, value,\n         authorization->wildcard);\n      if(authorization->status == ACME_AUTH_STATUS_PENDING)\n      {\n         arrayObj = json_object_get(rootObj, \"challenges\");\n         if(!json_is_array(arrayObj))\n            break;\n         n = json_array_size(arrayObj);\n         for(i = 0; i < n; i++)\n         {\n            challengeObj = json_array_get(arrayObj, i);\n            if(!json_is_object(challengeObj))\n               break;\n            typeObj = json_object_get(challengeObj, \"type\");\n            urlObj = json_object_get(challengeObj, \"url\");\n            statusObj = json_object_get(challengeObj, \"status\");\n            if(!json_is_string(typeObj) ||\n               !json_is_string(urlObj) ||\n               !json_is_string(statusObj))\n            {\n               break;\n            }\n            type = json_string_value(typeObj);\n            url = json_string_value(urlObj);\n            status = json_string_value(statusObj);\n            if(acmeClientParseChallengeType(type) == challengeType)\n            {\n               tokenObj = json_object_get(challengeObj, \"token\");\n               if(!json_is_string(tokenObj))\n                  break;\n               token = json_string_value(tokenObj);\n               if(osStrlen(url) <= ACME_CLIENT_MAX_URL_LEN &&\n                  osStrlen(token) <= ACME_CLIENT_MAX_URL_LEN &&\n                  osStrlen(value) <= ACME_CLIENT_MAX_NAME_LEN)\n               {\n                  challenge = &context->challenges[context->numChallenges];\n                  challenge->status = acmeClientParseChallengeStatus(status);\n                  osStrcpy(challenge->url, url);\n                  osStrcpy(challenge->token, token);\n                  osStrcpy(challenge->identifier, value);\n                  challenge->wildcard = authorization->wildcard;\n                  challenge->type = challengeType;\n                  error = acmeClientGenerateKeyAuthorization(context, challenge);\n                  if(!error)\n                  {\n                     if(challenge->type == ACME_CHALLENGE_TYPE_DNS_01)\n                     {\n                        error = acmeClientDigestKeyAuthorization(context,\n                           challenge);\n                     }\n                     else if(challenge->type == ACME_CHALLENGE_TYPE_TLS_ALPN_01)\n                     {\n                        error = acmeClientGenerateTlsAlpnCert(context, challenge);\n                     }\n                     else\n                     {\n                     }\n                  }\n                  if(!error)\n                  {\n                     context->numChallenges++;\n                  }\n                  break;\n               }\n            }\n         }\n      }\n      else\n      {\n         error = NO_ERROR;\n      }\n   } while(0);\n   json_decref(rootObj);\n   return error;\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__ImprovisedBubbleSort.2.c", "original_string": "void putdata(int x[50], int n)\n       {\n          int k;\n          for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n         }\n          printf(\"\\n\");\n       }"}
{"author": "paawankohli", "file": "DSA-LAB__q4.3.c", "original_string": "int Equal(node* root1, node* root2)\n{\n    return  (root1 == NULL && root2 == NULL) || ((root1 && root2 && root1 -> data == root2 -> data)\n            && Equal(root1->left, root2->left) && Equal(root1->right, root2->right));\n}"}
{"author": "2security", "file": "String__38RemoveExtraSpace.2.c", "original_string": "int main()\n    {\n        int i,n;\n        char str[50];\n        printf(\"\\n Enter the string:\");\n        gets(str);\n        printf(\"\\n Before removal of extra space:\");\n        printf(\"%s\",str);\n        printf(\"\\n After removal of extra space:\");\n        printf(\"%s\",RemoreExSpace(str));\n        printf(\"Good bye\");\n        return 0;\n    }"}
{"author": "SugumaranEvil", "file": "Datastructure__tree.3.c", "original_string": "void preorder(struct database *node){\n    if(node == NULL) {\n        return;\n    } else {\n        printf(\"%d\\n\",node->roll_no);\n        preorder(node->left);\n        preorder(node->right);\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader0.0.c", "original_string": "static bool isWhitespace(char *str)\n{\n  size_t idx = 0;\n  char currentChr = str[idx++];\n  while (currentChr != '\\0')\n  {\n    if (isspace(currentChr) == 0) \n    {\n      return false;\n    }\n    currentChr = str[idx++];\n  }\n  return true;\n}"}
{"author": "sdukesameer", "file": "dsa__n-rooks_castle-a.2.c", "original_string": "void rooks(int arr[N][N], int c){\n    if(c>=N){\n        printboard(arr);\n        int trs[N][N], t=0;\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                trs[j][i]=arr[i][j];\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                if(trs[i][j]==arr[i][j])\n                    t++;\n        if(t!=(N*N))\n            printboard(trs);\n        return;\n    }\n    for (int i = 0; i < N; i++){\n        if(safe(arr,i,c)){\n            arr[i][c]=1;\n            rooks(arr,c+1);\n            arr[i][c]=0;\n        }\n    }\n}"}
{"author": "rgautam320", "file": "Data-Structure__main20.2.c", "original_string": "int main()\n{\n    printf(\"Enter a String to Check\\n\");\n    scanf(\"%s\", stack);\n    len = strlen(stack);\n    for(i = 0; i<len; i++)\n    {\n        push(stack[i]);\n    }\n    for(i = 0; i<len; i++)\n    {\n        if(stack[i]==pop())\n        {\n            count++;\n        }\n    }\n    if(count == len)\n    {\n        printf(\"Given string is Palindrome\\n\");\n    }\n    else\n    {\n        printf(\"Given string is not Palindrome\\n\");\n    }\n    return 0;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__pwm_single.0.c", "original_string": "int main()\n{\n    PINSEL0 |= (1<<17);\n    PINSEL0 &= ~(1<<16);                \n    PWMPR = 14;\n    PWMMR0 = 10000;                         \n    PWMLER = (1<<0);\n    PWMMCR = (1<<1);                        \n    PWMPCR |= (1<<12);                  \n    PWMPCR &= ~(1<<4);                  \n    PWMTCR = (1<<0) | (1<<3);       \n    while(1)\n    {\n        PWMMR4 = 2500;              \n        PWMLER = (1<<4);\n        delay_ms(1000);\n        PWMMR4 = 5000;              \n        PWMLER = (1<<4);\n        delay_ms(1000);\n        PWMMR4 = 7500;              \n        PWMLER = (1<<4);\n        delay_ms(1000);\n        PWMMR4 = 10000;             \n        PWMLER = (1<<4);\n        delay_ms(1000);\n    }   \n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__lcd.6.c", "original_string": "void lcd_str1(char str[])\n{\n    int i,count=0;\n    for(i=0;str[i]!='\\0';++i)\n        {\n            lcd_data(str[i]);\n            if(count == 16)\n            {\n                lcd_cmd(0xC0);\n            }\n            count++;\n        }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_01.3.c", "original_string": "int main(int argc,char *argv[])\n  {     char sel;\n        int n,x,k;\n        int *arr;\n        F1=fopen(argv[1],\"r\");\n        F2=fopen(argv[2],\"w\");\n        if(F1==NULL)\n         printf(\"Cant open file\");\n        else\n          {\n           while(1)\n           {\n             fscanf(F1,\"%ch\",&sel);\n             if(sel=='r')\n             {\n               fscanf(F1,\" %d\",&n);\n               arr= read(n);\n             }\n            else if(sel=='d')\n             {\n               display(arr,n);\n             }\n             else if(sel=='s')\n             {\n              fscanf(F1,\"%d\",&k);\n              x=search(arr,n,k);\n              fprintf(F2,\"%d\\n\",x);\n             }\n             else if(sel=='t')\n               break;\n           }\n         }\n   fclose(F1);\n   fclose(F2);\n  }"}
{"author": "Dhruvik-Chevli", "file": "DAALab__bfs.4.c", "original_string": "int dequeue(struct Queue* queue)\n{\n    if (isEmpty(queue))\n        return -1;\n    int ele=queue->arr[queue->front];\n    if (queue->front==queue->rear)\n    {\n        queue->front=-1;\n        queue->rear=-1;\n    }\n    queue->front=(queue->front+1)%queue->cap;\n    queue->size--;\n    return ele;\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__sum999.0.c", "original_string": "int main()\n{\n    int array[SIZE];\n    printf(\"enter the array elements\\n\");\n    while(array[i]!=999)\n    {\n    for(i=0;i<SIZE;i++)\n    {\n        scanf(\"%d\",&array[i]);\n        n=i;\n        if(array[i]==999)\n        break;\n    }\n    }\n    pthread_t thread1, thread2;\n    pthread_create(&thread1, NULL,sumofnum,&array);\n    pthread_create(&thread2, NULL,productofnum,&array);\n   pthread_join(thread1,NULL);\n    pthread_join (thread2,NULL);\n    return 0;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__check_enemy.1.c", "original_string": "static void recursive_check(t_m *m, int x, int y)\n{\n    if (is_in_range(m, x, y))\n    {\n        if (is_king(m, x, y))\n            m->mate = 1;\n        else if (!is_enemy(m, x, y))\n            recursive_check(m, x + m->off_x, y + m->off_y);\n    }\n}"}
{"author": "kalpa96", "file": "Struct__date.0.c", "original_string": "int main(){\n    int i, j, key=0;\n    for(i=0; i<2; i++){\n        d[i].no = i+1;\n        printf(\"\\nEnter 0%d\\n\",d[i].no);\n        printf(\"Year : \");\n        scanf(\"%d\",&d[i].year);\n        printf(\"Month : \");\n        scanf(\"%d\",&d[i].month);\n        printf(\"Day : \");\n        scanf(\"%d\",&d[i].day);\n        if(d[i].month >12 || d[i].month<=0 ){\n            printf(\"Invalide Month...\\n\");\n            if(d[i].day >30 || d[i].day<=0 ){\n            printf(\"Invalide Date...\\n\");\n            }\n            i--;\n        }else{\n            if(d[i].day >30 || d[i].day<=0 ){\n            printf(\"Invalide Date...\\n\");\n            i--;\n            }\n        }\n    }\n    for(j=0; j<1; j++){\n        if(d[j].day==d[j+1].day){\n            if(d[j].month==d[j+1].month){\n                if(d[j].year==d[j+1].year){\n                    printf(\"Dates are equal..\\n\");\n                }\n                else{\n                    key = 1;\n                }\n            }\n            else{\n                key = 1;\n            }\n        }\n        else{\n            key = 1;\n        }\n    }\n    if(key==1){\n        printf(\"Dates are not equal.\\n\");\n    }\n    return 0;\n}"}
{"author": "shengelenge", "file": "wstep-do-programowania__zad130.1.c", "original_string": "int main()\n{\n    int A[MAX];\n    long w;\n    int n;\n    printf(\"podaj liczbe cyfr wczytywanej liczby binarnej: \");\n    scanf(\"%d\", &n);\n    printf(\"Podaj %d cyfr liczby (od lewej): \", n);\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"A[%d] = \", i);\n        scanf(\"%d\", &A[i]);\n    }\n    w = oblicz(A, n-1);\n    printf(\"Iteracyjnie: wynik = %ld\", w);\n    printf(\"(10)\");\n    return 0;\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-3test.11.c", "original_string": "void path(char*** maze,char*** mark,char*** road,int sr,int sc,int sh,int n,int pnum){\n    step=0;\n    min=100000;\n    pathnum=0;\n    top=-1;\n    int i,j,k;\n    element position;\n    int row,col,hei,dir;\n    int nr,nc,nh;\n    int countp=0;\n    int found=1;\n    int inproad=0;\n    position.row = sr;\n    position.col = sc;\n    position.hei = sh;\n    push(position);\n    while(top>-1){\n        position=pop();\n        row = position.row;\n        col = position.col;\n        hei = position.hei;\n        dir = position.dir;\n        if(!found){\n            while(top2>-1){\n                element lastposition = pop2();\n                int lr=lastposition.row;int lc=lastposition.col;int lh=lastposition.hei;int ld=lastposition.dir;\n                if(lr+move[dir].vert==row && lc+move[dir].horiz==col && lh+move[dir].hei==hei ){\n                    push2(lastposition);\n                    break;\n                }\n                road[lh][lr][lc]=maze[lh][lr][lc];\n                mark[lh][lr][lc]=maze[lh][lr][lc];\n                if(maze[lh][lr][lc]=='T'){\n                    step=step-3;\n                }\n                else step--;\n                if(maze[lh][lr][lc]=='P'){\n                    countp--;\n                }\n            }\n        }\n        mark[hei][row][col]='X';\n        road[hei][row][col]='*';\n        if(maze[hei][row][col]=='T'){\n            step=step+3;\n        }\n        else step++;\n        if(maze[hei][row][col]=='P'){\n            inproad=1;\n            countp++;\n        }\n        if(countp==pnum){\n            inproad=0;\n        }\n        push2(position);\n        printf(\"now %d %d %d\\n\",hei,row,col );\n        road[hei][row][col]='@';\n        printf(\"road!! \\n\");\n        for(i=0;i<n/2+1;i++){\n            for(j=i+1;j<n+2-i-1;j++){\n                for(k=i+1;k<n+2-i-1;k++){\n                    printf(\"%c \",road[i][j][k] );\n                }\n                printf(\"\\n\");\n            }\n            printf(\"\\n\");\n        }\n        printf(\"countp %d\\n\\n\",countp );\n        printf(\"mark!! \\n\");\n        for(i=0;i<n/2+1;i++){\n            for(j=i+1;j<n+2-i-1;j++){\n                for(k=i+1;k<n+2-i-1;k++){\n                    printf(\"%c \",mark[i][j][k] );\n                }\n                printf(\"\\n\");\n            }\n            printf(\"\\n\");\n        }\n        printf(\"countp %d\\n\\n\",countp );\n        printf(\"step %d\\n\\n\",step );\n        road[hei][row][col]='*';\n        if(maze[hei][row][col]=='F' && countp==pnum){\n            pathnum++;\n            if(min>step){\n                min=step;\n            }\n            printf(\"finally------------------------------------------------\\n\" );\n            printf(\"road!! \\n\");\n            for(i=0;i<n/2+1;i++){\n                for(j=i+1;j<n+2-i-1;j++){\n                    for(k=i+1;k<n+2-i-1;k++){\n                        printf(\"%c \",road[i][j][k] );\n                    }\n                    printf(\"\\n\");\n                }\n                printf(\"\\n\");\n            }\n            printf(\"countp %d pnum %d\\n\",countp,pnum );\n            printf(\"step %d\\n\\n\",step );\n            printf(\"pathnum %d\\n\",pathnum );\n        }\n        found=0;\n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            nh = hei+move[i].hei;\n            if(inproad){\n                if(mark[nh][nr][nc]!='X' && maze[nh][nr][nc]=='P'){\n                    found=1;\n                    element nextposition;\n                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;nextposition.dir=i;\n                    push(nextposition);\n                }\n            }\n            else{\n                if(mark[nh][nr][nc]!='X'){\n                    found=1;\n                    element nextposition;\n                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;nextposition.dir=i;\n                    push(nextposition);\n                }\n            }\n        }\n        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='P'){\n            if(inproad){\n                if(mark[nh][nr][nc]!='X' && maze[hei+1][row][col]=='P'){\n                    found=1;\n                    element nextposition;\n                    nextposition.row=row;nextposition.col=col;nextposition.hei=hei+1;nextposition.dir=4;\n                    push(nextposition);\n                }\n            }\n            else{\n                if(mark[hei+1][row][col]!='X'){\n                    found=1;\n                    element nextposition;\n                    nextposition.row=row;nextposition.col=col;nextposition.hei=hei+1;nextposition.dir=4;\n                    push(nextposition);\n                }\n            }\n        }\n        if((maze[hei][row][col]=='D'  || maze[hei][row][col]=='P')&& hei>0){\n            if(inproad){\n                if(mark[nh][nr][nc]!='X' && maze[hei-1][row][col]=='P'){\n                    found=1;\n                    element nextposition;\n                    nextposition.row=row;nextposition.col=col;nextposition.hei=hei-1;nextposition.dir=5;\n                    push(nextposition);\n                }\n            }\n            else{\n                if(mark[hei-1][row][col]!='X'){\n                    found=1;\n                    element nextposition;\n                    nextposition.row=row;nextposition.col=col;nextposition.hei=hei-1;nextposition.dir=5;\n                    push(nextposition);\n                }\n            }\n        }\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__kill.1.c", "original_string": "int main()\n{\n    pid_t pid = fork();\n    if(pid > 0)\n    {\n        while(1)\n        {\n            printf(\"parent, pid = %d\\n\", getpid());\n            sleep(1);\n        }\n    }\n    else if(pid == 0)\n    {\n        sleep(5);\n        printf(\"child pid = %d, ppid = %d\\n\", getpid(), getppid());         \n        kill(0, SIGKILL);\n    }\n    return 0;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__binarySearchTree.6.c", "original_string": "int main(){\n     struct Node*root=NULL;\n     root=create(10);\n     insert(root, 5);\n     insert(root, 7);\n     insert(root, 13);\n     insert(root, 1);\n     insert(root, 49);\n     insert(root, 50);\n     insert(root, 35);\n     insert(root, 8);\n     insert(root, 8);\n     delete(root,49);\n     delete(root,99);\n     verify(root, 70);\n     printf(\"\\n--inOrder Traversal--\\n\");\n     inOrderTraversal(root);\n     return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__compiler-util.0.c", "original_string": "LINE* opvarraw(SCOPE* s, char* op, VAR* v) {\n    char* tokens[] = { op, v->memsegment, itoa(v->index) };\n    LINE* ln = mksimpleln(tokens, strcount(tokens));\n    free(tokens[2]);\n    return ln;\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__sender_mian0.1.c", "original_string": "int main(){\n    unsigned int length;\n    welcome();\n    length = frame_construction(frame, sta_addr, des_addr, protocol, data, sizeof(data));\n    send_frame(frame, length);\n    return 0;\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__mqsemaphores.0.c", "original_string": "void main(int argc, char* argv[])\n{\n    int label, mem_size;\n    int shmid,sval,inval,rval,mqid,pid;\n    int msgid; \n    sem_t *s;\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s LabelForResources MemorySize(inbytes)\\n\",argv[0]);\n        exit(1);\n    }\n    label=atoi(argv[1]);\n    mqid=msgget((key_t)label,IPC_CREAT|0666);\n    if(mqid==-1)\n    {\n        perror(\"MSG-Q-CRE-ERR:\");\n        exit(1);\n    }\n    system(\"ipcs -q\");\n    mem_size=atoi(argv[2]); \n    shmid=shmget((key_t)label,mem_size,IPC_CREAT|0666);\n    if(shmid==-1)\n    {\n        perror(\"SHM_MEM-CRE-ERR:\");\n        msgctl(mqid,IPC_RMID,0);\n        exit(1);\n    }\n    system(\"ipcs -m\");\n    s=(sem_t*)shmat(shmid,0,0);\n    if(s==NULL)\n    {\n        perror(\"SHM-AT-ERR:\");\n        shmctl(shmid,IPC_RMID,0);\n        shmdt(s);\n        msgctl(mqid,IPC_RMID,0);\n        exit(1);\n    }\n    printf(\"\\nEnter the initialization value for the semaphore :\");\n    scanf(\"%d\",&inval);\n    rval=sem_init(s,1,inval);\n    if(rval==-1)\n    {\n        perror(\"Unable to initialize semaphore value:\");\n        msgctl(mqid,IPC_RMID,0);\n        sem_destroy(s);\n        shmdt(s);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    rval=sem_getvalue(s,&sval);\n    if(rval==-1)\n    {\n        perror(\"Unable to get semaphore value:\");\n        msgctl(mqid,IPC_RMID,0);\n        sem_destroy(s);\n        shmdt(s);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    printf(\"\\nSemaphore value after initialization is %d\\n\",sval);\n    printf(\"\\nEnter the message ID to be used between parent and child: \");\n    scanf(\"%d\",&msgid);\n    pid=fork();\n    if(pid==-1)\n    {\n        perror(\"FRK-ERR:\");\n        msgctl(mqid,IPC_RMID,0);\n        sem_destroy(s);\n        shmdt(s);\n        shmctl(shmid,IPC_RMID,0);\n        exit(1);\n    }\n    if(pid==0)\n    {\n        message m1;\n        printf(\"\\nCHILD : pid = %d\\n\",getpid());\n        rval=sem_wait(s);\n        if(rval==-1)\n        {\n            perror(\"SEM-WAIT-ERR:\");\n            msgctl(mqid,IPC_RMID,0);\n            sem_destroy(s);\n            shmdt(s);\n            shmctl(shmid,IPC_RMID,0);\n            exit(1);\n        }\n        printf(\"\\nCHILD : Enter the message to be sent to parent : \");\n        scanf(\"%s\",m1.txt);\n        m1.id=msgid;\n        rval=msgsnd(mqid,(message*)&m1,sizeof(m1),0);\n        if(rval==-1)\n        {\n            perror(\"MSG-SND-ERR:\");\n            msgctl(mqid,IPC_RMID,0);\n            sem_destroy(s);\n            shmdt(s);\n            shmctl(shmid,IPC_RMID,0);\n            exit(1);\n        }       \n        rval=sem_post(s);\n        if(rval==-1)\n        {\n            perror(\"SEM-POST-ERR:\");\n            msgctl(mqid,IPC_RMID,0);\n            sem_destroy(s);\n            shmdt(s);\n            shmctl(shmid,IPC_RMID,0);\n            exit(1);\n        }\n        exit(1);\n    }\n    else\n    {\n        message m2;\n        rval=sem_wait(s);\n        if(rval==-1)\n        {\n            perror(\"SEM-WAIT-ERR:\");\n            msgctl(mqid,IPC_RMID,0);\n            sem_destroy(s);\n            shmdt(s);\n            shmctl(shmid,IPC_RMID,0);\n            exit(1);\n        }\n        printf(\"\\nPARENT : Waiting to receive message from child\\n\");\n        rval=msgrcv(mqid,(message*)&m2,sizeof(m2),msgid,0);\n        if(rval==-1)\n        {\n            perror(\"MSG-RCV-ERR:\");\n            msgctl(mqid,IPC_RMID,0);\n            sem_destroy(s);\n            shmdt(s);\n            shmctl(shmid,IPC_RMID,0);\n            exit(1);\n        }\n        printf(\"\\nPARENT : Message received is : %s\\n\",m2.txt);\n        rval=sem_post(s);\n        if(rval==-1)\n        {\n            perror(\"SEM-POST-ERR:\");\n            msgctl(mqid,IPC_RMID,0);\n            sem_destroy(s);\n            shmdt(s);\n            shmctl(shmid,IPC_RMID,0);\n            exit(1);\n        }\n        msgctl(mqid,IPC_RMID,0);\n        sem_destroy(s);\n        shmdt(s);\n        shmctl(shmid,IPC_RMID,0);\n    }\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise9.2.c", "original_string": "int main(void){\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n    int arr[SIZE];\n    int function_type;                                                                      \n    int index;\n    int result_forwhile;\n    long result_fibo;\n    printf(\"Enter required element in Fibonacci series: \");\n    scanf(\"%d\",&index);\n    printf(\"\\n\");\n    printf(\"Type 1 for ForWhile function or type 2 for Recursive function: \");\n    scanf(\"%d\",&function_type);\n    if(function_type == FOR_WHILE){\n        result_forwhile = ForFibonacci(arr,index);\n        printf(\"The %d element in fibonacci series is %d\",index,result_forwhile);\n    }\n    else if(function_type == RECURSIVE){\n        result_fibo = RecursiveFibonacci(index);\n        printf(\"The %d element in recursive fibonacci is %ld\",index , result_fibo);\n    }\n    return 0;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__main.1.c", "original_string": "int main(){\n    int n;\n    printf(\"Giac: \");\n    scanf(\"%d\",&n);\n    int risultato = decToBin(n);\n    printf(\"\\nrisultato = %d\", risultato);\n    return 0;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__5_Tablas.0.c", "original_string": "void Multipli(int numero, int contador)\n{\n    if(contador <= 10){\n        printf(\"\\n%i X %i = %i\", numero, contador, numero*contador);\n        Multipli(numero, ++contador);\n    }\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__34_array_palindrom.0.c", "original_string": "int main()\n{\n  int i=0,j=0,k=0,array[100]={0}, no = 0,latest_no = 0, last = 0, sum = 0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    latest_no = array[i];\n    sum = 0;\n    while(latest_no != 0)\n    {\n      last = latest_no%10;\n      sum = (sum*10) + last;\n      latest_no = latest_no/10;\n    }\n    printf(\"value of Sum is %d\\n\",sum);\n    if( array[i] == sum)\n    {\n      printf(\"%d is Palindrom\\n\\n\",sum);\n    }\n    else\n    {\n      printf(\"No Number is Palindrom\\n\\n\");\n    }\n  }\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__Deleting_Duplicate_Numbers_In_Array.0.c", "original_string": "int main()\n{\n    system(\"cls\");\n    int a[100];\n    int n,i,j,k;\n    printf(\"Enter the no. of elements:\");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(a[i] == a[j])\n            {\n                for(k=j;k<n;k++)\n                {\n                    a[k] = a[k+1];\n                }\n                n--;\n                j--;\n            }\n        }\n    }\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\",a[i]);\n    }\n    getch();\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_5.2.c", "original_string": "void addbegin()\n{\n    struct node* temp;\n    temp = (struct node*)malloc(sizeof(struct node));\n    printf(\"Enter a node to insert : \");\n    scanf(\"%d\", &temp->data);\n    printf(\"%d inserted.\\n\", temp->data);\n    temp->link = root;\n    root = temp;\n}"}
{"author": "haon1026", "file": "linux-programming__loop_create_pthread_err.1.c", "original_string": "void* thread_fun(void *arg)\n{\n    int i = *((int*)arg);           \n    sleep(i);\n    printf(\"I'm %dth thread:pid = %d, tid = %lu\\n\", i+1, getpid(), pthread_self());\n    return NULL;\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__sender.4.c", "original_string": "int main(){\n    unsigned int length;\n    welcome();\n    length = frame_construction(sta_addr,des_addr,protocol,data,sizeof(data));\n    printf(\"Frame length: %d\\n\",length);\n    frame[length-10] = ~frame[length-10];\n    send_frame(frame,length);\n    return 0;\n}"}
{"author": "DanielSalis", "file": "AED1__teste4.4.c", "original_string": "int faltamPercorrer(TipoLista*l, int IDcidade){\n    int existe = existeNaLista(l, IDcidade);\n    int Distancia = 0;\n    int contCidades=1;\n    if(existe){\n        TipoElemento* aux = l->ultimo;\n        while(aux->IDcidade != IDcidade){\n            Distancia = Distancia + aux->distancia;\n            contCidades++;\n            aux = aux->ant;\n        }\n        Distancia = Distancia + aux->distancia;\n        aux = aux->ant;\n        printf(\"estou na cidade %d:\\n\", IDcidade);\n        printf(\"faltam percorrer %d km, passando por %d cidades\", Distancia, contCidades-1);\n        return 1;\n    }else{\n        printf(\"cidade nao existe no percurso\");\n        return 0;\n    }\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_1_3_9.0.c", "original_string": "int main()\n{\n    float num1, num2;\n    int operation;\n    float result;\n    printf(\"Podaj wartosc pierwszej liczby.\\n\");\n    scanf(\"%f\", &num1);\n    printf(\"Podaj wartosc drugiej liczby.\\n\");\n    scanf(\"%f\", &num2);\n    printf(\"Wybierz rodzaj operacji matematycznej.\\n\");\n    printf(\"---------------------------------------\\n\");\n    printf(\"1) Dodaj                   3) Pomnoz\\n\");\n    printf(\"2) Odejmij                 4) Podziel\\n\");\n    scanf(\"%d\", &operation);\n    switch (operation) {\n    case 1:\n        result = num1 + num2;\n        break;\n    case 2:\n        result = num1 - num2;\n        break;\n    case 3:\n        result = num1 * num2;\n        break;\n    case 4:\n        result = num1 / num2;\n        break;\n    }\n    printf(\"\\nWynik: %.2f\\n\", result);\n    getchar();\n    return 0;\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad54.0.c", "original_string": "int main()\n{\n    int userMin, userMax;\n    printf(\"Podaj liczb\\251 dolnej granicy tabeli: \");\n    scanf(\"%d\", &userMin);\n    printf(\"Podaj liczb\\251 g\\242rnej granicy tabeli: \");\n    scanf(\"%d\", &userMax);\n    printf(\"\\nLiczba\\t\\tKwadrat\\t\\tSze\\230cian\");\n    for(char i = userMin; i <= userMax; i++) {\n        printf(\"\\n%5d\\t\\t%5d\\t\\t%5d\", i, kwadrat(i), szescian(i));\n    }\n    getchar();\n    return 0;\n}"}
{"author": "earth429", "file": "mulpre__sqrt_newton_test.1.c", "original_string": "int sqrt_newton(int N) {\n    int x;\n    int b;\n    int c;\n    x = N / 2;\n    if(x == 0){ \n        return N;\n    }\n    if(x < 0){ \n        return -1;\n    }\n    b = x;\n    c = x;\n    while(1){\n        c = b;\n        b = x;\n        x = (b + (N / b)) / 2;\n        if(x == b){ \n            break;\n        }\n        if(x == c){ \n            if(b < x){ \n                x = b;\n            }\n            break;\n        }\n    }\n    return (x);\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_7.4.c", "original_string": "void print(struct stack* stk,int n,FILE* fp2)\n{\n    int i;\n    int top1=stk->top;\n    if(StackEmpty(stk))\n    {\n        fprintf(fp2, \"%d\\n\",-1);\n        return;\n    }\n    if(n==0)\n    {\n        for(i=top1;i>=0;i--)\n        {\n            fprintf(fp2, \"%d \",stk->A[i]);\n        }\n        fprintf(fp2, \"\\n\");\n    }\n    else if(n>0)\n    {\n        if(n<=top1+1)\n        {\n            for(i=0;i<n;i++)\n                {\n                    fprintf(fp2, \"%d \", stk->A[top1-i]);\n                }\n                        fprintf(fp2, \"\\n\");\n        }\n        else if(n>top1+1)\n        {\n            for(i=top1;i>=0;i--)\n            {\n                fprintf(fp2, \"%d \",stk->A[i]);\n            }\n            fprintf(fp2, \"END\\n\");\n        }   \n    }\n}"}
{"author": "SugumaranEvil", "file": "Linux_programming__open_read.0.c", "original_string": "int main()\n{\n    int file_des,c;\n    ssize_t rd,wt;\n    char arr[50],arr1[50];\n    file_des = open(\"/home/sugu/Linux_Programming/file.txt\",O_RDONLY,0640);\n    perror(\"open\");\n    printf(\"File_descriptor %d\\n\",file_des);\n    rd = read(file_des,arr,10);\n    perror(\"read\");\n    printf(\"Read %d\\n\",rd);\n    snprintf(arr1,10,\"%s\\n\",arr);\n    printf(\"%s\\n\",arr1);\n    c = close(file_des);\n    perror(\"close\");\n    printf(\"close%d\\n\",c);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__24_ln.1.c", "original_string": "int main(){\n        double X;\n        printf(\"Programa para calcular el cosh(X) por medio de sumas de Taylor\\nValor de X:\");\n        scanf(\"%lf\", &X);\n    if(X == 0.0){\n        printf(\"Fuera de rango\");\n    }else{\n            ln(1,10,0,X);\n    }\n    return 0;\n}"}
{"author": "behergue", "file": "Operating_Systems__myFS.8.c", "original_string": "int myMkfs(MyFileSystem *myFileSystem, int diskSize, char *backupFileName)\n{\n    myFileSystem->fdVirtualDisk = open(backupFileName, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);\n    assert(sizeof(SuperBlockStruct) <= BLOCK_SIZE_BYTES);\n    assert(sizeof(DirectoryStruct) <= BLOCK_SIZE_BYTES);\n    int numBlocks = diskSize / BLOCK_SIZE_BYTES;\n    int minNumBlocks = 3 + MAX_BLOCKS_WITH_NODES + 1;\n    int maxNumBlocks = NUM_BITS;\n    if(numBlocks < minNumBlocks) {\n        return -1;\n    }\n    if(numBlocks >= maxNumBlocks) {\n        return -2;\n    }\n    int i;\n    for(i = 0; i < NUM_BITS; i++) {\n        myFileSystem->bitMap[i] = 0;\n    }\n    myFileSystem->bitMap[BITMAP_IDX] = 1;\n    myFileSystem->bitMap[SUPERBLOCK_IDX] = 1;\n    myFileSystem->bitMap[DIRECTORY_IDX] = 1;\n    for(i = 3; i < 3 + MAX_BLOCKS_WITH_NODES; i++) {\n        myFileSystem->bitMap[i] = 1;\n    }\n    updateBitmap(myFileSystem);\n    myFileSystem->directory.numFiles = 0;\n    for(i = 0; i < MAX_FILES_PER_DIRECTORY; i++) {\n        myFileSystem->directory.files[i].freeFile = 1;\n    }\n    updateDirectory(myFileSystem);\n    NodeStruct currentNode;\n    currentNode.freeNode = 1;\n    for(i = 0; i < MAX_NODES; i++) {\n        updateNode(myFileSystem, i, &currentNode);\n    }\n    initializeSuperBlock(myFileSystem, diskSize);\n    updateSuperBlock(myFileSystem);\n    sync();\n    assert(myQuota(myFileSystem) >= 1);\n    if(initializeNodes(myFileSystem)) {\n        myFree(myFileSystem);\n        return -3;\n    }\n    printf(\"SF: %s, %d B (%d B/block), %d blocks\\n\", backupFileName, diskSize, BLOCK_SIZE_BYTES, numBlocks);\n    printf(\"1 block for SUPERBLOCK (%u B)\\n\", (unsigned int)sizeof(SuperBlockStruct));\n    printf(\"1 block for BITMAP, covering %u blocks, %u B\\n\", (unsigned int)NUM_BITS, (unsigned int)(NUM_BITS * BLOCK_SIZE_BYTES));\n    printf(\"1 block for DIRECTORY (%u B)\\n\", (unsigned int)sizeof(DirectoryStruct));\n    printf(\"%d blocks for inodes (%u B/inode, %u inodes)\\n\", MAX_BLOCKS_WITH_NODES, (unsigned int)sizeof(NodeStruct), (unsigned int)MAX_NODES);\n    printf(\"%d blocks for data (%d B)\\n\", myFileSystem->superBlock.numOfFreeBlocks, BLOCK_SIZE_BYTES * myFileSystem->superBlock.numOfFreeBlocks);\n    printf(\"Formatting completed!\\n\");\n    return 0;\n}"}
{"author": "kalpa96", "file": "c-programing__revenue.0.c", "original_string": "int main()\n{\n    int quantity_of_product;\n    float unit_price, revenue,discount;\n    printf(\"Enter quantity of product: \");\n    scanf(\"%d\",&quantity_of_product);\n    printf(\"\\nEnter the unit price: \");\n    scanf(\"%f\",&unit_price);\n    revenue=quantity_of_product*unit_price;\n    if(quantity_of_product>120 &&quantity_of_product<160)\n    {\n        discount=revenue*15/100;\n        printf(\"\\nDiscount : %f\",discount);\n        printf(\"\\nAll payments : %f\",(revenue-discount));\n    }\n    else if(quantity_of_product>160)\n    {\n        discount=revenue*20/100;\n        printf(\"\\nDiscount : %f\",discount);\n        printf(\"\\nAll payments : %f\",(revenue-discount));\n    }\n    else{\n        discount=revenue*0/100;\n        printf(\"\\nDiscount : %f\",discount);\n        printf(\"\\nAll payments : %f\",(revenue-discount));\n    }\n}"}
{"author": "Theemiss", "file": "binary_trees__binary_tree_print.2.c", "original_string": "void binary_tree_print(const binary_tree_t *tree)\n{\n    char **s;\n    size_t height, i, j;\n    if (!tree)\n        return;\n    height = _height(tree);\n    s = malloc(sizeof(*s) * (height + 1));\n    if (!s)\n        return;\n    for (i = 0; i < height + 1; i++)\n    {\n        s[i] = malloc(sizeof(**s) * 255);\n        if (!s[i])\n            return;\n        memset(s[i], 32, 255);\n    }\n    print_t(tree, 0, 0, s);\n    for (i = 0; i < height + 1; i++)\n    {\n        for (j = 254; j > 1; --j)\n        {\n            if (s[i][j] != ' ')\n                break;\n            s[i][j] = '\\0';\n        }\n        printf(\"%s\\n\", s[i]);\n        free(s[i]);\n    }\n    free(s);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__iterative_traversals.1.c", "original_string": "void iterative_inorder(Nodeptr root)\n{\n    Nodeptr cur = root;\n    int done = false;\n    STACK s; s.top = -1;\n    while (!done) \n    {\n        while (cur != NULL) \n        {\n            push(&s, cur);\n            cur = cur -> lchild;\n        }\n        if (isEmptyStack(s) == 0) \n        {\n            cur = pop(&s);\n            printf(\"%d \", cur -> data);\n            cur = cur -> rchild;\n        }\n        else\n            done = true;\n    }\n}"}
{"author": "2security", "file": "Matrix__36Transpose.1.c", "original_string": "void displayMat(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }"}
{"author": "paawankohli", "file": "DSA-LAB__q41.2.c", "original_string": "int alnum(char t)\n{\n    switch(t)\n    {\n        case '+':\n        case '-':\n        case '/':\n        case '*':\n        case '$':\n                    return 0;\n    }\n    return 1;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__Brute_ForceMethod.0.c", "original_string": "void Brute_Force(char S[],char P[],int n,int m)\n{\n    int i=0,j=0,k;\n    while(i<n && j<m)\n    {\n        k=i-m+1;\n        if(P[j]==S[i])\n        {\n            i=i+1;\n            j=j+1;\n        }\n        else\n        {\n            i=i+1;\n            j=0;\n        }\n    }\n    if(j==m)    \n    {\n        printf(\"pattern found at %d\",k);\n    }\n    else\n    {\n        printf(\"pattern not found\");\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__bst-del_int-iter_in-pre.6.c", "original_string": "void inorder(node* root)\n{\n    node* stack[nodes(root)];\n    int c=-1;\n    node* cur=root;\n    while(1)\n    {\n        while (cur)\n        {\n            stack[++c]=cur;\n            cur=cur->left;\n        }\n        if (c!=-1)\n        {\n            printf(\"\\t%d\\n\",stack[c--]->data);\n            cur=stack[c+1]->right;\n        }\n        else\n            break;\n    }\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__32_largest_differnce_in_array.0.c", "original_string": "int main()\n{\n  int i=0,j=0,k=0,array[100]={0},lar_dif = 0, no = 0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    for(j=i+1; j<no; j++)\n    {\n      if( (array[j] - array[i]) > lar_dif)\n       {\n         lar_dif = (array[j] - array[i]);\n       }\n    }\n  }\n  printf(\"Value of Lar_dif is %d\",lar_dif);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q32.4.c", "original_string": "void display(QUEUE* q)\n{\n    int i;\n    for(i=q->front+1;i<=q->rear;i=i+1)\n        printf(\"%d\\t\",q->arr[i]);\n    printf(\"\\n\");\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zadOsmi.1.c", "original_string": "Position PopStack(StackPosition stackHead)\n{\n    StackPosition tempStackElement = stackHead->next, prev = stackHead->next;\n    if (!tempStackElement->next)\n        return NULL;\n    while (tempStackElement->next)\n    {\n        prev = tempStackElement;\n        tempStackElement = tempStackElement->next;\n    }\n        Position directory = tempStackElement->data;\n        prev->next = tempStackElement->next;\n        free(tempStackElement);\n        return directory;\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_6.8.c", "original_string": "void dellist()\n{\n    struct node *temp = root, *p;\n    while(temp != NULL)\n    {\n        p = temp->right;\n        free(temp);\n        temp = p;\n    }\n    printf(\"All the elements in the list deleted successfully.\\n\\n\");\n    root = NULL;\n}"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__3-2.2.c", "original_string": "void escape(char s[], char t[]){\n  int i, j;\n  j = 0;\n  for(i = 0; s[i] != '\\0'; i++)\n    switch(s[i]){\n    case '\\n':\n      t[j++] = '\\\\';\n      t[j++] = 'n';\n      break;\n    case '\\t':\n      t[j++] = '\\\\';\n      t[j++] = 't';\n      break;\n    case '\\a':\n      t[j++] = '\\\\';\n      t[j++] = 'a';\n      break;\n    case '\\b':\n      t[j++] = '\\\\';\n      t[j++] = 'b';\n      break;\n    case '\\f':\n      t[j++] = '\\\\';\n      t[j++] = 'f';\n      break;\n    case '\\r':\n      t[j++] = '\\\\';\n      t[j++] = 'r';\n      break;\n    case '\\v':\n      t[j++] = '\\\\';\n      t[j++] = 'v';\n      break;\n    case '\\\\':\n      t[j++] = '\\\\';\n      t[j++] = '\\\\';\n      break;\n    case '\\?':\n      t[j++] = '\\\\';\n      t[j++] = '?';\n      break;\n    case '\\'':\n      t[j++] = '\\\\';\n      t[j++] = '\\'';\n      break;\n    case '\\\"':\n      t[j++] = '\\\\';\n      t[j++] ='\\\"';\n      break;\n    default:\n      t[j++] = s[i];\n      break;\n    }\n  t[j] = '\\0';\n}"}
{"author": "0712023", "file": "Arduino-Mood-Light-DIY-kit__Moodlight.1.c", "original_string": "void loop() {\n  while (BT.available()) {\n    char ReadChar = (char)BT.read();\n    if (ReadChar == ')')\n      RGB_Completed = true;\n    else\n      RGB += ReadChar;\n  }\n  if (RGB_Completed) {\n    DEBUG = true;\n    MsTimer2::stop();\n    if (RGB == \"CH1_5\") {\n      MsTimer2::set(200, random_set);\n      MsTimer2::start();\n    }\n    else if (RGB == \"CH1_6\") {\n      MsTimer2::set(50, rain_set);\n      MsTimer2::start();\n    }\n    else if (RGB == \"CH2_2\") {\n      DEBUG = false;\n      MsTimer2::set(1000, temp_set);\n      MsTimer2::start();\n    }\n    else if (RGB == \"CH2_3\") {\n      r = random(255);\n      g = random(255);\n      b = random(255);\n      MsTimer2::set(60, cds_set);\n      MsTimer2::start();\n    }\n    else if (RGB == \"CH2_4\") {\n      MsTimer2::set(90, ultra_set);\n      MsTimer2::start();\n    }\n    else rgb_set();\n    RGB = \"\";\n    RGB_Completed = false;\n  }\n  if ( !DEBUG )\n    celsius = dht.readTemperature();  \n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__test3.1.c", "original_string": "int main(){\n      unsigned char data[] = {0x47,0x00,0x87,0x00,0x00,0x00,0x00,0x00,0x14,0x00,0x4d,0x5f,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x00};\n      unsigned short ck = Checksum(data,sizeof(data));\n      printf(\"%04x\",ck);\n  }"}
{"author": "chandanXP", "file": "Datastructure-using-C__insertion.0.c", "original_string": "int display(int arr[], int n)\n{\n     for(int i = 0; i < n; i++){\n          printf(\"%d \",arr[i]);\n     }\n     printf(\"\\n\");\n}"}
{"author": "paawankohli", "file": "DSA-LAB__BToperations.1.c", "original_string": "int searchBT(nptr root, int x)\n{\n    if(root == NULL)\n        return 0;\n    else if (root -> data  == x  ||  searchBT(root -> lchild, x)  ||   searchBT(root -> rchild, x) )\n        return 1;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Pr.0.c", "original_string": "void main()\n{\n    int n,i,j,sum=0,temp,init_temp,k=0,k1;\n    char s[10];\n    float Waiting_time;\n    printf(\"\\nEnter the number of processess : \");\n    scanf(\"%d\",&n);\n    struct process p[n];\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter name : \");\n        scanf(\"%s\",p[i].name);\n        printf(\"\\nEnter AT : \");\n        scanf(\"%d\",&p[i].AT);\n        printf(\"\\nEnter BT : \");\n        scanf(\"%d\",&p[i].BT);\n        printf(\"\\nEnter priority : \");\n        scanf(\"%d\",&p[i].Pr);\n        p[i].status=0;\n    }\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(p[i].Pr>p[j].Pr)\n            {\n                temp=p[i].AT;\n                p[i].AT=p[j].AT;\n                p[j].AT=temp;\n                temp=p[i].BT;\n                p[i].BT=p[j].BT;\n                p[j].BT=temp;\n                temp=p[i].Pr;\n                p[i].Pr=p[j].Pr;\n                p[j].Pr=temp;\n                strcpy(s,p[i].name);\n                strcpy(p[i].name,p[j].name);\n                strcpy(p[j].name,s);\n            }   \n        }\n    }\n    temp=0;\n    while(k<n)\n    {\n        init_temp;\n        for(i=0;i<n;i++)\n        {\n            if(p[i].AT<=temp && p[i].status==0)\n            {\n                p[i].CT=p[i].BT+temp;\n                temp=temp+p[i].BT;\n                k++;\n                p[i].status=k;\n                break;\n            }\n        }\n        if(init_temp==temp)\n            temp++;\n    }\n    printf(\"\\nprocess\\tAT\\tBT\\tCT\\tTAT\\tWT\");\n    k1=1;\n    while(k1<=k)\n    {\n        for(i=0;i<n;i++)\n        {\n            if(p[i].status==k1)\n            {\n                p[i].TAT=p[i].CT-p[i].AT;\n                p[i].WT=p[i].TAT-p[i].BT;\n                sum=sum+p[i].WT;\n                printf(\"\\n%s\\t%d\\t%d\\t%d\\t%d\\t%d\",p[i].name,p[i].AT,p[i].BT,p[i].CT,p[i].TAT,p[i].WT);\n                k1++;\n            }\n        }\n    }\n    Waiting_time=(sum*1.0)/n;\n    printf(\"\\nAverage Waiting_time : %f\",Waiting_time);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__keypad_assign.1.c", "original_string": "void row_key(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(ROW);\n        IODIR1 = IODIR1 | (COL);\n        val = (IOPIN1 & ROW); \n        val = val >> 21;\n        switch(val)\n        {\n            case 0x0E: \n                col_key1();  \n                break;\n            case 0x0D:\n                col_key2();  \n                break;\n            case 0x0B:\n                col_key3();  \n                break;\n            case 0x07:\n                col_key4();  \n                break;\n        }\n}"}
{"author": "augustogunsch", "file": "jackc__util.0.c", "original_string": "char* heapstr(const char* str, int len) {\n    int size = sizeof(char) * (len + 1);\n    char* outstr = (char*)malloc(size);\n    strcpy(outstr, str);\n    return outstr;\n}"}
