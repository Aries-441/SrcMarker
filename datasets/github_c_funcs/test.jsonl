{"author": "chandanXP", "file": "Datastructure-using-C__peekInStack.5.c", "original_string": "int main()\n{\n    struct stack *sp=(struct stack*)malloc(sizeof(struct stack));\n    sp->size=10;\n    sp->top= -1;\n    sp->arr= (int *)malloc(sp->size* sizeof(int));\n    printf(\"Before pushing, Full: %d\\n\", isFull(sp));\n    printf(\"Before pushing, Empty: %d\\n\", isEmpty(sp));\n    push(sp, 56);\n    push(sp, 55);\n    push(sp, 54);\n    push(sp, 53);\n    push(sp, 52);\n    push(sp, 51);\n    push(sp, 50);\n    push(sp, 49);\n    push(sp, 48);\n    push(sp, 47); \n    push(sp, 46); \n    printf(\"After pushing, Full: %d\\n\", isFull(sp));\n    printf(\"After pushing, Empty: %d\\n\", isEmpty(sp));\n    printf(\"Popped %d from the stack\\n\", pop(sp));\n    for(int j=1; j <= sp->top + 1; j++){\n        printf(\"The value at position %d is %d\\n\",j,peek(sp, j));\n    }\n    return 0;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sum_Of_All_Diagonals.3.c", "original_string": "void display(int matrix[R][C])\n{\n    int i, j = 0;\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.1.c", "original_string": "TERM* parsetermnullified(PARSER* p) {\n    TOKENTYPE type = p->current->type;\n    if(type == integer) return parseint(p);\n    if(type == string) return parsestr(p);\n    if(type == keyword) return parsekeyword(p);\n    if(type == identifier) return parseidentifierterm(p);\n    if(equals(p, \"-\") || equals(p, \"~\")) return parseunaryopterm(p);\n    if(equals(p, \"(\")) return parseinnerexpression(p);\n    return NULL;\n}"}
{"author": "ankitraj311", "file": "Socket-thread__t.1.c", "original_string": "int main() \n{ \n    int i; \n    pthread_t tid; \n    for (i = 0; i < 3; i++) \n        pthread_create(&tid, NULL, myThreadFun, (void *)&tid); \n    pthread_exit(NULL); \n    return 0; \n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__odd_even_client.0.c", "original_string": "int main()\n{\nconst char* name=\"odd_even\";\nconst int SIZE=15*1024;\nint shmid;\nchar words;\nvoid* shmptr;\nshmid=shm_open(name,O_CREAT|O_RDWR,0666);\n      if (shmid< 0) {\n          printf(\"*** shmget error (server) ***\\n\");\n          exit(1);\n     }\n     ftruncate(shmid,SIZE);\n     shmptr=mmap(0,SIZE,PROT_WRITE,MAP_SHARED,shmid,0);\n     printf(\"inside client\\n\");\n     while(1)\n     {\n         puts(shmptr);\n         shmptr+=15*sizeof(char);\n     }\n     shm_unlink(name);\n     return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__LLunion.5.c", "original_string": "int main()\n{\n    nptr head1 = NULL, head2 = NULL, head3 = NULL;\n    int ele;\n    printf(\"Elements in list 1: \\n\");\n    while(1)\n    {\n        scanf(\"%d\", &ele);\n        if(ele == -1)\n            break;\n        insertRear(head1, ele);\n    } \n    display(head1);\n    printf(\"Elements in list 2: \\n\");\n    while(1)\n    {\n        scanf(\"%d\", &ele);\n        if(ele == -1)\n            break;\n        insertRear(head2, ele);\n    } \n    display(head2);  \n    printf(\"\\nUnion: \\n\");\n    display(head3 = listUnion(head1, head2));\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_04.0.c", "original_string": "int* read(int n)\n{\n        int i;\n        int s = sizeof(int);\n        int* arr1= (int*)malloc(s * n);\n        for(i = 0; i<n; i++)\n        {\n                fscanf(F1, \"%d\", (arr1+i));\n        }\n        return arr1;\n}"}
{"author": "Ana-Morales", "file": "binary_trees__16-binary_tree_is_perfect.0.c", "original_string": "size_t binary_tree_height(const binary_tree_t *tree)\n{\n    size_t height_left = 0;\n    size_t height_right = 0;\n    if (tree == NULL)\n        return (-1);\n    if (tree->left == NULL && tree->right == NULL)\n        return (0);\n    height_left = binary_tree_height(tree->left) + 1;\n    height_right = binary_tree_height(tree->right) + 1;\n    if (height_left > height_right)\n        return (height_left);\n    return (height_right);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__multiple_isr.1.c", "original_string": "void timer_config(void)\n{\n        T0PR = 14;\n        T0MR0 = 2000000;\n        T0MCR = (1<<0)|(1<<1);\n        T1PR = 14;\n        T1MR0 = 2000000;\n        T1MCR = (1<<0)|(1<<1);\n        T1TCR = (1<<0);\n        T0TCR = (1<<0);\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad5.3.c", "original_string": "int unosPrvi(pozicija p)\n{\n    FILE* fp = NULL;\n    fp = fopen(\"lista1.txt\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"Neuspjesno otvaranje datoteke!\\n\");\n        return 1;\n    }\n    while (!feof(fp))\n    {\n        pozicija q = NULL;\n        q = (pozicija)malloc(sizeof(struct lista));\n        if (q == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        pozicija pret, temp;\n        temp = p->next;\n        pret = p;\n        fscanf(fp, \"%d\\n\", &q->el);\n        while (temp != NULL)\n        {\n            pret = temp;\n            temp = temp->next;\n        }\n        pret->next = q;\n        if (temp != NULL)\n            q->next = temp;\n        else\n            q->next = NULL;\n    }\n    return 0;\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__BubbleSort.1.c", "original_string": "int bubbleSort(int x[],int y)\n{\n    int i,j,temp;\n    for(i=0;i<y;i++)\n    {\n        for(j=0;j<y-i-1;j++)\n        {\n            if(x[j] > x[j+1])\n            {\n                temp = x[j];\n                x[j] = x[j+1];\n                x[j+1] = temp;\n            }\n        }\n    }\n    printf(\"sorted array:\\n\");\n    for(i=0;i<y;i++)\n    {\n        printf(\"%d\\n\",x[i]);\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__UARTDrv.0.c", "original_string": "void uart_init(uart_port_t unit, uart_config_t *config, uint8_t txPin, uint8_t rxPin)\n{\n  uartUnit = unit;\n  uart_param_config(unit, config);\n  uart_set_pin(unit, txPin, rxPin, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);\n  uart_driver_install(unit, UART_BUFFER_SIZE, UART_BUFFER_SIZE, 0, NULL, 0);\n  uart_set_mode(unit, UART_MODE_UART);\n}"}
{"author": "MartinMarinovich", "file": "MarinovichMartinLABIPP1G-__servicio0.0.c", "original_string": "int hardCodearServicios(eServicio listadoServicios[], int tamanioServicio)\n{\n    int error = -1;\n    int idServicio [4]= {2000,2001,2002,2003};\n    char servicio [4][25] = {\"Bateria\",\"Antivirus\",\"Actualizacion\",\"Fuente\"};\n    int precios[4] = {250,300,400,600};\n    if(listadoServicios != NULL && tamanioServicio>0)\n    {\n        for(int i = 0; i<tamanioServicio; i++)\n        {\n            strcpy(listadoServicios[i].descripcion,servicio[i]);\n            listadoServicios[i].precio = precios[i];\n            listadoServicios[i].idServicio = idServicio[i];\n        }\n        error = 0;\n    }\n    return error;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__channel_survey.5.c", "original_string": "uint32_t channel_map_request_update(uint16_t conn_handle, uint8_t first_best_channel_number)\n{\n        ret_code_t err_code;\n        uint8_t number_channel_request = 0;\n        ble_gap_opt_ch_map_t channel_map = {0};\n        if (conn_handle == BLE_CONN_HANDLE_INVALID)\n        {\n                NRF_LOG_ERROR(\"Failure: because of disconnection!\");\n                return -1;\n        }\n        NRF_LOG_DEBUG(\"channel_map_request_update!!\");\n        channel_map.conn_handle = conn_handle;  \n        for (uint8_t i=0; i < BLE_GAP_CHANNEL_COUNT; i++)\n        {\n                uint8_t freq_index = m_average_ch_energy[i].index;\n                if (freq_index != ADVERTISING_CHANNEL_37 && freq_index != ADVERTISING_CHANNEL_38 && freq_index != ADVERTISING_CHANNEL_39)\n                {\n                        if (freq_index < 8)\n                        {\n                                channel_map.ch_map[0] |= 1 << (freq_index);\n                        }\n                        else if (freq_index < 16)\n                        {\n                                channel_map.ch_map[1] |= 1 << (freq_index-8);\n                        }\n                        else if (freq_index < 24)\n                        {\n                                channel_map.ch_map[2] |= 1 << (freq_index-16);\n                        }\n                        else if (freq_index < 32)\n                        {\n                                channel_map.ch_map[3] |= 1 << (freq_index-24);\n                        }\n                        else\n                        {\n                                channel_map.ch_map[4] |= 1 << (freq_index-32);\n                        }\n                        number_channel_request++;\n                }\n                if (number_channel_request > first_best_channel_number)\n                {\n                        break;\n                }\n        }\n        NRF_LOG_HEXDUMP_DEBUG(channel_map.ch_map, 5);\n        err_code = sd_ble_opt_set(BLE_GAP_OPT_CH_MAP, (ble_opt_t *)&channel_map);\n        APP_ERROR_CHECK(err_code);\n        update_channel_survey_status = false;\n}"}
{"author": "earth429", "file": "mulpre__t.0.c", "original_string": "int main(int argc, char **argv)\n{\n    double t1 = time(NULL);\n    struct NUMBER a, b, c, d, one, two, three, a_tmp;\n    int val;\n    setInt(&one ,1);\n    setInt(&two, 2);\n    setInt(&three, 3);\n    setInt(&b, 500); \n    printf(\"\u30cd\u30a4\u30d4\u30a2\u6570\u8a08\u7b97\u958b\u59cb\\n\");\n    neipia(&a, &b);\n    dispNumber(&a);\n    val = getDigit(&a);\n    printf(\"\\nval1:%d\\n\", val);\n    compareNumber(&a, \"neipia.txt\", val);\n    double t3 = time(NULL);\n    printf(\"\\n\u9014\u4e2d\u6642\u9593:%f\\n\", t3 - t1);\n    printf(\"\\n\u5e73\u65b9\u6839\u8a08\u7b97\u958b\u59cb\\n\");\n    divBy10(&a, &a_tmp);\n    copyNumber(&a_tmp, &a);\n    sqrt_newton(&a, &c);\n    dispNumberZeroSuppress(&c);\n    val = getDigit(&c);\n    printf(\"\\nval2:%d\\n\", val);\n    compareNumber(&c, \"sqrtE.txt\", val);\n    t3 = time(NULL);\n    printf(\"\\n\u9014\u4e2d\u6642\u9593:%f\\n\", t3 - t1);\n    printf(\"\\n\u4e09\u4e57\u6839\u8a08\u7b97\u958b\u59cb\\n\");\n    mulBy10(&a, &a_tmp);\n    copyNumber(&a_tmp, &a);\n    curt(&a, &d);\n    dispNumberZeroSuppress(&d);\n    val = getDigit(&d);\n    printf(\"\\nval3:%d\\n\", val);\n    compareNumber(&d, \"curtE.txt\", val);\n    double t2 = time(NULL);\n    printf(\"\\n\u51e6\u7406\u6642\u9593:%f\\n\", t2 - t1);\n    return 0;\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__InsertionOfNodeAtBeginningInLL.0.c", "original_string": "int add_at_beginning(struct node**temp1)\n{\n    struct node*tempo;\n    tempo = (struct node*) malloc (sizeof(struct node));\n    printf(\"Enter the element:\");\n    scanf(\"%d\",&tempo->data);\n    tempo->link = *temp1;\n    *temp1 = tempo;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e62.5.c", "original_string": "void menuIngresso()\n{                       \n    int pagamento, existeEvento;\n    if (capacidadeMax == 0)\n    {\n        printf(\"Nao ha evento cadastrado\\n\");   \n    }\n        else\n        {   \n            existeEvento = selecionarEvento();\n            if(existeEvento == 1)   \n            {\n                printf(\"\\n\\t\\t\\t\\t(10%% de desconto no dinheiro)\\n\\n\");\n                printf(\"\\n Digite 1 para pagamento no cartao: \");           \n                printf(\"\\n Digite 2 para pagamento em dinheiro: \\n\\t\");\n                scanf(\"%d\", &pagamento);\n                if(pagamento == 1)\n                {           \n                comprarIngresso(escolherIngresso(), 0);\n                }\n                    else\n                    {\n                        comprarIngresso(escolherIngresso(), 0.1);\n                    }\n            }\n                else\n                {\n                    printf(\"\\n\\n\\tNao existe esse evento!\\n\");\n                }   \n        }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__linear_search.2.c", "original_string": "int main(void) {\n    printf(\"linear search \\n\");\n    printf(\"searching for an  element in the array \\n\"); \n    printf(\"elements in the array are \\n\");\n    int a[5]={15,24,36,14,22};\n    int n=5;\n    printarray(a,n);\n    int data=36;\n    printf(\"\\n the searching element in the array is %d \\n\",data);\n    linear(a,n,data);\n    return EXIT_SUCCESS;\n}"}
{"author": "kalpa96", "file": "Pointers__min.0.c", "original_string": "int main(){\n    int num1,num2,num3;\n    int *p1,*p2,*p3;\n    printf(\"Enter Number 1 : \");\n    scanf(\"%d\",&num1);\n    printf(\"Enter Number 2 : \");\n    scanf(\"%d\",&num2);\n    printf(\"Enter Number 3 : \");\n    scanf(\"%d\",&num3);\n    printf(\"\\n\");\n    p1 = &num1;\n    p2 = &num2;\n    p3 = &num3;\n    if(*p1 > *p2){\n        if(*p1 > *p3){\n            printf(\"Maximum is : %d\\n\",*p1);\n        }\n        else{\n            printf(\"Maximum is : %d\\n\",*p3);\n        }\n    }\n    else{\n        if(*p2 > *p3){\n            printf(\"Maximum is : %d\\n\",*p2);\n        }\n        else{\n            printf(\"Maximum is : %d\\n\",*p3);\n        }\n    }\n    if(*p1 < *p2){\n        if(*p1 < *p3){\n            printf(\"Minimum is : %d\",*p1);\n        }\n        else{\n            printf(\"Minimum is : %d\",*p3);\n        }\n    }\n    else{\n        if(*p2 < *p3){\n            printf(\"Minimum is : %d\",*p2);\n        }\n        else{\n            printf(\"Minimum is : %d\",*p3);\n        }\n    }\n    return 0;\n}"}
{"author": "2security", "file": "Matrix__40CheckSymmetricMatrix.1.c", "original_string": "int ** Transpose(int mat1[][20],int mat2[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)\n        mat2[i][j]=mat1[j][i];\n    return mat2;\n    }"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc-a.10.c", "original_string": "int InternalNodeCount(list* node)\n{\n    if(node==NULL ||(node->left==NULL && node->right==NULL))\n        return 0;\n    else\n        return 1 + InternalNodeCount(node->left)+InternalNodeCount(node->right);\n}"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal.8.c", "original_string": "HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)\n{\n  HAL_StatusTypeDef status  = HAL_OK;\n  assert_param(IS_TICKFREQ(Freq));\n  if (uwTickFreq != Freq)\n  {\n    uwTickFreq = Freq;\n    status = HAL_InitTick(uwTickPrio);\n  }\n  return status;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_7.5.c", "original_string": "int main()\n{\n    int num;\n    char sel;\n    int n1; int capacity;\n    FILE* fp1;\n    FILE* fp2;\n    fp1=fopen(\"input.txt\",\"r\");\n    fp2=fopen(\"output.txt\",\"w\");\n    fscanf(fp1,\"%d\",&capacity);\n    struct stack* stk=(struct stack*)malloc(sizeof(struct stack));\n    stk->cap=capacity;\n    stk->top=-1;\n    stk->A=(int*)malloc(sizeof(int)*capacity);\n    while(1){\n    fscanf(fp1,\"%c\",&sel);\n    if(sel=='p')\n    {\n        fscanf(fp1,\"%d\",&n1);\n        push(stk,n1,fp2);\n    }\n    else if(sel=='t')\n    {\n        pop(stk,fp2);\n    }\n    else if(sel=='d')\n    {\n        fscanf(fp1,\"%d\",&num);\n        print(stk,num,fp2);\n    }\n    else if(sel=='s')\n    {\n        break;\n    }\n}\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_SLL.0.c", "original_string": "int main()\n{\n    printf(\"Linked list functions\\n\");\n    int choice;\n    printf(\"1.implementation\\n\");\n    printf(\"2.display\\n\");\n    printf(\"3.count\\n\");\n    printf(\"4.delete the element at the beginning position\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",& choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display\\n\");\n            display();\n            break;\n            case 3:printf(\"count the element in linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"delete the element from the beginning\\n\");\n            delete_at_beg();\n            break;\n            case 5:exit(0);\n            break;\n            default: printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",& choice);\n        }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__peekInStack.4.c", "original_string": "int peek(struct stack* sp, int i){\n    int arrayInd = sp->top-i+1;\n    if(arrayInd<0){\n        printf(\"Not a valid position for stack\\n\");\n        return -1;\n    }\n    else{\n        return sp->arr[arrayInd];\n    }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e2.0.c", "original_string": "int main(void) {\n    srand (time(NULL));\n    int jogarNovamente;\n    int jogarNovamente2;\n    int jogarMais = 1;\n    int escolhaJogo;\n    int jogador1;\n    int jogador2;\n    int jogadaComputador;\n    int linha;\n    int pontosJogador1 = 0;\n    int pontosJogador2 = 0;\n    int pontosComputador = 0;\n    int empate = 0;\n    int totalJogadas;\n    float porcentagemJogador1;\n    float porcentagemJogador2;\n    float porcentagemComputador;\n    printf(\"\\n                              JOKENPO ULTIMATE!\\n\\n\");\n    printf(\"\\n                    Digite >1< para jogar contra o computador.\\n\");\n    printf(\"                    Digite >2< para jogar contra outro humano.\\n\\n\");\n    printf(\"                                     >\");\n    scanf(\" %d\", &escolhaJogo);\n    while(jogarMais > 0){\n        jogadaComputador = rand()%3+1;\n        if(escolhaJogo == 1){ \n        printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n        printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n        printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n        printf(\"\\n                          HUMANO X COMPUTADOR, BOA SORTE!!\");\n        printf(\"\\n                                Faca a sua jogada: \\n\\n\");\n        printf(\"                                     >\");\n        scanf(\" %d\", &jogador1);\n            if(jogador1 >=1 && jogador1 <=3){ \n                printf(\"\\n                                  JO\");\n                sleep(1);\n                printf(\"KEN\");\n                sleep(1);\n                printf(\"PO!!! \\n\\n\");\n                sleep(1);\n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n                switch(jogador1){ \n                    case 1:\n                        printf(\"                                 PEDRA x \");\n                        break;\n                    case 2:\n                        printf(\"                                 PAPEL x \");\n                        break;\n                    case 3:\n                        printf(\"                                TESOURA x \");\n                        break;\n                }\n                switch(jogadaComputador){ \n                    case 1:\n                        printf(\"PEDRA \\n\\n\");\n                        break;\n                    case 2:\n                        printf(\"PAPEL \\n\\n\");\n                        break;\n                    case 3:\n                        printf(\"TESOURA \\n\\n\");\n                        break;\n                }\n                if ((jogador1 == 1 && jogadaComputador == 3) || (jogador1 == 2 && jogadaComputador == 1) || (jogador1 == 3 && jogadaComputador == 2)){ \n                    printf(\"                                 VOCE VENCEU!!! \\n\\n\");\n                    pontosJogador1 = pontosJogador1 + 1;\n                }\n                if (jogador1 == jogadaComputador){ \n                    printf(\"                                    EMPATE! \\n\\n\");\n                    empate++;\n                }\n                if ((jogadaComputador == 1 && jogador1 == 3) || (jogadaComputador == 2 && jogador1 == 1) || (jogadaComputador == 3 && jogador1 == 2)){ \n                    printf(\"                                 VOCE PERDEU :( \\n\\n\");\n                    pontosComputador = pontosComputador + 1;\n            }\n        } else { \n            printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n        }\n        }\n        if(escolhaJogo == 2){  \n            printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n            printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n            printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n            printf(\"\\n                          HUMANO X HUMANO, BOA SORTE!!\");\n            printf(\"\\n\\n                          JOGADOR 1 Faca a sua jogada: \\n\\n\");\n            printf(\"                                     >\");\n            scanf(\" %d\", &jogador1);\n            if(jogador1 >= 1 && jogador1 <= 3){\n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n                printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n                printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n                printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n                printf(\"\\n                          HUMANO X HUMANO, BOA SORTE!!\");\n                printf(\"\\n\\n                          JOGADOR 2 Faca a sua jogada: \\n\\n\");\n                printf(\"                                     >\");\n                scanf(\" %d\", &jogador2);\n                if(jogador2 >= 1 && jogador2 <= 3) {\n                    printf(\"\\n                                  JO\");\n                    sleep(1);\n                    printf(\"KEN\");\n                    sleep(1);\n                    printf(\"PO!!! \\n\\n\");\n                    sleep(1);\n                    for( linha = 0; linha < 35; linha++){ \n                        printf( \"\\n\" );\n                    }\n                    switch(jogador1){ \n                    case 1:\n                        printf(\"                                 PEDRA x \");\n                        break;\n                    case 2:\n                        printf(\"                                 PAPEL x \");\n                        break;\n                    case 3:\n                        printf(\"                                TESOURA x \");\n                        break;\n                    }\n                    switch(jogador2){ \n                    case 1:\n                        printf(\"PEDRA \\n\\n\");\n                        break;\n                    case 2:\n                        printf(\"PAPEL \\n\\n\");\n                        break;\n                    case 3:\n                        printf(\"TESOURA \\n\\n\");\n                        break;\n                    }\n                    if ((jogador1 == 1 && jogador2 == 3) || (jogador1 == 2 && jogador2 == 1) || (jogador1 == 3 && jogador2 == 2)){ \n                        printf(\"                               JOGADOR 1 VENCEU! \\n\\n\");\n                        pontosJogador1 = pontosJogador1 + 1;\n                    }\n                    if (jogador1 == jogador2){ \n                        printf(\"                                    EMPATE! \\n\\n\");\n                        empate++;\n                    }\n                    if ((jogador2 == 1 && jogador1 == 3) || (jogador2 == 2 && jogador1 == 1) || (jogador2 == 3 && jogador1 == 2)){ \n                        printf(\"                               JOGADOR 2 VENCEU! \\n\\n\");\n                        pontosJogador2 = pontosJogador2 + 1;\n                    }\n                } else { \n                    printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n                }\n            } else { \n                printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n            }\n        }\n        if(escolhaJogo > 2){  \n            printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n            exit(0);\n        }\n        printf(\"\\n\\n\\n\\n\\n\\n\\n\\n                          Para jogar novamente digite >1< \\n\");\n        printf(\"                          Para estatisticas digite    >2< \\n\");\n        printf(\"                          Para sair digite            >3< \\n\\n\");\n        printf(\"                                     >\");\n        scanf(\" %d\", &jogarNovamente);\n        if(jogarNovamente == 1){ \n            for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n        }\n        if(jogarNovamente == 2){ \n            for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n            }\n            totalJogadas = pontosJogador1 + pontosJogador2 + pontosComputador + empate;\n            printf(\"\\n                                 ESTATISTICAS!\\n\\n\");\n            printf(\"                          Vitorias do Jogador 1:     >%d< \\n\", pontosJogador1);\n            if(pontosJogador2 > 0){\n                printf(\"                      Vitorias do Jogador 2:     >%d< \\n\\n\", pontosJogador2);\n                printf(\"                      Empates:                   >%d< \\n\\n\", empate);\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                porcentagemJogador2 = ((float)pontosJogador2 / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\", porcentagemJogador1);\n                printf(\"                  Porcentagem de vitorias do Jogador 2:     >%.1f< \\n\", porcentagemJogador2);\n            }\n            if(pontosComputador > 0){\n                printf(\"                          Vitorias do Computador:    >%d< \\n\\n\", pontosComputador);\n                printf(\"                          Empates:                   >%d< \\n\\n\", empate);\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                porcentagemComputador = ((float)pontosComputador / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\", porcentagemJogador1);\n                printf(\"                  Porcentagem de vitorias do Computador:    >%.1f< \\n\", porcentagemComputador);\n            }\n            if(pontosJogador2 == 0 && pontosComputador == 0){\n                if(escolhaJogo == 1){\n                    printf(\"                          Vitorias do Computador:    >%d< \\n\\n\", pontosComputador);\n                }\n                if(escolhaJogo == 2){\n                    printf(\"                          Vitorias do Jogador 2:     >%d< \\n\\n\", pontosJogador2);\n                }\n                if(empate > 0){\n                        printf(\"                          Empates:                   >%d< \\n\\n\", empate);\n                }\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\\n\", porcentagemJogador1);\n            }\n            for( linha = 0; linha < 13; linha++){ \n                    printf( \"\\n\" );\n            }\n            printf(\"                          Para jogar novamente digite >1< \\n\");\n            printf(\"                          Para sair digite            >2< \\n\\n\");\n            printf(\"                                     >\");\n            scanf(\" %d\", &jogarNovamente2);\n            if(jogarNovamente2 == 1){ \n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n            }\n            if(jogarNovamente2 == 2){ \n                exit(0);\n            }\n            if(jogarNovamente2 >= 3){\n                printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n                exit(0);\n            }\n        }\n        if(jogarNovamente == 3){\n            exit(0);\n        }\n        if(jogarNovamente >= 4){\n            printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n            exit(0);\n        }\n    }\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server_directory.1.c", "original_string": "error_t scpServerOpenDir(ScpServerSession *session)\n{\n   error_t error;\n   uint_t perm;\n   perm = scpServerGetFilePermissions(session, session->path);\n   if((perm & SCP_FILE_PERM_READ) != 0)\n   {\n      session->dir[session->dirLevel] = fsOpenDir(session->path);\n      if(session->dir[session->dirLevel] != NULL)\n      {\n         session->fileMode = SCP_MODE_IRWXU | SCP_MODE_IRWXG | SCP_MODE_IRWXO;\n         error = NO_ERROR;\n      }\n      else\n      {\n         error = ERROR_DIRECTORY_NOT_FOUND;\n      }\n   }\n   else\n   {\n      error = ERROR_ACCESS_DENIED;\n   }\n   return error;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es1.1.c", "original_string": "int check(int a[], int dim_a, int b[], int dim_b){\n  int i = 0; \n  int trovato = 0; \n  int somma_b = somma(b, dim_b);\n  while(i<dim_a && !trovato){\n    if(a[i]==somma_b){\n      trovato = 1;\n    }\n    i++;\n  } \n  return trovato;\n}"}
{"author": "mehedi9021", "file": "C__practice5.0.c", "original_string": "int main()\n{\n    int\n    a[5][5], b[5][5], sum=0;\n    int r, c;\n    for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                scanf(\"%d\", &a[r][c]);\n            }\n        }\n        printf(\"\\n\");\n        for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                scanf(\"%d\", &b[100][100]);\n            }\n        }\n        printf(\"\\n\");\n        for(r=0; r<=2; r++)\n        {\n            for(c=0; c<=2; c++)\n            {\n                sum=a[r][c];\n            }\n            printf(\"%d\", sum);\n        }\n        return 0;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__a.2.c", "original_string": "int     main(int ac, char **av)\n{\n    int i;\n    int i2;\n    i = 0;\n    if (ac > 1)\n    {\n        while (i < ac)\n        {\n            i++;\n            i2 = 0;\n            while (av[i][i2] != '\\0')\n            {\n                if (ft_to_upper(av[i][i2], av[i][i2 + 1]))\n                    av[i][i2] -= 32;\n                else if (ft_to_lower(av[i][i2], av[i][i2 + 1]))\n                    av[i][i2] += 32;\n                write(1, &av[i][i2], 1);\n                i2++;\n            }\n            write(1, \"\\n\", 1);\n        }\n    }\n    else\n        write(1, \"\\n\", 1);\n    return (0);\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__OC.5.c", "original_string": "void main()\n{\n    int ch,i;\n    for(i=0;i<5;i++)\n    HASH[i]=NULL;\n    printf(\"\\n1.INSERT\\n2.DELETE\\n3.SEARCH\\n4.DISPLAY\\n\\n\");\n    while(1)\n    {\n        printf(\"\\nEnter choice:\");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                insert(key,val);\n                break;\n            }\n            case 2:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                delete(key,val);\n                break;\n            }\n            case 3:\n            {\n                printf(\"\\nEnter the key:\");\n                scanf(\"%d\",&key);\n                printf(\"\\nEnter the value:\");\n                scanf(\"%d\",&val);\n                search(key,val);\n                break;\n            }\n            case 4:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"author": "fikepaci", "file": "monty__monty_funcs_3.2.c", "original_string": "void monty_pstr(stack_t **stack, unsigned int line_number)\n{\n    stack_t *tmp = (*stack)->next;\n    while (tmp && tmp->n != 0 && (tmp->n > 0 && tmp->n <= 127))\n    {\n        printf(\"%c\", tmp->n);\n        tmp = tmp->next;\n    }\n    printf(\"\\n\");\n    (void)line_number;\n}"}
{"author": "0712023", "file": "Basis-and-Practice-in-Programming_SKKU__stage5.0.c", "original_string": "void tail_func(char tmp){\n  if(tmp == 'U'){\n    if(pos>7 && map[pos-8] != 'W'){\n      tail[tailpos] = pos;\n      if(tailpos>4){\n        map[tail[tailpos-5]] = 'E';\n      }\n      tailpos++;\n      pos-=8;\n    }\n  } else if (tmp == 'D'){\n    if(pos<55 && map[pos+8] != 'W'){\n      tail[tailpos] = pos;\n      if(tailpos>4){\n        map[tail[tailpos-5]] = 'E';\n      }\n      tailpos++;\n      pos+=8;\n    }\n  } else if (tmp == 'R'){\n    if(pos%8!=7 && map[pos+1] != 'W'){\n      tail[tailpos] = pos;\n      if(tailpos>4){\n        map[tail[tailpos-5]] = 'E';\n      }\n      tailpos++;\n      pos++;\n    }\n  } else if (tmp == 'L'){\n    if(pos%8!=0 && map[pos-1] != 'W'){\n      tail[tailpos] = pos;\n      if(tailpos>4){\n        map[tail[tailpos-5]] = 'E';\n      }\n      tailpos++;\n      pos--;\n    }\n  }\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Insertion_Sort.0.c", "original_string": "void main()\n{\n    int i = 0;\n    int size = 0;\n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n    insertion_sort(input_array, size);\n    printf(\"\\nAfter Insertion Sorting:- \\n\");\n    display(input_array, size);\n    printf(\"\\n\");\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__MatrixOperations.4.c", "original_string": "void display_matrix(int matrix[R][C])\n{\n    int i, j = 0;\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            printf(\"%d\\t\", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_DCLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio20.0.c", "original_string": "void *fhilo1(void *arg){\n    int i;\n    printf(\"\\nEstoy llenando el buffer \\n\");\n    for(i = 0; i < 10; i++){\n        sem_trywait(&semaforo);\n        buffer[i] = i+1;\n        sem_post(&semaforo);\n    }\n    sleep(random()%3);\n    pthread_exit(NULL);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__23_While.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cosh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    while(i <= veces){\n        Suma_total += Exp(X,(i*2)) / Fac((i*2));\n        ++i;\n    }\n    printf(\"Cosh(%i) es igual a %lf\", X, (Suma_total + 1));\n    return 0;\n}"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal_msp.0.c", "original_string": "void HAL_MspInit(void)\n{\n  __HAL_RCC_AFIO_CLK_ENABLE();\n  __HAL_RCC_PWR_CLK_ENABLE();\n  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);\n  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);\n  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);\n  __HAL_AFIO_REMAP_SWJ_NOJTAG();\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__sftp_server.0.c", "original_string": "void sftpServerGetDefaultSettings(SftpServerSettings *settings)\n{\n   settings->sshServerContext = NULL;\n   settings->numSessions = 0;\n   settings->sessions = NULL;\n   settings->numFileObjects = 0;\n   settings->fileObjects = NULL;\n   settings->rootDir = NULL;\n   settings->checkUserCallback = NULL;\n   settings->getFilePermCallback = NULL;\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__CountingSort.1.c", "original_string": "void counting_sort(int A[], int k, int n)\n{\n    int i, j,B[30],C[100];\n    count++;\n    for (i=0;i<=k;i++)\n    {\n        C[i]=0;\n        count++;\n        }\n        count++;\n    for (j=1;j<=n;j++){\n        C[A[j]]=C[A[j]]+1;\n        count++;\n        }\n        count++;\n    for (i=1;i<=k;i++){\n        C[i]=C[i]+C[i-1];\n        count++;\n        }\n        count++;\n    for (j=n;j>=1;j--)\n    {\n        count++;\n        B[C[A[j]]]=A[j];\n        count++;\n        C[A[j]]=C[A[j]]-1;\n        count++;\n    }\n    printf(\"Array after sorting\\n \");\n    for (i=1;i<=n;i++)\n        printf(\"%d \",B[i]);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__15_While.1.c", "original_string": "int main()\n{\n    int contador1 = 1;\n    int contador2 = 7;\n    while(contador1 < 8)\n    {\n        printf(\"\\n\");\n            if(contador1 >= 4)\n            Columna(contador2);\n        else\n            Columna(contador1);\n        --contador2;\n        ++contador1;\n    }\n}"}
{"author": "shengelenge", "file": "wstep-do-programowania__zad40.0.c", "original_string": "int main()\n{\n    double a, b, c;\n    double x1, x2;\n    double delta;\n    printf(\"Podaj liczby a, b i c:\\n\");\n    printf(\"a = \");\n    scanf(\"%lf\", &a);\n    printf(\"b = \");\n    scanf(\"%lf\", &b);\n    printf(\"c = \");\n    scanf(\"%lf\", &c);\n    delta = b*b - 4*a*c;\n    if (delta > 0)\n    {\n        x1 = (-1*b +  sqrt(delta))/2*a;\n        x2 = (-1*b -  sqrt(delta))/2*a;\n        printf(\"Miejsca zerowe funkcji f(x) = %.1lf x^2 + %.1lf x + %.1lf , x1 = %.1lf , x2 = %.1lf\", a,  b, c, x1, x2);\n    }\n    if (delta == 0)\n    {\n        x1 = (-1*b)/2*a;\n        printf(\"Miejsce zerowe funkcji f(x) = %.1lf x^2 + %.1lf x + %.1lf , x = %.1lf\", a,  b, c, x1);\n    }\n    if (delta < 0)\n        printf(\"Brak miejsc zerowych.\");\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__WiFiStationDrv.0.c", "original_string": "void wifi_init(void)\n{\n  tcpip_adapter_init();\n  esp_event_loop_init(&wifiEventHandlerCallback, NULL);\n  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();\n  esp_wifi_init(&cfg);\n  esp_wifi_set_mode(WIFI_MODE_STA);\n  esp_wifi_set_storage(WIFI_STORAGE_RAM);\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__unique.1.c", "original_string": "int get_numbers(int n, int max, int ns[], int i){\n  int r = n - max;\n  int check;\n  if(i == 10)\n    return 0;\n  if(r < 10 && check_number(r, ns, i)){\n    ns[i] = max;\n    i++;\n    if(check_number(r, ns, i)){\n    ns[i] = r;\n    return 1;\n      }\n    else{\n      check = get_numbers(r, max-1, ns, i);\n    }\n  }\n  else{\n    ns[i] = max;\n    i++;\n    check = get_numbers(r, max-1, ns, i);\n  }\n  return (max == 9)? valid_array(ns, n): check;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.11.c", "original_string": "void menu_modificacion_calificaciones(){\n    int opt = 0;\n    int posicion = posicion_alumno();\n    while(opt != 5) {\n        imprimir_menu_calificaciones();\n        scanf(\"%d\", &opt);\n        if (opt < MAX_CALIFICACIONES + 1) {\n            printf(\"La calificaci\u00f3n actual es: %f\\n\", \n                lista_estudiantes[posicion].calificaciones[opt-1]);\n            printf(\"Ingresa nueva calificaci\u00f3n %d:\", opt-1);\n            scanf(\"%f\", &lista_estudiantes[posicion].calificaciones[opt-1]);\n        }\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__led_all.1.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "haon1026", "file": "linux-programming__lseek.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    int fd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0644);\n    if(fd < 0)\n    {\n        perror(\"open error\");\n        exit(1);\n    }\n    char msg[] = \"It's a test for lseek\\n\";\n    write(fd, msg, strlen(msg));    \n    int n;\n    char ch;\n    while(n = read(fd, &ch, 1))\n    {\n        if(n < 0)\n        {\n            perror(\"read error\");\n            exit(1);\n        }\n        write(STDOUT_FILENO, &ch, n);\n    }\n    close(fd);\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader0.5.c", "original_string": "static bool createFirmwareUpdateInfoFile(void)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"wb\");\n  if (updateInfoFile == NULL) \n  {\n    printf(\"Failed to create %s: %s (error code: %i)\\n\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, strerror(errno), errno);\n    return false;\n  }\n  fclose(updateInfoFile);\n  return true;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListAllOperations.2.c", "original_string": "struct Node *insertAtIndex(struct Node *head, int data, int index)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     struct Node *p = head;\n     int i = 0;\n     while (i != index - 1) \n     {\n          p = p->next; \n          i++;\n     }\n     ptr->data = data;\n     ptr->next = p->next;\n     p->next = ptr;\n     return head; \n}"}
{"author": "ashlyn2002", "file": "programming-using-c__display_DLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n}"}
{"author": "dishanp", "file": "DSA__q30.0.c", "original_string": "void swapval(int a , int b)\n{\n    int t = a;\n    a = b;\n    b = t;\n    printf(\"\\n\\nAfter swapping by value : \\n\");\n    printf(\"Value of a : %d\\nValue of b : %d\", a, b);\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.12.c", "original_string": "SUBROUTDEC* getsubroutdecwithparent(SCOPE* s, SUBROUTCALL* call, VAR** varret) {\n    VAR* parent = getvar(s, call->parentname);\n    if(parent != NULL) {\n        if(parent->primitive) {\n            eprintf(\"Primitive type does not have subroutines; file '%s', line %i\\n\", call->debug->file, call->debug->definedat);\n            exit(1);\n        }\n        *varret = parent;\n        return getmethod(s, parent, call);\n    }\n    else\n        return getfunction(s, call);\n}"}
{"author": "jdes01", "file": "practicassoo__practica2ej1.1.c", "original_string": "int main(int argc, char const *argv[]){\n    srand (time(NULL));\n    int nHebras = atoi(argv[1]);\n    pthread_t thread[nHebras]; \n    int *numero, suma=0; \n    for (int i = 0; i < nHebras; i++){\n        if( pthread_create( &(thread[i]), NULL, (void*) generarNumeros, NULL ) != 0 ){ \n            fprintf(stderr, \"Error al crear la hebra\");         \n            exit(EXIT_FAILURE);                                 \n        }\n    }\n    for (int i = 0; i < nHebras; i++){\n        if( pthread_join( thread[i], (void **) &numero ) != 0 ){ \n            fprintf(stderr, \"Error al usar join\");         \n            exit(EXIT_FAILURE);                  \n        }\n        suma = suma + *numero;\n    }\n    printf(\"%i\", suma);\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "Common__cpu_endian.3.c", "original_string": "uint8_t reverseInt4(uint8_t value)\n{\n   value = ((value & 0x0C) >> 2) | ((value & 0x03) << 2);\n   value = ((value & 0x0A) >> 1) | ((value & 0x05) << 1);\n   return value;\n}"}
{"author": "sdukesameer", "file": "dsa__list-push-pop-del-rec_rev-count.4.c", "original_string": "node* rec_reverse(node* head)\n{\n    if(head == NULL || head->next == NULL)\n        return head;\n    node* revHead = rec_reverse(head->next);\n    head->next->next = head;\n    head->next = NULL; \n    return revHead;\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__107-quick_sort_hoare.0.c", "original_string": "int partition(int *array, int lo, int hi, size_t size)\n{\n    int i, j, pivot, tmp;\n    pivot = array[hi];\n    i = lo - 1;\n    j = hi + 1;\n    while (1)\n    {\n        while (array[++i] < pivot)\n        {\n            ;\n        }\n        while (array[--j] > pivot)\n        {\n            ;\n        }\n        if (i > j)\n            return (j);\n        if (i != j)\n        {\n            tmp = array[i];\n            array[i] = array[j];\n            array[j] = tmp;\n            print_array(array, size);\n        }\n    }\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad9.4.c", "original_string": "int PostOrderPrint(treePointer root)\n{\n    if (root)\n    {\n        PostOrderPrint(root->left);\n        PostOrderPrint(root->right);\n        printf(\"%d\\n\", root->data);\n    }\n    return 0;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Linear_Search.0.c", "original_string": "void main()\n{\n    int i, size, key = 0;\n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n    printf(\"\\nEnter the key to be searched: \\n\");\n    scanf(\"%d\", &key);\n    printf(\"\\n%d is found in Index %d\\n\", key, linear_search(input_array, size, key));\n}"}
{"author": "kbtomic", "file": "Seminarski-StrukturePodataka__Travels.1.c", "original_string": "islandPointer TravelToRightIsland(int* currentAmountOfCoins, int* numberOfFoundClues, islandPointer start, islandPointer currentIsland, stackPointer stackHead, int* flagForGameOver)\n{\n    islandPointer parentIsland = currentIsland;\n    if (HaveEnoughCoins(*currentAmountOfCoins, currentIsland->rightNext->coins))\n    {\n        *currentAmountOfCoins = SpendCoins(*currentAmountOfCoins, currentIsland->rightNext->coins);\n        currentIsland = currentIsland->rightNext;\n        PushStack(currentIsland, stackHead);\n        printf(\"%s\\n\", currentIsland->description);\n        if (isClueIsland(currentIsland))\n        {\n            printf(\"Trag je: %c\\n\", currentIsland->clue);\n            *numberOfFoundClues += 1;\n        }\n        else if (isDeathlyIsland(currentIsland, start))\n        {\n            if (HaveEnoughCoins(*currentAmountOfCoins, COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE))\n            {\n                char choice = RespawnPrint(*currentAmountOfCoins);\n                system(\"cls\");\n                if (tolower(choice) == 'd')\n                {\n                    *currentAmountOfCoins = SpendCoins(*currentAmountOfCoins, COINS_AMOUNT_FOR_RESPAWN_OR_MAIN_PRIZE);\n                    PrintCurrentPath(currentIsland, stackHead);\n                    printf(\"Status coina: %d\\n\", *currentAmountOfCoins);\n                    printf(\"Uskrsnuo si!\\n\");\n                    currentIsland = TravelToPrevIsland(parentIsland, currentIsland, stackHead);\n                }\n                else\n                {\n                    currentIsland = TravelToStartIsland(start, currentIsland, stackHead);\n                    *flagForGameOver = 1;\n                }\n            }\n            else\n            {\n                currentIsland = TravelToStartIsland(start, currentIsland, stackHead);\n                *flagForGameOver = 1;\n            }\n        }\n        else\n        {\n            PrintCurrentPath(currentIsland, stackHead);\n            currentIsland = TravelToPrevIsland(parentIsland, currentIsland, stackHead);\n        }\n    }\n    else \n    {\n        printf(\"Nazalost presiromasan si za daljnja putovanja :(!\\n\");\n        *flagForGameOver = 1;\n    }\n    return currentIsland;\n}"}
{"author": "mandarvu", "file": "msc__problem6.0.c", "original_string": "int main() {\n  int numbers[MAX], val, pos;\n  printf(\"Enter %d numbers: \", MAX);\n  for (int i = 0; i < MAX; i++)\n    scanf(\"%d\",numbers + i);\n  printf(\"\\nArray 1:\\n\");\n  for (int i = 0; i < MAX; i++)\n    printf(\"%d\\t\",  *(numbers + i));\n  printf(\"Enter the value to be searched\\n\" );\n  scanf(\"%d\",&val);\n  pos = search(numbers, val);\n  if (pos > 0)\n    printf(\"%d is at position %d\\n\",val, pos);\n  else\n    printf(\"%d not found\\n\",val);\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__nrf_dfu_flash.0.c", "original_string": "void dfu_fstorage_evt_handler(nrf_fstorage_evt_t * p_evt)\n{\n        if (NRF_LOG_ENABLED && (m_flash_operations_pending > 0))\n        {\n                m_flash_operations_pending--;\n        }\n        if (p_evt->result == NRF_SUCCESS)\n        {\n                NRF_LOG_DEBUG(\"Flash %s success: addr=%p, pending %d\",\n                              (p_evt->id == NRF_FSTORAGE_EVT_WRITE_RESULT) ? \"write\" : \"erase\",\n                              p_evt->addr, m_flash_operations_pending);\n        }\n        else\n        {\n                NRF_LOG_DEBUG(\"Flash %s failed (0x%x): addr=%p, len=0x%x bytes, pending %d\",\n                              (p_evt->id == NRF_FSTORAGE_EVT_WRITE_RESULT) ? \"write\" : \"erase\",\n                              p_evt->result, p_evt->addr, p_evt->len, m_flash_operations_pending);\n        }\n        if (p_evt->p_param)\n        {\n                ((nrf_dfu_flash_callback_t)(p_evt->p_param))((void*)p_evt->p_src);\n        }\n}"}
{"author": "2security", "file": "Star__HollowMirrorRhombusStar.0.c", "original_string": "int main()\n    {\n    int n,i,j;\n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<i;j++)\n            printf(\" \");\n        for(j=1;j<=n;j++)\n            {\n                if(i==1||i==n||j==1||j==n)\n                    printf(\"*\");\n                else\n                    printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }"}
{"author": "fikepaci", "file": "sorting_algorithms__103-merge_sort.1.c", "original_string": "void sort(int *array, int low, int high, int *temp)\n{\n    int mid;\n    if (low < high)\n    {\n        mid = (low + high) / 2;\n        sort(array, low, mid, temp);\n        sort(array, mid + 1, high, temp);\n        merge(array, low, mid, high, temp);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__inToPost.3.c", "original_string": "int main() \n{ \n    char exp[100], ans[100];\n    scanf(\"%s\", exp);   \n    infixToPostfix(exp, ans);\n    printf(\"%s \\n\", ans); \n}"}
{"author": "dle2005", "file": "Algorithm__Optimal_Binary_Search_Trees_v2.2.c", "original_string": "void optsearchtree(int n, float *p, float *minavg, index **R) {\n    index i, j, k, diagonal;\n    float **A = (float **)malloc(sizeof(float *) * (n + 2));\n    for(int t = 0; t < n + 2; t++)\n        A[t] = (float *)malloc(sizeof(float) * (n + 1));\n    for(i = 1; i <= n; i++) {\n        A[i][i-1] = 0;\n        A[i][i] = p[i];\n        R[i][i] = i;\n        R[i][i-1] = 0;\n    }\n    A[n+1][n] = 0;\n    R[n+1][n] = 0;\n    for(diagonal = 1; diagonal <= n-1; diagonal++) {\n        for(i = 1; i <= n - diagonal; i++) {\n            j = i + diagonal;\n            k = min(i, j, A, p);\n            A[i][j] = A[i][k-1] + A[k+1][j] + sum(i, j, p);\n            R[i][j] = k;\n        }\n    }\n    printf(\"A = \\n\");\n    for(int i = 1; i <= n + 1; i++) {\n        for(int j = 0; j <= n; j++)\n            printf(\"%.3f \", A[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    *minavg = A[1][n];\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__pwm_double.0.c", "original_string": "int main()\n{\n    PINSEL0 |= (1<<17);\n    PINSEL0 &= ~(1<<16);  \n    PWMPR = 14;\n    PWMMR0 = 10000;\n    PWMLER = 1<<0;\n    PWMMCR = (1<<1);   \n    PWMPCR = (1<<4)|(1<<12);  \n    PWMTCR = (1<<0)|(1<<3);  \n        while(1)\n        {\n            PWMMR3 = 1000;   \n            PWMMR4 = 3500;\n            PWMLER = (1<<3)|(1<<4);\n            delay(500);\n            PWMMR3 = 1000;  \n            PWMMR4 = 6000;\n            PWMLER = (1<<3)|(1<<4);\n            delay(500);\n            PWMMR3 = 1000;  \n            PWMMR4 = 8500;\n            PWMLER = (1<<3)|(1<<4);\n            delay(500);\n    }\n}"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio1.1.c", "original_string": "void *func2 (void *arg){\n    int err;\n    if(err = pthread_join(thread1, NULL)){\n        printf(\"Error al esperar a thread1 \\n \");\n    }else{\n        int suma = 1;\n        int size=(int) arg;\n        for(int i = 1; i < size; i++){\n            suma = suma * (int) arg;\n            arg--;\n        }\n        printf(\"Soy el thread 2 y estoy calculando el factorial de %d que es: %d \\n\", size, suma);\n    }\n    pthread_exit(NULL);\n}"}
{"author": "davibernardos", "file": "DB-PJ__e150.3.c", "original_string": "int main(int argc, char *argv[]) {\n    char vetorCaptcha[TAM];\n    char vetorUsuario[TAM];\n    int captcha;\n    int validacaoDados;\n    int comparacao;\n    int resultado;\n    int cont;\n    srand(time(NULL));\n    do \n    {\n        system (\"COLOR F\");\n        system (\"cls\");\n        printf (\"Teste de Turing.\\n\\n\");\n        for (cont = 0; cont < 6; cont++)\n        {\n            do\n            {\n                captcha = (rand() % 122);\n            }\n            while (captcha <= 48 || captcha >= 57 && captcha <= 97 || captcha >= 122);\n            vetorCaptcha[cont] = captcha;\n            printf (\"%c \", vetorCaptcha[cont]);\n        }\n        system (\"COLOR F\");\n        printf (\"\\n\\nDigite os caracteres acima: \");\n        gets(vetorUsuario);\n        validacaoDados = validarDados (vetorUsuario);\n        if (validacaoDados == 0)\n        {\n            comparacao = compararCaptcha (vetorCaptcha, vetorUsuario);\n            resultado = exibirResultado (comparacao);\n            if (resultado == 1)\n            {\n                validacaoDados = resultado;\n                printf (\"%d\", validacaoDados);\n            }   \n        }\n    }\n    while (validacaoDados != 0);\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__BinHexConverter.0.c", "original_string": "static inline char convertBinValueToHexDigit(uint8_t value, bool upperCase)\n{\n  char hexA = (upperCase) ? ('A') : ('a');\n  return ((char)((value < 10) ? ('0' + value) : (hexA + value - 10)));\n}"}
{"author": "haon1026", "file": "linux-programming__dup2.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    int fd1 = open(argv[1], O_RDWR|O_CREAT, 0644);   \n    if(fd1 < 0)\n    {\n        perror(\"open error\");\n        exit(1);\n    }\n    int fd2 = open(argv[2], O_RDWR|O_CREAT, 0644);   \n    if(fd2 < 0)\n    {\n        perror(\"open error\");\n        exit(1);\n    }\n    int newfd = dup2(fd1, fd2);                 \n    printf(\"newfd = %d\\n\", newfd);\n    int ret = write(fd2, \"1234567\", 7);         \n    printf(\"ret = %d\\n\", ret);\n    dup2(fd1, STDOUT_FILENO);                   \n    printf(\"-------------------\\n\");\n    close(fd1);\n    close(newfd);\n    return 0;\n}"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__map_manager.3.c", "original_string": "void        map_errors(char **map)\n{\n    int i;\n    int j;\n    i = 0;\n    j = 0;\n    while (++i <= g_map_height)\n    {\n        while (++j <= g_map_width)\n        {\n            if (map[i][j] != '1' && map[i][j] != '0' && map[i][j] != '2'\n            && map[i][j] != 'N' && map[i][j] != 'W' && map[i][j] != 'E'\n            && map[i][j] != 'S' && map[i][j] != ' ')\n                error_redirect(0);\n            else if (map[i][j] != ' ' && map[i][j] != '1')\n            {\n                if (map[i][j + 1] == ' ' || map[i][j - 1] == ' '\n                || map[i + 1][j] == ' ' || map[i - 1][j] == ' ')\n                    error_redirect(1);\n                if (map[i][j] == 'N' || map[i][j] == 'S' ||\n                map[i][j] == 'E' || map[i][j] == 'W')\n                    player_init(map[i][j], i - 1, j - 1);\n            }\n        }\n        j = 1;\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.7.c", "original_string": "static void openFirmwareUpdateInfoFile(void)\n{\n  char command[260 + 1] = \"\";\n  snprintf(command, sizeof(command), \"code %s\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n  system(command);\n}"}
{"author": "dle2005", "file": "Algorithm__Hamiltonian_v2.2.c", "original_string": "void main() {\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"\\n\");\n    W = (int **)malloc(sizeof(int *) * (n+1));\n    for(int i = 0; i <= n; i++) {\n        W[i] = (int *)malloc(sizeof(int) * (n+1));\n        memset(W[i], 0, sizeof(int) * (n+1));\n    }\n    vindex = (int *)malloc(sizeof(int) * (n+1));\n    vindex[0] = 1;\n    printf(\"W = \\n\");\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++)\n            scanf(\"%d\", &W[i][j]);\n    printf(\"\\n\");\n    hamiltonian(0);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_bpdu.2.c", "original_string": "error_t rstpValidateConfigBpdu(RstpBridgePort *port, const RstpBpdu *bpdu,\n   size_t length)\n{\n   RstpBridgeContext *context;\n   context = port->context;\n   if(length < RSTP_CONFIG_BPDU_SIZE)\n      return ERROR_INVALID_LENGTH;\n   if(ntohs(bpdu->messageAge) >= ntohs(bpdu->maxAge))\n      return ERROR_INVALID_PACKET;\n   if(rstpCompareBridgeAddr(&bpdu->bridgeId.addr, &context->bridgeId.addr) == 0 &&\n      rstpComparePortNum(ntohs(bpdu->portId), port->portId) == 0)\n   {\n      return ERROR_WRONG_IDENTIFIER;\n   }\n   return NO_ERROR;\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__PrimeNumFunc.1.c", "original_string": "int checkPrime(int n)\n{\n    int flag = 0,j;\n    for (j = 2;j <= n/2; j++)\n    {\n        if(n%j == 0)\n        {\n           flag = 1;\n           break;\n        }\n    }\n    return flag;\n}"}
{"author": "dishanp", "file": "DSA__q5.0.c", "original_string": "int main()\n{\n    int *A;\n    int n;\n    int choice;\n    int size = 0;\n    int t;\n    printf(\"1 : Lower Triangular Matrix\\n\");\n    printf(\"2 : Upper Triangular Matrix\\n\");\n    printf(\"Enter Choice : \");\n    scanf(\"%d\", &choice);\n    printf(\"Enter Dimensions : \");\n    scanf(\"%d\", &n);\n    switch(choice)\n    {\n        case 1 :\n        size = n*(n + 1) / 2;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i >= j)\n                    A[i*(i-1)/2 + (j-1)] = t ;\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i >= j)\n                    printf(\"%d \", A[i*(i-1)/2 + (j-1)]);\n                else\n                    printf(\"  \");\n            }\n            printf(\"\\n\");\n        }\n        break;\n        case 2 :\n        size = n * (n + 1) / 2;\n        A = (int*)malloc(size * sizeof(int));\n        printf(\"\\nEnter elements : \\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                scanf(\"%d\", &t);\n                if(i <= j)\n                    A[(n*(i-1) - (i-1)*(i-2)/2) + (j-i)] = t ;\n            }\n        }\n        printf(\"\\n1D array storing the elements : \");\n        for(int i = 0 ; i < size ; i++)\n        {\n            printf(\"%d \", A[i]);\n        }\n        printf(\"\\n\\nDisplaying matrix from stored 1D array values :\\n\");\n        for(int i = 1 ; i <= n ; i++)\n        {\n            for(int j = 1 ; j <= n ; j++)\n            {\n                if(i <= j)\n                    printf(\"%d \", A[(n*(i-1) - (i-1)*(i-2)/2) + (j-i)]);\n                else\n                    printf(\"  \");\n            }\n            printf(\"\\n\");\n        }\n        break;\n    }\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__MatrixOperations.0.c", "original_string": "void main()\n{\n    int i, j = 0;\n    int choice = 0;\n    int contin = 0;\n    int matrix1[R][C];\n    int matrix2[R][C];\n    int matrix3[R][C];\n    printf(\"\\nEnter elements of Matrix1...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &matrix1[i][j]);\n        }\n    }\n    printf(\"\\nEnter elements of Matrix2...\\n\");\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            scanf(\"%d\", &matrix2[i][j]);\n        }\n    }\n    do\n    {\n        printf(\"\\nPress:- \");\n        printf(\"\\n1 for ADDITION\");\n        printf(\"\\n2 for SUBTRACTION\");\n        printf(\"\\n3 for  MULTIPLICATION\");\n        printf(\"\\n4 for EXIT\");\n        printf(\"\\nEnter your choice: \");\n        scanf(\"%d\", &choice);\n        switch(choice)\n        {\n            case 1:\n                add_matrices(matrix1, matrix2);\n                break;\n            case 2:\n                subtract_matrices(matrix1, matrix2);\n                break;\n            case 3:\n                multiply_matrices(matrix1, matrix2);\n                break;\n            case 4:\n                exit(0);\n                break;\n            default:\n                printf(\"\\nEnter a correct choice...\");\n        }\n        printf(\"\\nPress 5 to continue, else press any other number: \");\n        scanf(\"%d\", &contin);\n    }while(contin == 5);\n}"}
{"author": "2security", "file": "Matrix__35SumLowerTriangularMatrix.1.c", "original_string": "int main()\n    {\n    int i,j,r,c,mat1[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    if(r!=c)\n        printf(\"Lower triangualr matrix or not matrix should be square\");\n    else\n        {\n        printf(\"\\n Enter the matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        printf(\"The sum of the lower triangular matrix=%d\",SumLowerTri(mat1,r));    \n        }\n    return 0;\n    }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__21_For.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cos(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X); \n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n        if(i%2 == 0)\n        Suma_total += (Exp(X, i*2) / Fac(i*2));\n    else\n        Suma_total -= (Exp(X, i*2) / Fac(i*2));\n    }\n    printf(\"cos(%i) es igual a %lf\", X, (Suma_total + 1.0));\n    return 0;\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__routing_utils.0.c", "original_string": "int     c_w(char *str, char c)\n{\n    int i;\n    int j;\n    j = 0;\n    i = 0;\n    while (str[i] != '\\0')\n    {\n        while (str[i] == c && str[i] != '\\0')\n        {\n            i++;\n        }\n        if (str[i] != c && str[i] != '\\0')\n            j++;\n        while (str[i] != c && (str[i] != '\\0'))\n            i++;\n    }\n    return (j);\n}"}
{"author": "davibernardos", "file": "DB-Projetos__e9.0.c", "original_string": "int main(int argc, char *argv[]) {\n    float percVitoriasComputador, percVitoriasJogador, percVitoriasJogador1, percVitoriasJogador2;\n    int computador, jogador, jogador1, jogador2, opcao, jogar;\n    int vitComputador, vitJogador, vitJogador1, vitJogador2, empate, partidas;\n    srand(time(NULL));\n    vitComputador = 0;\n    vitJogador = 0;\n    vitJogador1 = 0;\n    vitJogador2 = 0;\n    empate = 0;\n    partidas = 0;\n    printf(\"\\nDigite 1 para jogar contra o computador. \\n\");\n    printf(\"Digite 2 para jogar contra outro jogador. \\n\");\n    scanf(\"%d\", &opcao);\n    while(opcao < 1 || opcao > 2)\n    {\n        printf(\"Opcao invalida. Digite novamente.\");\n        printf(\"\\nDigite 1 para jogar contra o computador. \\n\");\n        printf(\"Digite 2 para jogar contra outro jogador. \\n\");\n        scanf(\"%d\", &opcao);\n    }\n        do{\n            switch(opcao)\n            {\n                case 1:\n                    printf(\"\\nEscolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador);\n                    while(jogador < 1 || jogador > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nEscolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador);\n                    }\n                    computador = rand();\n                    printf(\"\", computador, (1 + computador % 3));\n                    printf(\"\\nComputador escolheu %d\\n\", (1 + computador % 3));\n                    if((1 + computador % 3) == 2 && jogador == 1 || (1 + computador % 3) == 3 && jogador == 2 || (1 + computador % 3) == 1 && jogador == 3)\n                    {\n                        printf(\"Computador ganhou.\\n\");\n                        vitComputador++;\n                    }else\n                    {\n                        if(jogador == (1 + computador % 3))\n                        {\n                            printf(\"Empate.\\n\");\n                            empate++;\n                        }else\n                        {\n                            printf(\"Jogador ganhou.\\n\");\n                            vitJogador++;\n                        }\n                    }\n                    partidas++;\n                    printf(\"\\nJogar novamente?\\n\");\n                    printf(\"1. Sim\\n\");\n                    printf(\"2. Nao\\n\");\n                    scanf(\"%d\", &jogar);\n                    while(jogar < 1 || jogar > 2)\n                    {\n                        printf(\"Opcao invalida. Escolha novamente.\\n\");\n                        printf(\"\\nJogar novamente?\\n\");\n                        printf(\"1. Sim\\n\");\n                        printf(\"2. Nao\\n\");\n                        scanf(\"%d\", &jogar);\n                    }\n                    break;\n                case 2:\n                    printf(\"\\nJogador 1 escolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador1);\n                    while(jogador1 < 1 || jogador1 > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nJogador 1 escolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador1);\n                    }\n                    printf(\"\\nJogador 2 escolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador2);\n                    while(jogador2 < 1 || jogador2 > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nJogador 2 escolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador2);\n                    }\n                    if(jogador1 == 2 && jogador2 == 1 || jogador1 == 3 && jogador2 == 2 || jogador1 == 1 && jogador2 == 3)\n                    {\n                        printf(\"Jogador 1 ganhou.\\n\");\n                        vitJogador1++;\n                    }else\n                    {\n                        if(jogador1 == jogador2)\n                        {\n                            printf(\"Empate.\\n\");\n                            empate++;\n                        }else\n                        {\n                            printf(\"Jogador 2 ganhou.\\n\");\n                            vitJogador2++;\n                        }\n                    }\n                    partidas++;\n                    printf(\"\\nJogar novamente?\\n\");\n                    printf(\"3. Sim\\n\");\n                    printf(\"4. Nao\\n\");\n                    scanf(\"%d\", &jogar);\n                    while(jogar < 3 || jogar > 4)\n                    {\n                        printf(\"Opcao invalida. Escolha novamente.\\n\");\n                        printf(\"\\nJogar novamente?\\n\");\n                        printf(\"3. Sim\\n\");\n                        printf(\"4. Nao\\n\");\n                        scanf(\"%d\", &jogar);\n                    }\n                    break;\n            }\n            if(jogar == 1)\n            {\n            }else\n            {\n                if(jogar == 2)\n                {\n                    printf(\"\\nTotal de %d partida(s).\\n\", partidas);\n                    printf(\"\\nComputador venceu %d partida(s). \\n\", vitComputador);\n                    printf(\"Jogador venceu %d partida(s). \\n\", vitJogador);\n                    printf(\"Total de %d empate(s). \\n\", empate);\n                    percVitoriasComputador = (vitComputador * 100) / partidas;\n                    printf(\"Percentual de vitorias do computador = %.2f%%\\n\", percVitoriasComputador);\n                    percVitoriasJogador = (vitJogador * 100) / partidas;\n                    printf(\"Percentual de vitorias do jogador = %.2f%%\\n\", percVitoriasJogador);\n                    break;          \n                }else\n                {\n                    if(jogar == 3)\n                    {\n                    }else\n                    {\n                        if(jogar == 4)\n                        {\n                            printf(\"\\nTotal de %d partida(s).\\n\", partidas);\n                            printf(\"\\nJogador 1 venceu %d partida(s). \\n\", vitJogador1);\n                            printf(\"Jogador 2 venceu %d partida(s). \\n\", vitJogador2);\n                            printf(\"Total de %d empate(s). \\n\", empate);\n                            percVitoriasJogador1 = (vitJogador1 * 100) / partidas;\n                            printf(\"Percentual de vitorias do jogador 1 = %.2f%\\n\", percVitoriasJogador1);\n                            percVitoriasJogador2 = (vitJogador2 * 100) / partidas;\n                            printf(\"Percentual de vitorias do jogador 2 = %.2f%\\n\", percVitoriasJogador2);\n                            break;\n                        }\n                    }\n                }\n            }       \n        }while(opcao == 1 || opcao == 2);   \n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q23.3.c", "original_string": "void dequeueright(queue *q)\n{\n    if (q->front==q->rear)\n        printf(\"Queue Empty\");\n    else\n        printf(\"\\n%s deleted\", q->c[--(q->rear)] );\n}"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLL.0.c", "original_string": "nptr createNode(int x)\n{\n    nptr temp = (nptr)malloc(sizeof(node));\n    temp -> data = x;\n    temp -> left = temp -> right = NULL;\n    return temp;\n}"}
{"author": "ankitraj311", "file": "450_babbar__6_union_array_SELF_unsorted_array.1.c", "original_string": "void union_array(int arr1[], int arr2[], int size_arr1, int size_arr2)\n{\n  int total_size = size_arr1+size_arr2;\n  int arr3[total_size], j = 0;\n  for(int i = 0; i<size_arr1; i++)\n  {\n    arr3[j] = arr1[i];\n    j++;\n  }\n  for(int i = 0; i<size_arr2; i++)\n  {\n    arr3[j] = arr2[i];\n    j++;\n  }\n  printf(\"Array befor Union :-\");\n  array_print(arr3,total_size);\n  for(int i = 0; i<total_size; i++)\n  {\n    for(int j = i+1; j<total_size;)\n    {\n      if(arr3[i] == arr3[j])\n      {\n        for(int k = j; k<total_size; k++)\n    {\n          arr3[k] = arr3[k+1];\n    }\n    total_size--;\n      }\n      else\n      {\n        j++;\n      }\n    }\n  }\n  printf(\"Array after Union :-\");\n  array_print(arr3,total_size);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__ext1_intr.4.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}"}
{"author": "MFarid94", "file": "Assignment4__Exercise11.0.c", "original_string": "void SwapBits(unsigned int *ptr){\n    unsigned short temp;\n    unsigned short *ptrS = (unsigned short *)ptr;\n    temp = *ptrS;\n    *ptrS = *(ptrS + 1);\n    *(ptrS + 1) = temp;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.13.c", "original_string": "TERM* parseexpressionnullified(PARSER* p) {\n    TERM* head = parsetermnullified(p);\n    TERM* current = head;\n    TERM* nextt;\n    while(isop(p->current)) {\n        current->op = p->current->token[0]; \n        next(p);\n        nextt = parseterm(p);\n        current->next = nextt;\n        current = nextt;\n    }\n    if(current != NULL)\n        current->next = NULL;\n    return head;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad5.4.c", "original_string": "int unosDrugi(pozicija p)\n{\n    FILE* fp = NULL;\n    fp = fopen(\"lista2.txt\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"Neuspjesno otvaranje datoteke!\\n\");\n        return 1;\n    }\n    while (!feof(fp))\n    {\n        pozicija q = NULL;\n        q = (pozicija)malloc(sizeof(struct lista));\n        if (q == NULL)\n        {\n            printf(\"Neuspjesna alokacija memorije!\\n\");\n            return 1;\n        }\n        pozicija pret, temp;\n        temp = p->next;\n        pret = p;\n        fscanf(fp, \"%d\\n\", &q->el);\n        while (temp != NULL)\n        {\n            pret = temp;\n            temp = temp->next;\n        }\n        pret->next = q;\n        if (temp != NULL)\n            q->next = temp;\n        else\n            q->next = NULL;\n    }\n    return 0;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad10.5.c", "original_string": "treePointer Pop(stackPointer head)\n{\n    stackPointer deletedStackElement = head->next;\n    treePointer returnedTree = NULL;\n    head->next = deletedStackElement->next;\n    returnedTree = deletedStackElement->nextTree;\n    free(deletedStackElement);\n    return returnedTree;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__BToperations.3.c", "original_string": "int Equal( Nodeptr root1, Nodeptr root2)\n{\n    return  ((root1 == NULL && root2 == NULL) || (root1 && root2 && root1 -> data == root2 -> data)) \n            && Equal(root1->lchild, root2->lchild) \n            && Equal(root1->rchild, root2->rchild);\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_dma_ex.3.c", "original_string": "static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)\n{  \n  hdma->Instance->NDTR = DataLength;\n  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)\n  {   \n    hdma->Instance->PAR = DstAddress;\n    hdma->Instance->M0AR = SrcAddress;\n  }\n  else\n  {\n    hdma->Instance->PAR = SrcAddress;\n    hdma->Instance->M0AR = DstAddress;\n  }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_pos_DCLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->pre=0;\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n            newnode->next=newnode;\n            newnode->pre=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            newnode->next=head;\n            temp=newnode;\n            head->pre=temp;\n        }\n    printf(\"do you need to continue(0,1)?\\nenter 0 to stop and 1 to continue =\");\n    scanf(\"%d\",&choice);\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_after_pos_DLL.3.c", "original_string": "int count()\n{\n    struct node *temp;\n    temp=head;\n    int c=0;\n    while(temp!=0)\n    {\n        c++;\n        temp=temp->next;\n    }\n    printf(\"the number of elements in the linked list is %d \\n\",c);\n    return c;\n}"}
{"author": "2security", "file": "Star__HeartStarWithName.0.c", "original_string": "int main()\n    {\n        int i,j,k=0,n,m;\n        char name[20];\n        printf(\"Enter Name\");\n        gets(name);\n        printf(\"Enter value of n\");\n        scanf(\"%d\",&n);\n        m=strlen(name);\n        for(i=n/2;i<n;i=i+2)\n            {\n                for(j=1;j<n-i;j=j+2)\n                    printf(\" \");\n                for(j=1;j<=i;j++)\n                    printf(\"*\");\n                for(j=1;j<=i-4*k;j++)\n                    printf(\" \");\n                for(j=1;j<=i;j++)\n                    printf(\"*\");\n            k++;\n                printf(\"\\n\");\n            }\n        for(i=n;i>=1;i--)\n            {\n                for(j=1;j<=n-i;j++)\n                    printf(\" \"); \n                if(i==n)\n                    {\n                    for(j=1;j<=(n*2-m)/2;j++)   \n                        printf(\"*\");\n                    printf(\"%s\",name);\n                    for(j=1;j<(n*2-m)/2;j++)    \n                        printf(\"*\");\n                    }\n                else\n                    {\n                    for(j=1;j<=2*i-1;j++)\n                        printf(\"*\");    \n                    }\n                printf(\"\\n\");\n            }\n        printf(\"\\n\");\n        return 0;\n    }"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListDelete.4.c", "original_string": "struct Node * deleteByGivenKey(struct Node * head, int value){\n     struct Node *p = head;\n     struct Node *q = head->next;\n     while ( q->data != value && q->next != NULL)\n     {\n          p = p->next;\n          q = q->next;\n     }\n     if (q->data == value)\n     {\n          p->next = q->next;\n          free(q);\n     }\n     return head;\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__sum0.0.c", "original_string": "int main()\n{\n     int    ShmID,p[2];\n     pipe(p);\n     float    *ShmPTR; \n     pid_t  pid; \n     int    status;\n     int a[10],i;\n     printf(\"enter the 10 array elements\\n\");\n     for(i=0;i<10;i++)\n     {\n         scanf(\"%d\",&a[i]);\n     }\n     ShmID = shmget(IPC_PRIVATE, 10*sizeof(int), IPC_CREAT | 0666); \n     if (ShmID < 0) {\n          printf(\"*** shmget error (server) ***\\n\");\n          exit(1);\n     }\n     printf(\"Server has received a shared memory of 10 integers...\\n\");\n     ShmPTR = (float *) shmat(ShmID, NULL, 0);\n     printf(\"Server has attached the shared memory...\\n\");\n     for(i=0;i<10;i++)\n     {\n         ShmPTR[i]=a[i];\n     }\n     pid=fork();\n     if (pid == 0) {\n        float sum;\n        sum=ClientProcess(ShmPTR);\n        close(p[0]);\n        write(p[1],&sum,sizeof(sum));\n        close(p[1]);\n          exit(0);\n     }\n     else{\n         wait(&status);\n         float sum,avg;\n         close(p[1]);\n         read(p[0],&sum,sizeof(sum));\n         avg=sum/10;\n        printf(\"the average is %f\\n\",avg);\n        shmdt((void *) ShmPTR); \n        shmctl(ShmID, IPC_RMID, NULL);\n     }\n     return 0;\n}"}
{"author": "2security", "file": "Star__Rhombus.0.c", "original_string": "int main()\n    {\n    int n,i,j;\n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<=2*n-1;j++)   \n            {\n            if(i+j>=n+1&&i+j<2*n+1)\n                {\n                printf(\"*\");\n                }\n            else \n                printf(\" \");\n            }   \n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__K.0.c", "original_string": "int main()\n{\n    int qtd, n, qtd_total = 0;\n    scanf (\"%i\", &qtd);\n    for (int i=0; i<qtd; i++)\n    {\n        scanf (\"%i\", &n);\n        while (n>=100)\n        {\n            n -= 100;\n            qtd_total++;\n        }\n        if ((50<=n)&&(n<=99))\n        {\n            n -= 50;\n            qtd_total++;\n        } \n        if ((25<=n)&&(n<=49))\n        {\n            n -= 25;\n            qtd_total++;\n        }\n        while ((10<=n)&&(n<=24))\n        {\n            n -= 10;\n            qtd_total++;\n        }\n        if ((5<=n)&&(n<=9))\n        {\n            n -= 5;\n            qtd_total++;\n        }\n        while ((2<=n)&&(n<=4))\n        {\n            n -= 2;\n            qtd_total++;\n        }\n        if (n==1)\n        {\n            n--;\n            qtd_total++;\n        }\n        printf (\"%i notas\\n\", qtd_total);\n        qtd_total = 0;\n    }\n    return 0;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sort_Array_Ascending.0.c", "original_string": "void main()\n{\n    int i = 0;\n    int size = 0;\n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n    printf(\"\\nArray after Sorting is as follows:- \\n\");\n    sorting(input_array, size);\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-central-scanner-with-whitelist__nrf_fstorage.4.c", "original_string": "ret_code_t nrf_fstorage_erase(nrf_fstorage_t const * p_fs,\n                              uint32_t               page_addr,\n                              uint32_t               len,\n                              void                 * p_context)\n{\n    NRF_FSTORAGE_PARAM_CHECK(p_fs,        NRF_ERROR_NULL);\n    NRF_FSTORAGE_PARAM_CHECK(p_fs->p_api, NRF_ERROR_INVALID_STATE);\n    NRF_FSTORAGE_PARAM_CHECK(len,         NRF_ERROR_INVALID_LENGTH);\n    NRF_FSTORAGE_PARAM_CHECK(addr_is_page_aligned(p_fs, page_addr), NRF_ERROR_INVALID_ADDR);\n    NRF_FSTORAGE_PARAM_CHECK(\n        addr_is_within_bounds(p_fs, page_addr, (len * p_fs->p_flash_info->erase_unit)),\n        NRF_ERROR_INVALID_ADDR\n    );\n    return (p_fs->p_api)->erase(p_fs, page_addr, len, p_context);\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.22.c", "original_string": "void addparameter(SCOPE* s, PARAMETER* p, int* i) {\n    addvar(s, &(s->parameters), mkvar(p->type, p->name, p->primitive, p->debug, arg, *i));\n    (*i)++;\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__sum1.2.c", "original_string": "void* product_of_elements(void* a[SIZE])\n{\n    float product=1;\n    int* ar=(int*) a;\n    for(i=0;i<SIZE;i++)\n    {\n         product =ar[i] * product;\n    }\n    printf(\"product=%f\\n\",product);\n}"}
{"author": "MFarid94", "file": "Assignment4__Exercise3.1.c", "original_string": "int main(void){\n    setvbuf(stdout, NULL ,_IONBF , 0);\n    setvbuf(stderr, NULL ,_IONBF , 0);\n    int arr[SIZE];\n    int i;\n    int *ptr = arr;\n    printf(\"Enter array elements: \");\n    for(i=0 ; i<SIZE ;i++){\n        scanf(\"%d\",ptr);\n        ptr++;\n    }\n    for(i=0 ; i<SIZE ;i++){\n        printf(\"Array element before re-arranging: arr[%d] = %d\\n\",i,arr[i]);\n    }\n    ReverseArray(arr);\n    ptr = arr;           \n    for(i=0 ; i<SIZE ;i++){\n        printf(\"Array element after re-arranging: arr[%d] = %d\\n\",i,*ptr);\n        ptr++;\n    }\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-expressions.9.c", "original_string": "TERM* parsecalltermnullified(PARSER* p) {\n    SUBROUTCALL* call = parsesubroutcallnullified(p);\n    if(call == NULL)\n        return NULL;\n    TERM* t = mkterm(subroutcall);\n    t->call = call;\n    return t;\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__sender0.4.c", "original_string": "int main(){\n    unsigned int length;\n    welcome();\n    length = frame_construction(sta_addr,des_addr,protocol,data,sizeof(data));\n    printf(\"Frame length: %d\\n\",length);\n    frame[length-10] = ~frame[length-10];\n    send_frame(frame,length);\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__tokenizer.17.c", "original_string": "TOKEN* tokenize(char* file) {\n    TOKEN* head = mktoken();\n    TOKEN* lastitem = head;\n    TOKEN* curitem = head;\n    STRING* tmptoken = mkstring(200);\n    CHARTYPE lasttype = space;\n    CHARTYPE curtype;\n    int lnscount = 1;\n    FILE* input = fopen(file, \"r\");\n    unsigned char c;\n    while(!feof(input)) {\n        c = fgetc(input);\n        if(c == '\\n')\n            lnscount++;\n        else if(c == '/' && handlecomment(input, &lnscount)) \n            continue;\n        else if(c == '\"') {\n            if(lasttype != space)\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            readstr(input, tmptoken, lnscount);\n            lastitem = curitem;\n            curitem = appendtokenraw(curitem, tmptoken, lnscount, string);\n            lasttype = space;\n            continue;\n        }\n        curtype = getchartype(c);\n        if(curtype == common) {\n            if(lasttype == charsymbol) {\n                lastitem = curitem;\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            }\n            append(tmptoken, c);\n        } else {\n            if(lasttype != space){\n                lastitem = curitem;\n                curitem = appendtoken(curitem, tmptoken, file, lnscount);\n            }\n            if(curtype == charsymbol)\n                append(tmptoken, c);\n        }\n        lasttype = curtype;\n    }\n    if(curitem == head) {\n        eprintf(\"File '%s' is empty\\n\", file);\n        exit(1);\n    }\n    lastitem->next = NULL;\n    free(curitem);\n    freestr(tmptoken);\n    fclose(input);\n    return head;\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__receiver.2.c", "original_string": "int output_octal(unsigned char *x,unsigned int len) {\n    int i;\n    for (i =0;i<len;i++) {\n        printf(\"%02x\",x[i]);\n        if (i != len-1) printf(\" \");\n        if(i %9 == 0 && i!=0) printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_in_SLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    while(temp!=0)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "zjzj-zz", "file": "4s_Numerical__Gauss2.0.c", "original_string": "int main(){\n    double a[N][N] = { { 4.0, 2.0 }, { 4.0, 5.0 } };\n    double b[N] = { 2.0, -7.0 };\n    double x[N], y[N];\n    int i, j, k;\n    for( i = 0; i < N; i++ ) x[i]=1.0;\n    for( i = 0; i < 30; i++ ){\n        for( j = 0; j < N; j++ ){\n            for( k = 0; k < N; k++ ) y[k] = x[k];\n            x[j] = ( (a[j][j] * y[j]) + b[j] );\n            for( k = 0; k < N; k++ ){\n                x[j] -= ( a[j][k] * y[k] );\n            }\n            x[j] /= a[j][j];\n        }\n        printf(\"[i=%2d]\", i+1 );\n        for( j = 0; j < N; j++ ){\n            printf(\" x%d = %.10f \", j+1, x[j]);\n        } \n        printf(\"\\n\");\n    }\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__UARTDrv.1.c", "original_string": "void uart_recvTask(void)\n{\n  size_t rxDataLen = 0;\n  if (uart_get_buffered_data_len(uartUnit, &rxDataLen) != ESP_OK) \n  {\n    return;\n  }\n  if (rxDataLen == 0) \n  {\n    return;\n  }\n  uint8_t *data = ((uint8_t *)(malloc(rxDataLen)));\n  uart_read_bytes(uartUnit, data, ((uint32_t)(rxDataLen)), 100 / portTICK_RATE_MS);\n  for ( int64_t __i = 0 ; __i < rxDataLen; __i++ )\n  {\n    firmwareUpdateInfoReader_onCharacterReceived(*(data + __i));\n  }\n  if (data != NULL) \n  {\n    free(data);\n  }\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.16.c", "original_string": "void striplabels(ASSEMBLER* a) {\n    STRINGLIST* curln = a->lns;\n    STRINGLIST* lastln;\n    int count = 0;\n    while(curln != NULL) {\n        if(curln->content[0] == '(') {\n            handlelabelsymbol(a, curln, count);\n            if(count > 0)\n                lastln->next = curln->next;\n            else\n                a->lns = curln->next;\n            STRINGLIST* tmp = curln;\n            curln = curln->next;\n            free(tmp);\n        }\n        else {\n            lastln = curln;\n            curln = curln->next;\n            count++;\n        }\n    }\n}"}
{"author": "SugumaranEvil", "file": "Linux_programming__open_read_write.0.c", "original_string": "int main()\n{\n    int file_des,i;\n    char arr[13]=\"hi i am arr1\\n\";\n    char arr1[13]=\"hi i am arr1\\n\";\n    char arr2[13]=\"hi i am arr2\\n\";\n    char rd_fd[100];\n    char sarr[100];\n    file_des = open(\"/home/sugu/Linux_Programming/file.txt\",O_CREAT | O_RDWR,0655);\n    perror(\"open\");\n    ssize_t wt,rd;\n    i=lseek(file_des,0,SEEK_SET); \n    perror(\"lseek\");              \n    printf(\"lseek%d\\n\",i);        \n    wt = write(file_des,arr,13);  \n    perror(\"write\");              \n    printf(\"write%d\\n\",wt);       \n    rd = read(file_des,rd_fd,13); \n    perror(\"read\");               \n    printf(\"Read%d\\n\",rd);        \n    snprintf(sarr,13,\"%s\\n\",rd_fd);\n    printf(\"%s\\n\",sarr);           \n    i=lseek(file_des,0,SEEK_CUR);  \n    perror(\"lseek\");               \n    printf(\"lseek%d\\n\",i);         \n    wt = write(file_des,arr1,13);  \n    perror(\"write\");               \n    printf(\"write%d\\n\",wt);        \n    rd = read(file_des,rd_fd,13);  \n    perror(\"read\");                \n    printf(\"read%d\\n\",rd);         \n    snprintf(sarr,13,\"%s\\n\",rd_fd);\n    printf(\"%s\\n\",sarr);           \n    i=lseek(file_des,-15,SEEK_END);\n    perror(\"lseek\");               \n    printf(\"lseek%d\\n\",i);         \n    wt = write(file_des,arr2,13);  \n    perror(\"write\");               \n    printf(\"write%d\\n\",wt);        \n    rd = read(file_des,rd_fd,13);  \n    perror(\"read\");                \n    printf(\"Read%d\\n\",rd);         \n    snprintf(sarr,13,\"%s\\n\",rd_fd);\n    printf(\"%s\\n\",sarr);           \n    close(file_des);               \n    perror(\"close\");\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_8.4.c", "original_string": "void traverse_postorder(struct node* root)\n{\n    if(root != NULL)\n    {\n        traverse_postorder(root->left);\n        traverse_postorder(root->right);\n        printf(\"%d\\t\", root->data);\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader.4.c", "original_string": "static void openFirmwareUpdateInfoFileInVSCode(void)\n{\n  char vsCodePath[260 + 1] = \"\";\n  char *os = getenv(\"OS\");\n  if (os != NULL && strcmp(os, \"Windows_NT\") == 0) \n  {\n    snprintf(vsCodePath, sizeof(vsCodePath), \"C:\\\\Users\\\\%s\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\bin\\\\code\", getenv(\"USERNAME\"));\n  }\n  else\n  {\n    snprintf(vsCodePath, sizeof(vsCodePath), \"/usr/bin/code\");\n  }\n  if (access(vsCodePath, F_OK) != -1) \n  {\n    char openCommand[260 + 1] = \"\";\n    snprintf(openCommand, sizeof(openCommand), \"code %s\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n    system(openCommand);\n  }\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__receiver3.3.c", "original_string": "int receive_frame(){\n    FILE *file = fopen(\"pipe.bin\", \"r\");\n    fread(&frame_len,sizeof(frame_len),1,file);\n    printf(\"[INFO] frame length: %d\\n\",frame_len);\n    if(frame_len < 64){  \n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(frame_len >1518){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    fread(&frame,sizeof(char),frame_len,file);\n    memcpy(&des_addr,&frame[0],6);\n    memcpy(&sta_addr,&frame[6],6);\n    memcpy(&protocol,&frame[12],sizeof(protocol));\n    payload = &frame[14];    \n    if(!addr_check(des_addr))   exit(1);\n    init_crc_table();\n    unsigned int crc32_temp = crc32(frame,frame_len-4);\n    unsigned char crc32_result[4];\n    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));\n    int i = 0;\n    int flag_crc32 = 1;\n    for(i = 3;i<sizeof(crc32_result);i--){\n        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;\n    }\n    if(flag_crc32){\n        printf(\"[INFO] CRC32 check success!\\n\");\n    }else {\n        printf(\"[Error] CRC32 check error!\\n\");\n        printf(\"[Error] frame's CRC32 : \");\n        printf(\"%02x %02x %02x %02x\\n\",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);\n        printf(\"[Error] calculated CRC32 : \");\n        output_octal(crc32_result,4);\n        exit(1);\n    }\n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: \");\n    output_octal(sta_addr,6);\n    printf(\"Des address  : \");\n    output_octal(des_addr,6);\n    printf(\"protocol     : %d\\n\",protocol);\n    printf(\"payload      : \");\n    output_octal(payload,frame_len-6-6-2-4);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result,4);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] Frame received success!\\n\");\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__100.0.c", "original_string": "int main()\n{\n    float v0, alfa, g = 10, x, y, t_queda, x_max;\n    int t;\n    printf(\"\\nInforme a velocidade inicial em m/s: \");\n    scanf(\"%f\", &v0);\n    printf(\"\\nInforme o \u00e2ngulo do lan\u00e7amentos em graus: \");\n    scanf(\"%f\", &alfa);\n    alfa = alfa * 3.14 / 180;\n    t_queda = (2 * v0 * sin(alfa)) / g;\n    x_max = (pow(v0, 2) * sin(alfa * 2)) / g;\n    printf(\"\\n\");\n    for (t = 0; t <= fabs(t_queda); t++)\n    {\n        x = v0 * cos(alfa) * t;\n        y = v0 * sin(alfa) * t - 0.5 * g * pow(t, 2);\n        printf(\"t = %is: Altura = %.2fm, Alcance = %.2fm\\n\", t, y, x);\n        sleep(1);\n    }\n    printf(\"t = %is: Altura = 0.00m, Alcance = %.2fm\\n\\n\", t++, x_max);\n}"}
{"author": "augustogunsch", "file": "jackc__parser-structure.1.c", "original_string": "char* parsetype(PARSER* p) {\n    if(p->current->type != identifier && p->current->type != keyword)\n        unexpected(p);\n    char* result = p->current->token;\n    next(p);\n    return result;\n}"}
{"author": "RafaelFelisbino-hub", "file": "MATRIZ-exercices__Exercicio6MATRIZ.0.c", "original_string": "int main() \n{\n    int matrizA[5][3], matrizB[5][3], matrizC[5][3], i, j;\n    for(i = 0; i < 5; i++)\n        for (j = 0; j < 3; j++) \n        {\n            printf(\"Digite os valores da primeira matriz: %d linha, %d coluna:  \", i, j);\n            scanf_s(\"%i\", &matrizA[i][j]);\n        }\n    for (i = 0; i < 5; i++)\n        for (j = 0; j < 3; j++)\n        {\n            printf(\"Digite os valores da segunda matriz: %d linha, %d coluna:  \", i, j);\n            scanf_s(\"%i\", &matrizB[i][j]);\n        }\n    for (i = 0; i < 5; i++)\n        for (j = 0; j < 3; j++) \n        {\n            matrizC[i][j] = matrizA[i][j] + matrizB[i][j];\n            printf(\"A soma dos elementos e:  %i\\n\", matrizC[i][j]);\n        }\n    system(\"pause\");\n}"}
{"author": "dle2005", "file": "Algorithm__Knapsack.2.c", "original_string": "void main() {\n    printf(\"n = \");\n    scanf(\"%d\", &n);\n    printf(\"W = \");\n    scanf(\"%d\", &W);\n    w = (int *)malloc(sizeof(int) * n + 1);\n    p = (int *)malloc(sizeof(int) * n + 1);\n    bestset = (int *)malloc(sizeof(int) * n + 1);\n    include = (int *)malloc(sizeof(int) * n + 1);\n    printf(\"w[1...n] = \");\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", &w[i]);\n    printf(\"p[1...n] = \");\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", &p[i]);\n    printf(\"\\n\");\n    knapsack(0, 0, 0);\n    printf(\"bestset[1..n] = \");\n    for(int i = 1; i <= numbest; i++)\n        printf(\"%d \", bestset[i]);\n    printf(\"\\n\");\n    free(w);\n    free(p);\n    free(bestset);\n    free(include);\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_print_combn.10.c", "original_string": "void comb9(int *numeros,int a,int b,int c, int d,int e,int f,int g,int h,int i)\n{\n  while(a<=1)\n       {\n        while(b<=2)\n            {\n              while(c<=3)\n                  {\n                    while(d<=4)\n                        {\n                            while(e<=5)\n                                {\n                                    while(f<=6)\n                                        {\n                                          while(g<=7)\n                                              {\n                                                while(h<=8)\n                                                     {\n                                                      while(i<=9)\n                                                          {\n                                                            printf(\"%i%i%i%i%i%i%i%i%i, \",numeros[a],numeros[b],numeros[c],numeros[d],numeros[e],numeros[f],numeros[g],numeros[h],numeros[i]);\n                                                            i=i+1;\n                                                          }\n                                                      h=h+1;\n                                                      i=h+1;\n                                                     }\n                                                g=g+1;\n                                                h=g+1;\n                                                i=h+1;\n                                              }\n                                          f=f+1;\n                                          g=f+1;\n                                          h=g+1;\n                                          i=h+1;\n                                        } \n                                    e=e+1;\n                                    f=e+1;\n                                    g=f+1;\n                                    h=g+1;\n                                    i=h+1;\n                                }\n                            d=d+1;\n                            e=d+1;\n                            f=e+1;\n                            g=f+1;\n                            h=g+1;\n                            i=h+1;\n                        }\n                    c=c+1;\n                    d=c+1;\n                    e=d+1;\n                    f=e+1;\n                    g=f+1;\n                    h=g+1;\n                    i=h+1;\n                  }\n              b=b+1;\n              c=b+1;\n              d=c+1;\n              e=d+1;\n              f=e+1;\n              g=f+1;\n              h=g+1;\n              i=h+1;\n            }\n        a=a+1;\n        b=a+1;\n        c=b+1;\n        d=c+1;\n        e=d+1;\n        f=e+1;\n        g=f+1;\n        h=g+1;\n        i=h+1;\n       }\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.12.c", "original_string": "void replacevar(ASSEMBLER* a, STRINGLIST* ln, int val) {\n    int size = sizeof(char)*(countplaces(val) + 2);\n    char* newln = (char *)malloc(size);\n    snprintf(newln, size, \"@%i\", val);\n    ln->content = newln;\n    strtogarbage(a, newln);\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__44.0.c", "original_string": "int main()\n{\n    int matriz[4][4];\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            scanf(\"%i\", &matriz[i][j]);\n        }\n    }\n    printf(\"\\n\");\n    for (int i = 0; i < 4; i++)\n    {\n        for (int j = 0; j < 4; j++)\n        {\n            if (j > i)\n            {\n                printf(\" 0 \");\n            }\n            else\n            {\n                printf(\"%2i \", matriz[i][j]);\n            }\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__list-push-pop-del-rec_rev-count.0.c", "original_string": "node* createNode(node* head, int n)\n{\n    node* newnode=malloc(sizeof(node));\n    newnode->data=n;\n    newnode->next=head;\n    return newnode;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_SLL.5.c", "original_string": "void insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    newnode->next=0;\n    temp=head;\n    while(temp->next!=0)\n    {\n        temp=temp->next;\n    }\n    temp->next=newnode;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-tree.5.c", "original_string": "void freeexpression(TERM* e) {\n    if(e->type == arrayitem)\n        freearray(e->array);\n    else if(e->type == innerexpression || e->type == unaryopterm)\n        freeexpression(e->expression);\n    else if(e->type == subroutcall)\n        freesubroutcall(e->call);\n    TERM* next = e->next;\n    free(e);\n    if(next != NULL)\n        freeexpression(next);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__binarySearchTree.2.c", "original_string": "struct Node*insert(struct Node*root, int value){\n     if(root==NULL){\n          root = create(value);\n     }\n     else if(value<root->data){\n          root->left = insert(root->left, value);\n     }\n     else if (value > root->data){\n          root->right = insert(root->right, value);\n     }\n     else{\n          printf(\"\\nValue: %d you enterd is already exist\\n\", value);\n     }\n     return root;\n}"}
{"author": "jose120918", "file": "sorting_algorithms__101-cocktail_sort_list.1.c", "original_string": "int swp_bck(listint_t *current, listint_t **list)\n{\n    listint_t *moving = NULL;\n    moving = current->prev;\n    moving->next = current->next;\n    current->next->prev = moving;\n    current->prev = moving->prev;\n    current->next = moving;\n    moving->prev = current;\n    if (current->prev)\n        current->prev->next = current;\n    else\n        *list = current;\n    print_list(*list);\n    return (1);\n}"}
{"author": "dishanp", "file": "DSA__q110.2.c", "original_string": "int main()\n{\n    int *arr;\n    int n;\n    printf(\"Enter number of elements : \");\n    scanf(\"%d\", &n);\n    arr = (int*)malloc(n*sizeof(int));\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"Enter element no %d :\", i+1);\n        scanf(\"%d\", arr + i);\n    }\n    printf(\"Original array : \\n\");\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    rearrange(arr, n);\n    printf(\"\\nRearranged array : \\n\");\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n}"}
{"author": "earth429", "file": "mulpre__mulprec1.7.c", "original_string": "int mulBy10(struct NUMBER *a, struct NUMBER *b){\n    int i;\n    clearByZero(b);\n    b->sign = a->sign; \n    if(a->n[KETA - 1] != 0){\n        return -1;\n    }\n    for (i = KETA - 2; i >= 0;i--){\n        b->n[i + 1] = a->n[i];\n    }\n    b->n[0] = 0;\n    return 0;\n}"}
{"author": "sdukesameer", "file": "c__min_largest.0.c", "original_string": "int max(int* arr, int n){\n    int m=0;\n    for (int i = 0; i < n; i++){\n        if(arr[i]>m)\n            m=arr[i];\n    }\n    return m;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__led_all.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | (0xFF << 17);   \n    while(1)\n    {\n        for(int i=17;i<=24;++i)\n        {\n            IOSET1 = (1<<i);\n            delay(100);\n            IOCLR1 = (1<<i);\n            delay(100);\n        }\n        for(int i=24;i>=17;--i)\n        {\n            IOSET1 = (1<<i);\n            delay(100);\n            IOCLR1 = (1<<i);\n            delay(100);\n        }\n    }\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Sum_Rows_Columns_Matrix.2.c", "original_string": "void find_Sum_Of_Columns(int matrix[R][C])\n{\n    int i, j, col_sum = 0;\n    int rows = R;\n    int columns = C;\n    int temp = 0;\n    int output_matrix[R][C];\n    temp = rows;\n    rows = columns;\n    columns = temp;\n    for(i=0; i<rows; i++)\n    {\n        for(j=0; j<columns; j++)\n        {   \n            output_matrix[i][j] = matrix[j][i];\n        }\n    }\n    for(i=0; i<rows; i++)\n    {\n        col_sum = 0;\n        for(j=0; j<columns; j++)\n        {\n            col_sum += output_matrix[i][j];\n        }\n        printf(\"\\nSum of Column %d: %d\\n\", i, col_sum);\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.0.c", "original_string": "static bool isWhitespace(char *str)\n{\n  size_t idx = 0;\n  char currentChr = str[idx++];\n  while (currentChr != '\\0')\n  {\n    if (isspace(currentChr) == 0) \n    {\n      return false;\n    }\n    currentChr = str[idx++];\n  }\n  return true;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__util.8.c", "original_string": "void printstrlist(STRINGLIST* strlist, FILE* stream) {\n    while(strlist != NULL) {\n        fprintf(stream, \"%s\\n\", strlist->content);\n        strlist = strlist->next;\n    }\n}"}
{"author": "augustogunsch", "file": "jack-compiler__io.5.c", "original_string": "bool isdotjack(char* f, int len) {\n    const char* ext = \".jack\";\n    return strcmp(strtail(f, len, strlen(ext)), ext) == 0;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post-a.5.c", "original_string": "void postorder(list *root)\n{\n    if (root != NULL)\n    {\n        postorder(root->left);\n        postorder(root->right);\n        printf(\"%d \\n\", root->key); \n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_directory.0.c", "original_string": "error_t acmeClientSendDirectoryRequest(AcmeClientContext *context)\n{\n   error_t error;\n   error = NO_ERROR;\n   while(!error)\n   {\n      if(context->requestState == ACME_REQ_STATE_INIT)\n      {\n         TRACE_DEBUG(\"\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"## GET DIRECTORY ##############################################################\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"\\r\\n\");\n         if(context->directory.newNonce[0] != '\\0' &&\n            context->directory.newAccount[0] != '\\0' &&\n            context->directory.newOrder[0] != '\\0' &&\n            context->directory.revokeCert[0] != '\\0' &&\n            context->directory.keyChange[0] != '\\0')\n         {\n            break;\n         }\n         else\n         {\n            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)\n      {\n         error = acmeClientFormatRequestHeader(context, \"GET\",\n            context->directoryUri);\n         if(!error)\n         {\n            context->requestState = ACME_REQ_STATE_SEND_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||\n         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||\n         context->requestState == ACME_REQ_STATE_CLOSE_BODY)\n      {\n         error = acmeClientSendRequest(context);\n      }\n      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)\n      {\n         error = acmeClientParseDirectoryResponse(context);\n         context->requestState = ACME_REQ_STATE_INIT;\n         break;\n      }\n      else\n      {\n         error = ERROR_WRONG_STATE;\n      }\n   }\n   return error;\n}"}
{"author": "sdukesameer", "file": "c__rec_quick_sort.4.c", "original_string": "int main()\n{\n    scanf(\"%d\",&n);\n    if(n<1||n>50)\n    {\n        printf(\"ERROR\");\n        exit(1);\n    }\n    int arr[n];\n    for (int i = 0; i < n; i++)\n        scanf(\"%d\",&arr[i]);\n    printf(\"Original: \");\n    printArray(arr);\n    printf(\"%d: \",c++);\n    printArray(arr);\n    quickSort(arr, 0, n-1);\n    printf(\"Sorted: \");\n    printArray(arr);\n    return 0;\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__receiver.1.c", "original_string": "int addr_check(unsigned char des_addr[6]){\n    int flag = 1;\n    int i =0;\n    for(i = 0;i<6;i++){\n        if(des_addr[i] != my_addr[i]) flag = 0;\n    }\n    if(flag){\n        printf(\"[INFO] Address check success!\\n\");\n    }else {\n        printf(\"[Error] Address check error!\\n\");\n    }\n    return flag;\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__19.0.c", "original_string": "void main()\n{\n    int a[90][90],r,c,i,j;\n    printf(\"enter no. of rows and columns\");\n    scanf(\"%d%d\",&r,&c);\n    printf(\"enter array elements\");\n    for(i=0;i<r;i++)\n    {\n        for(j=0;j<c;j++)\n        {\n            scanf(\"%d\",&a[i][j]);\n        }\n    }\n    sumofrows(a,r,c);\n    sumofcolumns(a,r,c);\n}"}
{"author": "2security", "file": "File__5CompareTwoFile.1.c", "original_string": "int main()\n    {\n        FILE *fptr1,*fptr2;\n        char str[100];\n        int n,line,col;\n        fptr1=fopen(\"File51.txt\",\"r\");\n        fptr2=fopen(\"File52.txt\",\"r\");\n        if(fptr1==NULL||fptr2==NULL)\n            {\n                perror(\"File openning error (: \");\n                getch();\n                exit(0);\n            }           \n        if(CompareFile(fptr1,fptr2))\n            printf(\"\\n Two file is same\");\n        else\n            printf(\"\\n Two file is not same error:%d pos:%d line:%d\",error,pos,line);\n        fclose(fptr1);\n        fclose(fptr2);\n        return 0;\n    }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es10.1.c", "original_string": "int potenza(int base, int esponente){\n  int risultato = 1;\n  for(int i = 0; i < esponente; i++){\n    risultato = risultato * base;\n  }\n    return (risultato);\n}"}
{"author": "bgmanuel99", "file": "PracticasArquitecturaDeComputadores__ejercicio30.0.c", "original_string": "int main(int argc, char *argv[]) {\n    int rank, \n    size; \n    MPI_Init(&argc, &argv); \n    MPI_Comm_size(MPI_COMM_WORLD, &size); \n    MPI_Comm_rank(MPI_COMM_WORLD, &rank); \n    int localData[2];\n    int resultSum[2];\n    int resultProd[2];\n    for(int i = 0; i < 2; i++){\n        localData[i] = rank+1;\n    }\n    MPI_Reduce(localData, resultSum, 2, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);\n    MPI_Reduce(localData, resultProd, 2, MPI_INT, MPI_PROD, 0, MPI_COMM_WORLD);\n    MPI_Barrier(MPI_COMM_WORLD);\n    if(rank == 0){\n        printf(\"El resultado de la suma de los arrays es: %d, %d.\\n\", resultSum[0], resultSum[1]);\n        printf(\"El resultado del producto de los arrays es: %d, %d.\\n\", resultProd[0], resultProd[1]);\n    }\n    MPI_Finalize();\n    return 0;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e5.0.c", "original_string": "int main(int argc, char *argv[]) {\n    int modoJogo;\n    int jogarNovamente;\n    int jogador1;\n    int jogador2;\n    int ia;\n    int empates;\n    int vitoriasP1;\n    float porcentvitP1;\n    int vitoriasP2;\n    float porcentvitP2;\n    int vitoriasIA;\n    float porcentvitIA;\n    int contador;\n    printf(\"-^^- JOKENPO GAME by TS -^^- \\n \\n \\n\");\n    printf(\"Digite o numero de uma das opcoes abaixo:\\n 1 - Jogar Player Vs Player \\n 2- Jogar Player Vs IA\\n 3- Sair\\n\");\n    scanf(\"%d\", &modoJogo);\n    while(modoJogo != 1 && modoJogo !=2 && modoJogo !=3 ) {\n        printf(\"Opcao Invalida, digite uma opcao valida:\\n 1 - Jogar Player Vs Player \\n 2- Jogar Player Vs IA\\n 3- Sair\\n\");\n        scanf(\"%d\", &modoJogo);\n    }\n    switch (modoJogo) {\n        case 1:\n        printf(\" -^^- MODO PLAYER VS PLAYER -^^- \\n \\n \\n\");\n        jogarNovamente=1;\n        vitoriasP1=0;\n        vitoriasP2=0;\n        contador=0;\n        do {\n            printf(\"Player 1 -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador1);\n            while(jogador1 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador1);\n            }\n            printf(\"Player 2 -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador2);\n            while(jogador2 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador2);\n            }\n            if((jogador1 == 1 && jogador2 == 1) || (jogador1 == 2 && jogador2 == 2)|| (jogador1==3 && jogador2==3)) {\n                printf(\"EMPATOU! \\n\");\n                empates++;\n                contador++;\n            } else {\n                if(jogador1 == 1 && jogador2 == 2) {\n                    printf(\"PEDRA E PAPEL = VITORIA JOGADOR 2! \\n\");\n                    vitoriasP2++;\n                    contador++;\n                } else {\n                    if(jogador1==1 && jogador2 == 3) {\n                        printf(\"PEDRA E TESOURA = VITORIA JOGADOR 1! \\n\");\n                        vitoriasP1++;\n                        contador++;\n                    } else {\n                        if(jogador1==2 && jogador2==1) {\n                            printf(\"PAPEL E PEDRA = VITORIA JOGADOR 1! \\n\");\n                            vitoriasP1++;\n                            contador++;\n                        } else {\n                            if(jogador1==2 && jogador2==3) {\n                                printf(\"PAPEL E TESOURA = VITORIA JOGADOR 2! \\n\");\n                                vitoriasP2++;\n                                contador++;\n                            } else {\n                                if(jogador1==3 && jogador2==1) {\n                                    printf(\"TESOURA E PEDRA = VITORIA JOGADOR 2! \\n\");\n                                    vitoriasP2++;\n                                    contador++;\n                                } else {\n                                    printf(\"TESOURA E PAPEL = VITORIA JOGADOR 1! \\n\");\n                                    vitoriasP1++;\n                                    contador++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            printf(\"Deseja jogar Novamente? \\n 1- Sim\\n 2-Nao \\n\");\n            scanf(\"%d\", &jogarNovamente);\n            while(jogarNovamente >2) {\n                printf(\"Opcao Invalida, digite uma opcao valida:\\n 1- Sim\\n 2-Nao \\n\");\n                scanf(\"%d\", &jogarNovamente);\n            }\n        } while(jogarNovamente ==1);\n        printf(\"ESTATISTICAS: \\n\");\n        printf(\"Numero de Vezes Jogadas: %d \\n\", contador);\n        printf(\"Numero de Empates: %d \\n\", empates);\n        if(vitoriasP1 == 0 && vitoriasP2 == 0) {\n            printf(\"Porcentagem de Vitorias PLAYER 1 = 0 \\nPorcentagem de Vitorias PLAYER 2 = 0\");\n        } else {\n            porcentvitP1=(vitoriasP1*100)/(contador-empates);\n            porcentvitP2=(vitoriasP2*100)/(contador-empates);\n            printf(\"Porcentagem de Vitorias PLAYER 1 = %f \\n\", porcentvitP1);\n            printf(\"Porcentagem de Vitorias PLAYER 2 = %f \\n\", porcentvitP2);\n        }\n        break;\n    case 2:\n        printf(\" -^^- MODO PLAYER VS I.A -^^- \\n \\n \\n\");\n        jogarNovamente=1;\n        vitoriasP1=0;\n        vitoriasIA=0;\n        contador=0;\n        do {\n            printf(\"Player -> Digite sua opcao de jogada: \\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n            scanf(\"%d\", &jogador1);\n            while(jogador1 >3) {\n                printf(\"Jogada Invalida, por favor digite uma jogada valida:\\n 1 - PEDRA \\n 2 - PAPEL \\n 3 - TESOURA \\n\");\n                scanf(\"%d\", & jogador1);\n            }\n            srand(time(NULL));\n            ia=(rand() % 3)+1;\n            printf(\"Jogada da maquina:\\n %d\\n\", ia);\n            if((jogador1 == 1 && ia == 1) || (jogador1 == 2 && ia == 2)|| (jogador1==3 && ia==3)) {\n                printf(\"EMPATOU! \\n\");\n                empates++;\n                contador++;\n            } else {\n                if(jogador1 == 1 && ia == 2) {\n                    printf(\"PEDRA E PAPEL = VITORIA MAQUINA! \\n\");\n                    vitoriasIA++;\n                    contador++;\n                } else {\n                    if(jogador1==1 && ia == 3) {\n                        printf(\"PEDRA E TESOURA = VITORIA JOGADOR! \\n\");\n                        vitoriasP1++;\n                        contador++;\n                    } else {\n                        if(jogador1==2 && ia==1) {\n                            printf(\"PAPEL E PEDRA = VITORIA JOGADOR! \\n\");\n                            vitoriasP1++;\n                            contador++;\n                        } else {\n                            if(jogador1==2 && ia==3) {\n                                printf(\"PAPEL E TESOURA = VITORIA MAQUINA! \\n\");\n                                vitoriasIA++;\n                                contador++;\n                            } else {\n                                if(jogador1==3 && ia==1) {\n                                    printf(\"TESOURA E PEDRA = VITORIA MAQUINA! \\n\");\n                                    vitoriasIA++;\n                                    contador++;\n                                } else {\n                                    printf(\"TESOURA E PAPEL = VITORIA JOGADOR! \\n\");\n                                    vitoriasP1++;\n                                    contador++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            printf(\"Deseja jogar Novamente? \\n 1- Sim\\n 2-Nao \\n\");\n            scanf(\"%d\", &jogarNovamente);\n            while(jogarNovamente >2) {\n                printf(\"Opcao Invalida, digite uma opcao valida:\\n 1- Sim\\n 2-Nao \\n\");\n                scanf(\"%d\", &jogarNovamente);\n            }\n        } while(jogarNovamente ==1);\n        printf(\"ESTATISTICAS: \\n\");\n        printf(\"Numero de Vezes Jogadas: %d \\n\", contador);\n        printf(\"Numero de Empates: %d \\n\", empates);\n        if(vitoriasP1 == 0 && vitoriasIA == 0) {\n            printf(\"Porcentagem de Vitorias PLAYER 1 = 0 \\nPorcentagem de Vitorias PLAYER 2 = 0\");\n        } else {\n            porcentvitP1=(vitoriasP1*100)/(contador-empates);\n            porcentvitIA=(vitoriasIA*100)/(contador-empates);\n            printf(\"Porcentagem de Vitorias PLAYER 1 = %f \\n\", porcentvitP1);\n            printf(\"Porcentagem de Vitorias da MAQUINA = %f \\n\", porcentvitIA);\n        }\n        break;\n        case 3:\n            exit(0);\n            break;\n        }\n    system(\"pause\");\n    return 0;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica1-7.1.c", "original_string": "int main(void){\n    pid_t pid, pidHijo;\n    int status, o=0;\n    switch (pid) {\n    case -1:\n        exit(EXIT_FAILURE);\n        break;\n    case 0:\n        signal(SIGUSR1, tratarSennal);\n        for (int i = 0; i < 5; i++) pause();\n        exit(EXIT_SUCCESS);\n        break;    \n    default:\n        for (int i = 0; i < 5; i++){\n            sleep(1);\n            kill(pid,SIGUSR1);\n        }\n        pidHijo=wait(&status);\n        break;\n    }\n}"}
{"author": "zjzj-zz", "file": "1s_programing__score.0.c", "original_string": "int main(void) {\n  float wait_time = 0.01;\n  int barw = 20, barh = 150;\n  int bardy = 50;\n  int bar1x = 70, bar1y = DL_HEIGHT / 2;\n  int bar1kup = 'w', bar1kdown = 's';\n  int bar2x = DL_WIDTH - 70, bar2y = DL_HEIGHT / 2;\n  int bar2kup = 'i', bar2kdown = 'k';\n  int br = 15;\n  int bvx = 5.0, bvy = 5.0;\n  int bx = DL_WIDTH / 2, by = DL_HEIGHT / 2;\n  int score1 = 0, score2 = 0;\n  int sx = DL_WIDTH / 2 - 120, sy = 50;\n  char sscore[] = \"   :   \";\n  int t, k, x, y;\n  dl_initialize(1.0);\n  while (1) {\n    while (dl_get_event(&t, &k, &x, &y)) {\n      if (t == DL_EVENT_KEY) {\n    if (k == bar1kup)\n      bar1y -= bardy;\n    else if (k == bar1kdown)\n      bar1y += bardy;\n    else if (k == bar2kup)\n      bar2y -= bardy;\n    else if (k == bar2kdown)\n      bar2y += bardy;\n      }\n    }\n    if (bar1y - barh / 2 < 0)\n      bar1y = barh / 2;\n    if (bar1y + barh / 2 > DL_HEIGHT)\n      bar1y = DL_HEIGHT - barh / 2;\n    if (bar2y - barh / 2 < 0)\n      bar2y = barh / 2;\n    if (bar2y + barh / 2 > DL_HEIGHT)\n      bar2y = DL_HEIGHT - barh / 2;\n    bx += bvx;\n    if (bx - br <= 0 || bx + br >= DL_WIDTH) \n      bvx *= -1;\n    by += bvy;\n    if (by - br <= 0 || by + br >= DL_HEIGHT)\n      bvy *= -1;\n    if (by > bar1y - barh / 2 && by < bar1y + barh / 2) {\n      if (bvx < 0 && bx - br <= bar1x + barw / 2 && bx - br >= bar1x - barw / 2) \n    bvx *= -1;\n      if (bvx > 0 && bx + br >= bar1x - barw / 2 && bx + br <= bar1x + barw / 2)\n    bvx *= -1;\n    }\n    if (by > bar2y - barh / 2 && by < bar2y + barh / 2) {\n      if (bvx < 0 && bx - br <= bar2x + barw / 2 && bx - br >= bar2x - barw / 2) \n    bvx *= -1;\n      if (bvx > 0 && bx + br >= bar2x - barw / 2 && bx + br <= bar2x + barw / 2)\n    bvx *= -1;\n    }\n    if (bx - br <= 0) {\n      score2++;\n      bx = bar1x + barw + 1;\n      by = bar1y;\n      bvx = abs(bvx) + 0.1;\n    }\n    if (bx + br >= DL_WIDTH) {\n      score1++;\n      bx = bar2x - barw - 1;\n      by = bar2y;\n      bvx = -abs(bvx) - 0.1;\n    }\n    if(score1 > 999)\n      score1 = 999;\n    if(score2 > 999)\n      score2 = 999;\n    dl_stop();\n    dl_clear(DL_C(\"black\"));\n    dl_rectangle(bar1x - barw / 2, bar1y - barh / 2,\n         bar1x + barw / 2, bar1y + barh / 2, DL_C(\"red\"), 1, 1);\n    dl_rectangle(bar2x - barw / 2, bar2y - barh / 2,\n         bar2x + barw / 2, bar2y + barh / 2, DL_C(\"green\"), 1, 1);\n    dl_circle(bx, by, br, DL_C(\"blue\"), 1, 1);\n    sprintf (sscore, \"%3d:%d\", score1, score2);\n    dl_text (sscore, sx, sy, 2.0, DL_C(\"white\"), 2);\n    dl_resume();\n    dl_wait(wait_time);\n  }\n  return 0;\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise5.0.c", "original_string": "int LinearSearch(int arr[] , int element , int size ){\n    int i;\n    for(i =0; i <size ; i++){\n        if(arr[i] == element)\n            return i;           \n    }\n    return -1;  \n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__if-else1.0.c", "original_string": "int main ()\n{\n    int a,b;\n    printf(\"l\u00fctfen bir say\u0131 giriniz:\");\n    scanf(\"%d\",&a);\n    printf(\"l\u00fctfen bir say\u0131 giriniz:\");\n    scanf(\"%d\",&b);\n    if(a<b)\n        printf(\"a b'den k\u00fc\u00e7\u00fckt\u00fcr\");\n    if(a>b)\n        printf(\"a b'den b\u00fcy\u00fckt\u00fcr\");\n    if(a==b)\n        printf(\"a b ye e\u015fittir\");\n    return 0;\n    }"}
{"author": "Sowmyamithra", "file": "Data-Structures__OC.2.c", "original_string": "void delete(int key,int value)\n{\n    int index=H(key);\n    int ct=0;\n    if(HASH[index]!=NULL)\n    {\n        temp=HASH[index];\n        q=temp;\n        while(temp->next!=NULL)\n        {\n            if(temp->val==value)\n            {\n                if(temp==HASH[index])\n                {\n                    HASH[index]=temp->next;\n                    free(temp);\n                    temp=HASH[index];\n                    printf(\"\\nValue deleted\");\n                    ct++;\n                }\n                else\n                {\n                    q->next=temp->next;\n                    free(temp);\n                    printf(\"\\nValue deleted\");\n                    ct++;\n                }\n            }\n            q=temp;\n            temp=temp->next;\n        }\n        if(temp->val==value)\n        {\n            q->next=NULL;\n            free(temp);\n            printf(\"\\nValue deleted\");\n            ct++;\n        }\n        if(ct==0)\n        printf(\"\\nValue is not found\");\n    }\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__33_array_armstrong.0.c", "original_string": "int main()\n{\n  int i=0,j=0,k=0,array[100]={0}, no = 0,latest_no = 0, last = 0, sum = 0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    latest_no = array[i];\n    sum = 0;\n    while(latest_no != 0)\n    {\n      last = latest_no%10;\n      sum = sum + (last*last*last);\n      latest_no = latest_no/10;\n    }\n    printf(\"value of Sum is %d\\n\",sum);\n    if( array[i] == sum)\n    {\n      printf(\"%d is Armstrong\\n\\n\",sum);\n    }\n    else\n    {\n      printf(\"No Number is Armstrong\\n\\n\");\n    }\n  }\n}"}
{"author": "deessee0", "file": "Appunti-C__scambia.1.c", "original_string": "void scambiaEsplicito(int v[], int dim, int i, int j){\n    if(dim > 0)\n    {\n        if((i > 0) && (i <= dim-1) && (j > 0) && (j <= dim-1))\n        {\n            int tmp = *(v + i);\n            *(v + i) = *(v + j);\n            *(v + j) = tmp;\n        }\n    }\n}"}
{"author": "Theemiss", "file": "simple_shell__more_fun.3.c", "original_string": "int _strncmp(const char *s1, const char *s2, size_t n)\n{\n    size_t i;\n    if (s1 == NULL)\n        return (-1);\n    for (i = 0; i < n && s2[i]; i++)\n    {\n        if (s1[i] != s2[i])\n        {\n            return (1);\n        }\n    }\n    return (0);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__doublyLinkedList.7.c", "original_string": "int main()\n{\n     struct Node *head;\n     struct Node *second;\n     struct Node *third;\n     struct Node *fourth;\n     head = (struct Node *)malloc(sizeof(struct Node));\n     second = (struct Node *)malloc(sizeof(struct Node));\n     third = (struct Node *)malloc(sizeof(struct Node));\n     fourth = (struct Node *)malloc(sizeof(struct Node));\n     head->data = 7;\n     head->next = second;\n     head->prev = NULL;\n     second->data = 11;\n     second->next = third;\n     second->prev = head;\n     third->data = 70;\n     third->next = fourth;\n     third->prev = second;\n     fourth->data = 22;\n     fourth->next = NULL;\n     fourth->prev = third;\n     Traversal(head); \n     head = deleteLastNode(head);\n     printf(\"---After deletion---\\n\");\n     Traversal(head);\n     return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__cll-ins-sor-seq-del.6.c", "original_string": "int main()\n{\n    while (1)\n    {\n        int ch;\n        printf(\"\\n1. SORTED ORDER INSERTION\\n\");\n        printf(\"2. SEQUENTIAL ORDER INSERTION\\n\");\n        printf(\"3. EXIT PROGRAM\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1)\n        {\n            printf(\"\\n\\tSORTED ORDER\\n\");\n            node* head=NULL;\n            int c;\n            while(1)\n            {\n                int c;\n                printf(\"\\n1. ENTER AN INTEGER\\n\");\n                printf(\"2. DELETE AN INTEGER\\n\");\n                printf(\"3. DISPLAY CONTENT OF CIRCULAR LINK-LIST\\n\");\n                printf(\"4. EXIT SORTED ORDER INSERTION\\n\");\n                printf(\"Enter your choice: \");\n                scanf(\"%d\",&c);\n                if(c==1)\n                {\n                    int n;\n                    printf(\"Please enter an element: \");\n                    scanf(\"%d\",&n);\n                    sort_insertion(&head,n);\n                    printf(\"%d inserted using SORTED ORDER INSERTION.\\n\",n);\n                }\n                else if(c==2)\n                {\n                    if (head==NULL)\n                        printf(\"\\nCAN'T DELETE. LIST EMPTY\\n\");\n                    else\n                    {\n                        int n;\n                        printf(\"\\nPlease enter the element to be deleted: \");\n                        scanf(\"%d\",&n);\n                        node* del_node=search(head,n);\n                        if(del_node==NULL)\n                            printf(\"COULDN'T DELETE %d. NOT FOUND IN LIST.\\n\",n);\n                        else\n                        {\n                            deletion(&head,del_node);\n                            printf(\"%d deleted from LIST.\\n\",n);\n                        }\n                    }\n                }\n                else if (c==3)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nDISPLAYING CONTENTS OF CIRCULAR LINK-LIST: \\n\");\n                        print(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==4)\n                {\n                    printf(\"\\nExitting Sorted Order Insertion, Thank You.\\n\");\n                    break;\n                }\n                else\n                    printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n            }\n        }\n        else if(ch==2)\n        {\n            printf(\"\\n\\tSEQUENTIAL ORDER\\n\");\n            node* head=NULL;\n            int c;\n            while(1)\n            {\n                int c;\n                printf(\"\\n1. ENTER AN INTEGER\\n\");\n                printf(\"2. DELETE AN INTEGER\\n\");\n                printf(\"3. DISPLAY CONTENT OF CIRCULAR LINK-LIST\\n\");\n                printf(\"4. EXIT SEQUENTAIL ORDER INSERTION\\n\");\n                printf(\"Enter your choice: \");\n                scanf(\"%d\",&c);\n                if(c==1)\n                {\n                    int n;\n                    printf(\"Please enter an element: \");\n                    scanf(\"%d\",&n);\n                    seq_insertion(&head,n);\n                    printf(\"%d inserted using SEQUENTIAL ORDER INSERTION.\\n\",n);\n                }\n                else if(c==2)\n                {\n                    if (head==NULL)\n                        printf(\"\\nCAN'T DELETE. LIST EMPTY\\n\");\n                    else\n                    {\n                        int n;\n                        printf(\"\\nPlease enter the element to be deleted: \");\n                        scanf(\"%d\",&n);\n                        node* del_node=search(head,n);\n                        if(del_node==NULL)\n                            printf(\"COULDN'T DELETE %d. NOT FOUND IN LIST.\\n\",n);\n                        else\n                        {\n                            deletion(&head,del_node);\n                            printf(\"%d deleted from LIST.\\n\",n);\n                        }\n                    }\n                }\n                else if (c==3)\n                {\n                    if(head==NULL)\n                        printf(\"\\n\\tLIST EMPTY\\n\");\n                    else\n                    {\n                        printf(\"\\nDISPLAYING CONTENTS OF CIRCULAR LINK-LIST: \\n\");\n                        print(head);\n                        printf(\"\\n\");\n                    }\n                }\n                else if (c==4)\n                {\n                    printf(\"\\nExitting Sequential Order Insertion, Thank You.\\n\");\n                    break;\n                }\n                else\n                    printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n            }\n        }\n        else if(ch==3)\n        {\n            printf(\"\\nExitting Program, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"\\nINVALID CHOICE! TRY AGAIN.\\n\");\n    }\n    return 0;\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__string.0.c", "original_string": "int main()\n{\n    char str[SIZE];\n    int i,n=0,pid,fd[2],f1[2];\n    pipe(fd);\n    printf(\"enter the string with in 30 letter or else change the string size  in pgm:\\n\");\n    fgets(str,sizeof(str),stdin);\n    for(i=1;str[i]!='\\0';i++)\n        {\n        n++;\n        }\n    printf(\"the number of character in the string is %d\\n\",n);\n    pid=fork();\n    if (pid==0)\n    {\n        printf(\"inside the child process--------\\n\");\n        char b[SIZE],ch;\n        int n,vowel=0,i=0;\n        close(fd[1]);\n        read(fd[0],b,sizeof(b));\n        close(fd[0]);\n        n=strlen(b);\n        printf(\"the string gets to the child using pipes is :%s\\n\",b);\n        while(i<=n)\n        {\n            ch=b[i];\n            if(ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u'||ch=='A'||ch=='E'||ch=='I'||ch=='O'||ch=='U')\n            {vowel++;}\n            i++;\n        }\n        printf(\"the vowel count in the given string is %d\",vowel);\n    }\n    else{\n        close(fd[0]);\n    write(fd[1],str,sizeof(str));\n    close(fd[1]);\n        wait(NULL);\n        printf(\"\\n********back to parent process******!\");\n    }\n        return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__merg_sort.2.c", "original_string": "void printarray(int a[],int n)\n{\n    int i;\n    for(i=0;i<n;i++)\n        printf(\"%d\\t\",a[i]);\n}"}
{"author": "Mr-JoE1", "file": "Play-with-C__hex_to_dec.0.c", "original_string": "int main()\n{\n    char hex[32]={0};\n    int  dec,i;\n    int  cnt;   \n    int  dig;   \n    printf(\"Enter hex value: \");\n    gets(hex);\n    cnt=0;\n    dec=0;\n    for(i=(strlen(hex)-1);i>=0;i--)\n    {\n        switch(hex[i])\n        {\n            case 'A':\n                dig=10; break;\n            case 'B':\n                dig=11; break;\n            case 'C':\n                dig=12; break;\n            case 'D':\n                dig=13; break;\n            case 'E':\n                dig=14; break;\n            case 'F':\n                dig=15; break;\n            default:\n                dig=hex[i]-0x30;\n        }\n        dec= dec+ (dig)*pow((double)16,(double)cnt);\n        cnt++;\n    }\n    printf(\"DECIMAL value is: %d\",dec);\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__dequeue.3.c", "original_string": "int dequeueright(queue *q)\n{\n    if (q->front==q->rear)\n    {\n        printf(\"Queue Empty\");\n        return -1;\n    }\n    else\n        return q->c[--(q->rear)];\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__full_function_of_CLL.5.c", "original_string": "void insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node *)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    if(head==0)\n    {\n        head=newnode;\n        newnode->next=newnode;\n    }\n    else\n    {\n        temp=head;\n        while(temp->next!=head)\n        {\n            temp=temp->next;\n        }\n        newnode->next=head;\n        temp->next=newnode;\n    }\n}"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio20.2.c", "original_string": "int main(int argc, char const *argv[])\n{\n    pthread_t hilo1,hilo2;\n    time_t t;\n    srandom(time(&t));\n    sem_init(&semaforo,0,10);\n    while(1){\n        pthread_create(&hilo1,NULL, *fhilo1,NULL);\n        pthread_create(&hilo2,NULL, *fhilo2,NULL);\n        if(buffer[0] == 0) pthread_join(hilo1,NULL);\n        else pthread_join(hilo2,NULL);\n    }\n    sem_destroy(&semaforo);\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__ssh_server.0.c", "original_string": "void sshServerGetDefaultSettings(SshServerSettings *settings)\n{\n   settings->interface = NULL;\n   settings->port = SSH_PORT;\n   settings->numConnections = 0;\n   settings->connections = NULL;\n   settings->numChannels = 0;\n   settings->channels = NULL;\n   settings->prngAlgo = NULL;\n   settings->prngContext = NULL;\n   settings->passwordAuthCallback = NULL;\n   settings->publicKeyAuthCallback = NULL;\n}"}
{"author": "andi-s0106", "file": "sorting_algorithms__1-insertion_sort_list.0.c", "original_string": "void insertion_sort_list(listint_t **list)\n{\n    listint_t *current;\n    listint_t *sorted;\n    if (list == NULL || *list == NULL || (*list)->next == NULL)\n        return;\n    sorted = *list;\n    current = (*list)->next;\n    while (current != NULL)\n    {\n        if (sorted != NULL &&  current->n < sorted->n)\n        {\n            current = swap(&current, &sorted);\n            sorted = current->prev;\n            if (sorted == NULL)\n                *list = current;\n            print_list(*list);\n            while (sorted != NULL && current->n < sorted->n)\n            {\n                current = swap(&current, &sorted);\n                sorted = current->prev;\n                if (sorted == NULL)\n                    *list = current;\n                print_list(*list);\n            }\n        }\n        else\n        {\n            sorted = current;\n            current = sorted->next;\n        }\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__ip2.0.c", "original_string": "NODE insert(NODE first,int e,int pr)\n{\n    NODE temp=(NODE)malloc(sizeof(struct node));\n    temp->data=e;\n    temp->next=NULL;\n    if (first==NULL)\n        return temp;\n    else if(first->next==NULL)\n    {\n        if (first->data>e)\n        {\n            temp->next=first;\n            return temp;\n        }\n        else if(first->data<e)\n            first->next=temp;\n        else\n        {\n            if (pr==1)\n                printf(\"Input not unique\\n\");\n            free(temp);\n        }\n    }\n    else\n    {\n        NODE m=first;\n        while(m->next!=NULL && m->next->data<=e)\n            m=m->next;\n        if (m->data!=e)\n        {\n            temp->next=m->next;\n            m->next=temp;\n        }\n        else\n        {\n            if (pr==1)\n                printf(\"Input not unique\\n\");\n            free(temp);\n        }\n        return first;\n    }\n}"}
{"author": "MartinMarinovich", "file": "MarinovichMartinLABIPP1G-__marca.2.c", "original_string": "int listarMarcas(eMarca listaDeMarcas[], int tamanio)\n{\n    int error = -1;\n    if(listaDeMarcas !=NULL && tamanio>0)\n    {\n        system(\"cls\");\n        printf(\"\\n****  LISTADO DE MARCAS  ****\\n\");\n        printf(\" Id       Descripcion\\n\");\n        printf(\"----------------------------------\\n\");\n        for(int i = 0 ; i<tamanio; i++)\n        {\n            mostrarMarca(listaDeMarcas[i]);\n        }\n        error = 0;\n    }\n    return error;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__p.1.c", "original_string": "void    ft_print_char(unsigned char c)\n{\n    if (c >= ' ' && c <= '~')\n        write(1, &c, 1);\n    else\n        write(1, \".\", 1);\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example41.0.c", "original_string": "int main()\n{\n  int num1,num2,ek=0;\n  printf(\"%s\\n\",\"EKOK almak istedi\u011finiz iki pozitif tam say\u0131 giriniz:\");\n  scanf(\"%d%d\",&num1,&num2);\n  if(num1>num2)\n    ek=ekok(num1,num2);\n  else\n    ek=ekok(num2,num1);\n  printf(\"girilen de\u011ferlerin EKOK u:%d\\n\",ek);  \n  return 0;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.6.c", "original_string": "void removeVal(struct btreeNode *myNode, int pos) {\n        int i = pos + 1;\n        while (i <= myNode->count) {\n                myNode->val[i - 1] = myNode->val[i];\n                myNode->link[i - 1] = myNode->link[i];\n                i++;\n        }\n        myNode->count--;\n  }"}
{"author": "dishanp", "file": "DSA__q63.1.c", "original_string": "void insert(struct node_freq *p, int index, int key)\n{\n    struct node_freq *t = (struct node_freq *)malloc(sizeof(struct node_freq));\n    t->data = key;\n    t->freq = 0;\n    if(index == 0)\n    {\n        t->next = head;\n        head = t;\n    }\n    else\n    {\n        for(int i = 0 ; i < index - 1 ; i++)\n        {\n            p = p->next;\n        }\n        t->next = p->next;\n        p->next = t;\n    }\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__server_arhcive_select.0.c", "original_string": "void *get_in_addr(struct sockaddr *sa)\n{\n    if (sa->sa_family == AF_INET) {\n        return &(((struct sockaddr_in*)sa)->sin_addr);\n    }\n    return &(((struct sockaddr_in6*)sa)->sin6_addr);\n}"}
{"author": "earth429", "file": "mulpre__mulprec.1.c", "original_string": "void dispNumber(struct NUMBER *a){\n    int i;\n    if(getSign(a) == 1){\n        printf(\"+\");\n    } else {\n        printf(\"-\");\n    }\n    for (i = KETA - 1; i >= 0;i--){\n        printf(\"%2d\", a->n[i]);\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__BB.0.c", "original_string": "int main()\n{\n    char str[31];\n    long int tam, soma = 0, pot;\n    fgets(str, 31, stdin);\n    for (int i=0; str[i] != '\\0'; i++)\n    {\n        if (str[i] == '\\n')\n        {\n            str[i] = '\\0';\n        }\n    }\n    tam = strlen(str);\n    pot = tam-1;\n    for (int i=0; i<tam; i++)\n    {\n        if (str[i] == '1')\n        {\n            soma += pow(2,(pot-i));\n        }\n    }\n    printf(\"%li\\n\", soma);\n    return 0;\n}"}
{"author": "dishanp", "file": "DSA__q35.2.c", "original_string": "void reverse_m(struct node *p, int m)\n{\n    int counter = 0;\n    struct node *q = NULL;\n    struct node *r = NULL;\n    while(counter < m)\n    {\n        r = q;\n        q = p;\n        p = p->next;\n        q->next = r;\n        counter++;\n    }\n    first = q;\n    while(q->next != NULL)\n    {\n        q = q->next;\n    }\n    q->next = p;\n}"}
{"author": "2security", "file": "File__3WriteEvenOddPrimeNumSepFile.2.c", "original_string": "int main()\n    {\n        FILE *fptr,*eptr,*optr,*pptr;\n        int n;\n        fptr=fopen(\"File3.txt\",\"r\");\n        eptr=fopen(\"FIle3Even.txt\",\"w\");\n        optr=fopen(\"FIle3Odd.txt\",\"w\");\n        pptr=fopen(\"FIle3Prime.txt\",\"w\");\n        if(fptr==NULL||eptr==NULL||optr==NULL||pptr==NULL)\n            {\n                perror(\"File openning error(:\");\n                getch();\n                exit(0);\n            }\n        while(fscanf(fptr,\"%d\",&n)!=EOF)\n            {\n                if(isPrime(n))\n                    fprintf(pptr,\"%d \",n);\n                if(isEven(n))\n                    fprintf(eptr,\"%d \",n);\n                else\n                    fprintf(optr,\"%d \",n);  \n            }\n        printf(\"\\n Successfully written into file...\");\n        fclose(fptr);\n        fclose(eptr);\n        fclose(optr);\n        fclose(pptr);\n        return 0;\n    }"}
{"author": "fikepaci", "file": "sorting_algorithms__1-insertion_sort_list.1.c", "original_string": "void swap_forward(listint_t *c)\n{\n    listint_t *tmp, *head;\n    tmp = c->prev;\n    if (tmp != NULL)\n    {\n        tmp->next = c->next;\n        c->next->prev = tmp;\n    }\n    else\n        c->next->prev = NULL;\n    c->prev = c->next;\n    if (c->next->next != NULL)\n    {\n        c->next = c->next->next;\n        c->prev->next = c;\n        c->next->prev = c;\n    }\n    else\n    {\n        c->next->next = c;\n        c->next = NULL;\n    }\n    head = c;\n    while (head->prev != NULL)\n        head = head->prev;\n    print_list(head);\n    swap_backward(c->prev);\n}"}
{"author": "deepaliajabsingjadhav", "file": "file__copy_file.1.c", "original_string": "int main()\n{\n    char name1[20];\n    char name2[20];\n    printf(\"Enter source file name\\n\");\n    scanf(\"%s\",name1);\n    printf(\"Enter destination file name\\n\");\n    scanf(\"%s\",name2);\n    FileCopy(name1,name2);\n    return 0;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e90.1.c", "original_string": "int comparar (char captchalido [6], char captchaescrito [6])\n{\n    int cont;\n    int diferenca;\n    diferenca = 0;\n    for ( cont = 0; cont <6; cont++)\n    {\n        if (captchalido [cont]   != captchaescrito [cont])\n        {\n            diferenca ++;\n        }\n    }\n        if (diferenca > 0){\n            return 1;\n        }\n        else {\n            return 0;\n        }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e62.1.c", "original_string": "void cadastrarEvento()\n{\n    fflush(stdin);\n    printf(\"\\t-Digite o nome do evento: \");\n    gets(nomeEvento[contEvento]);\n    fflush(stdin);\n    printf(\"\\n\\t-Informe a capacidade maxima de pessoas: \");\n    scanf(\"%d\", &capacidadeMax);\n    capacidade[contEvento] = capacidadeMax;\n    capacidadeMeia = 0.4*capacidadeMax;\n    capacidadeInteira = 0.6*capacidadeMax;\n    capacidadeI[contEvento] = capacidadeInteira;\n    capacidadeM[contEvento] = capacidadeMeia;\n    printf(\"\\n\\t-Digite o valor de cada ingresso: \");\n    scanf(\"%g\", &valorIngresso);\n    preco[contEvento] = valorIngresso;\n        contEvento++;   \n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__24_delet_specific_ex.0.c", "original_string": "int main()\n{\n  int i,j,k,array1[100],array2[100],no=0,delete_no=0,delete_index=0;\n  printf(\"Enter Length of Array\");\n  scanf(\"%d\",&no);\n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n  printf(\"Enter number to delete it from Array\\n\");\n  scanf(\"%d\",&delete_no);\n  for(i=0; i<no; i++)\n  {\n    if(array1[i] == delete_no)\n    {\n      printf(\"Number is %d Index is %d\",array1[i],i);\n      delete_index = i;\n    }\n  }\n  printf(\"\\n\");\n  for(j=0; j<no-1; j++)\n  {\n    if(j < delete_index)\n    {\n      array2[j] = array1[j];\n    }\n    if(j >= delete_index)\n    {\n      array2[j] = array1[j+1];\n    }\n  }\n  printf(\"\\n\");\n  for(i=0; i<no-1; i++)\n  {\n    printf(\"%d \",array2[i]);\n  }\n}"}
{"author": "sdukesameer", "file": "dsa__bfs.3.c", "original_string": "int dequeue(queue* q){\n    int ret=q->items[0];\n    for(int i=0; i<q->end; i++)\n        q->items[i]=q->items[i+1];\n    q->end--;\n    return ret;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__5.0.c", "original_string": "int main(int argc, char **argv)\n{\n    FILE *arq_1, *arq_2;\n    char aux, *str_1, *str_2;\n    int n, m;\n    float **matriz, aux_2, *texto;\n    if (argc < 3)\n    {\n        printf(\"\\nErro! N\u00e3o foram informados arquivos o suficiente\\n\\n\");\n        return 0;\n    }\n    arq_1 = fopen(argv[1], \"r\");\n    arq_2 = fopen(argv[2], \"w\");\n    if (arq_1 == NULL || arq_2 == NULL)\n    {\n        printf(\"\\nErro ao abrir o arquivo.\\n\\n\");\n        return 0;\n    }\n    int i = 0;\n    while (fscanf(arq_1, \"%f\", &aux_2) != EOF)\n    {\n        i++;\n    }\n    printf(\"\\ni = %i\\n\", i);\n    texto = malloc(i * sizeof(float));\n    rewind(arq_1);\n    for (int j = 0; j < i; j++)\n    {\n        fscanf(arq_1, \"%f\", texto+j);\n    }\n    n = texto[0];\n    m = texto[1];\n    matriz = malloc(n * sizeof(float*));\n    for (int i = 0; i < n; i++)\n    {\n        matriz[i] = malloc(m * sizeof(float));\n    }\n    for (int i = 0, k = 0; i < n; i++)\n    {\n        for (int  j = 0; j < m; j++)\n        {\n            matriz[i][j] = texto[k+2];\n            k++;\n        }\n    }\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            fprintf(arq_2, \"%f \", matriz[j][i]);\n        }\n        fprintf(arq_2, \"%c\", '\\n');\n    }\n    return 0;\n}"}
{"author": "deessee0", "file": "Appunti-C__SommaArray.1.c", "original_string": "int somma(int v[], int dim)\n    {\n        int tot=0;\n        int i=0;\n        for(i=0;i<dim;i++)\n        {\n            tot += v[i]; \n        }\n        return tot;\n    }"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es31.2.c", "original_string": "void calcolo_area(float *perimetro, float ac, float *ipotenusa, float *bc, float *area)\n{\n    double parziale = (*perimetro/2) * (*perimetro/2 - ac) * (*perimetro/2 - *ipotenusa) * (*perimetro/2 - *bc);\n    *area = sqrt(parziale);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__str_len.2.c", "original_string": "int main()\n{\n    int iRet = 0;\n    char Arr[30] = {'\\0'};\n    printf(\"Enter string\\n\");\n    scanf(\"%[^'\\n']s\",Arr);\n    iRet = StrlenR(Arr);\n    printf(\"Length is %d\\n\\n\",iRet);\n    return 0;\n}"}
{"author": "2security", "file": "String__30SearchAlloccurrence.1.c", "original_string": "void KMPAlgorithm(char* text, char* pattern) {\n   int M = strlen(pattern),c=0;\n   int N = strlen(text);\n   int pps[M];\n   prefixSuffixArray(pattern, M, pps);\n   int i = 0;\n   int j = 0;\n   while (i < N) {\n      if (pattern[j] == text[i]) {\n         j++;\n         i++;\n      }\n      if (j == M) {\n         c++;\n         j = pps[j - 1];\n      }\n      else if (i < N && pattern[j] != text[i]) {\n         if (j != 0)\n         j = pps[j - 1];\n         else\n         i = i + 1;\n      }\n   }\nprintf(\"\\n No of matching occurence is:=%d\",c);\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_01.2.c", "original_string": "int search(int A[],int n,int k)\n{\n int i;\n for(i=0;i<n;i++)\n   if(A[i]==k)\n     return i;\n   return -1;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__adc_sw_cntl.0.c", "original_string": "int main()\n{\n    int res,done = 1;\n    PINSEL1 |= 1<<24;\n    PINSEL1 &= ~(1<<25); \n    lcd_config();\n    ADCR = (1<<1)|(4<<8)|(1<<21)|(1<<24);  \n    while(1)\n    {\n        while(!(ADDR & (done<<31)));\n        res = ADDR & (0x3FF<<6);   \n        res = res>>6;                               \n        res = res/3.3;  \n        lcd_num(res);\n        delay(1000);\n    }\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__HeapSort.5.c", "original_string": "void heapsort(int a[100],int n)\n    {\n        int temp,i;\n        count++;\n        build_max_heap(a,n);\n        count++;\n        for(i=n-1;i>0;i--)\n        {\n            count++;\n            temp=a[0];\n            count++;\n            a[0]=a[i];\n            count++;\n            a[i]=temp;\n            count++;\n            max_heapify(a,i,0);\n            count++;\n        }\n    }"}
{"author": "HakNinja", "file": "C-Advance__4nested_str.0.c", "original_string": "int main()\n{\n    int u;\n    struct student x;\n    printf(\"Enter Details:\\n\");\n    printf(\"Enter roll number:\");\n    scanf(\"%d\",&x.rno);\n    printf(\"Enter name of student\");\n    printf(\"\\nFirst name:\");\n    scanf(\"%s\",&x.name.fn);\n    printf(\"Middle name:\");\n    scanf(\"%s\",&x.name.mn);\n    printf(\"Last name:\");\n    scanf(\"%s\",&x.name.ln);\n    printf(\"Enter Date Of Birth\");\n    printf(\"\\nDate:\");\n    scanf(\"%d\",&x.dob.d);\n    printf(\"Month:\");\n    scanf(\"%d\",&x.dob.m);\n    printf(\"Year:\");\n    scanf(\"%d\",&x.dob.y);\n    printf(\"Percentage:\");\n    scanf(\"%f\",&x.per);\n    printf(\"\\n--------------------------------------------------------------------------\");\n    printf(\"\\nRoll number:%d\\n\",x.rno);\n    printf(\"\\nName:%s %s %s\\n\",x.name.fn,x.name.mn,x.name.ln);\n    printf(\"DoB:%d/%d/%d\\n\",x.dob.d,x.dob.m,x.dob.y);\n    printf(\"Percentage:%f\\n\",x.per);\n    return(0);\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-util.0.c", "original_string": "LINE* opvarraw(SCOPE* s, char* op, VAR* v) {\n    char* tokens[] = { op, v->memsegment, itoa(v->index) };\n    LINE* ln = mksimpleln(tokens, strcount(tokens));\n    free(tokens[2]);\n    return ln;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__palhaco.1.c", "original_string": "void desenhaCabeca(){\n    glPushMatrix();\n        glColor3f(1.0,1.0,1.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glutWireSphere(2.0, 20, 20);\n    glPopMatrix();\n}"}
{"author": "mandarvu", "file": "msc__problem90.1.c", "original_string": "int main()\n{\n    int a, b, c;\n    printf(\"Give coefficients a, b and c in ax^2 + bx +c = 0 in order.\\n\");\n    scanf(\"%d %d %d\",&a,&b,&c);\n    findRoots(a, b, c);\n    return 0;\n}"}
{"author": "behergue", "file": "Operating_Systems__mytar_routines.3.c", "original_string": "int createTar(int nFiles, char *fileNames[], char tarName[]){\n    FILE * f = fopen(tarName, \"w\");\n    int headerSize = sizeof(int);\n    for(int i = 0; i < nFiles; i++)\n        headerSize += strlen(fileNames[i]) + 1 + sizeof(int);\n    fseek(f, headerSize, SEEK_SET);\n    int* fileSizes = (int*) malloc(nFiles * sizeof(int));\n    for(int i = 0; i < nFiles; i++){\n        FILE * a = fopen(fileNames[i], \"r\");\n        int t = copynFile(a, f, 100);\n        fileSizes[i] = 0;\n        while(t != 0){\n            fileSizes[i] += t;\n            t = copynFile(a, f, 100);\n        }\n        fclose(a);\n    }\n    fseek(f, 0, SEEK_SET);\n    fwrite(&nFiles, sizeof(int), 1, f);\n    for(int i = 0; i < nFiles; i++){\n        fwrite(fileNames[i], sizeof(char), strlen(fileNames[i]) + 1, f);\n        fwrite(&fileSizes[i], sizeof(int), 1, f);\n    }\n    fclose(f);\n    free(fileSizes);\n    return EXIT_SUCCESS;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_c_extended.4.c", "original_string": "void ble_lbs_on_db_disc_evt(ble_lbs_c_t * p_ble_lbs_c, ble_db_discovery_evt_t const * p_evt)\n{\n    if (p_evt->evt_type == BLE_DB_DISCOVERY_COMPLETE &&\n        p_evt->params.discovered_db.srv_uuid.uuid == LBS_UUID_SERVICE &&\n        p_evt->params.discovered_db.srv_uuid.type == p_ble_lbs_c->uuid_type)\n    {\n        ble_lbs_c_evt_t evt;\n        evt.evt_type    = BLE_LBS_C_EVT_DISCOVERY_COMPLETE;\n        evt.conn_handle = p_evt->conn_handle;\n        for (uint32_t i = 0; i < p_evt->params.discovered_db.char_count; i++)\n        {\n            const ble_gatt_db_char_t * p_char = &(p_evt->params.discovered_db.charateristics[i]);\n            switch (p_char->characteristic.uuid.uuid)\n            {\n                case LBS_UUID_LED_CHAR:\n                    evt.params.peer_db.led_handle = p_char->characteristic.handle_value;\n                    break;\n                case LBS_UUID_LED_COL_CHAR:\n                    evt.params.peer_db.led_color_handle = p_char->characteristic.handle_value;\n                    break;\n                case LBS_UUID_BUTTON_CHAR:\n                    evt.params.peer_db.button_handle      = p_char->characteristic.handle_value;\n                    evt.params.peer_db.button_cccd_handle = p_char->cccd_handle;\n                    break;\n                default:\n                    break;\n            }\n        }\n        NRF_LOG_DEBUG(\"Led Button Service discovered at peer.\");\n        if (p_ble_lbs_c->conn_handle != BLE_CONN_HANDLE_INVALID)\n        {\n            if ((p_ble_lbs_c->peer_lbs_db.led_handle         == BLE_GATT_HANDLE_INVALID)&&\n                (p_ble_lbs_c->peer_lbs_db.led_color_handle   == BLE_GATT_HANDLE_INVALID)&&\n                (p_ble_lbs_c->peer_lbs_db.button_handle      == BLE_GATT_HANDLE_INVALID)&&\n                (p_ble_lbs_c->peer_lbs_db.button_cccd_handle == BLE_GATT_HANDLE_INVALID))\n            {\n                p_ble_lbs_c->peer_lbs_db = evt.params.peer_db;\n            }\n        }\n        p_ble_lbs_c->evt_handler(p_ble_lbs_c, &evt);\n    }\n}"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal_gpio.3.c", "original_string": "void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)\n{\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\n  assert_param(IS_GPIO_PIN_ACTION(PinState));\n  if (PinState != GPIO_PIN_RESET)\n  {\n    GPIOx->BSRR = GPIO_Pin;\n  }\n  else\n  {\n    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;\n  }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e61.0.c", "original_string": "int main(int argc, char *argv[]) {\n    char nomeEvento[20], localEvento[40], dataEvento[8], horaEvento[5];\n    int detalhes, cadastro, qntdIngressos;\n    int qntdInteiro, qntdMeio, tipoCompra;\n    int capacMax;\n    int contadorCompra;\n    float vlrIngresso, vlrMeioIngresso;\n    float vlrPago, vlrTroco, vlrSobra;\n    do\n    {\n        system(\"cls\");\n        printf(\"-----------------------------------------------------------\\n\");\n        printf(\"----------------   Vendedor de Ingressos   ----------------\\n\");\n        printf(\"--------------    Configuracoes do Evento    --------------\\n\");\n        printf(\"-----------------------------------------------------------\\n\\n\\n\");\n        printf(\"Digite o nome do evento: \");\n        setbuf(stdin, NULL);\n        gets(nomeEvento);\n        printf(\"\\n      |Deseja adicionar detalhes ao evento?\\n\");\n        do\n        {\n            printf(\"        |   1. Sim\\n\");\n            printf(\"        |   2. Nao, desejo inserir as inforamcoes sobre os ingressos\\n      |\\n\");\n            printf(\"        |   Digite a opcao desejada: \");\n            scanf(\"%d\", &detalhes);\n                switch(detalhes)\n                {\n                    case 1:\n                        printf(\"        |\\n     |Digite a data do evento (dd/mm/aa): \");\n                        setbuf(stdin, NULL);\n                        gets(dataEvento);\n                        printf(\"        |\\n     |Digite a hora do evento (hh:mm): \");\n                        setbuf(stdin, NULL);\n                        gets(horaEvento);\n                        printf(\"        |\\n     |Digite o local do evento (cidade, bairro, rua e logradouro): \");\n                        setbuf(stdin, NULL);\n                        gets(localEvento);\n                        break;\n                    case 2:\n                        break;\n                    default:\n                        printf(\"\\n      |opcao invalida, digite novamente.\\n\");\n                }\n        }\n        while (detalhes>2 || detalhes<1);\n        printf(\"\\nDigite o total de ingressos a serem vendidos: \");\n        scanf(\"%d\", &qntdIngressos);\n        printf(\"Digite o valor unitario de cada ingresso: R$\");\n        scanf(\"%f\", &vlrIngresso);\n        do\n        {\n            printf(\"\\n\\n\\n          |Finalizar cadastro?                         |\\n\");\n            printf(\"            |   1. Sim                               |\\n\");\n            printf(\"            |   2. Nao, reenserir informacoes        |\\n            |                                        |\\n\");\n            printf(\"            |Digite a opcao desejada: \");\n            scanf(\"%d\", &cadastro); \n            if(cadastro >2 || cadastro<1)\n            {\n                printf(\"            |\\n         |   Opcao invalida, digite novamente: \");\n            }\n        }\n        while(cadastro>2 || cadastro<1);\n    }\n    while(cadastro==2);\n    qntdMeio = qntdIngressos*0.4;\n    qntdInteiro = qntdIngressos-qntdMeio;\n    vlrMeioIngresso = vlrIngresso*0.5;\n    capacMax = qntdIngressos;\n    do\n    {   \n        system(\"cls\");\n        printf(\"---------------------------------------------------------\\n\");\n        printf(\"| Auto atendimento - Venda de ingressos - %s | \\n\", nomeEvento);\n        printf(\"---------------------------------------------------------\\n\");\n        if(detalhes==1)\n        {\n            printf(\"\\n  - Data: %s\\n    - Hora: %s\\n    - Local: %s\", dataEvento, horaEvento, localEvento);\n        }\n        printf(\"\\n  - Capacidade maxima: %d \", capacMax);\n        printf(\"\\n  - Valor unitario ingresso: R$ %.2f\\n\\n \", vlrIngresso);printf(\"__________________________________________________________\");\n        printf(\"\\n\\nDigite o tipo de ingresso que deseja comprar: \");\n        printf(\"\\n  1. Ingresso inteiro\");\n        printf(\"\\n  2. Meio ingresso\");\n        printf(\"\\n\\n    Digite a opcao desejada: \");\n        scanf(\"%d\", &tipoCompra);\n            switch(tipoCompra)\n            {           \n                case 1:\n                    if(qntdInteiro > 0)\n                    {\n                        printf(\"\\n\\nValor a ser pago: R$%.2f\", vlrIngresso);\n                        do\n                        {\n                            printf(\"\\n\\nDigite o valor total que voce esta pagando a maquina: R$\");\n                            scanf(\"%g\", &vlrPago);\n                            if(vlrPago>vlrIngresso)\n                            {\n                                vlrTroco = vlrPago - vlrIngresso;\n                                printf(\"Seu troco e: R$%.2f\", vlrTroco);\n                            }else{\n                                if(vlrPago==vlrIngresso)\n                                {\n                                    printf(\"Nao ha troco.\");;\n                                }else{\n                                    vlrSobra = vlrIngresso - vlrPago;\n                                    printf(\"Precisa-se de mais R$%.2f para completar a compra do ingresso.\", vlrSobra);\n                                    }\n                                }\n                        }while(vlrPago<vlrIngresso);\n                        qntdInteiro--;\n                    }else{\n                    printf(\"Infelizmente nao temos mais ingressos nesta categoria.\");\n                        }\n                    break;\n                case 2:\n                    if(qntdMeio > 0)\n                    {\n                        printf(\"\\n\\nValor a ser pago: R$%.2f\", vlrMeioIngresso);\n                        do\n                        {\n                            printf(\"\\n\\nDigite o valor total que voce esta pagando a maquina: R$\");\n                            scanf(\"%g\", &vlrPago);\n                            if(vlrPago>vlrMeioIngresso)\n                            {\n                                vlrTroco = vlrPago - vlrMeioIngresso;\n                                printf(\"Seu troco e: R$%.2f\", vlrTroco);\n                            }else{\n                                if(vlrPago==vlrMeioIngresso)\n                                {\n                                    printf(\"Nao ha troco.\");\n                                }else{\n                                    vlrSobra = vlrMeioIngresso - vlrPago;\n                                    printf(\"Precisa-se de mais R$%.2f para completar a compra do ingresso.\", vlrSobra);\n                                    }\n                                }\n                        }while(vlrPago<vlrMeioIngresso);\n                        qntdMeio--;\n                    }else{\n                    printf(\"\\n- Infelizmente nao temos mais ingressos nesta categoria.\");\n                        }\n                    break;\n                default:\n                    printf(\"\\nOpcao invalida, digite novamente: \");\n            }\n        qntdIngressos = qntdInteiro + qntdMeio;\n        printf(\"\\n\\n\\nObrigado por comprar conosco!\\n\\n___________________________________________________________\");\n        printf(\"\\n                        Relatorio                            \");\n        printf(\"\\n\\n    Total de ingressos disponiveis = %d\\n   Ingressos inteiros = %d Meio ingressos = %d\", qntdIngressos, qntdInteiro, qntdMeio);\n        printf(\"\\n__________________________________________________________\");\n        if(qntdIngressos > 0)\n        {\n            do\n            {\n                printf(\"\\n\\n\\nDeseja realizar uma nova compra?\");\n                printf(\"\\n  1. Sim\\n    2. Nao, desejo finalizar.\");\n                printf(\"\\n\\n    Digite a opcao desejada: \");\n                scanf(\"%d\", &contadorCompra);\n            }while(contadorCompra < 1 && contadorCompra > 2);\n        }\n    }while(contadorCompra == 1 && qntdIngressos > 0);\n    if(qntdIngressos == 0)\n    {\n        printf(\"\\n\\n\\nNao ha mais ingressos disponiveis neste evento, todos foram vendidos.\");\n    }\nreturn 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__AJ.1.c", "original_string": "int primo(long int num, long int vet[], int tam)\n{    \n    if (num == 1) return false;\n    else if (num == 2) return true;\n    else\n    {\n        for (int j = 0; j <= tam; j++)\n        {\n            if ((num % vet[j] == 0) && (num != vet[j]))\n                return false;\n        }\n    }\n    return true;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q1_doublylq.3.c", "original_string": "int delst(nptr* start,nptr* end)\n{\n    if(!*start)\n    {\n        printf(\"Underflow!!\\n\"); \n        return -99;\n    }\n    nptr temp; int x;\n    temp=*start;\n    x=temp->ele;\n    if(!((*start)->rlink))\n    {\n        *end=*start=NULL;\n        free(temp);\n        return x;\n    }\n    *start=(*start)->rlink;\n    (*start)->llink=NULL;\n    free(temp);\n    return x;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__21_Dowhile.1.c", "original_string": "double Exp(int numero, int exponente)\n{\n    double Total = 1;\n    int i = 0;\n    do{\n    Total *= numero;\n    ++i;\n    }while(i < exponente);\n    return Total;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__vm-lines.2.c", "original_string": "void println(LINE* ln, FILE* stream) {\n    for(int i = 0; i < ln->count; i++) {\n        fprintf(stream, \"%s\", ln->tokens[i]);\n        if(i + 1 < ln->count)\n            fprintf(stream, \" \");\n    }\n    fprintf(stream, \"\\n\");\n}"}
{"author": "davibernardos", "file": "DB-Projetos__e2.0.c", "original_string": "int main(void) {\n    srand (time(NULL));\n    int jogarNovamente;\n    int jogarNovamente2;\n    int jogarMais = 1;\n    int escolhaJogo;\n    int jogador1;\n    int jogador2;\n    int jogadaComputador;\n    int linha;\n    int pontosJogador1 = 0;\n    int pontosJogador2 = 0;\n    int pontosComputador = 0;\n    int empate = 0;\n    int totalJogadas;\n    float porcentagemJogador1;\n    float porcentagemJogador2;\n    float porcentagemComputador;\n    printf(\"\\n                              JOKENPO ULTIMATE!\\n\\n\");\n    printf(\"\\n                    Digite >1< para jogar contra o computador.\\n\");\n    printf(\"                    Digite >2< para jogar contra outro humano.\\n\\n\");\n    printf(\"                                     >\");\n    scanf(\" %d\", &escolhaJogo);\n    while(jogarMais > 0){\n        jogadaComputador = rand()%3+1;\n        if(escolhaJogo == 1){ \n        printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n        printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n        printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n        printf(\"\\n                          HUMANO X COMPUTADOR, BOA SORTE!!\");\n        printf(\"\\n                                Faca a sua jogada: \\n\\n\");\n        printf(\"                                     >\");\n        scanf(\" %d\", &jogador1);\n            if(jogador1 >=1 && jogador1 <=3){ \n                printf(\"\\n                                  JO\");\n                sleep(1);\n                printf(\"KEN\");\n                sleep(1);\n                printf(\"PO!!! \\n\\n\");\n                sleep(1);\n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n                switch(jogador1){ \n                    case 1:\n                        printf(\"                                 PEDRA x \");\n                        break;\n                    case 2:\n                        printf(\"                                 PAPEL x \");\n                        break;\n                    case 3:\n                        printf(\"                                TESOURA x \");\n                        break;\n                }\n                switch(jogadaComputador){ \n                    case 1:\n                        printf(\"PEDRA \\n\\n\");\n                        break;\n                    case 2:\n                        printf(\"PAPEL \\n\\n\");\n                        break;\n                    case 3:\n                        printf(\"TESOURA \\n\\n\");\n                        break;\n                }\n                if ((jogador1 == 1 && jogadaComputador == 3) || (jogador1 == 2 && jogadaComputador == 1) || (jogador1 == 3 && jogadaComputador == 2)){ \n                    printf(\"                                 VOCE VENCEU!!! \\n\\n\");\n                    pontosJogador1 = pontosJogador1 + 1;\n                }\n                if (jogador1 == jogadaComputador){ \n                    printf(\"                                    EMPATE! \\n\\n\");\n                    empate++;\n                }\n                if ((jogadaComputador == 1 && jogador1 == 3) || (jogadaComputador == 2 && jogador1 == 1) || (jogadaComputador == 3 && jogador1 == 2)){ \n                    printf(\"                                 VOCE PERDEU :( \\n\\n\");\n                    pontosComputador = pontosComputador + 1;\n            }\n        } else { \n            printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n        }\n        }\n        if(escolhaJogo == 2){  \n            printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n            printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n            printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n            printf(\"\\n                          HUMANO X HUMANO, BOA SORTE!!\");\n            printf(\"\\n\\n                          JOGADOR 1 Faca a sua jogada: \\n\\n\");\n            printf(\"                                     >\");\n            scanf(\" %d\", &jogador1);\n            if(jogador1 >= 1 && jogador1 <= 3){\n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n                printf(\"\\n                          Para jogar PEDRA digite    >1<\\n\");\n                printf(\"                          Para jogar PAPEL digite    >2<\\n\");\n                printf(\"                          Para jogar TESOURA digite  >3<\\n\\n\");\n                printf(\"\\n                          HUMANO X HUMANO, BOA SORTE!!\");\n                printf(\"\\n\\n                          JOGADOR 2 Faca a sua jogada: \\n\\n\");\n                printf(\"                                     >\");\n                scanf(\" %d\", &jogador2);\n                if(jogador2 >= 1 && jogador2 <= 3) {\n                    printf(\"\\n                                  JO\");\n                    sleep(1);\n                    printf(\"KEN\");\n                    sleep(1);\n                    printf(\"PO!!! \\n\\n\");\n                    sleep(1);\n                    for( linha = 0; linha < 35; linha++){ \n                        printf( \"\\n\" );\n                    }\n                    switch(jogador1){ \n                    case 1:\n                        printf(\"                                 PEDRA x \");\n                        break;\n                    case 2:\n                        printf(\"                                 PAPEL x \");\n                        break;\n                    case 3:\n                        printf(\"                                TESOURA x \");\n                        break;\n                    }\n                    switch(jogador2){ \n                    case 1:\n                        printf(\"PEDRA \\n\\n\");\n                        break;\n                    case 2:\n                        printf(\"PAPEL \\n\\n\");\n                        break;\n                    case 3:\n                        printf(\"TESOURA \\n\\n\");\n                        break;\n                    }\n                    if ((jogador1 == 1 && jogador2 == 3) || (jogador1 == 2 && jogador2 == 1) || (jogador1 == 3 && jogador2 == 2)){ \n                        printf(\"                               JOGADOR 1 VENCEU! \\n\\n\");\n                        pontosJogador1 = pontosJogador1 + 1;\n                    }\n                    if (jogador1 == jogador2){ \n                        printf(\"                                    EMPATE! \\n\\n\");\n                        empate++;\n                    }\n                    if ((jogador2 == 1 && jogador1 == 3) || (jogador2 == 2 && jogador1 == 1) || (jogador2 == 3 && jogador1 == 2)){ \n                        printf(\"                               JOGADOR 2 VENCEU! \\n\\n\");\n                        pontosJogador2 = pontosJogador2 + 1;\n                    }\n                } else { \n                    printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n                }\n            } else { \n                printf(\"\\n                        Voce nao digitou um numero valido. \\n\");\n            }\n        }\n        if(escolhaJogo > 2){  \n            printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n            exit(0);\n        }\n        printf(\"\\n\\n\\n\\n\\n\\n\\n\\n                          Para jogar novamente digite >1< \\n\");\n        printf(\"                          Para estatisticas digite    >2< \\n\");\n        printf(\"                          Para sair digite            >3< \\n\\n\");\n        printf(\"                                     >\");\n        scanf(\" %d\", &jogarNovamente);\n        if(jogarNovamente == 1){ \n            for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n        }\n        if(jogarNovamente == 2){ \n            for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n            }\n            totalJogadas = pontosJogador1 + pontosJogador2 + pontosComputador + empate;\n            printf(\"\\n                                 ESTATISTICAS!\\n\\n\");\n            printf(\"                          Vitorias do Jogador 1:     >%d< \\n\", pontosJogador1);\n            if(pontosJogador2 > 0){\n                printf(\"                      Vitorias do Jogador 2:     >%d< \\n\\n\", pontosJogador2);\n                printf(\"                      Empates:                   >%d< \\n\\n\", empate);\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                porcentagemJogador2 = ((float)pontosJogador2 / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\", porcentagemJogador1);\n                printf(\"                  Porcentagem de vitorias do Jogador 2:     >%.1f< \\n\", porcentagemJogador2);\n            }\n            if(pontosComputador > 0){\n                printf(\"                          Vitorias do Computador:    >%d< \\n\\n\", pontosComputador);\n                printf(\"                          Empates:                   >%d< \\n\\n\", empate);\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                porcentagemComputador = ((float)pontosComputador / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\", porcentagemJogador1);\n                printf(\"                  Porcentagem de vitorias do Computador:    >%.1f< \\n\", porcentagemComputador);\n            }\n            if(pontosJogador2 == 0 && pontosComputador == 0){\n                if(escolhaJogo == 1){\n                    printf(\"                          Vitorias do Computador:    >%d< \\n\\n\", pontosComputador);\n                }\n                if(escolhaJogo == 2){\n                    printf(\"                          Vitorias do Jogador 2:     >%d< \\n\\n\", pontosJogador2);\n                }\n                if(empate > 0){\n                        printf(\"                          Empates:                   >%d< \\n\\n\", empate);\n                }\n                porcentagemJogador1 = ((float)pontosJogador1 / (float)totalJogadas) * 100;\n                printf(\"                  Porcentagem de vitorias do Jogador 1:     >%.1f< \\n\\n\", porcentagemJogador1);\n            }\n            for( linha = 0; linha < 13; linha++){ \n                    printf( \"\\n\" );\n            }\n            printf(\"                          Para jogar novamente digite >1< \\n\");\n            printf(\"                          Para sair digite            >2< \\n\\n\");\n            printf(\"                                     >\");\n            scanf(\" %d\", &jogarNovamente2);\n            if(jogarNovamente2 == 1){ \n                for( linha = 0; linha < 35; linha++){ \n                    printf( \"\\n\" );\n                }\n            }\n            if(jogarNovamente2 == 2){ \n                exit(0);\n            }\n            if(jogarNovamente2 >= 3){\n                printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n                exit(0);\n            }\n        }\n        if(jogarNovamente == 3){\n            exit(0);\n        }\n        if(jogarNovamente >= 4){\n            printf(\"\\n              Voce nao digitou um numero valido. Reinicie o jogo. \\n\");\n            exit(0);\n        }\n    }\n    return 0;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e19.0.c", "original_string": "char * gerarCaptcha (char captchaGerado[6]) {\n    int contadorLetras;\n    int padraoCaptcha;\n    padraoCaptcha = rand() % 3;\n    switch (padraoCaptcha) {\n        case 0: {\n            for (contadorLetras=0; contadorLetras < 6 ; contadorLetras++) {\n                if(contadorLetras == 0 || contadorLetras == 3) {\n                    captchaGerado[contadorLetras] = 65 + (rand() % 26);\n                } else {\n                    if(contadorLetras == 1 || contadorLetras == 4) {\n                        captchaGerado[contadorLetras] = 48 + (rand() % 10);\n                    } else {\n                        if(contadorLetras == 2 || contadorLetras == 5 ) {\n                            captchaGerado[contadorLetras] = 97 + (rand() % 26);\n                        }\n                    }\n                }\n            }\n            break;\n        }\n        case 1: {\n            for (contadorLetras=0; contadorLetras < 6 ; contadorLetras++) {\n                if(contadorLetras == 1 || contadorLetras == 3) {\n                    captchaGerado[contadorLetras] = 65 + (rand() % 26);\n                } else {\n                    if(contadorLetras == 0 || contadorLetras == 5) {\n                        captchaGerado[contadorLetras] = 48 + (rand() % 10);\n                    } else {\n                        if(contadorLetras == 2 || contadorLetras == 4 ) {\n                            captchaGerado[contadorLetras] = 97 + (rand() % 26);\n                        }\n                    }\n                }\n            }\n            break;\n        }\n        case 2: {\n            for (contadorLetras=0; contadorLetras < 6 ; contadorLetras++) {\n                if(contadorLetras == 0 || contadorLetras == 5) {\n                    captchaGerado[contadorLetras] = 65 + (rand() % 26);\n                } else {\n                    if(contadorLetras == 2 || contadorLetras == 3) {\n                        captchaGerado[contadorLetras] = 48 + (rand() % 10);\n                    } else {\n                        if(contadorLetras == 1 || contadorLetras == 4 ) {\n                            captchaGerado[contadorLetras] = 97 + (rand() % 26);\n                        }\n                    }\n                }\n            }\n            break;\n        }\n    }\n    return captchaGerado;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__uart_rx.0.c", "original_string": "int main()\n{\n    char var;\n    PINSEL0 |= (1<<0)|(1<<2);   \n    PINSEL0 &= ~((1<<1)|(1<<3));\n    lcd_config();\n    U0LCR = (1<<7);     \n    U0DLL = 97;             \n    U0DLM = 0;\n    U0LCR &= ~(1<<7);   \n    U0LCR = (1<<0)|(1<<1); \n    while(1)\n    {\n        while(!(U0LSR & (1<<0)));   \n            var = U0RBR;            \n            lcd_data(var);\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__double_linked_list_create.1.c", "original_string": "void createList(int n)\n{\n    int i, data;\n    struct node *newNode;\n            head = (struct node *)malloc(sizeof(struct node));\n            printf(\"Enter data of 1 node: \");\n            scanf(\"%d\", &data);\n            head->data = data;\n            head->prev = NULL;\n            head->next = NULL;\n            last = head;\n            for(i=2; i<=n; i++)\n            {\n                newNode = (struct node *)malloc(sizeof(struct node));\n                    printf(\"Enter data of %d node: \", i);\n                    scanf(\"%d\", &data);\n                    newNode->data = data;\n                    newNode->prev = last;\n                    newNode->next = NULL;\n                    last->next = newNode;\n                    last = newNode;\n            }\n        printf(\"\\nDOUBLY LINKED LIST CREATED SUCCESSFULLY\\n\");\n    }"}
{"author": "2security", "file": "Matrix__32CheckUpperTriangularMatrix.1.c", "original_string": "int main()\n    {\n    int i,j,r,c,mat1[20][20];\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    if(r!=c)\n        printf(\"For checking upper triangualr matrix or not matrix should be square\");\n    else\n        {\n        printf(\"\\n Enter the matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        if(checkUpperTri(mat1,r)==1)\n            printf(\"Matrix is Upper triangualr matrix\");\n        else\n            printf(\"Matrix is not Upper triangualr matrix\");\n        }\n    return 0;\n    }"}
{"author": "Sowmyamithra", "file": "Data-Structures__OC.4.c", "original_string": "void display()\n{\n    int i;\n    for(i=0;i<5;i++)\n    {\n        if(HASH[i]!=NULL)\n        {\n            printf(\"\\nvalues with index %d \\n\",i);\n            temp=HASH[i];\n            while(temp->next!=NULL)\n            {\n                printf(\"\\t%d\",temp->val);\n                temp=temp->next;\n            }\n            printf(\"\\t%d\",temp->val);\n        }\n    }\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__42_compare_2_matrix.0.c", "original_string": "int main()\n{\n  int i,j,k,r1,c1,r2,c2, flag = 0;\n  printf(\"Enter Value of r1, c1, r2, c2\\n\");\n  scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n  int m1[r1][c1], m2[r2][c2], sum = 0, mul[r1][c2];\n  if( c1==c2 && r1==r2)\n  {\n    printf(\"Enter value of Matrix1\\n\");\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        scanf(\"%d\",&m1[i][j]);\n      }\n    }\n    printf(\"Enter value of Matrix2\\n\");\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        scanf(\"%d\",&m2[i][j]);\n      }\n    }\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        if(m1[i][j] == m2[i][j])\n    {\n      flag = 1;\n    }\n    else\n        {\n          flag = 2;         \n      break;\n      }\n    }\n  }\n }\n else\n {\n   printf(\"Comparison is Not Possible\");\n }\n    if(flag == 1)\n    {\n      printf(\"Matrix Matched\");\n    }  \n    else\n    {\n      printf(\"Matrix didn't Matched\");\n    }\n}"}
{"author": "dle2005", "file": "File_Structure__read_rand.1.c", "original_string": "void GenRecordSequence(int *list, int n) {\n    int i, j, k;\n    srand((unsigned int)time(0));\n    for(i=0; i<n; i++)\n        list[i] = i;\n    for(i=0; i<SUFFLE_NUM; i++) {\n        j = rand() % n;\n        k = rand() % n;\n        swap(&list[j], &list[k]);\n    }\n    return;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_07.0.c", "original_string": "int* read(int n)\n{\n        int i;\n        int s = sizeof(int);\n        int* arr1= (int*)malloc(s * n);\n        for(i = 0; i<n; i++)\n        {\n                fscanf(F1, \"%d\", (arr1+i));\n        }\n        return arr1;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__22_While.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Senh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    while(i <= veces){\n        Suma_total += Exp(X,(i*2)+1) / Fac((i*2)+1);\n        ++i;\n    }\n    printf(\"senh(%i) es igual a %lf\", X, (Suma_total + X));\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__circularlinkedlist.3.c", "original_string": "void display()\n{\n    if(rear==NULL)\n    printf(\"\\nlist is empty\");\n    else\n    {\n        printf(\"\\nList is:\\n\");\n        for(temp=front;temp!=rear;temp=temp->next)\n        {\n            printf(\"\\t%d\",temp->val);\n        }\n        printf(\"\\t%d\",temp->val);\n        printf(\"\\t%d\",temp->next->val);\n    }\n}"}
{"author": "SugumaranEvil", "file": "Linux_programming__prc6.0.c", "original_string": "int main()\n{\n  int msgid;\n  int shmid1,i=0,j;\n  char *data_ptr;\n  int ret_msgrcv;\n  struct my_message msg_buffer;\n  char str[136];\n  msgid = msgget(1001,0644);\n  perror(\"msgget :\");\n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,11 ,0);\n  perror(\"msgrcv :\");\n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  str[i]='\\n';\n  msgid = msgget(1002,0644);\n  perror(\"msgget :\");\n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,12 ,0);\n  perror(\"msgrcv :\");\n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  str[i]='\\n';\n  msgid = msgget(1003,IPC_CREAT|0644);\n  perror(\"msgget :\");\n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,13 ,0); \n  perror(\"msgrcv :\");\n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  str[i]='\\n';\n  msgid = msgget(1004,IPC_CREAT|0644);\n  perror(\"msgget :\");\n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,14 ,0); \n  perror(\"msgrcv :\");\n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  str[i]='\\n';\n  msgid = msgget(1005,IPC_CREAT|0644);\n  perror(\"msgget :\");\n  ret_msgrcv = msgrcv(msgid, &msg_buffer, 200,15 ,0); \n  perror(\"msgrcv :\");\n  for(j=0 ;msg_buffer.Buffer[j]!='\\0'; i++ ,j++)\n     str[i]=msg_buffer.Buffer[j];\n  str[i]='\\n';\n  printf(\"i = %d\\n\",i);\n  shmid1 = shmget(111,8192,IPC_CREAT | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n  perror(\"shmget :\");\n  data_ptr = shmat(shmid1,NULL,0);\n  perror(\"shmat  :\");\n  strcpy(data_ptr,str);\n  shmdt(data_ptr);\n  perror(\"shmdt  :\");\n  return 0;\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__tcpserver.0.c", "original_string": "void main(int argc,char*argv[])\n{\n    int sid,sid1,rval;\n    struct sockaddr_in s,c;\n    char buffer[20];\n    int clen; \n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    sid=socket(AF_INET,SOCK_STREAM,6);\n    if(sid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=AF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=bind(sid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)    \n    {\n        perror(\"BIND-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    rval=listen(sid,5);\n    if(rval==-1)\n    {\n        perror(\"LISTEN-ERR:\");\n        close(sid);\n        exit(1);\n    }\n    clen=sizeof(c);\n    sid1=accept(sid,(struct sockaddr*)&c,&clen);\n    rval=recv(sid1,buffer,sizeof(buffer),0);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nClient request is %s\\n\",buffer);\n    }\n    rval=send(sid1,buffer,sizeof(buffer),0);\n    if(rval==-1)\n    {\n        perror(\"MSG-SND-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nResponse sent\\n\");\n    }\n    close(sid);\n    close(sid1);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__extr_intr.0.c", "original_string": "int main()\n{\n    IODIR1 |= LED_ALL;\n    PINSEL0 = PINSEL0 | (1<<29); \n    PINSEL0 = PINSEL0 & ~(1<<28);\n    intr_config();\n    while(1)\n    {\n            blink_led(17);\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__list-del-rev.6.c", "original_string": "int main()\n{\n    int ch;\n    node* head=NULL;\n    while(1)\n    {\n        printf(\"\\n\");\n        printf(\"1. INSERT\\n\");\n        printf(\"2. DELETE\\n\");\n        printf(\"3. REVERSE\\n\");\n        printf(\"4. COUNT\\n\");\n        printf(\"5. PRINT\\n\");\n        printf(\"6. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            printf(\"Enter the element: \");\n            scanf(\"%d\",&n);\n            head=insert(head, n);\n        }\n        else if (ch==2)\n        {\n            int key;\n            printf(\"Enter the element you want to delete: \");\n            scanf(\"%d\",&key);\n            delete(&head,key);\n        }\n        else if (ch==3)\n        {\n            if(head==NULL)\n                printf(\"Oops!, Can't REVERSE, STACK EMPTY\\n\");\n            else\n            {\n                head=rec_reverse(head);\n                printf(\"Link-List Reversed\\n\");\n            }\n        }\n        else if (ch==4)\n            printf(\"Count of elements are= %d\\n\",count(head));\n        else if (ch==5)\n        {\n            node* temp=print(head);\n            if(temp==NULL)\n                printf(\"CAN'T PRINT, STACK EMPTY\\n\");\n            else\n                printf(\"\\t%d\\n\",temp->data);\n        }\n        else if (ch==6)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid, choice try again.\\n\");\n    }\n    return 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__quick_sort.4.c", "original_string": "int main(void) {\n    printf(\"sorting the elements in the array \\n\"); \n    printf(\"quick sort \\n\");\n    int a[]={70,89,2,14,56,33,90};\n    int n=sizeof(a)/sizeof(a[0]);\n    printf(\"the elements in the array are :\\n \");\n    printarray(a,n);\n    printf(\"\\n after sorting elements in the array are :\\n\");\n    quicksort(a,0,n-1);\n    printarray(a,n);\n    return EXIT_SUCCESS;\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example11.1.c", "original_string": "int mutDeger(int x,int y)\n{\n    x+=y;\n    if(x<0)\n    {\n        x*=-1;\n        printf(\"%d\\n\",x);\n    } \n    else\n        printf(\"%d\\n\",x);\n    return x;\n}"}
{"author": "sdukesameer", "file": "c__parity_check.0.c", "original_string": "long convert(int decimalnum)\n{\n    long binarynum = 0;\n    int rem, temp = 1;\n    while (decimalnum!=0)\n    {\n        rem = decimalnum%2;\n        decimalnum = decimalnum / 2;\n        binarynum = binarynum + rem*temp;\n        temp = temp * 10;\n    }\n    return binarynum;\n}"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__2-1.0.c", "original_string": "void main(){\n  printf(\"\\n\");\n  printf(\"Range values from standard headers:\\n\");\n  printf(\"\\t -Signed-\\n\");\n  printf(\"char  : [%d, %d]\\n\", CHAR_MIN, CHAR_MAX);\n  printf(\"short : [%d, %d]\\n\", SHRT_MIN, SHRT_MAX);\n  printf(\"int   : [%d, %d]\\n\", INT_MIN, INT_MAX);\n  printf(\"long  : [%ld, %ld]\\n\\n\", LONG_MIN, LONG_MAX);\n  printf(\"\\t -Unsigned-\\n\");\n  printf(\"char  : [0, %d]\\n\", UCHAR_MAX);\n  printf(\"short : [0, %d]\\n\", USHRT_MAX);\n  printf(\"int   : [0, %u]\\n\", UINT_MAX);\n  printf(\"long  : [0, %lu]\\n\", ULONG_MAX);\n  printf(\"\\n\");\n  printf(\"Range values by direct computation:\\n\");\n  printf(\"\\t -Signed-\\n\");\n  printf(\"char  : [-%d, %d]\\n\", raise(2, sizeof(char)*CHAR_BIT - 1 ) ,\n     raise(2, sizeof(char)*CHAR_BIT - 1) - 1);\n  printf(\"short : [-%d, %d]\\n\", raise(2, sizeof(short)*CHAR_BIT - 1 ) ,\n     raise(2, sizeof(short)*CHAR_BIT - 1) - 1);\n  printf(\"int   : [%d, %d]\\n\", raise(2, sizeof(int)*CHAR_BIT - 1 ) ,\n     raise(2, sizeof(int)*CHAR_BIT - 1) - 1);\n  printf(\"long  : [-%lu, %lu]\\n\\n\",\n     l_raise(2, sizeof(long)*CHAR_BIT - 1 ) ,\n     l_raise(2, sizeof(long)*CHAR_BIT - 1) - 1);\n  printf(\"\\t -Unsigned-\\n\");\n  printf(\"char  : [0, %d]\\n\", raise(2, sizeof(char)*CHAR_BIT) - 1);\n  printf(\"short : [0, %d]\\n\", raise(2, sizeof(short)*CHAR_BIT) - 1);\n  printf(\"int   : [0, %u]\\n\", raise(2, sizeof(int)*CHAR_BIT) - 1);\n  printf(\"long  : [0, %lu]\\n\", (unsigned long)(raise(2, sizeof(long)*CHAR_BIT))-1);\n}"}
{"author": "mehedi9021", "file": "Data_Structure__insert_element.2.c", "original_string": "void inab(int data)\n{\n    struct node*peloon;\n    peloon=(struct node*)malloc(sizeof(struct node));\n    peloon->data=data;\n    peloon->next=head;\n    head=peloon;\n}"}
{"author": "bgmanuel99", "file": "PracticasArquitecturaDeComputadores__ejercicio1.0.c", "original_string": "int main(int argc, char** argv)\n{\n    clock_t t_ini, t_fin;\n    double secs;\n    int nproc=50;\n    int myrank;\n    t_ini = clock();\n    MPI_Init(&argc,&argv);\n    MPI_Comm_size (MPI_COMM_WORLD, &nproc);\n    MPI_Comm_rank (MPI_COMM_WORLD,&myrank);\n    printf(\"Hola mundo, soy el proceso %d de un total de %d \\n\",myrank,nproc);\n    MPI_Finalize();\n    t_fin = clock();\n    secs = (double)(t_fin - t_ini)/ CLOCKS_PER_SEC;\n    printf(\"%.16g milisegundos\\n\", secs * 1000.0);\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__io.9.c", "original_string": "FILELIST* getfilesfromdir(char* dir) {\n    FILELIST* filelist = NULL;\n    DIR* d = opendir(dir);\n    if(d == NULL) {\n        eprintf(\"Error while opening directory '%s': %s\\n\", dir, strerror(errno));\n        exit(errno);\n    }\n    int len = strlen(dir);\n    struct dirent* thisfile;\n    while(thisfile = readdir(d), thisfile != NULL) {\n        int thislen = strlen(thisfile->d_name);\n        if(isdotjack(thisfile->d_name, thislen)) {\n            char* fullname = getfullname(thisfile->d_name, thislen, dir, len);\n            char* name = ezheapstr(thisfile->d_name);\n            filelist = addfile(filelist, fullname, name);\n        }\n    }\n    closedir(d);\n    if(filelist == NULL) {\n        eprintf(\"Directory '%s' doesn't have any .jack file\\n\", dir);\n        exit(1);\n    }\n    return filelist;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__RR.3.c", "original_string": "void main()\n{\n    int n,i,j,temp,min,k,k1,init_temp,sum=0,T,flag=0,set=0;\n    float Waiting_time;\n    char s[10];\n    printf(\"\\nEnter time slice : \");\n    scanf(\"%d\",&T);\n    printf(\"\\nEnter the number of processess : \");\n    scanf(\"%d\",&n);\n    struct process p[n];\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter name : \");\n        scanf(\"%s\",p[i].name);\n        printf(\"\\nEnter AT : \");\n        scanf(\"%d\",&p[i].AT);\n        printf(\"\\nEnter BT : \");\n        scanf(\"%d\",&p[i].BT);\n        p[i].CT=0;\n        p[i].status=0;\n        p[i].BT1=p[i].BT;\n    }\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(p[i].AT>p[j].AT)\n            {\n                temp=p[i].AT;\n                p[i].AT=p[j].AT;\n                p[j].AT=temp;\n                temp=p[i].BT;\n                p[i].BT=p[j].BT;\n                p[j].BT=temp;\n                temp=p[i].BT1;\n                p[i].BT1=p[j].BT1;\n                p[j].BT1=temp;\n                strcpy(s,p[i].name);\n                strcpy(p[i].name,p[j].name);\n                strcpy(p[j].name,s);\n            }\n        }\n    }\n    k=0;\n    temp=0;\n    while(isempty())\n    {\n        for(i=0;i<n;i++)\n        {\n            if(p[i].AT<=temp)\n            {\n                enqueue(p[i].name[0]);\n                break;\n            }\n        }\n        if(isempty())\n            temp++;\n    }\n    while(k<n)\n    {\n        s[0]=dequeue();\n        for(i=0;i<n;i++)\n        {\n            flag=0;\n            if(p[i].name[0]==s[0] && p[i].BT1!=0)\n            {\n                printf(\"%c\\t\",s[0]);\n                flag=1;\n                set=i;\n                if(p[i].BT1>T)\n                {\n                    p[i].BT1=p[i].BT1-T;\n                    temp=temp+T;\n                    p[i].CT=temp;\n                }\n                else\n                {\n                    temp=temp+p[i].BT1;\n                    p[i].CT=temp;\n                    p[i].BT1=0;\n                }\n            }\n            if(flag==1)\n            {\n                for(j=0;j<n;j++)\n                {\n                    if(p[j].name[0]!=s[0] && p[j].AT<=temp && p[j].BT1!=0)\n                        enqueue(p[j].name[0]);\n                }\n                if(p[set].BT1!=0)\n                    enqueue(p[set].name[0]);\n                break;\n            }\n        }\n        for(i=0;i<n;i++)\n        {\n            if(p[i].BT1==0 && p[i].status==0)\n            {\n                k++;\n                p[i].status=k;\n            }\n        }   \n    }\n    printf(\"\\nstatus : \");\n    for(i=0;i<n;i++)\n        printf(\"\\t%d\",p[i].status);\n    printf(\"\\nprocess\\tAT\\tBT\\tCT\\tTAT\\tWT\");\n    k1=1;\n    while(k1<=k)\n    {\n        for(i=0;i<n;i++)\n        {\n            if(p[i].status==k1)\n            {\n                p[i].TAT=p[i].CT-p[i].AT;\n                p[i].WT=p[i].TAT-p[i].BT;\n                sum=sum+p[i].WT;\n                printf(\"\\n%s\\t%d\\t%d\\t%d\\t%d\\t%d\",p[i].name,p[i].AT,p[i].BT,p[i].CT,p[i].TAT,p[i].WT);\n                k1++;\n            }\n        }\n    }\n    Waiting_time=(sum*1.0)/n;\n    printf(\"\\nAverage Waiting_time : %f\",Waiting_time);\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.22.c", "original_string": "void freeasmlns(STRINGLIST* lns) {\n    if(lns != NULL) {\n        free(lns->content);\n        STRINGLIST* next = lns->next;\n        free(lns);\n        freeasmlns(next);\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__Md_Sameer_13000119114.11.c", "original_string": "void preorder(list* node){\n    int top=-1;\n    list *s[50];\n    while(1){\n        while(node!=NULL){\n            printf(\" %d\",node->key);\n            s[++top]=node;\n            node=node->left;\n        }\n        if(top==-1)\n            break;\n        node=s[top]->right;\n        top=top-1;\n    }\n    printf(\"\\n\");\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__receiver.3.c", "original_string": "int receive_frame(){\n    FILE *file = fopen(\"pipe.bin\", \"r\");\n    fread(&frame_len,sizeof(frame_len),1,file);\n    printf(\"[INFO] frame length: %d\\n\",frame_len);\n    if(frame_len < 64){  \n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(frame_len >1518){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    fread(&frame,sizeof(char),frame_len,file);\n    memcpy(&des_addr,&frame[0],6);\n    memcpy(&sta_addr,&frame[6],6);\n    memcpy(&protocol,&frame[12],sizeof(protocol));\n    payload = &frame[14];    \n    if(!addr_check(des_addr))   exit(1);\n    init_crc_table();\n    unsigned int crc32_temp = crc32(frame,frame_len-4);\n    unsigned char crc32_result[4];\n    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));\n    int i = 0;\n    int flag_crc32 = 1;\n    for(i = 3;i<sizeof(crc32_result);i--){\n        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;\n    }\n    if(flag_crc32){\n        printf(\"[INFO] CRC32 check success!\\n\");\n    }else {\n        printf(\"[Error] CRC32 check error!\\n\");\n        printf(\"[Error] frame's CRC32 : \");\n        printf(\"%02x %02x %02x %02x\\n\",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);\n        printf(\"[Error] calculated CRC32 : \");\n        output_octal(crc32_result,4);\n        exit(1);\n    }\n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: \");\n    output_octal(sta_addr,6);\n    printf(\"Des address  : \");\n    output_octal(des_addr,6);\n    printf(\"protocol     : %d\\n\",protocol);\n    printf(\"payload      : \");\n    output_octal(payload,frame_len-6-6-2-4);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result,4);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] Frame received success!\\n\");\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__arreglo_uni_dinamico_realloc.2.c", "original_string": "float promedio_calorias(int a[], int tam){\n    int suma = 0;\n    for (int i = 0; i < tam; i++){\n        suma += a[i];\n    }\n    return (suma/tam);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__assignment_key.2.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-util.7.c", "original_string": "LINE* mksimpleln(char** tokens, int count) {\n    LINE* ln = mkline(count);\n    for(int i = 0; i < count; i++)\n        addtoken(ln, ezheapstr(tokens[i]));\n    ln->next = NULL;\n    return ln;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.7.c", "original_string": "float minimo(float *c){\n    float min = c[0];\n    for (int i = 1; i < MAX_CALIFICACIONES; i++){\n        if (min > c[i]){\n            min = c[i];\n        }\n    }\n    return min;\n}"}
{"author": "0712023", "file": "Basis-and-Practice-in-Programming_SKKU__stage_04.0.c", "original_string": "void stage_04(char input_list[INPUT_LEN][BUF_SIZ])\n{\n  printf(\"\\n\");\n  char pnt[20] = \".\";\n  char exc[20] = \"!\";\n  char qes[20] = \"?\";\n  char at[20] = \"@\";\n  char unb[20] = \"_\";\n  char buffer[50] = \"\";\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, pnt);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, exc);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, qes);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, at);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n  for(int i = 0; i<7;i++){\n    strcpy(buffer, unb);\n    strcat(buffer, input_list[i]);\n    crack(4, buffer);\n    for(int j = 0; j<strlen(input_list[i]);j++){\n      char tmp[2] = {};\n      tmp[0] = buffer[j];\n      buffer[j] = buffer[j+1];\n      buffer[j+1] = tmp[0];\n      crack(4, buffer);\n    }\n  }\n  return;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_last_CLL.4.c", "original_string": "void insert_end()\n{\n    struct node *newnode,*temp;\n    newnode=(struct node *)malloc(sizeof(struct node));\n    printf(\"enter the data =\");\n    scanf(\"%d\",&newnode->data);\n    if(head==0)\n    {\n        head=newnode;\n        newnode->next=newnode;\n    }\n    else\n    {\n        temp=head;\n        while(temp->next!=head)\n        {\n            temp=temp->next;\n        }\n        newnode->next=head;\n        temp->next=newnode;\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__stack_using_linked_list.4.c", "original_string": "int main()\n{\n    printf(\"the stack using linked list\\n\");\n    push(2);\n    push(3);\n    push(10);\n    display();\n    peek();\n    pop();\n    peek();\n    display();\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__lcd_func.5.c", "original_string": "void delay(int ct)\n{\n    for(int i =0 ;i<ct; i++)\n    {\n        for(int j=0;j<6000;++j)\n        {\n        }\n    }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_10.4.c", "original_string": "int isMatchingPair(char character1, char character2) \n{ \n   if (character1 == '(' && character2 == ')') \n     return 1; \n   else if (character1 == '{' && character2 == '}') \n     return 1; \n   else if (character1 == '[' && character2 == ']') \n     return 1; \n   else\n     return 0; \n}"}
{"author": "sdukesameer", "file": "dsa__pre-eva.8.c", "original_string": "int main()\n{\n    while(1)\n    {\n        char exp[MAX+1];\n        printf(\"\\nTo exit enter a blank expression.\\n\");\n        printf(\"Enter a postfix expression: \");\n        gets(exp);\n        if(strlen(exp)>50){\n            printf(\"Overflow, expression length greater than 50.\\n\");\n            break;\n        }\n        else if(strlen(exp)==0){\n            printf(\"No expression found.\\n\");\n            break;\n        }\n        else\n        { \n            float ans=evaluatePrefix(exp);\n            if(ans)\n                printf(\"Prefix Evaluation: %.2f\\n\",ans);\n        }\n    }\n    return 0;\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b1.0.c", "original_string": "size_t num_rows(char *filename) {\n    size_t n = 0;\n    FILE *f = fopen(filename, \"r\");\n    for (char c = fgetc(f); c != EOF; c = fgetc(f))\n        if (c == '\\n') n++;\n    fclose(f);\n    return n;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_CLL.1.c", "original_string": "void create()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            temp=newnode;\n        }\n        temp->next=head;\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop and 1 to continue =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_28.0.c", "original_string": "int main()\n{\n        int i,j,z;\n    int a[5];\n    int b[5];\n    int c[5];\n    for(i = 0; i < 5; i++){\n        printf(\"Digite um valor para a: \", i);\n        scanf(\"%d\",&a[i]);\n    }\n        printf(\"\\n \\n\");\n    for(z = 0; z < 5; z++){\n        if( z %2 ==0){\n            c[z] = a[z];\n        printf(\"\\n vetor c(impar): %d \\n\",c[z]);\n        }\n         if( z %2 != 0){\n            b[z] = a[z];\n        printf(\"\\n vetor b (par): %d \\n\",b[z]);\n        }\n    }\n    system(\"PAUSE\");\n    return 0;\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__OptimizedSelectionsort.1.c", "original_string": "int selectionSort(int x[], int n)\n{\n    int i,j,temp,flag = 0;\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(x[i] > x[j])\n            {\n                temp = x[j];\n                x[j] = x[i];\n                x[i] = temp;\n                flag = 1;\n            }\n        }\n        if(flag == 0)\n        {\n            break;\n        }\n    }\n    printf(\"sorted array:\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\n\",x[i]);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLLcircular.1.c", "original_string": "nptr insertLeft(nptr head, int x)\n{\n    if (head == NULL)\n    {\n        nptr temp = createNode(x);\n        temp -> left = temp -> right = temp;\n        return temp;\n    }\n    else\n    {\n        nptr temp = createNode(x);\n        temp -> left = head -> left;\n        temp -> right = head;\n        head -> left = temp;\n        (temp -> left) -> right = temp;\n        return temp;\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q1_doublylq.1.c", "original_string": "void insertst(nptr* start,nptr* end,int x)\n{\n    nptr temp=createNode(x);\n    if(!*start)\n    {\n        *start=temp;\n        *end=temp;\n    }\n    else\n    {\n        temp->rlink=*start;\n        (*start)->llink=temp;\n        *start=temp;\n    }\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_cortex.1.c", "original_string": "void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)\n{ \n  uint32_t prioritygroup = 0x00U;\n  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));\n  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));\n  prioritygroup = NVIC_GetPriorityGrouping();\n  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));\n}"}
{"author": "davibernardos", "file": "DB-PJ__e60.3.c", "original_string": "int main(int argc, char *argv[]) {\n    srand(time(NULL));\n    int cont;\n    int resultado;\n    char * captcha;\n    char vetorCaptcha[7];\n    char * digitado;\n    char vetorDigitado[50];\n    resultado = 1;\n    printf(\"\\n =========\\n |CAPTCHA| \\n =========\\n\\nDite o codigo abaixo corretamente para continuar: \\n\\n\");\n    do{\n        captcha = gerarCaptcha(vetorCaptcha);\n        printf(\"%s\\n\" , captcha);\n        digitado = lerDigitado(vetorDigitado);\n        resultado = compararCaptcha(digitado , captcha);\n        if (resultado != 0)\n        {\n          printf(\"\\nIncorreto! Tente novamente:\\n\\n\");\n        }\n    }while(resultado != 0);\n    printf(\"\\nCORRETO!!!\\Agora ja pode prosseguir...\");\n    return 0;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__card_dos.1.c", "original_string": "void suffle(int wDeck[][13]){\n    int card, row, column;\n    for(card = 1; card <= 52; card++){\n        row = rand() % 4;\n        column = rand() % 13;\n        while (wDeck[row][column] != 0){\n            row = rand() % 4;\n            column = rand() % 13;\n        }\n        wDeck[row][column] = card;\n    }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__deletionAtGivenInfo.2.c", "original_string": "int main(){\n     struct Node*head,\n     *second,\n     *third, \n     *fourth, \n     *fifth, \n     *sixth, \n     *seventh;\n     head= (struct Node*)malloc(sizeof(struct Node));\n     second = (struct Node*)malloc(sizeof(struct Node));\n     third = (struct Node *)malloc(sizeof(struct Node));\n     fourth = (struct Node*)malloc(sizeof(struct Node));\n     fifth = (struct Node*)malloc(sizeof(struct Node));\n     sixth = (struct Node*)malloc(sizeof(struct Node));\n     seventh = (struct Node*)malloc(sizeof(struct Node));\n     head->data =100;\n     head->next = second;\n     second->data= 200;\n     second->next= third;\n     third->data=300;\n     third->next=fourth;\n     fourth->data=400;\n     fourth->next=fifth;\n     fifth->data=500;\n     fifth->next= sixth;\n     sixth->data=600;\n     sixth->next=seventh;\n     seventh->data=700;\n     seventh->next=NULL;\n     linkedListtraversal(head);\n     head = deleteByInfo(head, 300);\n     linkedListtraversal(head);\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__receiver0.3.c", "original_string": "int receive_frame(){\n    FILE *file = fopen(\"pipe.bin\", \"r\");\n    fread(&frame_len,sizeof(frame_len),1,file);\n    printf(\"[INFO] frame length: %d\\n\",frame_len);\n    if(frame_len < 64){  \n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(frame_len >1518){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    fread(&frame,sizeof(char),frame_len,file);\n    memcpy(&des_addr,&frame[0],6);\n    memcpy(&sta_addr,&frame[6],6);\n    memcpy(&protocol,&frame[12],sizeof(protocol));\n    payload = &frame[14];    \n    if(!addr_check(des_addr))   exit(1);\n    init_crc_table();\n    unsigned int crc32_temp = crc32(frame,frame_len-4);\n    unsigned char crc32_result[4];\n    memcpy(crc32_result,&crc32_temp,sizeof(crc32_temp));\n    int i = 0;\n    int flag_crc32 = 1;\n    for(i = 3;i<sizeof(crc32_result);i--){\n        if(crc32_result[i] != frame[frame_len-(4-i)]) flag_crc32 = 0;\n    }\n    if(flag_crc32){\n        printf(\"[INFO] CRC32 check success!\\n\");\n    }else {\n        printf(\"[Error] CRC32 check error!\\n\");\n        printf(\"[Error] frame's CRC32 : \");\n        printf(\"%02x %02x %02x %02x\\n\",frame[frame_len-4],frame[frame_len-3],frame[frame_len-2],frame[frame_len-1]);\n        printf(\"[Error] calculated CRC32 : \");\n        output_octal(crc32_result,4);\n        exit(1);\n    }\n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: \");\n    output_octal(sta_addr,6);\n    printf(\"Des address  : \");\n    output_octal(des_addr,6);\n    printf(\"protocol     : %d\\n\",protocol);\n    printf(\"payload      : \");\n    output_octal(payload,frame_len-6-6-2-4);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result,4);\n    printf(\"**************************************\\n\");\n    printf(\"[INFO] Frame received success!\\n\");\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_7_c.1.c", "original_string": "void changeArrays(unsigned int n, int * array1, int * array2, int * array3){\n    int i = 0;\n    int tempValue;\n    for(i; i < n; i++){\n        tempValue = array3[i];\n        array3[i] = array2[i];\n        array2[i] = array1[i];\n        array1[i] = tempValue;\n    }\n}"}
{"author": "2security", "file": "Star__HollowMirroredRightTriangleStar.0.c", "original_string": "int main()\n    {\n    int n,i,j;\n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<=n-i;j++)\n            printf(\" \");\n        for(j=1;j<=i;j++)\n            {\n                if(i==j||i==n||j==1)\n                    printf(\"*\");\n                else\n                    printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__25_For.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular sen(X) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X); \n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n        if(i%2 == 0)\n            Suma_total += Exp(X, (i*2)+1) / Fac((i*2)+1);\n    else\n        Suma_total -= Exp(X, (i*2)+1) / Fac((i*2)+1);\n    }\n    printf(\"sen(%i) es igual a %lf\", X, (Suma_total + X));\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_freertos.12.c", "original_string": "bool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   portBASE_TYPE ret;\n   if(timeout == INFINITE_DELAY)\n   {\n      ret = xSemaphoreTake(event->handle, portMAX_DELAY);\n   }\n   else\n   {\n      ret = xSemaphoreTake(event->handle, OS_MS_TO_SYSTICKS(timeout));\n   }\n   return ret;\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad3.0.c", "original_string": "int main()\n{\n    struct ksiazka bibl[MAXKS]; \n    int licznik = 0;\n    int index;\n    float koszt = 0;\n    printf(\"Podaj tytul ksiazki.\\n\");\n    printf(\"Aby zakonczyc, wcisnij [enter] na poczatku wiersza.\\n\");\n    while(licznik < MAXKS && gets(bibl[licznik].tytul) != NULL && bibl[licznik].tytul[0] != '\\0'){\n        printf(\"Teraz podaj autora.\\n\");\n        gets(bibl[licznik].autor);\n        printf(\"Teraz podaj wartosc.\\n\");\n        scanf(\"%f\", &bibl[licznik++].wartosc);\n        while(getchar() != '\\n')\n            continue; \n        if(licznik < MAXKS)\n            printf(\"Podaj kolejny tytul.\\n\");\n    }\n    printf(\"Oto posortowana lista Twoich ksiazek:\\n\");\n    for(index = 0; index < licznik; index++){\n        for(int j = 0; j < licznik; j++){\n            if(strcmp(bibl[j].tytul,bibl[index].tytul)>0){\n                struct ksiazka temp = bibl[index];\n                bibl[index] = bibl[j];\n                bibl[j] = temp;\n            }\n        }\n    }\n    for(index = 0; index < licznik; index++){\n        printf(\"%s, autor: %s, cena: %.2f zl\\n\", bibl[index].tytul, bibl[index].autor, bibl[index].wartosc);\n        koszt += bibl[index].wartosc;\n    }\n    printf(\"----------------------------------------------------------------\\n\");\n    printf(\"Wartosc wszystkich ksiazek: %.2f zl\\n\", koszt);\n    getchar();\n    return 0;\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__20.1.c", "original_string": "void sum(int a[][90],int r,int c)\n{\n    int i,j,sum=0;\n    if(r!=c)\n        printf(\"not a square matrix\");\n    else\n    {\n        for(i=0;i<r;i++)\n        {\n            for(j=0;j<c;j++)\n            {\n                if(j<i)\n                    sum=sum+a[i][j];\n            }\n        }\n    }\n    printf(\"%d\",sum);\n}"}
{"author": "theuwis", "file": "AdventOfCode2017__main1.0.c", "original_string": "void check_end(int * i, int * col, int * row){\n    if(*i == input){\n        printf(\"answer=%d (%d, %d)\\n\", (abs(*col) + abs(*row)), *col, *row);\n        exit(EXIT_SUCCESS);\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__display_DLL.1.c", "original_string": "void creat()\n{\n    struct node *newnode,*temp;\n    int choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_pos_DCLL.3.c", "original_string": "int count()\n{\n    struct node *temp;\n    int c=0;\n    temp=head;\n    do\n    {\n        c++;\n        temp=temp->next;\n    }while(temp!=head);\n    printf(\"the number of elements in the linked list is %d\\n\",c);\n    return c;\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__105-radix_sort.0.c", "original_string": "void countingSort(int *array, int radix, int exp, size_t size)\n{\n    int bucketIdx, *bucket = NULL, *out = NULL, i;\n    size_t j;\n    bucket = malloc(sizeof(int) * radix);\n    if (!bucket)\n        return;\n    i = 0;\n    while (i < radix)\n    {\n        bucket[i] = 0;\n        i++;\n    }\n    for (j = 0; j < size; j++)\n    {\n        bucketIdx = (array[j] / exp) % radix;\n        bucket[bucketIdx]++;\n    }\n    i = 1;\n    while (i < radix)\n    {\n        bucket[i] += bucket[i - 1];\n        i++;\n    }\n    out = malloc(sizeof(int) * size);\n    if (!out)\n    {\n        free(bucket);\n        return;\n    }\n    i = size - 1;\n    while (i >= 0)\n    {\n        bucketIdx = (array[i] / exp) % radix;\n        out[--bucket[bucketIdx]] = array[i];\n        i--;\n    }\n    for (j = 0; j < size; j++)\n        array[j] = out[j];\n    free(bucket);\n    free(out);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.2.c", "original_string": "void firmwareUpdateInfoReader_init(void)\n{\n  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);\n  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));\n  memset(updateVerificationData, 0, updateVerificationDataSize);\n  if (!createFirmwareUpdateInfoFile()) \n  {\n    return;\n  }\n  if (canOpenFirmwareUpdateInfoFile()) \n  {\n    openFirmwareUpdateInfoFile();\n  }\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Stack.0.c", "original_string": "void main()\n{\n    int choice = 0;\n    int contin = 0;\n    ptr.top = -1;\n    do{\n        printf(\"\\nPress 1 for PUSH\");\n        printf(\"\\nPress 2 for POP\");\n        printf(\"\\nPress 3 for DISPLAY\");\n        printf(\"\\nPress 4 for EXIT\");\n        printf(\"\\nEnter your choice: \");\n        scanf(\"%d\", &choice);\n        switch(choice)\n        {\n            case 1:\n                push();\n                break;\n            case 2:\n                pop();\n                break;\n            case 3:\n                display();\n                break;\n            case 4:\n                exit(0);\n                break;\n            default:\n                printf(\"\\nEnter a valid choice!!!\");\n        }\n        printf(\"\\nPress 1 to continue, else press any other number to EXIT: \");\n        scanf(\"%d\", &contin);\n    }while(contin == 1);\n}"}
{"author": "jose120918", "file": "binary_trees__15-binary_tree_is_full.0.c", "original_string": "size_t count_leaves(const binary_tree_t *tree)\n{\n    int count = 0;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    if ((*tree).right == NULL && (*tree).left == NULL)\n    {\n        return (1);\n    }\n    count = count_leaves((*tree).right) + count_leaves((*tree).left);\n    return (count);\n}"}
{"author": "tadeograch", "file": "sorting_algorithms__1-insertion_sort_list.0.c", "original_string": "void insertion_sort_list(listint_t **list)\n{\n    listint_t *temp_n, *temp_sort, *swapper;\n    if (!list || *list == NULL)\n        return;\n    if ((*list)->next == NULL)\n        return;\n    temp_n = *list;\n    while (temp_n != NULL)\n    {\n        temp_sort = temp_n;\n        if (temp_sort->prev != NULL)\n        {\n            while (temp_sort->n < (temp_sort->prev)->n && temp_sort->prev != NULL)\n            {\n                swapper = temp_sort->prev;\n                if (swapper->prev == NULL)\n                {\n                    swap(temp_sort, swapper, list);\n                    print_list(*list);\n                    break;\n                }\n                swap(temp_sort, swapper, list);\n                print_list(*list);\n            }\n        }\n        temp_n = temp_n->next;\n    }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__fprime.0.c", "original_string": "void    fprime(int nb)\n{\n    int i;\n    i = 2;\n    if (nb == 1)\n    {\n        printf(\"1\");\n        return ;\n    }\n    while (nb >= i)\n    {\n        if (nb % i == 0)\n        {\n            printf(\"%d\",i);\n            if (nb != i)\n            {\n                printf(\"%c\",'*');\n                nb /= i;\n                i--;\n            }\n        }\n        i++;\n    }\n}"}
{"author": "fikepaci", "file": "monty__int_to_string.0.c", "original_string": "char *get_int(int num)\n{\n    unsigned int temp;\n    int length = 0;\n    long num_l = 0;\n    char *ret;\n    temp = _abs(num);\n    length = get_numbase_len(temp, 10);\n    if (num < 0 || num_l < 0)\n        length++; \n    ret = malloc(length + 1); \n    if (!ret)\n        return (NULL);\n    fill_numbase_buff(temp, 10, ret, length);\n    if (num < 0 || num_l < 0)\n        ret[0] = '-';\n    return (ret);\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es20.0.c", "original_string": "int main(void) {\n  int a, b, c;\n  int risultato;\n  printf(\"Primo numero: \");\n  scanf(\"%d\", &a);\n  printf(\"Secondo numero: \");\n  scanf(\"%d\", &b);\n  printf(\"Terzo numero: \");\n  scanf(\"%d\", &c);\n  risultato = max_finder(a,b,c);\n  printf( \"Risultato: %d\\n\", risultato ); \n  return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-statements.3.c", "original_string": "STATEMENT* parselet(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, letstatement);\n    LETSTATEMENT* letst = (LETSTATEMENT*)malloc(sizeof(LETSTATEMENT));\n    letst->varname = parseidentifier(p);\n    if(equals(p, \"[\")) {\n        next(p);\n        letst->arrayind = parseexpression(p);\n        checkcontent(p, \"]\");\n    }\n    else\n        letst->arrayind = NULL;\n    checkcontent(p, \"=\");\n    letst->expression = parseexpression(p);\n    checkcontent(p, \";\");\n    s->type = letstatement;\n    s->letstatement = letst;\n    return s;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes2.11.c", "original_string": "void menu_modificacion_calificaciones(){\n    int opt = 0;\n    int posicion = posicion_alumno();\n    while(opt != 5) {\n        imprimir_menu_calificaciones();\n        scanf(\"%d\", &opt);\n        if (opt < MAX_CALIFICACIONES + 1) {\n            printf(\"La calificaci\u00f3n actual es: %f\\n\", \n                lista_estudiantes[posicion].calificaciones[opt-1]);\n            printf(\"Ingresa nueva calificaci\u00f3n %d:\", opt-1);\n            scanf(\"%f\", &lista_estudiantes[posicion].calificaciones[opt-1]);\n        }\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__bst-del_int-iter_in-pre.3.c", "original_string": "node* deletion(node* root, int n)\n{\n    if (root==NULL) return root;\n    if (n<root->data)\n        root->left=deletion(root->left,n);\n    else if (n>root->data)\n        root->right=deletion(root->right,n);\n    else\n    {\n        if(root->left==NULL)\n        {\n            node* temp=root->right;\n            free(root);\n            return temp;\n        }\n        else if(root->right==NULL)\n        {\n            node* temp=root->left;\n            free(root);\n            return temp;\n        }\n        node* temp=root->right;\n        while (temp&&temp->left!=NULL)\n            temp=temp->left;\n        root->data=temp->data;\n        root->right=deletion(root->right,temp->data);\n    }\n    return root;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__stack_using_linked_list.0.c", "original_string": "void push(int x)\n{\n    struct node *newnode;\n    newnode=(struct node*)malloc(sizeof(struct node));\n    newnode->data=x;\n    newnode->next=top;\n    top=newnode;\n    printf(\"the element pushed into the stack is %d\\n\",x);\n}"}
{"author": "earth429", "file": "mulpre__mulprec1.6.c", "original_string": "int isZero(struct NUMBER *a){\n    int i;\n    for (i = 0; i < KETA;i++){\n        if(a->n[i] != 0){\n            return -1;\n        }\n    }\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__studentStruct.2.c", "original_string": "int main()\n{\n    int n;\n    printf(\"Enter no. of students:\");\n    scanf(\"%d\", &n);\n    STUDENT* ptr = calloc(n, sizeof(STUDENT));\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"\\nEnter data of %dth student: \\n\", i + 1);\n        readData(ptr + i);\n    }\n    for(int i = 0 ; i < n - 1 ; i++)\n    {\n        STUDENT temp;\n        for(int j = 0 ; j < n - i - 1 ; j++)\n            if( ptr[j].rollNum  > ptr[j+1].rollNum )\n            {\n                temp = ptr[j];\n                ptr[j] = ptr[j+1];\n                ptr[j+1] = temp;\n            }\n    }\n    for(int i = 0 ; i < n ; i++)\n    {\n        printf(\"\\nData of %dth student: \\n\", i + 1);\n        printData(ptr + i);\n    }\n    free(ptr);\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client_thread.1.c", "original_string": "void communication(int socket_client) {\n    int* pclient = malloc(sizeof(int));\n    *pclient = socket_client;\n    pthread_t send_msg_thread;\n    if (pthread_create(&send_msg_thread, NULL, (void *)send_msg_handler, pclient) != 0)\n    {\n        printf(\"ERROR: pthread\\n\");\n        return EXIT_FAILURE;\n    }\n    pthread_t recv_msg_thread;\n    if (pthread_create(&recv_msg_thread, NULL, (void *)recv_msg_handler, pclient) != 0)\n    {\n        printf(\"ERROR: pthread\\n\");\n        return EXIT_FAILURE;\n    }\n    block();\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__4.2.c", "original_string": "double area(rect_t retangulo)\n{\n    double area = (retangulo.sup_esq.x - retangulo.inf_dir.x) * (retangulo.sup_esq.y - retangulo.inf_dir.y);\n    return (area < 0) ? area*(-1) : area;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__create_list_with_function.1.c", "original_string": "void createlist(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int i, data;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n;i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=temp->next;\n    }\n}"}
{"author": "kalpa96", "file": "c-programing__power.0.c", "original_string": "int main(){\n    int n1,n2;\n    printf(\"Enter the number 1 :\\n\");\n    scanf(\"%d\",&n1);\n    printf(\"Enter the number 2 :\\n\");\n    scanf(\"%d\",&n2);\n    po(n1,n2);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__stackUsingArray.2.c", "original_string": "int main(){\n     struct stack * s;\n     s->size = 80;\n     s->top = -1;\n     s->arr = (int*)malloc(s->size*sizeof(int));\n     s->arr[0]= 7;\n     s->top++;\n     if(isEmpty(s)){\n          printf(\"The stack is empty..\\n\");\n     }\n     else{\n          printf(\"The stack is not empty..\\n\");\n     }\n     return 0;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__ft_split.0.c", "original_string": "char    **ft_split(char *str)\n{\n    char    **tab;\n    int i;\n    int i2;\n    int i3;\n    i = 0;\n    i2 = 0;\n    tab = (char**)malloc(sizeof(char**) * 1000);\n    while (str[i])\n    {\n        if (str[i] > 32)\n        {\n            i3 = 0;\n            tab[i2] = (char*)malloc(sizeof(char*) * 1000);\n            while (str[i] > 32)\n            {\n                tab[i2][i3] = str[i];\n                i++;\n                i3++;\n            }\n            tab[i2][i3] = '\\0';\n            i2++;\n        }\n        i++;\n    }\n    tab[i2] = 0;\n    return (tab);\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_03.4.c", "original_string": "int binary_bitonic(int arr[],int str, int end ) \n{ \n    int mid; \n    mid = (str + end) / 2; \n    if(arr[mid] > arr[mid-1] && arr[mid] > arr[mid + 1]) \n    { \n        return mid; \n    } \n    else if(arr[mid] > arr[mid - 1] && arr[mid] < arr[mid + 1]) \n    { \n        binary_bitonic(arr, mid , end); \n    } \n    else if(arr[mid] < arr[mid - 1] && arr[mid] > arr[mid + 1]) \n    { \n        binary_bitonic(arr, str, mid); \n    } \n}"}
{"author": "mehedi9021", "file": "C_Programming__order_and_coefficient_of_mattrix.0.c", "original_string": "int main()\n{\n    int array[10][10];\n    int i, j, m, n, sum = 0;\n    printf(\"Enter the order of the matrix\\n\");\n    scanf(\"%d %d\", &m, &n);\n    printf(\"Enter the co-efficients of the matrix\\n\");\n    for (i = 0; i < m; ++i)\n    {\n        for (j = 0; j < n; ++j)\n        {\n            scanf(\"%d\", &array[i][j]);\n        }\n    }\n    for (i = 0; i < m; ++i)\n    {\n        for (j = 0; j < n; ++j)\n        {\n            sum = sum + array[i][j] ;\n        }\n        printf(\"Sum of the %d row is = %d\\n\", i, sum);\n        sum = 0;\n    }\n    sum = 0;\n    for (j = 0; j < n; ++j)\n    {\n        for (i = 0; i < m; ++i)\n        {\n            sum = sum + array[i][j];\n        }\n        printf(\"Sum of the %d column is = %d\\n\", j, sum);\n        sum = 0;\n    }\n    return 0;\n}"}
{"author": "theuwis", "file": "AdventOfCode2017__main21.1.c", "original_string": "int main(void){\n    for(int i = 0; i < SIZE; i++){\n        for(int j = 0; j < SIZE; j++){\n            grid[i][j] = 0;\n        }\n    }\n    int col = (SIZE - 1) / 2, row = (SIZE - 1) / 2;\n    int current_ring_multiplier = 1;\n    grid[row][col] = 1;\n    while(1){\n        col++;\n        grid[row][col] = get_value(&row, &col);\n        for(int j = 0; j < current_ring_multiplier; j++){\n            row--;\n            grid[row][col] = get_value(&row, &col);\n        }\n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            col--;\n            grid[row][col] = get_value(&row, &col);\n        }\n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            row++;\n            grid[row][col] = get_value(&row, &col);\n        }\n        for(int j = 0; j < current_ring_multiplier + 1; j++){\n            col++;\n            grid[row][col] = get_value(&row, &col);\n        }\n        current_ring_multiplier += 2;\n    }\n    return EXIT_SUCCESS;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es1.0.c", "original_string": "int somma(int a[], int dim){\n  int s = 0; \n  for(int i=0; i<dim; i++){\n    s+=a[i];\n  }\n  return s;\n}"}
{"author": "sdukesameer", "file": "dsa__list-ins-seq-sor_acend_decend.2.c", "original_string": "void sorted_insert_asc(node** head, int inp)\n{\n    node* newnode=createnode(inp);\n    if(*head==NULL||newnode->data < (*head)->data)\n    {\n        newnode->next=*head;\n        *head=newnode;\n        printf(\"%d inserted\\n\",(*head)->data);\n    }\n    else\n    {\n        node* temp=*head;\n        while(temp->next!=NULL&&temp->next->data < newnode->data)\n            temp=temp->next;\n        newnode->next=temp->next;\n        temp->next=newnode;\n        printf(\"%d inserted\\n\",temp->next->data);\n    }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_extended.2.c", "original_string": "uint32_t ble_lbs_init(ble_lbs_t * p_lbs, const ble_lbs_init_t * p_lbs_init)\n{\n    uint32_t              err_code;\n    ble_uuid_t            ble_uuid;\n    ble_add_char_params_t add_char_params;\n    p_lbs->led_write_handler = p_lbs_init->led_write_handler;\n    p_lbs->led_col_write_handler = p_lbs_init->led_col_write_handler;\n    ble_uuid128_t base_uuid = {LBS_UUID_BASE};\n    err_code = sd_ble_uuid_vs_add(&base_uuid, &p_lbs->uuid_type);\n    VERIFY_SUCCESS(err_code);\n    ble_uuid.type = p_lbs->uuid_type;\n    ble_uuid.uuid = LBS_UUID_SERVICE;\n    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_lbs->service_handle);\n    VERIFY_SUCCESS(err_code);\n    memset(&add_char_params, 0, sizeof(add_char_params));\n    add_char_params.uuid              = LBS_UUID_BUTTON_CHAR;\n    add_char_params.uuid_type         = p_lbs->uuid_type;\n    add_char_params.init_len          = sizeof(uint8_t);\n    add_char_params.max_len           = sizeof(uint8_t);\n    add_char_params.char_props.read   = 1;\n    add_char_params.char_props.notify = 1;\n    add_char_params.read_access       = SEC_OPEN;\n    add_char_params.cccd_write_access = SEC_OPEN;\n    err_code = characteristic_add(p_lbs->service_handle,\n                                  &add_char_params,\n                                  &p_lbs->button_char_handles);\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n    memset(&add_char_params, 0, sizeof(add_char_params));\n    add_char_params.uuid             = LBS_UUID_LED_CHAR;\n    add_char_params.uuid_type        = p_lbs->uuid_type;\n    add_char_params.init_len         = sizeof(uint8_t);\n    add_char_params.max_len          = sizeof(uint8_t);\n    add_char_params.char_props.read  = 1;\n    add_char_params.char_props.write = 1;\n    add_char_params.read_access  = SEC_OPEN;\n    add_char_params.write_access = SEC_OPEN;\n    err_code = characteristic_add(p_lbs->service_handle, &add_char_params, &p_lbs->led_char_handles);\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n    memset(&add_char_params, 0, sizeof(add_char_params));\n    add_char_params.uuid             = LBS_UUID_LED_COL_CHAR;\n    add_char_params.uuid_type        = p_lbs->uuid_type;\n    add_char_params.init_len         = sizeof(uint32_t);\n    add_char_params.max_len          = sizeof(uint32_t);\n    add_char_params.char_props.read  = 1;\n    add_char_params.char_props.write = 1;\n    add_char_params.read_access  = SEC_OPEN;\n    add_char_params.write_access = SEC_OPEN;\n    err_code = characteristic_add(p_lbs->service_handle, &add_char_params, &p_lbs->led_col_char_handles);\n    if (err_code != NRF_SUCCESS)\n    {\n        return err_code;\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__timer0_timer1_isr.2.c", "original_string": "void intr_config(void)\n{\n        VICIntSelect = VICIntSelect & ~((1<<4)|(1<<5)); \n        VICVectCntl2 = (1<<5)|4;   \n        VICVectAddr2 = (long)&timer0_isr;\n        VICVectCntl1 = (1<<5)|5;   \n        VICVectAddr1 = (long)&timer1_isr;\n        VICIntEnable = (1<<5)|(1<<4);   \n}"}
{"author": "2security", "file": "Array__RemoveDuplicates.1.c", "original_string": "int removeDuplicates(int arr[],int n)\n    {\n    int i,j=0,*temp,k;\n    if(n==0||n==1)\n        return n;\n    temp=(int *)malloc((n)*sizeof(int *));\n    for(i=0;i<n;i++)\n        {\n        for(j=i+1;j<n;)\n            {\n            if(arr[i]==arr[j])\n                {\n                for(k=j;k<n;k++)\n                    arr[k]=arr[k+1];\n                n--;\n                }\n            else\n                j++;    \n            }\n        }\n    return n;\n    }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__10_Dowhile.0.c", "original_string": "int main()\n{\n    system(\"cls\"); \n    int contador = 1;\n    int X_1 = 1;\n    int X_2 = 80;\n    do{\n        if(contador <= 80){\n            if(contador == X_1)\n                printf(\"X\");\n            else if(contador == X_2)\n                printf(\"X\");\n            else\n                printf(\" \");\n         }else{\n             sleep(0.4);\n             system(\"cls\");\n             ++X_1;\n             --X_2;\n            contador = 1;\n         }\n    ++contador;\n    }while(X_1 != 41);\n    return 0;\n}"}
{"author": "earth429", "file": "mulpre__multiple.1.c", "original_string": "int multiple(struct NUMBER *a, struct NUMBER *b, struct NUMBER *c) {\n    int i, j, h, e, aj, bi;\n    struct NUMBER tmp, d;\n    clearByZero(c);\n    dispNumberZeroSuppress(a);\n    dispNumberZeroSuppress(b);\n    for (i = 0; i < KETA;i++){\n        printf(\"i\u306f\u3053\u3053\u3067\u3059\u3088%d\\n\", i);\n        bi = b->n[i];\n        h = 0;\n        clearByZero(&d);\n        for (j = 0; j < KETA;j++){\n            aj = a->n[j];\n            printf(\"aj:%d\\nbi%d\\n\", aj, bi);\n            e = aj * bi + h; \n            printf(\"e:%d\\n\", e); \n            if(j + i < KETA){\n                d.n[j + i] = (e % 10); \n                printf(\"dl:\");\n                dispNumberZeroSuppress(&d);\n                puts(\"\");\n                e /= 10;\n                h = e; \n            }\n        }\n        if(h != 0){ \n            return -1;\n        }\n        printf(\"c:\");\n        dispNumberZeroSuppress(c);\n        printf(\"d:\");\n        dispNumberZeroSuppress(&d);\n        puts(\"\");\n        add(c, &d, &tmp);\n        copyNumber(&tmp, c);\n    }\n    return 0; \n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__90.2.c", "original_string": "void exibe_aprovados(FILE *arq)\n{\n    aluno_t aluno;\n    int media;\n    while (fread(&aluno, sizeof(aluno_t), 1, arq) != 0)\n    {\n        media = ((aluno.prova[0] * 2) + (aluno.prova[1] * 3) + (aluno.prova[2] * 3) + (aluno.trab[0] + aluno.trab[1])) / 10;\n        if (media >= 6.0)\n        {\n            printf(\"\\nNome: %s\\n\", aluno.nome);\n            printf(\"\\t-> Prova 1: %i\\n\", aluno.prova[0]);\n            printf(\"\\t-> Prova 2: %i\\n\", aluno.prova[1]);\n            printf(\"\\t-> Prova 3: %i\\n\", aluno.prova[3]);\n            printf(\"\\t-> Trabalho 1: %i\\n\", aluno.trab[0]);\n            printf(\"\\t-> Trabalho 2: %i\\n\", aluno.trab[1]);\n        }\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q1_doublylq.0.c", "original_string": "nptr createNode(int x)\n{\n    nptr temp=(nptr)malloc(sizeof(node));\n    temp->ele=x;\n    temp->llink=NULL;\n    temp->rlink=NULL;\n    return temp;\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__additional_check.0.c", "original_string": "void    check_crgb(char **colors, int cc, int cw)\n{\n    if (g_cr != -1 && g_cg != -1 && g_cb != -1)\n    {\n        ft_putstr(\"Error\\ndouble includion\\n\");\n        exit(0);\n    }\n    if (cc != 3 || cw != 2)\n    {\n        ft_putstr(\"Error\\nWrong number of parametres in ceiling colors!\\n\");\n        exit(0);\n    }\n    else if (!array_is_rgb(colors))\n    {\n        ft_putstr(\"Error\\nWrong parametres in ceiling colors!\\n\");\n        exit(0);\n    }\n    else\n        get_crgb(atoi(&colors[0][0]), atoi(&colors[1][0]), atoi(&colors[2][0]));\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_beg_CLL.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"the function of circular linked list\\n\");\n    printf(\"1.implementation of linked list\\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.delete the element from the beginning position\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter your choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation of linked list\\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4:printf(\"delete the element from the beginning position\\n\");\n            delete_beg();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice \\n\");\n            break;\n        }\n        printf(\"enter your choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "Theemiss", "file": "simple_shell__finding_path.2.c", "original_string": "char *_getenv(char *name)\n{\n    size_t nl, vl;\n    char *value;\n    int i, x, j;\n    nl = _strlen(name);\n    for (i = 0 ; environ[i]; i++)\n    {\n        if (_strncmp(name, environ[i], nl) == 0)\n        {\n            vl = _strlen(environ[i]) - nl;\n            value = malloc(sizeof(char) * vl);\n            if (!value)\n            {\n                free(value);\n                perror(\"unable to alloc\");\n                return (NULL);\n            }\n            j = 0;\n            for (x = nl + 1; environ[i][x]; x++, j++)\n            {\n                value[j] = environ[i][x];\n            }\n            value[j] = '\\0';\n            return (value);\n        }\n    }\n    return (NULL);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__spi_decode.1.c", "original_string": "void spi_data(int data)\n{\n    IOCLR0  =   (1<<7);         \n    S0SPDR = data;              \n    while(!(S0SPSR & (1<<7)));\n    IOSET0 = (1<<7);            \n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__planetas.13.c", "original_string": "int main(int argc, char *argv[]){\n    glutInit(&argc,argv);\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);\n    glutInitWindowPosition(50,50);\n    glutInitWindowSize(700,700);\n    glutCreateWindow(\"Planetas\");\n    glutDisplayFunc(display);\n    glutSpecialFunc(rotacionarPlaneta);\n    glutTimerFunc(5, executaAnimacao, 1);\n    glutMouseFunc(mouse);\n    init();\n    initTexture();\n    glutMainLoop();\n    return 0;\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_7_b.1.c", "original_string": "void biggerElement(unsigned int n, int * array1, int * array2, int * array3){\n    int i = 0;\n    for(i; i < n; i++){\n        if(array1[i] > array2[i]){\n            array3[i] = array1[i];\n        } else {\n            array3[i] = array2[i];\n        }\n    }\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Single.2.c", "original_string": "void rem_file(char name)\n{\n    if(isthere(name)==-1)\n        printf(\"\\nFile does not exist\");\n    else\n    {\n        temp=start;\n        q=temp;\n        while(temp->next!=NULL)\n        {\n            if(temp->file==name)\n            {\n                if(temp==start)\n                {\n                    start=start->next;\n                    free(temp);\n                    temp=start;\n                }\n                else\n                {\n                    q->next=temp->next;\n                    free(temp);\n                    temp=q->next;\n                }\n            }\n            q=temp;\n            temp=temp->next;\n        }\n        if(temp->file==name)\n        {\n            q->next=NULL;\n            free(temp);\n        }\n    }\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__24_For.1.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular ln(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X); \n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n       if(i%2 == 0)\n      Suma_total += Exp(X-1, i+1) / (i+1);\n       else\n      Suma_total -= Exp(X-1, i+1) / (i +1);\n    }\n    printf(\"ln(%i) es igual a %lf\", X, (Suma_total + (X - 1)));\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader.2.c", "original_string": "void firmwareUpdateInfoReader_run(void)\n{\n  char updateInfoString[260 + 1] = \"\";\n  if (!loadFirmwareUpdateInfoFile(updateInfoString, sizeof(updateInfoString))) \n  {\n    memset(lastUpdateInfoString, 0, sizeof(lastUpdateInfoString));\n    return;\n  }\n  if (strncmp(updateInfoString, lastUpdateInfoString, 260) == 0) \n  {\n    return;\n  }\n  strncpy(lastUpdateInfoString, updateInfoString, 260);\n  if (!parseFirmwareUpdateInfo(updateInfoString)) \n  {\n    return;\n  }\n  printf(\"Firmware update request towards version %s received\\n\", updateVersion);\n  fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__59_check_palindrom.0.c", "original_string": "int main()\n{\n  int i,j = 0,k, count = 0, count1 = 0;\n  char str_arr[100], str_arr1[100], f;\n  printf(\"Enter String to find It's palindrom or Not\\n\");\n  scanf(\"%[^\\n]s\",str_arr);\n  for(i=0; str_arr[i] != '\\0'; i++)\n  {\n    count++;\n  }\n  for(i=count-1; i>=0; i--)\n  {\n    str_arr1[j] = str_arr[i];\n    j++;\n  }\n  str_arr1[i] = '\\0';\n  printf(\"String After Reverse is %s\\n\",str_arr1);\n  for(i=0; str_arr[i] != '\\0'; i++)\n  {\n    if(str_arr[i] == str_arr1[i])\n    {\n    count1++;\n    }\n  }\n  printf(\"Value of Count1 is %d Count is %d\\n\",count1,count);\n  if(count1 == count)\n  {\n    printf(\"String is Palindrom\\n\");\n  }\n  else\n  {\n    printf(\"Not a Palindrom String\\n\");\n  }\n}"}
{"author": "fikepaci", "file": "binary_trees__16-binary_tree_is_perfect.3.c", "original_string": "int is_perfect_recursive(const binary_tree_t *tree,\n        size_t leaf_depth, size_t level)\n{\n    if (is_leaf(tree))\n        return (level == leaf_depth ? 1 : 0);\n    if (tree->left == NULL || tree->right == NULL)\n        return (0);\n    return (is_perfect_recursive(tree->left, leaf_depth, level + 1) &&\n            is_perfect_recursive(tree->right, leaf_depth, level + 1));\n}"}
{"author": "2security", "file": "String__4CompareTwoString.0.c", "original_string": "int Mystrcompare(char *str1,char *str2)\n    {\n    int m=Mystrlen(str1),flag=0,i;\n    int n=Mystrlen(str2);\n    if(m>n)\n        return m-n;\n    else if(m<n)\n        return m-n;\n    else \n        {\n        for(i=0;i<m;i++)\n            {\n                if(str1[i]!=str2[i])\n                    {\n                        flag=1;\n                        break;\n                    }\n            }\n            if(flag==0)\n                return 0;\n            else \n                return 1;\n        }\n    }"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__shell_server.6.c", "original_string": "error_t shellServerWriteStream(ShellServerSession *session, const void *data,\n   size_t length, size_t *written, uint_t flags)\n{\n   error_t error;\n   if(session != NULL)\n   {\n      error = sshWriteChannel(session->channel, data, length, written, flags);\n   }\n   else\n   {\n      error = ERROR_INVALID_PARAMETER;\n   }\n   return error;\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.16.c", "original_string": "ASMBLK* copytemplate(TEMPLATE* t) {\n    ASMBLK* blk = (ASMBLK*)malloc(sizeof(ASMBLK));\n    blk->head = asmln(t->items[0]);\n    STRINGLIST* curr = blk->head;\n    for(int i = 1; i < t->count; i++) {\n        STRINGLIST* newln = asmln(t->items[i]);\n        curr->next = newln;\n        curr = newln;\n    }\n    curr->next = NULL;\n    blk->tail = curr;\n    return blk;\n}"}
{"author": "Dhruvik-Chevli", "file": "DAALab__consgcd.0.c", "original_string": "int GCD(int a ,int b)\n{\n    int c;\n    int opcount=0;\n    if(b<a)\n    {   \n        a=a^b;\n        b=a^b;\n        a=a^b;\n    }\n    c=a;\n    while(1)\n    {\n        opcount++;\n        if(a%c==0 && b%c==0)\n        {\n            printf(\"opcount: %d\\n\",opcount);\n            return c;\n        }\n        c-=1;\n    }\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__OptimizedSelectionsort.0.c", "original_string": "int main()\n{\n    int z,res;\n    printf(\"enter the no.of elements:\");\n    scanf(\"%d\",&z);\n    int arr[z];\n    int i;\n    printf(\"the elements are:\\n\");\n    for(i=0;i<z;i++)\n    {\n        scanf(\"%d\",&arr[i]);\n    }\n    res = selectionSort(arr,z); \n    return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__2.6.c", "original_string": "complex_t multiplicacao(complex_t a, complex_t b)\n{\n    complex_t c;\n    c.real = (a.real * b.real) - (a.imaginario * b.imaginario);\n    c.imaginario = (a.real * b.imaginario) + (a.imaginario * b.real);\n    return c;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__15_.2.c", "original_string": "void Filas(int contador, int contador2)\n{\n    printf(\"\\n\");\n    if(contador < 8){\n        if(contador >= 4){\n            Columnas(1,contador2);\n            Filas(++contador,--contador2);\n        }else{\n            Columnas(1,contador);\n            Filas(++contador, --contador2);\n        }\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__util.8.c", "original_string": "void printstrlist(STRINGLIST* strlist, FILE* stream) {\n    while(strlist != NULL) {\n        fprintf(stream, \"%s\\n\", strlist->content);\n        strlist = strlist->next;\n    }\n}"}
{"author": "MFarid94", "file": "Assignment4__Exercise7.0.c", "original_string": "void Swap(int *X, int *Y){\n    *X = *X ^ *Y;\n    *Y = *X ^ *Y;\n    *X = *X ^ *Y;\n}"}
{"author": "sdukesameer", "file": "dsa__n-bishop-a.2.c", "original_string": "void bishops(int arr[N][N], int c){\n    if(c>=N){\n        printboard(arr);\n        if(N>1){\n            int trs[N][N];\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                    trs[j][i]=arr[i][j];\n            printboard(trs);\n        }\n        return;\n    }\n    for (int i = 0; i < N; i++){\n        if(safe(arr,i,c)){\n            arr[i][c]=1;\n            bishops(arr,c+1);\n            arr[i][c]=0;\n        }\n    }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e160.0.c", "original_string": "char * gerarCaptcha(char captcha[6])\n{\n    int cont, num;\n    srand(time(NULL));\n    for(cont = 0; cont < 6; cont++)\n    {\n        num = rand() % 3;\n        if(num == 0)\n            captcha[cont] = 65 + (rand() % 26);\n        else\n            if(num == 1)\n                captcha[cont] = 97 + (rand() % 26);\n            else\n                captcha[cont] = 48 + (rand() % 10);\n    }\n    return captcha;\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__primenosbetw2.0.c", "original_string": "int main()\n{\n    int low,high,i,temp,flag;\n    printf(\"enter the lower number:\");\n    scanf(\"%d\",&low);\n    printf(\"enter the higher number:\");\n    scanf(\"%d\",&high);\n    if(low>high)\n    {\n        temp = low;\n        low = high;\n        high = temp;\n    }\n    while(low<high)\n    {\n        flag = 0;\n        if(low<=1)\n        {\n            low++;\n            continue;\n        }\n        for(i = 2;i <= low/2; i++)\n        {\n            if(low%i == 0)\n            {\n                flag = 1;\n                break;\n            }\n        }\n        if(flag == 0)\n        printf(\"%d\\n\", low);\n        low++;\n    }\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zadOsmi.7.c", "original_string": "StackPosition AllocateMemoryForStack()\n{\n    StackPosition newStackElement = (StackPosition)malloc(sizeof(Dir));\n    if (!newStackElement)\n    {\n        printf(\"Can not allocate memory!\\n\");\n    }\n    return newStackElement;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader.9.c", "original_string": "static bool parseFirmwareUpdateInfo(char *updateInfoString)\n{\n  memset(updateVersion, 0, sizeof(updateVersion));\n  memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n  if (strstr(updateInfoString, UPDATE_INFO_SEPARATOR) == NULL) \n  {\n    printf(\"Firmware update request with missing version and/or verification data entered\\n\");\n    return false;\n  }\n  char *parsedVersion = strtok(updateInfoString, UPDATE_INFO_DELIMITERS);\n  if (parsedVersion == NULL) \n  {\n    printf(\"Firmware update request with missing version and verification data entered\\n\");\n    return false;\n  }\n  if (strlen(parsedVersion) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) \n  {\n    printf(\"Received firmware update version too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH);\n    return false;\n  }\n  strncpy(updateVersion, parsedVersion, sizeof(updateVersion));\n  char *parsedVerificationData = strtok(NULL, UPDATE_INFO_DELIMITERS);\n  if (parsedVerificationData == NULL) \n  {\n    printf(\"Firmware update request with missing version or verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (strlen(parsedVerificationData) > getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM) << 1) \n  {\n    printf(\"Received firmware update verification data too long (max. length = %hhu)\\n\", MAX_UPDATE_VERSION_LENGTH << 1);\n    memset(updateVersion, 0, sizeof(updateVersion));\n    return false;\n  }\n  if (convertHexString8ToBinData(parsedVerificationData, strlen(parsedVerificationData), updateVerificationData, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM)) == 0) \n  {\n    printf(\"Firmware update request with invalid verification data entered\\n\");\n    memset(updateVersion, 0, sizeof(updateVersion));\n    memset(updateVerificationData, 0, getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM));\n    return false;\n  }\n  return true;\n}"}
{"author": "andi-s0106", "file": "binary_trees__12-binary_tree_leaves.1.c", "original_string": "size_t count_leaves(const binary_tree_t *tree, size_t leaves)\n{\n    size_t left;\n    size_t right;\n    left = leaves;\n    right = leaves;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    if (tree->left == NULL && tree->right == NULL)\n    {\n        return (1);\n    }\n    left = count_leaves(tree->left, leaves);\n    right = count_leaves(tree->right, leaves);\n    return (left + right);\n}"}
{"author": "behergue", "file": "Operating_Systems__fuseLib.6.c", "original_string": "static int my_release(const char *path, struct fuse_file_info *fi)\n{\n    (void) path;\n    (void) fi;\n    fprintf(stderr, \"--->>>my_release: path %s\\n\", path);\n    return 0;\n}"}
{"author": "ankitraj311", "file": "450_babbar__3_kth_small_SELF_MADE.2.c", "original_string": "int main()\n{\n  int arr[100] = {1000, 11, 445, 1, 330, 3000};\n  int no = 6,k=0,rindex=0;\n  printf(\"Array is :- \");\n  array_print(arr,no);\n  printf(\"Enter value of kth\");\n  scanf(\"%d\",&k);\n  rindex = kmin(arr,(no-1),(k-1));\n  printf(\"rindex is %d\\n\",rindex);\n  printf(\"kth Min value is %d\",arr[rindex]);\n}"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio11.0.c", "original_string": "void *productor(void *arg){\n    int i = 0;\n    printf(\"Lleno el buffer para mi consumidor\\n\");\n    pthread_mutex_lock(&count_mutex); \n    for(i; i < 10;i++ ){\n        buffer[i]=i+1;\n    }\n    printf(\"He terminado y permito a mi consumidor leer el buffer\\n\");\n    pthread_cond_signal(&count_threshold_cv);\n    pthread_mutex_unlock(&count_mutex);\n    sleep(1);\n    pthread_exit(NULL);\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_sys_bios.16.c", "original_string": "bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   Bool ret;\n   if(timeout == 0)\n   {\n      ret = Semaphore_pend(semaphore->handle, BIOS_NO_WAIT);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      ret = Semaphore_pend(semaphore->handle, BIOS_WAIT_FOREVER);\n   }\n   else\n   {\n      ret = Semaphore_pend(semaphore->handle, OS_MS_TO_SYSTICKS(timeout));\n   }\n   return ret;\n}"}
{"author": "augustogunsch", "file": "jackc__util.7.c", "original_string": "STRINGLIST* initstrlist(const char** strs, int count) {\n    STRINGLIST* strlist = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n    STRINGLIST* curr = strlist;\n    for(int i = 0; i < count-1; i++) {\n        curr->content = ezheapstr(strs[i]);\n        curr->next = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n        curr = curr->next;\n    }\n    curr->content = ezheapstr(strs[count-1]);\n    curr->next = NULL;\n    return strlist;\n}"}
{"author": "Oryx-Embedded", "file": "Common__cpu_endian.4.c", "original_string": "uint8_t reverseInt8(uint8_t value)\n{\n   value = ((value & 0xF0) >> 4) | ((value & 0x0F) << 4);\n   value = ((value & 0xCC) >> 2) | ((value & 0x33) << 2);\n   value = ((value & 0xAA) >> 1) | ((value & 0x55) << 1);\n   return value;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__17_.1.c", "original_string": "void Columnas(int contador, int pibote){\n    if(contador <= 19){\n        if(contador == (1 + pibote) || contador == (19 - pibote))\n            printf(\"Z\");\n        else\n            printf(\" \");\n        Columnas(++contador, pibote);\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__pol-add-sub-mul.4.c", "original_string": "int main()\n{\n    {\n        node* exp1=NULL; node* exp2=NULL;\n        char fexp[51],sexp[51];\n        printf(\"Input in this format \\\" +/- ax^y +/- ... +/- ... \\\"\\n\");\n        printf(\"Enter 1st Exp. = \");\n        gets(fexp);\n        printf(\"Enter 2nd Exp. = \");\n        gets(sexp);\n        if(strlen(fexp)==0 && strlen(sexp)==0)\n        {\n            printf(\"No expression found.\\n\");\n            exit(1);\n        }\n        else if(strlen(fexp)>=51 || strlen(sexp)>=51)\n        {\n            printf(\"Expressions too lengthy.\\n\");\n            exit(1);\n        }\n        else if(strlen(fexp)!=0 && strlen(sexp)==0)\n            printf(\" %s\\n\",fexp);\n        else if(strlen(fexp)==0 && strlen(sexp)!=0)\n            printf(\" %s\\n\",sexp);\n        else\n        {\n            {\n                if(fexp[0]!='-'){\n                    for(int i=50; i>0; i--) fexp[i]=fexp[i-1];\n                    fexp[0]='+';\n                }\n                int t=0,c1=0,c2=0;\n                char a[10],b[10];\n                for(int i=0; i<=strlen(fexp); i++)\n                {\n                    if(fexp[i]==' ')\n                        continue;\n                    else if(t==0)\n                    {\n                        if(fexp[i]=='x'){\n                            t=1;\n                            i++;\n                            if(fexp[i+1]=='-' && fexp[i+2]!=' ')\n                            {\n                                i++;\n                                b[c2++]=fexp[i];\n                            }\n                        }\n                        else\n                            a[c1++]=fexp[i];\n                    }\n                    else if(fexp[i]=='+' || fexp[i]=='-' || fexp[i]=='\\0')\n                        {\n                            t=0;\n                            if(atoi(a)!=0)\n                                createNode(atoi(a),atoi(b),&exp1);\n                            if(fexp[i]!='\\0')\n                            {\n                                for (int j = 0; j < 10; j++)\n                                    a[j]=b[j]='\\0';\n                                c1=c2=0;\n                                a[c1++]=fexp[i];\n                            }\n                        }\n                    else if(t==1)\n                            b[c2++]=fexp[i];\n                }\n            }\n            {\n                if(sexp[0]!='-'){\n                    for(int i=50; i>0; i--) sexp[i]=sexp[i-1];\n                    sexp[0]='+';\n                }\n                int t=0,c1=0,c2=0;\n                char a[10],b[10];\n                for(int i=0; i<=strlen(sexp); i++)\n                {\n                    if(sexp[i]==' ')\n                        continue;\n                    else if(t==0)\n                    {\n                        if(sexp[i]=='x'){\n                            t=1;\n                            i++;\n                            if(sexp[i+1]=='-')\n                            {\n                                i++;\n                                b[c2++]=sexp[i];\n                            }\n                        }\n                        else\n                            a[c1++]=sexp[i];\n                    }\n                    else if(t==1)\n                    {\n                        if(sexp[i]=='+' || sexp[i]=='-' || sexp[i]=='\\0')\n                        {\n                            t=0;\n                            if(atoi(a)!=0)\n                                createNode(atoi(a),atoi(b),&exp2);\n                            if(sexp[i]!='\\0')\n                            {\n                                for (int j = 0; j < 10; j++)\n                                    a[j]=b[j]='\\0';\n                                c1=c2=0;\n                                a[c1++]=sexp[i];\n                            }\n                        }\n                        else\n                            b[c2++]=sexp[i];\n                    }\n                }\n            }\n            while(1)\n            {\n                int ch;\n                printf(\"\\n\\n1. ADDITION\\n\");\n                printf(\"2. SUBTRACTION\\n\");\n                printf(\"3. MULTIPLICATION\\n\");\n                printf(\"4. PRINT EXPRESSIONS\\n\");\n                printf(\"5. EXIT PROGRAM\\n\");\n                printf(\"What operation do you want to perform: \");\n                scanf(\"%d\",&ch);\n                if(ch==5)\n                {\n                    printf(\"Exitting Program, Thank You.\\n\");\n                    break;\n                }\n                switch (ch)\n                {\n                case 1:\n                    printf(\"\\n\");\n                    display(poly_add_sub('+',exp1,exp2));\n                    break;\n                case 2:\n                    printf(\"\\n\");\n                    display(poly_add_sub('-',exp1,exp2));\n                    break;\n                case 3:\n                    printf(\"\\n\");\n                    display(poly_mul(exp1,exp2));\n                    break;\n                case 4:\n                    printf(\"\\nExpression 1: \");\n                    display(exp1);\n                    printf(\"\\nExpression 2: \");\n                    display(exp2);\n                    break;\n                default:\n                    printf(\"Invalid choice!\\n\");\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica33.2.c", "original_string": "void * productor(){                                         \n    sem_wait(&empty);                                       \n    sem_wait(&mutex);                                       \n    hebraProductor++;                                       \n    int numero = rand()%101;                                \n    producirDato(numero);                                   \n    printf(\"---->Productor %d, Dato %d\\n\",hebraProductor, numero);\n    sem_post(&mutex);                                       \n    sem_post(&full);                                        \n    pthread_exit(NULL);                                     \n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__keypad.5.c", "original_string": "void col_4(void)    \n{\n    int val;\n    IODIR1 = IODIR1 & ~COLS;        \n    IODIR1 = IODIR1 | ROWS;         \n    val = IOPIN1 & COLS;        \n    val = val >> 17;\n    switch(val)\n    {\n        case 0x0E:  lcd_data('.');  delay(200); break;\n        case 0x0D:  lcd_data('0');  delay(200); break;\n        case 0x0B:  lcd_data('=');  delay(200); break;\n        case 0x07:  lcd_data('+');  delay(200); break;\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__sftp_server.4.c", "original_string": "error_t sftpServerSetRootDir(SftpServerSession *session, const char_t *rootDir)\n{\n   SftpServerContext *context;\n   if(session == NULL || rootDir == NULL)\n      return ERROR_INVALID_PARAMETER;\n   context = session->context;\n   pathCopy(session->rootDir, context->rootDir, SFTP_SERVER_MAX_ROOT_DIR_LEN);\n   pathCombine(session->rootDir, rootDir, SFTP_SERVER_MAX_ROOT_DIR_LEN);\n   pathCanonicalize(session->rootDir);\n   pathRemoveSlash(session->rootDir);\n   pathCopy(session->homeDir, session->rootDir, SFTP_SERVER_MAX_HOME_DIR_LEN);\n   return NO_ERROR;\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.19.c", "original_string": "ASMBLK* translatepushstatic(VMTRANSLATOR* t) {\n    tpushstat.items[0] = dotat(t, t->classname, t->currln->tokens[2]);\n    return copytemplate(&tpushstat);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListAllOperations.3.c", "original_string": "struct Node *insertAtEnd(struct Node *head, int data)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     ptr->data = data;\n     struct Node *p = head;\n     while (p->next != NULL)\n     {\n          p = p->next;\n     }\n     p->next = ptr;\n     ptr->next = NULL;\n     return head; \n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Two.4.c", "original_string": "void main()\n{\n    int ch,dir;\n    char name[5];\n    while(1)\n    {\n        printf(\"\\nEnter choice : \");\n        scanf(\"%d\",&ch);\n        switch(ch)\n        {\n            case 1: \n            {\n                printf(\"\\nEnter directory : \");\n                scanf(\"%d\",&dir);\n                printf(\"\\nEnter file name : \");\n                scanf(\"%s\",name);\n                add_file(dir,name[0]);\n                break;\n            }\n            case 2: \n            {\n                printf(\"\\nEnter directory : \");\n                scanf(\"%d\",&dir);\n                printf(\"\\nEnter file name : \");\n                scanf(\"%s\",name);\n                rem_file(dir,name[0]);\n                break;\n            }\n            case 3:\n            {\n                display();\n                break;\n            }\n            default:\n            {\n                exit(0);\n                break;\n            }\n        }\n    }\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__restoring_three_numbers.1.c", "original_string": "void change(int vector[], int i, int j){\n  int aux;\n  aux = vector[i];\n  vector[i] = vector[j];\n  vector[j] = aux;\n}"}
{"author": "augustogunsch", "file": "jackc__compiler.2.c", "original_string": "void freecompiler(COMPILER* c) {\n    pthread_mutex_destroy(&(c->ifmutex));\n    pthread_mutex_destroy(&(c->whilemutex));\n    pthread_mutex_destroy(&(c->staticmutex));\n    freescope(c->globalscope);\n    free(c);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__multi_led.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | (1<<17)|(1<<18);\n    while(1)\n    {\n        IOSET1 = (1<<17)|(1<<18);\n        delay(1000);\n        IOCLR1 = (1<<17)|(1<<18);\n        delay(1000);\n    }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e20.3.c", "original_string": "char * gerarCaptchaMatematico(){\n    int cont, tipo, caractere;\n    char captcha[3];\n    captcha[0]=numeroAleatorio(48,57);\n    tipo=numeroAleatorio(1,2);\n        switch(tipo){\n            case 1:\n                caractere=43;\n            break;\n            case 2:\n                caractere=42;\n            break;\n        }\n    captcha[1]=caractere;\n    captcha[2]=numeroAleatorio(48,57);\n    captcha[3]=0;\n    return captcha;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Single.3.c", "original_string": "void display()\n{\n    temp=start;\n    printf(\"\\nFiles are : \");\n    while(temp!=NULL)\n    {\n        printf(\"%c\\t\",temp->file);\n        temp=temp->next;\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__2.7.c", "original_string": "complex_t divisao(complex_t a, complex_t b)\n{\n    complex_t c, d;\n    complex_t b2 = conjugado(b);\n    d = multiplicacao(b, b2);\n    c = multiplicacao(a, b2);\n    c.real /= d.real;\n    c.imaginario /= d.real;\n    return c;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post.0.c", "original_string": "node* createNode(int n)\n{\n    node* newNode=(node*)malloc(sizeof(node));\n    newNode->data=n;\n    newNode->left=NULL;\n    newNode->right=NULL;\n    return newNode;\n}"}
{"author": "earth429", "file": "mulpre__bisection_test.1.c", "original_string": "int bisection(double a,double b, double *x) {\n    double e; \n    double d; \n    double fx; \n    int as, bs, cs; \n    e = 1.e-7;\n    as = sgn(f(a)); \n    bs = sgn(f(b)); \n    if(as == bs){ \n        return -1; \n    }\n    while(1){\n        d = (a + b) / 2.0;\n        fx = f(d);\n        cs = sgn(fx);\n        printf(\"now a = %lf\\n\", a);\n        printf(\"now b = %lf\\n\", b);\n        if(cs == as){\n            a = d;\n        }\n        if(cs == bs){\n            b = d;\n        }\n        if(fx == 0.0){ \n            break;\n        }\n        if(fabs(a - b) < e){ \n            break;\n        }\n    }\n    *x = d;\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__RR.1.c", "original_string": "char dequeue()\n{\n    char c;\n    if(r!=-1 && f!=-1)\n    {\n        c=Queue[f];\n        f=f+1;\n        return(c);\n    }\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b3.0.c", "original_string": "size_t find_empty(bool *seats) {\n    for (size_t i = 8; i < 126 * 8 + 7; i++)\n        if (seats[i - 1] && !seats[i] && seats[i + 1]) return i;\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__FIFO.0.c", "original_string": "void enqueue(int page)\n{\n    if(f==-1 && r==-1)\n    {\n        f=f+1;\n        r=r+1;\n        Queue[r]=page;\n    }\n    else\n    {\n        r=(r+1)%3;\n        Queue[r]=page;\n    }\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_8.2.c", "original_string": "void traverse_inorder(struct node* root)\n{\n    if(root != NULL)\n    {\n        traverse_inorder(root->left);\n        printf(\"%d\\t\", root->data);\n        traverse_inorder(root->right);\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server_directory.2.c", "original_string": "void scpServerGetNextDirEntry(ScpServerSession *session)\n{\n   error_t error;\n   uint_t perm;\n   FsDirEntry dirEntry;\n   while(1)\n   {\n      error = fsReadDir(session->dir[session->dirLevel], &dirEntry);\n      if(!error)\n      {\n         if(!osStrcmp(dirEntry.name, \".\") || !osStrcmp(dirEntry.name, \"..\"))\n         {\n         }\n         else\n         {\n            pathCombine(session->path, dirEntry.name, SCP_SERVER_MAX_PATH_LEN);\n            pathCanonicalize(session->path);\n            perm = scpServerGetFilePermissions(session, session->path);\n            if((perm & SCP_FILE_PERM_LIST) != 0)\n            {\n               if((dirEntry.attributes & FS_FILE_ATTR_DIRECTORY) != 0)\n               {\n                  if((session->dirLevel + 1) < SCP_SERVER_MAX_RECURSION_LEVEL)\n                  {\n                     session->dirLevel++;\n                     error = scpServerOpenDir(session);\n                     if(error)\n                     {\n                        session->dirLevel--;\n                     }\n                  }\n                  else\n                  {\n                     error = ERROR_OPEN_FAILED;\n                  }\n               }\n               else\n               {\n                  error = scpServerOpenFileForReading(session);\n               }\n               if(!error)\n               {\n                  break;\n               }\n            }\n            pathRemoveFilename(session->path);\n            pathRemoveSlash(session->path);\n         }\n      }\n      else\n      {\n         break;\n      }\n   }\n   if(error)\n   {\n      fsCloseDir(session->dir[session->dirLevel]);\n      session->dir[session->dirLevel] = NULL;\n      if(session->dirLevel > 0)\n      {\n         pathRemoveFilename(session->path);\n         pathRemoveSlash(session->path);\n      }\n   }\n   session->state = SCP_SERVER_SESSION_STATE_READ_COMMAND;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__BinHexConverter0.5.c", "original_string": "size_t convertHexString8ToBinData(char *inputStr, size_t inputStrLength, uint8_t *pOutputData, size_t outputDataSize)\n{\n  if (outputDataSize < inputStrLength >> 1) \n  {\n    return 0;\n  }\n  if ((inputStrLength & 0x01u) != 0) \n  {\n    return 0;\n  }\n  memset(pOutputData, 0x00u, outputDataSize);\n  for ( size_t i = 0 ; i < inputStrLength; i = i + 2 )\n  {\n    pOutputData[i >> 1] = convertHexString8ToBinValue(inputStr + i, 2);\n  }\n  return inputStrLength >> 1;\n}"}
{"author": "theuwis", "file": "AdventOfCode2016__main12.0.c", "original_string": "int main(){\n   clock_t start = clock(), diff;\n   for(int i = 0; i < strlen(input); i++){\n      if(input[i] == '^'){\n         traps[0][i] = true;\n      }\n      else{\n         nr_safe++;\n      }\n   }\n   for(int row = 1; row < NR_ROWS; row++){\n      for(int col = 0; col < NR_COLS; col++){\n         if(col == 0){\n            left = false;\n            center = traps[row - 1][col];\n            right = traps[row - 1][col + 1];\n         }\n         else if(col == NR_COLS - 1){\n            left = traps[row - 1][col - 1];\n            center = traps[row - 1][col];\n            right = false;\n         }\n         else{\n            left = traps[row - 1][col - 1];\n            center = traps[row - 1][col];\n            right = traps[row - 1][col + 1];\n         }\n         if((left && center && !right) || (!left && center && right) ||\n               (!left && !center && right) || (left && !center && !right)){\n            traps[row][col] = true;\n         }\n         else{\n            traps[row][col] = false;\n            nr_safe++;\n         }\n      }\n   }\n   diff = clock() - start;\n   int msec = diff * 1000 / CLOCKS_PER_SEC;\n   printf(\"answer=%d\\n\", nr_safe);\n   printf(\"time: %ds %dms\", msec/1000, msec%1000);\n   return EXIT_SUCCESS;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-structure.15.c", "original_string": "VARDEC* parsevardecs(PARSER* p) {\n    VARDEC* head = parsevardec(p);\n    VARDEC* curr = head;\n    VARDEC* nextv;\n    while(nextv = parsevardec(p), nextv != NULL) {\n            curr->next = nextv;\n        curr = nextv;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}"}
{"author": "2security", "file": "Pointer__18ReturnMultipleValue.0.c", "original_string": "int* Myreturn(int *a,int n)\n    {\n    int i;\n    for(i=0;i<n;i++)\n        *(a+i)=2*(*(a+i));\n    return a;\n    }"}
{"author": "0712023", "file": "Basis-and-Practice-in-Programming_SKKU__5_even_out.0.c", "original_string": "int main() {\n  int power(int x, int n){\n    if (n ==1 ){\n      return x;\n    } else if(n == 0){\n      return 1;\n    }\n    return (x*power(x,n-1));\n  }\n  int len(int number){\n    int cnt = 0;\n    while (number>0){\n      cnt++;\n      number /= 10;\n    }\n    return cnt;\n  }\n  int a = 0;\n  int i = 0;\n  int func(int number){\n    if (len(number) >0){\n      a+=number%10*power(10, i);\n      number = number/100;\n      i++;\n      func(number);\n    } else {\n      return 0;\n    }\n  }\n  int number = 0;\n  scanf(\"%d\", &number);\n  func(number);\n  printf(\"%d\", a);\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server.2.c", "original_string": "error_t scpServerStart(ScpServerContext *context)\n{\n   error_t error;\n   OsTask *task;\n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n   TRACE_INFO(\"Starting SCP server...\\r\\n\");\n   if(context->running)\n      return ERROR_ALREADY_RUNNING;\n   error = sshServerRegisterChannelRequestCallback(context->sshServerContext,\n      scpServerChannelRequestCallback, context);\n   if(!error)\n   {\n      context->stop = FALSE;\n      context->running = TRUE;\n      task = osCreateTask(\"SCP Server\", scpServerTask, context,\n         SCP_SERVER_STACK_SIZE, SCP_SERVER_PRIORITY);\n      if(task == OS_INVALID_HANDLE)\n      {\n         error = ERROR_OUT_OF_RESOURCES;\n      }\n   }\n   if(error)\n   {\n      context->running = FALSE;\n      sshServerUnregisterChannelRequestCallback(context->sshServerContext,\n         scpServerChannelRequestCallback);\n   }\n   return error;\n}"}
{"author": "jdes01", "file": "practicasSSOO__ssoopractica3-3a.1.c", "original_string": "void * productor(){ \n    for (int i=0; i<10; i++){   \n        sem_wait(&empty);                                                          \n        sem_wait(&mutex);  \n        int numero = rand()%101;    \n        producirDato(numero);\n        printf(\"Productor:\\n\");\n        printf(\"Dato %d: %d\\n\", i+1, numero);\n        sem_post(&mutex);                                  \n        sem_post(&full);                                   \n    }\n    pthread_exit(NULL);                                   \n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es22.2.c", "original_string": "void stampa_vettore(int a[], int dim)\n{\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        printf(\"%d\\n\", a[i]);\n    }\n}"}
{"author": "Dhruvik-Chevli", "file": "PPLab__p2.0.c", "original_string": "int main(int argc,char* argv[]){\n    int rank,size,num;\n    char st[10];\n    char res[10];\n    MPI_Init(&argc,&argv);\n    MPI_Comm_rank(MPI_COMM_WORLD,&rank);\n    MPI_Comm_size(MPI_COMM_WORLD,&size);\n    if(size!=4){\n        printf(\"\\nUse 4 processes\\n\");\n        MPI_Abort(MPI_COMM_WORLD,EXIT_FAILURE);\n    }\n    if(rank==0){\n        printf(\"\\nProcess[%d]: Sending numbers\\n\",rank);\n        num=1;\n        MPI_Send(&num,1,MPI_INT,1,0,MPI_COMM_WORLD);\n        num=2;\n        MPI_Send(&num,1,MPI_INT,2,0,MPI_COMM_WORLD);\n        num=3;\n        MPI_Send(&num,1,MPI_INT,3,0,MPI_COMM_WORLD);\n    }else{\n        MPI_Recv(&num,1,MPI_INT,0,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);\n        printf(\"\\nProcess[%d]: Received %d\\n\",rank,num);\n    }\n    MPI_Finalize();\n    return 0;\n}"}
{"author": "mandarvu", "file": "msc__problem104.0.c", "original_string": "void string_reverse(char *origin, char *rev) {\n  int f = 0, cnt = 0, j = 0;\n  while ( *(origin + f) != '\\0' ) {\n    cnt++;\n    f++;\n  }\n  for (int i = cnt - 1; i >= 0; i--)\n  {\n    *(rev + j) = *(origin + i);\n    j++;\n  }\n  *(rev + j) = '\\0';\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-tree.11.c", "original_string": "void freesubroutbody(SUBROUTBODY* b) {\n    if(b->vardecs != NULL)\n        freevardecs(b->vardecs);\n    if(b->statements != NULL)\n        freestatements(b->statements);\n    free(b);\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Seg.0.c", "original_string": "int get_count()\n{\n    int i,ct=0;\n    for(i=0;i<16;i++)\n    {\n        if(Mem[i]==0)\n            ct=ct+1;\n    }\n    return(ct);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__check_multiplebit2_on_off.0.c", "original_string": "BOOL CheckBit(int iNo)\n{\n    int iMask = 0X00000E00;\n    int iResult = 0;\n    if(iNo < 0)\n    {\n        iNo = -iNo;\n    }\n    iResult = iNo & iMask;\n    if(iResult == iMask)\n    {\n        return TRUE;\n    }\n    else\n    {\n        return FALSE;\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__nonVIC.0.c", "original_string": "int main()\n{\n    IODIR1 = IODIR1 | (0xFF<<17);       \n    IODIR0 |= (1<<11);\n    timer1_config();\n    timer0_config();\n    interrupt_config();\n    while(1)\n    {\n            blink_LED(24);\n    }\n}"}
{"author": "seefeesaw", "file": "Recursion__fibonacci.0.c", "original_string": "int fib(int n)\n{\n    int t0=0,t1=1,s=0,i;\n    if(n<=1)return n;\n    for(i = 2;i<=n;i++)\n    {\n        s=t0 + t1;\n        t0 = t1;\n        t1 = s;\n    }\n    return s;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__io.10.c", "original_string": "FILELIST* getsinglefile(char* file) {\n    int len = strlen(file);\n    if(isdotjack(file, len)){\n        char* name = getname(file, len);\n        char* fullname = heapstr(file, len);\n        FILE* input = fopen(fullname, \"r\");\n        if(input == NULL) {\n            eprintf(\"Error while reading file '%s': %s\\n\", file, strerror(errno));\n            exit(errno);\n        }\n        fclose(input);\n        return addfile(NULL, fullname, name);\n    }\n    else {\n        eprintf(\"Input file must be named like 'Xxx.vm'\\n\");\n        exit(1);\n    }\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es12.0.c", "original_string": "int main(void) {\n    int dim; \n    printf(\"inserire dimensione array: \"); \n    scanf(\"%d\", &dim);\n    int a[dim];\n    int b[dim];\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\n\");\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"b[%d] = \", i);\n        scanf(\"%d\", &b[i]);\n    }\n    printf(\"\\n\");\n    int c[dim];\n    printf(\"Prodotto scalare dei due vettori: \\n\");\n    for(int i=0; i<dim; i++)\n    {\n        c[i] = a[i] * b[i];\n        printf(\"c[%d] = \", i );\n        printf(\"%d\", c[i]);\n        printf(\"\\n\");\n    }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__circularLinkedList.5.c", "original_string": "struct Node *deleteByGivenKey(struct Node *head, int value)\n{\n     struct Node *p = head;\n     struct Node *q = head->next;\n     while (q->data != value) \n     {\n          p = p->next;\n          q = q->next;\n     }\n     if (q->data == value) \n     {\n          p->next = q->next; \n          free(q);           \n     }\n     return head;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__dequeue1.4.c", "original_string": "void search(int val)\n{\n    int i,c=0;\n    if((front==-1 && rear==-1) || front>rear)\n    printf(\"\\nqueue is empty\");\n    else\n    {\n        for(i=front;i<=rear;i++)\n        {\n            if(queue[i]==val)\n            {\n                printf(\"\\nvalue found\");\n                c=c+1;\n                break;\n            }\n        }\n        if(c==0)\n        printf(\"\\nvalue not found\");\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__poly.1.c", "original_string": "nptr insert(nptr head, int c, int e)\n{\n    if(head == NULL)\n        return head = createNode(c, e);\n    nptr temp = head;\n    while(temp -> next != NULL)\n        temp = temp -> next;\n    temp -> next = createNode(c, e);\n    return head;\n}"}
{"author": "sdukesameer", "file": "dsa__dll-ins-seq-sor-del.5.c", "original_string": "void printreversed(node* head)\n{\n    node* dll=head;\n    while (dll->next!=NULL)\n        dll=dll->next;\n    while(dll!=NULL)\n    {\n        printf(\"%d  \",dll->data);\n        dll=dll->prev;\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__lz77encode.0.c", "original_string": "void compress(char *str, int k)\n{\n    int pos,         \n        tam_maior,   \n        tam,         \n        pos_aux,     \n        indice = 0,  \n        i_aux,       \n        end = false; \n    printf(\"(-1,0,%c)\", *str); \n    str++;\n    indice++;\n    while (*str) \n    {\n        tam_maior = 0;\n        pos = 0;\n        for (int i = indice - 1; i >= (indice - k) && i >= 0; i--)\n        {\n            if (*(str - indice + i) == *(str))\n            {\n                tam = 0;\n                i_aux = i;\n                for (int j = 0; *(str - indice + i_aux + j) == *(str + j); j++)\n                {\n                    if (j == 0) \n                    {\n                        pos_aux = -(-indice + i_aux + j);\n                    }\n                    if ((-indice + i_aux + j) >= 0)\n                    {\n                        i_aux = i - j;\n                    }\n                    tam++;\n                }\n                if (tam > tam_maior)\n                {\n                    tam_maior = tam;\n                    pos = pos_aux;\n                }\n            }\n        }\n        str += tam_maior;\n        indice += tam_maior;\n        if (*str == '\\0')\n        {\n            printf(\"(%i,%i,\\\\0)\", pos, tam_maior);\n            end = true;\n        }\n        else\n        {\n            printf(\"(%i,%i,%c)\", pos, tam_maior, *str);\n        }\n        str++;\n        indice++;\n    }\n    if (end == false) \n    {\n        printf(\"(0,0,\\\\0)\");\n    }\n    putchar('\\n');\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_dma_ex.0.c", "original_string": "HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)\n{\n  HAL_StatusTypeDef status = HAL_OK;\n  assert_param(IS_DMA_BUFFER_SIZE(DataLength));\n  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)\n  {\n    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;\n    status = HAL_ERROR;\n  }\n  else\n  {\n    __HAL_LOCK(hdma);\n    if(HAL_DMA_STATE_READY == hdma->State)\n    {\n      hdma->State = HAL_DMA_STATE_BUSY; \n      hdma->Instance->CR |= (uint32_t)DMA_SxCR_DBM;\n      hdma->Instance->M1AR = SecondMemAddress;\n      DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);\n      __HAL_DMA_ENABLE(hdma);\n    }\n    else\n    {\n      status = HAL_BUSY;\n    }\n  }\n  return status;\n}"}
{"author": "SugumaranEvil", "file": "Datastructure__single_linked_list.1.c", "original_string": "void print_list()\n{\n    int index=0;\n    print_ptr = head;\n    while(print_ptr!=NULL)\n    {\n        index++;\n        printf(\"Node Index %d Data value %c\\n\",index,print_ptr->data);\n        print_ptr=print_ptr->next;\n    }\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__udpserver.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    int sockid,rval,clen;\n    char buffer[20];\n    struct sockaddr_in s,c;\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDRESS PORT#\\n\",argv[0]);\n        exit(0);\n    }\n    sockid=socket(PF_INET,SOCK_DGRAM,17);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=PF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    rval=bind(sockid,(struct sockaddr*)&s,sizeof(s));\n    if(rval==-1)\n    {\n        perror(\"BIND-ERR\");\n        close(sockid);\n        exit(1);\n    }\n    clen=sizeof(c);\n    rval=recvfrom(sockid,buffer,sizeof(buffer),0,(struct sockaddr*)&c,&clen);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nRequest received\\nRequest message is : %s\\n\",buffer);\n    }\n    rval=sendto(sockid,buffer,sizeof(buffer),0,(struct sockaddr*)&c,sizeof(c));\n    if(rval==-1)\n    {\n        perror(\"MSG-SND-ERR:\");\n    }\n    else\n    {\n        printf(\"\\nResponse sent successfully\\n\");\n    }\n    close(sockid);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_pos_DCLL.4.c", "original_string": "void insert_at_pos()\n{\n    struct node *newnode,*temp;\n    int i=1;\n    int pos;\n    int leg=count();\n    printf(\"enter the position in between the 1 to %d\\n\",leg);\n    printf(\"enter the position =\");\n    scanf(\"%d\",&pos);\n    if(pos>leg)\n    {\n        printf(\"invalied position\\n\");\n    }\n    else\n    {\n        temp=head;\n        while(i<pos-1)\n        {\n            temp=temp->next;\n            i++;\n        }\n        newnode=(struct node*)malloc(sizeof(struct node));\n        printf(\"enter the data =\");\n        scanf(\"%d\",&newnode->data);\n        newnode->next=temp->next;\n        newnode->pre=temp;\n        temp->next->pre=newnode;\n        temp->next=newnode;\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.18.c", "original_string": "void addlocalvar(SCOPE* s, VARDEC* v, int* i) {\n    STRINGLIST* currname = v->names;\n    while(currname != NULL) {\n        addvar(s, &(s->localvars), mkvar(v->type, currname->content, v->primitive, v->debug, local, *i));\n        currname = currname->next;\n        (*i)++;\n    }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__print_hex.3.c", "original_string": "int     main(int ac, char **av)\n{\n    if (ac == 2)\n    {\n        ft_print_hex(ft_atoi(av[1]));\n    }\n    write(1, \"\\n\", 1);\n    return (0);\n}"}
{"author": "dle2005", "file": "Algorithm__Optimal_Binary_Search_Trees_v2.1.c", "original_string": "int min(int i, int j, float **A, float *p) {\n    int index;\n    float min = 999;\n    for(int k = i; k <= j; k++) {\n        if(A[i][k-1] + A[k+1][j] + sum(i, j, p) < min) {\n            min = A[i][k-1] + A[k+1][j] + sum(i, j, p);\n            index = k;\n        }\n    }\n    return index;\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__udpclient.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    struct sockaddr_in s,c; \n    int rval,sockid,slen;\n    char m1[20],m2[20];\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP-Address Port#\\n\",argv[0]);\n        exit(1);\n    }\n    sockid=socket(PF_INET,SOCK_DGRAM,17);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    s.sin_family=PF_INET;\n    s.sin_port=htons(atoi(argv[2]));\n    s.sin_addr.s_addr=inet_addr(argv[1]);\n    c.sin_port=htons(5080);\n    printf(\"\\nEnter the request message : \");\n    scanf(\"%s\",m1);\n    slen=sizeof(s);\n    rval=sendto(sockid,m1,sizeof(m1),0,(struct sockaddr*)&s,slen);\n    if(rval==-1)\n    {\n        perror(\"MSG-SEND-ERR:\");\n        exit(1);\n    }\n    printf(\"\\nMessage sent successfully\\n\");\n    strncpy(m2,\" \",20);\n    rval=recvfrom(sockid,m2,sizeof(m2),0,(struct sockaddr*)&s,&slen);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n        exit(1);\n    }\n    printf(\"\\nMessage received is : %s\\n\",m2);\n    close(sockid);\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__sender.4.c", "original_string": "int main(){\n    unsigned int length;\n    welcome();\n    length = frame_construction(sta_addr,des_addr,protocol,data,sizeof(data));\n    printf(\"Frame length: %d\\n\",length);\n    frame[length-10] = ~frame[length-10];\n    send_frame(frame,length);\n    return 0;\n}"}
{"author": "earth429", "file": "mulpre__multiple.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a, b, c;\n    int return_val;\nint x, y;\n    x = 16;\n    y = 16;\n    setInt(&a, x);\n    setInt(&b, y);\n    printf(\"x = %d\\ny = %d\\nx * y = %d\\n\", x, y, x * y);\n    return_val = multiple(&a, &b, &c);\n    printf(\"\\n\");\n    dispNumberZeroSuppress(&c);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__WiFiStationDrv.2.c", "original_string": "static esp_err_t wifiEventHandlerCallback(void *ctx, system_event_t *event)\n{\n  switch (event->event_id)\n  {\n    case SYSTEM_EVENT_STA_GOT_IP:\n    {\n      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);\n      break;\n    }\n    case SYSTEM_EVENT_STA_LOST_IP:\n    case SYSTEM_EVENT_STA_DISCONNECTED:\n    case SYSTEM_EVENT_STA_STOP:\n    case SYSTEM_EVENT_STA_DHCP_TIMEOUT:\n    {\n      fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_DISCONNECTED);\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return ESP_OK;\n}"}
{"author": "sdukesameer", "file": "dsa__dfs.7.c", "original_string": "int main(){\n    graph g;\n    int f=1,x;\n    input(&g);\n    printf(\"\\n\\' If\");\n    for(int i=0; i<g.n;i++)\n        printf(\" %c=%d\",'A'+i,i+1);\n    printf(\" \\'\\nEnter the initial vertex: \");\n    while(f){\n        scanf(\"%d\",&x);\n        if(x>0 && x<g.n+1)\n            f=0;\n        else\n            printf(\"Invalid input. Try again.\\n\");\n    }\n    dfs(g,x-1);\n    free_graph(&g);\n}"}
{"author": "davibernardos", "file": "DB-PJ__e70.0.c", "original_string": "int main(int argc, char *argv[]) \n{\n    int capacidadeMaxima, ingressoComprado, opcao, escolha, contInteira, tipo, contMeia, ingressosRestantes;\n    float entradaInteira, meiaEntrada, valorPagar, pagamento, totalPagar;\n    char nomeEvento[30]; \n    printf(\"Digite o nome do Evento: \");\n    scanf(\"%s\", &nomeEvento);\n    printf(\"\\nDigite a capacidade maxima: \");\n    scanf(\"%d\", &capacidadeMaxima);\n    printf(\"\\nDigite o valor da entrada inteira: \");\n    scanf(\"%g\", &entradaInteira);   \n    contInteira = 0;\n    contMeia = 0;\n    system(\"cls\");\n    while(opcao != 2)\n    {\n        system(\"cls\");\n        printf(\"Menu\\n\");\n        printf(\"\\n(1) Comprar Ingressos \\n\");\n        printf(\"(2) Sair \\n\\n\");\n        printf(\"Digite a opcao desejada: \");\n        scanf(\"%d\", &opcao);\n        if((contInteira + contMeia) == capacidadeMaxima)\n        {\n            opcao = 0;\n            printf(\"Ingressos Esgotados !\\n\");\n            system(\"pause\");\n        }\n        system(\"cls\");\n        if(opcao == 1)\n        {\n            ingressoComprado= 0;\n            printf(\"Nome do Evento: %s\\n\", nomeEvento);\n            printf(\"Capacidade Maxima: %d\\n\", capacidadeMaxima);\n            printf(\"O Valor da Entrada Inteira: %g\\n\\n\", entradaInteira);\n            printf(\"\\nIngressos:\\n\");\n            printf(\"\\n(1) Entrada Inteira\\n\");\n            printf(\"(2) Meia Entrada\\n\\n\");\n            printf(\"Escolha a opcao desejada: \");\n            scanf(\"%d\", &escolha);\n            if(escolha == 1)\n            {\n                valorPagar = entradaInteira;\n                printf(\"\\nValor a pagar: %g\", valorPagar);\n                contInteira++;\n            }\n            else\n            {\n                valorPagar = entradaInteira / 2;\n                printf(\"\\nValor a pagar: %g\", valorPagar);\n                contMeia++;\n            }\n            while(ingressoComprado == 0)\n            {\n                printf(\"\\n\\nForma de Pagamento:\\n\");\n                printf(\"\\n(1) Somente em Dinheiro\\n\");\n                printf(\"\\nDigite 1 para iniciar o pagamento:\");\n                scanf(\"%d\", &tipo);\n                if(tipo == 1)\n                {\n                    printf(\"\\nDigite o valor em dinheiro:\");\n                    scanf(\"%g\", &pagamento);\n                    totalPagar = pagamento - valorPagar;\n                    if(totalPagar < 0)\n                    {\n                        printf(\"\\nValor menor que valor total do ingresso\\n\\n\");\n                    }\n                    else \n                    {\n                        printf(\"\\ntroco eh: %g\", totalPagar);\n                        ingressoComprado = 1;\n                    }\n                }\n                else\n                {\n                    printf(\"Pagamento somente em dinherio !\\n\\n\");\n                }\n            }\n            printf(\"\\n\\nIngressos Comprado\\n\\n\");\n            system(\"pause\");\n        }\n        else if(opcao == 2)\n        {\n            printf(\"Total de ingressos: %d\\n\", capacidadeMaxima);\n            ingressosRestantes = capacidadeMaxima - ingressoComprado;\n            printf(\"\\nSobraram: %d\\n\\n\", ingressosRestantes);\n            system(\"pause\");\n        }\n    }\n    return 0;\n}"}
{"author": "2security", "file": "String__25ReplaceFirstOccurrence.0.c", "original_string": "int main()\n    {\n        int i,pos;\n        char str[30],ch,rech;\n        printf(\"\\n Enter the string\");\n        gets(str);\n        printf(\"\\n Enter character to replace\");\n        ch=getchar();\n        getchar();\n        printf(\"\\n Enter character to replace with\");\n        rech=getchar();\n        for(i=0;i<str[i]!='\\0';i++)\n            {\n                if(str[i]==ch)\n                    {\n                        pos=i;\n                        str[pos]=rech;\n                        break;\n                    }\n            }\n        printf(\"\\n After replace %s\",str);\n        return 0;\n    }"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__goal_client.5.c", "original_string": "int main(int argc, char **argv){\n    if(argc != 2){\n        printf(\"Usage: %s <port>\\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n    char *ip = \"127.0.0.1\";\n    int port = atoi(argv[1]);\n    signal(SIGINT, catch_ctrl_c_and_exit);\n    printf(\"Please enter your name: \");\n  fgets(name, 32, stdin);\n  str_trim_lf(name, strlen(name));\n    if (strlen(name) > 32 || strlen(name) < 2){\n        printf(\"Name must be less than 30 and more than 2 characters.\\n\");\n        return EXIT_FAILURE;\n    }\n    struct sockaddr_in server_addr;\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n  server_addr.sin_family = AF_INET;\n  server_addr.sin_addr.s_addr = inet_addr(ip);\n  server_addr.sin_port = htons(port);\n  int err = connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));\n  if (err == -1) {\n        printf(\"ERROR: connect\\n\");\n        return EXIT_FAILURE;\n    }\n    send(sockfd, name, 32, 0);\n    printf(\"=== WELCOME TO THE CHATROOM ===\\n\");\n    pthread_t send_msg_thread;\n  if(pthread_create(&send_msg_thread, NULL, (void *) send_msg_handler, NULL) != 0){\n        printf(\"ERROR: pthread\\n\");\n    return EXIT_FAILURE;\n    }\n    pthread_t recv_msg_thread;\n  if(pthread_create(&recv_msg_thread, NULL, (void *) recv_msg_handler, NULL) != 0){\n        printf(\"ERROR: pthread\\n\");\n        return EXIT_FAILURE;\n    }\n    while (1){\n        if(flag){\n            printf(\"\\nBye\\n\");\n            break;\n    }\n    }\n    close(sockfd);\n    return EXIT_SUCCESS;\n}"}
{"author": "sdukesameer", "file": "c__sort-structure.1.c", "original_string": "void sortStudents(StudentType students[], int n ){\n    StudentType t;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n-i;j++)\n        {\n            if(students[j].rollNo<students[j+1].rollNo)\n            {\n                t=students[j];\n                students[j]=students[j+1];\n                students[j+1]=t;\n            }\n        }\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server_directory.0.c", "original_string": "error_t scpServerCreateDir(ScpServerSession *session, const char_t *name)\n{\n   error_t error;\n   uint_t perm;\n   pathCombine(session->path, name, SCP_SERVER_MAX_PATH_LEN);\n   pathCanonicalize(session->path);\n   pathRemoveSlash(session->path);\n   if(!fsDirExists(session->path))\n   {\n      perm = scpServerGetFilePermissions(session, session->path);\n      if((perm & SCP_FILE_PERM_WRITE) != 0)\n      {\n         error = fsCreateDir(session->path);\n         if(error)\n         {\n            error = ERROR_DIRECTORY_NOT_FOUND;\n         }\n      }\n      else\n      {\n         error = ERROR_ACCESS_DENIED;\n      }\n   }\n   else\n   {\n      error = NO_ERROR;\n   }\n   if(!error)\n   {\n      session->dirLevel++;\n   }\n   return error;\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__if-else2.0.c", "original_string": "int main ()\n{\n    int s1,s2,s3;\n    printf(\"l\u00fctfen \u00fc\u00e7 tane say\u0131 giriniz:\");\n    scanf(\"%d %d %d\",&s1,&s2,&s3);\n    if(s1<s2 && s1<s3)\n        printf(\"en k\u00fc\u00e7\u00fck say\u0131 %d\\n\",s1);\n    if(s2<s1 && s2<s3)\n        printf(\"en k\u00fc\u00e7\u00fck say\u0131 %d\\n\",s2);\n    if(s3<s1 && s3<s2)\n        printf(\"en k\u00fc\u00e7\u00fck say\u0131 %d\\n\",s3);\n    if(s1>s2 && s1>s3)\n        printf(\"en b\u00fcy\u00fck say\u0131 %d\",s1);\n    if(s2>s1 && s2>s3)\n        printf(\"en b\u00fcy\u00fck say\u0131 %d\",s2);   \n    if(s3>s1 && s3>s2)\n        printf(\"en b\u00fcy\u00fck say\u0131 %d\",s3);\n    return 0;\n    }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__23_For.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cosh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    for(int i = 1; i <= veces; ++i){\n        Suma_total += Exp(X,(i*2)) / Fac((i*2));\n    }\n    printf(\"Cosh(%i) es igual a %lf\", X, (Suma_total + 1));\n    return 0;\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__1000-sort_deck.1.c", "original_string": "int partition(deck_node_t **deck, int lo, int hi)\n{\n    deck_node_t *pivot = *deck, *pi = *deck, *pj = *deck, *tmp = *deck;\n    int i, j, k, v;\n    kind_t p;\n    char *s = \"A234567891JQK\";\n    for (i = 0; i < lo; i++)\n    {\n        pivot = pivot->next;\n        pi = pi->next;\n        pj = pj->next;\n    }\n    while (i < hi)\n    {\n        pivot = pivot->next;\n        i++;\n    }\n    p = pivot->card->kind;\n    i = lo;\n    for (j = lo; j < hi; j++)\n    {\n        for (k = 0; s[k] != pj->card->value[0]; k++)\n            ;\n        for (v = 0; s[v] != pivot->card->value[0]; v++)\n            ;\n        if ((pj->card->kind < p) || (pj->card->kind == p && k <= v))\n        {\n            if (pi != pj)\n            {\n                swap_func(deck, pi, pj);\n                tmp = pi;\n                pi = pj;\n                pj = tmp;\n            }\n            pi = pi->next, i++;\n        }\n        pj = pj->next;\n    }\n    if (pi != pivot)\n        swap_func(deck, pi, pivot);\n    return (i);\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b1.2.c", "original_string": "bool **get_trees(char *filename, size_t n, size_t m) {\n    FILE *f = fopen(filename, \"r\");\n    bool **trees = calloc(sizeof(bool*), n);\n    for (size_t i = 0; i < n; i++)\n        trees[i] = calloc(sizeof(bool), m);\n    char c;\n    for (size_t i = 0; i < n; i++)\n        for (size_t j = 0; j < m; j++) {\n            c = fgetc(f);\n            if (c == '\\n') c = fgetc(f);\n            if (c == '#') trees[i][j] = true;\n        }\n    fclose(f);\n    return trees;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-tree.14.c", "original_string": "void freetree(CLASS* c) {\n    free(c->debug);\n    if(c->vardecs != NULL)\n        freeclassvardecs(c->vardecs);\n    if(c->subroutdecs != NULL)\n        freesubroutdecs(c->subroutdecs);\n    CLASS* next = c->next;\n    free(c);\n    if(next != NULL)\n        freetree(next);\n}"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__2-3.2.c", "original_string": "int hexa_to_int(char s){\n  if(s == 'a' || s == 'A')\n    return 10;\n  if(s == 'b' || s == 'B')\n    return 11;\n  if(s == 'c' || s == 'C')\n    return 12;\n  if(s == 'd' || s == 'D')\n    return 13;\n  if(s == 'e' || s == 'E')\n    return 14;\n  if(s == 'f' || s == 'F')\n    return 15;\n  return s - '0';\n}"}
{"author": "dishanp", "file": "DSA__q1.3.c", "original_string": "void displayrowmajor(int **sp)\n{\n    printf(\"\\nRow Major Representation : \\n\\n\");\n    printf(\"\\tRows\\t\\tColumns\\t\\tValues\\n\");\n    for(int i = 0 ; i < num + 1 ; i++)\n    {\n        for(int j = 0 ; j < 3 ; j++)\n        {\n            printf(\"\\t%d\\t\", sp[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__check_mate.3.c", "original_string": "int     check_bishop(char **tab, int row, int col, int size)\n{\n    int     r;\n    int     c;\n    r = row - 1;\n    c = col - 1;\n    while (r >= 0 && c >= 0 && !is_piece(tab[r][c]))\n        if (tab[r--][c--] == 'K')\n            return (1);\n    r = row - 1;\n    c = col + 1;\n    while (r >= 0 && c < size && !is_piece(tab[r][c]))\n        if (tab[r--][c++] == 'K')\n            return (1);\n    r = row + 1;\n    c = col - 1;\n    while (r < size && c >= 0 && !is_piece(tab[r][c]))\n        if (tab[r++][c--] == 'K')\n            return (1);\n    r = row + 1;\n    c = col + 1;\n    while (r < size && c < size && !is_piece(tab[r][c]))\n        if (tab[r++][c++] == 'K')\n            return (1);\n    return (0);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q21.2.c", "original_string": "int prec(char ch)           \n{ \n    if (ch == '+' || ch == '-')\n        return 1; \n    if (ch == '*' || ch == '/')\n        return 2; \n    if (ch == '^')\n        return 3;  \n    return -1; \n}"}
{"author": "earth429", "file": "mulpre__sqrt_newton.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER r1, ans, tmp;\n    int i, j, r;\n    double r2;\n    srandom(time(NULL));\n    for (i = 0; i < 10;i++){\n        r = random();\n        setInt(&r1, r);\n        for (j = 0; j < 10;j++){\n            mulBy10(&r1, &tmp);\n            copyNumber(&tmp, &r1);\n        }\n        sqrt_newton(&r1, &ans);\n        printf(\"r1:\");\n        dispNumberZeroSuppress(&ans);\n        puts(\"\");\n        r2 = sqrt((double)r);\n        printf(\"r2:%f\\n\", r2);\n    }\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__n-queen-a.0.c", "original_string": "int safe(int arr[N][N], int row, int col){\n    int i,j;\n    for ( i = 0; i < col; i++){\n        if(arr[row][i])\n            return 0;\n    }\n    for ( i = row, j = col; i >= 0 && j >= 0; i--, j--){\n        if(arr[i][j])\n            return 0;\n    }\n    for ( i = row, j = col; i < N && j >= 0; i++, j--){\n        if(arr[i][j])\n            return 0;\n    }\n    return 1;\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad4.0.c", "original_string": "int main()\n{\n    float array[10];\n    float userNumber;\n    float sumPlus = 0;\n    float sumMinus = 0;\n    int licznik = 0;\n    int licznikPlus = 0;\n    int licznikMinus = 0;\n    while(licznik < 10) {\n        printf(\"Podaj liczbe nr %d do tablicy: \", licznik + 1);\n        scanf(\"%f\", &userNumber);\n        array[licznik] = userNumber;\n        licznik++;\n    }\n    for(int i = 0; i < 10; i++){\n        if(array[i] > 0){\n            sumPlus += array[i];\n            licznikPlus++;\n        }\n        if(array[i] < 0){\n            sumMinus += array[i];\n            licznikMinus++;\n        }\n    }\n    if (licznikPlus != 0) {\n        printf(\"Srednia arytmatyczna dodatnich elementow: %.2f\\n\", sumPlus/licznikPlus);\n    } else {\n        printf(\"Srednia arytmatyczna dodatnich elementow wynosi 0\\n\");\n    }\n    if (licznikMinus != 0) {\n        printf(\"Srednia arytmatyczna ujemnych elementow: %.2f\\n\", sumMinus/licznikMinus);\n    } else {\n        printf(\"Srednia arytmatyczna ujemnych elementow wynosi 0\\n\");\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__queue_with_linkedlist.3.c", "original_string": "void Print() {\n    struct Node* temp = front;\n    while(temp != NULL) {\n        printf(\"%d  \\n\",temp->data);\n        temp = temp->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise17.1.c", "original_string": "int main(void)\n{\n    setvbuf(stdout , NULL , _IONBF , 0);\n    setvbuf(stderr , NULL , _IONBF , 0);\n    int i;\n    int a_size = 10;\n    int b_size = 5;\n    int array_A[a_size];\n    int array_B[b_size];\n    printf(\"Enter Array A elements: \");\n    for(i=0 ; i < a_size ; i++){\n        scanf(\"%d\",&array_A[i]);\n            }\n    printf(\"\\n\");\n    printf(\"Enter Array B elements: \");\n    for(i=0 ; i < b_size ; i++){\n        scanf(\"%d\",&array_B[i]);\n        }\n    printf(\"Array A before the Swap : \");\n    for(i=0;i<a_size;i++)\n    {\n        printf(\"%d \",array_A[i]);\n    }\n    printf(\"\\n\");\n    printf(\"Array B before the Swap : \");\n    for(i=0;i<b_size;i++)\n    {\n        printf(\"%d \",array_B[i]);\n    }\n    printf(\"\\n\");\n    Swap(a_size,array_A,b_size,array_B);\n    printf(\"Array A after the Swap : \");\n    for(i=0;i<b_size;i++)\n    {\n        printf(\"%d \",array_A[i]);\n    }\n    printf(\"\\n\");\n    printf(\"Array B after the Swap : \");\n    for(i=0;i<b_size;i++)\n    {\n        printf(\"%d \",array_B[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__os.16.c", "original_string": "SUBROUTDEC* getossubroutdec(CLASS* os, SUBROUTCALL* call) {\n    CLASS* c = getosclass(os, call->parentname);\n    if(c == NULL)\n        return NULL;\n    return getsubroutdecinclass(c, call->name);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__BinHexConverter.4.c", "original_string": "size_t convertBinDataToHexString8(uint8_t *inputData, size_t inputDataSize, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < inputDataSize * 2) \n  {\n    return 0;\n  }\n  outputStr[0] = '\\0';\n  size_t count = 0;\n  for ( size_t i = 0 ; i < inputDataSize; i++ )\n  {\n    count += convertBinValueToHexString8(inputData[i], outputStr + 2 * i, outputStrSize - count, upperCase);\n  }\n  if (outputStrSize > count) \n  {\n    outputStr[count++] = '\\0';\n  }\n  return count;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es31.4.c", "original_string": "int main(void) \n{\n    float ac, gamma, bc=15;\n    int alfa = 90;\n    float ipotenusa, perimetro, altezza, area;\n    printf(\"\\n-------------------------------------\\n\");\n    printf(\"Inserisci il valore del cateto minore: \");\n    scanf(\"%f\", &ac);\n    printf(\"Inserisci il valore dell'angolo gamma: \");\n    scanf(\"%f\", &gamma);\n    printf(\"\\n-------------------------------------\\n\");\n    calcolo_ipotenusa(&ac, &gamma, &ipotenusa);\n    printf(\"L'ipotenusa del triangolo \u00e8: %f\\n\", ipotenusa);\n    perimetro = calcolo_perimetro(ac, ipotenusa, &bc);\n    printf(\"Il perimetro del triangolo \u00e8: %f\\n\", perimetro);\n    calcolo_area(&perimetro, ac, &ipotenusa, &bc, &area);\n    printf(\"L'area del triangolo \u00e8: %f\\n\", area);\n    altezza = calcolo_altezza(&ipotenusa, &area);\n    printf(\"L'altezza del triangolo \u00e8: %f\\n\", altezza);\n    return 0;\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise22.1.c", "original_string": "int main(void)\n{\n    int arr1[10] = {1,2,3,3,3,4,4,5,5,5};\n    int arr2[10];\n    int arr2_usedSize = 0;\n    int ret,i;\n    ret = removeDuplicates(arr1,10,arr2,&arr2_usedSize);\n    if(ret == SUCCESS)\n    {\n        for(i=0;i<arr2_usedSize;i++)\n        {\n            printf(\"%d \\t\",arr2[i]);\n        }\n    }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.2.c", "original_string": "void splitNode (int val, int *pval, int pos, struct btreeNode *node,\n     struct btreeNode *child, struct btreeNode **newNode) {\n        int median, j;\n        if (pos > MIN)\n                median = MIN + 1;\n        else\n                median = MIN;\n        *newNode = (struct btreeNode *)malloc(sizeof(struct btreeNode));\n        j = median + 1;\n        while (j <= MAX) {\n                (*newNode)->val[j - median] = node->val[j];\n                (*newNode)->link[j - median] = node->link[j];\n                j++;\n        }\n        node->count = median;\n        (*newNode)->count = MAX - median;\n        if (pos <= MIN) {\n                addValToNode(val, pos, node, child);\n        } else {\n                addValToNode(val, pos - median, *newNode, child);\n        }\n        *pval = node->val[node->count];\n        (*newNode)->link[0] = node->link[node->count];\n        node->count--;\n  }"}
{"author": "dishanp", "file": "DSA__q11.0.c", "original_string": "int main()\n{\n   int i,n,a[100];\n   printf(\"number of elements to store in the array :\");\n   scanf(\"%d\",&n);\n   printf(\"Input %d number of elements in the array :\\n\",n);\n   for(i=0;i<n;i++)\n      {\n      printf(\"element - %d : \",i);\n      scanf(\"%d\",&a[i]);\n      }\n   printf(\"\\nvalues oF the array are : \\n\");\n   for(i=0;i<n;i++)\n     {\n       printf(\"% 5d\",a[i]);\n     }\n   printf(\"\\n values of array in reverse are :\\n\");\n   for(i=n-1;i>=0;i--)\n      {\n       printf(\"% 5d\",a[i]);\n      }\n   printf(\"\\n\\n\");\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__QuickSort.1.c", "original_string": "void getdata(int x[50],int n)\n       {\n        int k;\n        printf(\"enter the value  for sorting\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        }     \n       }"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio20.1.c", "original_string": "void *fhilo2(void *arg){\n    int i;\n    printf(\"\\nLos valores del buffer son: \\n\");\n    for(i = 0; i < 10; i++){\n        sem_trywait(&semaforo); \n        printf(\"%d, \",buffer[i]);\n        buffer[i] = 0;\n        sem_post(&semaforo);\n    }\n    sleep(random()%3);\n    printf(\"\\n\");\n    for(i = 0; i < 10; i++){\n        printf(\"%d, \",buffer[i]);\n    }\n    pthread_exit(NULL);\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__telephone1.1.c", "original_string": "void *display_dir(void *para)\n{\n    printf(\"entered in to the thread2  process!\\n\");\n    FILE *fp;\n    printf(\"\\ncustomer details\\n\");\n    fp=fopen(\"details.txt\",\"r\");\n    if(fp==NULL)\n    {\n        printf(\"error!\");\n        exit(1);\n    }\n    for (i=0;i<beg;i++)\n    {\n        fread(&cust,sizeof(struct tele),1,fp);\n        printf(\"(%d) %s %s\\t :%s\\n\",i+1,cust[i].name,cust[i].sir_name,cust[i].number);\n    }\n        fclose(fp);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__arrayADT.3.c", "original_string": "int main(){\n     struct myArray marks;\n     createArray(&marks, 100, 2);\n     printf(\"We are running setVal function now.\\n\");\n     setVal(&marks);\n     printf(\"We are running show function now.\\n\");\n     show(&marks);\n     return 0;\n}"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__utils.0.c", "original_string": "void    global_init(void)\n{\n    g_no = NULL;\n    g_so = NULL;\n    g_we = NULL;\n    g_ea = NULL;\n    g_width = 0;\n    g_height = 0;\n    g_fr = -1;\n    g_fg = -1;\n    g_fb = -1;\n    g_cr = -1;\n    g_cg = -1;\n    g_cb = -1;\n    g_map_started = 0;\n    g_map = ft_strdup(\"\");\n}"}
{"author": "paawankohli", "file": "DSA-LAB__singlyLL.6.c", "original_string": "int deleteRear(nptr &head)\n{\n    if (head == NULL)\n        return -1;\n    nptr rear2 = head;\n    nptr rear = head -> next;\n    while(rear -> next != NULL)\n    {\n        rear2 = rear2 -> next;\n        rear = rear -> next;\n    }\n    rear2 -> next = rear2 -> next -> next;\n    int x = rear -> data;\n    free(rear);\n    return x;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc.14.c", "original_string": "int main()\n{\n    int ch;\n    node* root=NULL;\n    while (1)\n    {\n        printf(\"\\n1. RECURSIVE INSERTION\\n\");\n        printf(\"2. ITERATIVE INSERTION\\n\");\n        printf(\"3. IN-ORDER TRAVERSAL\\n\");\n        printf(\"4. PRE-ORDER TRAVERSAL\\n\");\n        printf(\"5. POST-ORDER TRAVERSAL\\n\");\n        printf(\"6. HEIGHT OF BINARY TREE\\n\");\n        printf(\"7. CONSTRUCT MIRROR IMAGE\\n\");\n        printf(\"8. COUNT TOTAL NUMBER OF NODES\\n\");\n        printf(\"9. COUNT TOTAL NUMBER OF LEAF NODES\\n\");\n        printf(\"10. COUNT TOTAL NUMBER OF INTERNAL NODES\\n\");\n        printf(\"11. MAX AND MIN ELEMENTS IN THE BINARY TREE\\n\");\n        printf(\"12. DEALLOCATE SPACE OCCUPIED BY BINARY TREE\\n\");\n        printf(\"13. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1)\n        {\n            int n;\n            printf(\"Please enter an element: \");\n            scanf(\"%d\",&n);\n            root=rec_insertion(root,n);\n            printf(\"\\n%d inserted in BINARY SEARCH TREE using Recursive Insertion\\n\",n);\n        }\n        else if(ch==2)\n        {\n            int n;\n            printf(\"Please enter an element: \");\n            scanf(\"%d\",&n);\n            iter_insertion(&root,n);\n            printf(\"\\n%d inserted in BINARY SEARCH TREE using Iterative Insertion\\n\",n);\n        }\n        else if(ch==3)\n        {\n            if(root==NULL)\n                printf(\"\\n\\tTREE EMPTY\\n\");\n            else\n            {\n                printf(\"\\n     IN-ORDER\\n\");\n                rec_inorder(root);\n            }\n        }\n        else if(ch==4)\n        {\n            if(root==NULL)\n                printf(\"\\n\\tTREE EMPTY\\n\");\n            else\n            {\n                printf(\"\\n     PRE-ORDER\\n\");\n                rec_preorder(root);\n            }\n        }\n        else if(ch==5)  \n        {\n            if(root==NULL)\n                printf(\"\\n\\tTREE EMPTY\\n\");\n            else\n            {\n                printf(\"\\n     POST-ORDER\\n\");\n                rec_postorder(root);\n            }\n        }\n        else if(ch==6)\n            printf(\"\\nHeight of the tree: %d\\n\",height(root));\n        else if(ch==7)\n        {\n            mirror_image(&root);\n            printf(\"\\nImage Tree Created\\n\");\n        }\n        else if(ch==8)\n                printf(\"\\nTotal number of nodes: %d\\n\",count_totalnodes(root));\n        else if(ch==9)\n            printf(\"\\nNumber of leaf nodes: %d\\n\",count_leafnodes(root));\n        else if(ch==10)\n            printf(\"\\nNumber of internal nodes: %d\\n\",count_internalnodes(root));\n        else if(ch==11)\n        {\n            printf(\"\\nMaximum element: %d\\n\",largest_element(root));\n            printf(\"Minimum element: %d\\n\",smallest_element(root));\n        }\n        else if(ch==12)\n        {\n            deallocate_space(root);\n            root=NULL;\n            printf(\"\\n\\nDeallocated the space occupied by Binary Tree.\\n\");\n        }\n        else if(ch==13)\n        {\n            printf(\"\\nExitting Program, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"\\nINVALID CHOICE! TRY AGAIN\\n\");\n    }\n    return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__list-push-pop-del-rec_rev-count.2.c", "original_string": "node* pop(node* head)\n{\n    if(head==NULL)\n        printf(\"CAN'T POP, STACK EMPTY\\n\");\n    else if(head->next==NULL)\n    {\n        printf(\"%d popped from stack\\n\",head->data);\n        free(head);\n        return NULL;\n    }\n    else\n    {\n        head->next=pop(head->next);\n        return head;\n    }\n}"}
{"author": "jose120918", "file": "binary_trees__102-binary_tree_is_complete.0.c", "original_string": "size_t tree_size(const binary_tree_t *tree)\n{\n    int count = 0;\n    if (tree == NULL)\n    {\n        return (0);\n    }\n    count = 1 + tree_size((*tree).left) + tree_size((*tree).right);\n    return (count);\n}"}
{"author": "MFarid94", "file": "Assignment4__Exercise12.1.c", "original_string": "int main(void)\n{\n    int arr[ARRAY_SIZE] = {1,2,3,1,2,3,1,1,1,1,3,3,3};\n    int num = OddRepetitionNumberInArray(arr,ARRAY_SIZE);\n    printf(\"number is : %d\",num); \n    return 0;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_07.1.c", "original_string": "void display(int A[],int n)\n{\n  int i;\n  for(i=0;i<n;i++)\n  {\n        fprintf(F2,\"%d \",A[i]);\n        if(i==(n-1))\n        fprintf(F2,\"\\n\");}\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__print_hex.1.c", "original_string": "int     ft_atoi(char *str)\n{\n    int     i;\n    int     sign;\n    int     res;\n    res = 0;\n    sign = 1;\n    if (str[0] == '-')\n        sign = -1;\n    i = 0;\n    while (str[i])\n    {\n        res = res * 10 + str[i] - 48;\n        i++;\n    }\n    return (res * sign);\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.10.c", "original_string": "SUBROUTDEC* getmethod(SCOPE* s, VAR* parent, SUBROUTCALL* call) {\n    CLASS* c = getclass(s, parent->type);\n    SUBROUTDEC* d = getsubroutdecfromlist(c->subroutdecs, call->name);\n    if(d == NULL)\n        return NULL;\n    if(d->subroutclass != method) {\n        eprintf(\"Calling a function/constructor as if it were a method; file '%s', line %i\\n\", call->debug->file, call->debug->definedat);\n        exit(1);\n    }\n    return d;\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.31.c", "original_string": "ASMBLK* translatecomp(VMTRANSLATOR* t, char* op) {\n    int labellen;\n    char* label = mkcmplab(t, &labellen);\n    tcomp.items[tcomp.count-6] = atraw(t, label, labellen);\n    int sz = sizeof(char) * 6;\n    char* trueop = (char*)malloc(sz);\n    sprintf(trueop, \"D;J%s\", op);\n    tcomp.items[tcomp.count-5] = trueop;\n    togarbage(t, trueop);\n    tcomp.items[tcomp.count-1] = enclosingparenthesis(t, label, labellen);\n    return copytemplate(&tcomp);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_nonce.0.c", "original_string": "error_t acmeClientSendNewNonceRequest(AcmeClientContext *context)\n{\n   error_t error;\n   error = NO_ERROR;\n   while(!error)\n   {\n      if(context->requestState == ACME_REQ_STATE_INIT)\n      {\n         TRACE_DEBUG(\"\\r\\n\");\n         TRACE_DEBUG(\"################################################################################\\r\\n\");\n         TRACE_DEBUG(\"## GET NEW NONCE ###############################################################\\r\\n\");\n         TRACE_DEBUG(\"################################################################################\\r\\n\");\n         TRACE_DEBUG(\"\\r\\n\");\n         if(context->nonce[0] != '\\0')\n         {\n            break;\n         }\n         else\n         {\n            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)\n      {\n         error = acmeClientFormatRequestHeader(context, \"HEAD\",\n            context->directory.newNonce);\n         if(!error)\n         {\n            context->requestState = ACME_REQ_STATE_SEND_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||\n         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||\n         context->requestState == ACME_REQ_STATE_CLOSE_BODY)\n      {\n         error = acmeClientSendRequest(context);\n      }\n      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)\n      {\n         error = acmeClientParseNewNonceResponse(context);\n         context->requestState = ACME_REQ_STATE_INIT;\n         break;\n      }\n      else\n      {\n         error = ERROR_WRONG_STATE;\n      }\n   }\n   return error;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__LLqueue.4.c", "original_string": "int main()\n{\n    printf(\"1. Push    2. Pop    3. Display    0.Exit\\n\");\n    int ch, ele;\n    nptr queue = NULL;\n    do\n    {\n        printf(\"Command: \"); scanf(\"%d\", &ch);\n        switch(ch)\n        {\n            case 1:     \n                    printf(\"Element: \"); scanf(\"%d\", &ele);\n                    push(queue, ele);\n                    break;\n            case 2:\n                    ele = pop(queue);\n                    if(ele == -1)\n                        printf(\"Queue empty!\\n\");\n                    else\n                        printf(\"%d popped!\\n\", ele);\n                    break;\n            case 3:\n                    display(queue);\n        }\n    }while(ch != 0);\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__rpn_calc.2.c", "original_string": "int     isnum(char *str)\n{\n    int ctrl;\n    ctrl = 0;\n    if (str[ctrl] == '+' || str[ctrl] == '-')\n        ctrl++;\n    if (str[ctrl] >= 0 && str[ctrl] <= 9)\n        return (1);\n    return (0);\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es32.3.c", "original_string": "int main(void) {\n    int dim;\n    int i = 0;\n    int n, risultato;\n    printf(\"Inserire dimensione array: \"); \n    scanf(\"%d\", &dim);\n    int a[dim];\n    for(int i=0; i<dim; i++)\n    {\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\n\");\n    printf(\"Inserisci il numero che vuoi ricercare nell'array: \");\n    scanf(\"%d\", &n);\n    printf(\"----------------------------\\nVettore inserito:\\n\");\n    stampa_vettore(a, dim);\n    printf(\"\\n\");\n    delta_minimo(a, n, dim);\n    return 0;\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_gpio.1.c", "original_string": "void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)\n{\n  uint32_t position;\n  uint32_t ioposition = 0x00U;\n  uint32_t iocurrent = 0x00U;\n  uint32_t tmp = 0x00U;\n  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));\n  for(position = 0U; position < GPIO_NUMBER; position++)\n  {\n    ioposition = 0x01U << position;\n    iocurrent = (GPIO_Pin) & ioposition;\n    if(iocurrent == ioposition)\n    {\n      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2U));\n      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;\n      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));\n      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;\n      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));\n      tmp = SYSCFG->EXTICR[position >> 2U];\n      tmp &= (0x0FU << (4U * (position & 0x03U)));\n      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))\n      {\n        tmp = 0x0FU << (4U * (position & 0x03U));\n        SYSCFG->EXTICR[position >> 2U] &= ~tmp;\n        EXTI->IMR &= ~((uint32_t)iocurrent);\n        EXTI->EMR &= ~((uint32_t)iocurrent);\n        EXTI->RTSR &= ~((uint32_t)iocurrent);\n        EXTI->FTSR &= ~((uint32_t)iocurrent);\n      }\n    }\n  }\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__adivina.1.c", "original_string": "int menu(){\n    int opcion;\n    system(\"clear\");\n    printf(\"Juedo de adivina un n\u00famero.\\n\");\n    printf(\"1. Jugar\\n\");\n    printf(\"2. Salir\\n\");\n    printf(\"Elije una opci\u00f3n:\");\n    scanf(\"%d\", &opcion);\n    return opcion;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__linear_search.0.c", "original_string": "void linear(int a[],int n,int data)\n{\n    int i,result=0;\n    for(i=0;i<n;i++)\n    {\n        if(a[i]==data)\n        {\n            result=1;\n            break;\n        }\n    }\n    if(result==0)\n    {\n        printf(\"the element is not found in the array \\n\");\n    }\n    else\n    {\n        printf(\"the element is  found in the array at index %d \\n\",i);\n        printf(\"the element is  found in the array at position  %d \\n\",i+1);\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__n-bishop-a.1.c", "original_string": "int safe(int arr[N][N], int row, int col){\n    int i,j;\n    for (i = row-1, j = col-1; i >= 0 && j >= 0; i--, j--)\n        if(arr[i][j])\n            return 0;\n    for (i = row+1, j = col+1; i < N && j < N; i++, j++)\n        if(arr[i][j])\n            return 0;\n    for (i = row+1, j = col-1; i < N && j >= 0; i++, j--)\n        if(arr[i][j])\n            return 0;\n    for (i = row-1, j = col+1; i >= 0 && j < N; i--, j++)\n        if(arr[i][j])\n            return 0;\n    return 1;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__pwm_double_edge.1.c", "original_string": "void delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__SelectionSort.3.c", "original_string": "void selectionsort(int numbers[],int array_size)\n{\n    int i,j,T,min;\n    count++;\n    for(i=0;i<array_size;i++)\n    {\n        count++;\n        min=i;\n        count++;\n        for(j=i+1;j<array_size;j++)\n        {\n            count++;\n            if(numbers[j]<numbers[min])\n            {\n                count++;\n                min=j;\n                count++;\n            }\n        }\n        count++;\n        if(i!=min)\n        {\n        count++;\n        T=numbers[min];\n        count++;\n        numbers[min]=numbers[i];\n        count++;\n        numbers[i]=T;\n        count++;\n        }\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__bridge_mib_impl_tp.6.c", "original_string": "error_t bridgeMibGetNextDot1dTpPortEntry(const MibObject *object, const uint8_t *oid,\n   size_t oidLen, uint8_t *nextOid, size_t *nextOidLen)\n{\n   error_t error;\n   uint_t i;\n   size_t n;\n   uint_t numPorts;\n   uint16_t portNum;\n   uint16_t curPortNum;\n   portNum = 0;\n   if(*nextOidLen < object->oidLen)\n      return ERROR_BUFFER_OVERFLOW;\n   osMemcpy(nextOid, object->oid, object->oidLen);\n   numPorts = bridgeMibGetNumPorts();\n   for(i = 1; i <= numPorts; i++)\n   {\n      curPortNum = bridgeMibGetPortNum(i);\n      n = object->oidLen;\n      error = mibEncodeIndex(nextOid, *nextOidLen, &n, curPortNum);\n      if(error)\n         return error;\n      if(oidComp(nextOid, n, oid, oidLen) > 0)\n      {\n         if(portNum == 0 || curPortNum < portNum)\n         {\n            portNum = curPortNum;\n         }\n      }\n   }\n   if(portNum == 0)\n      return ERROR_OBJECT_NOT_FOUND;\n   n = object->oidLen;\n   error = mibEncodeIndex(nextOid, *nextOidLen, &n, portNum);\n   if(error)\n      return error;\n   *nextOidLen = n;\n   return NO_ERROR;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__22_senh.3.c", "original_string": "void Senh(int contador, int iteraciones, double total, double X)\n{\n    if(contador <= iteraciones){\n        total = total + Exp((contador*2)+1,X) / Fac((contador*2)+1);\n        Senh(++contador,iteraciones,total,X);\n    }else{\n        printf(\"\\n**El Senh(%lf) es igual a: %lf\",X,total+X);\n    }\n}"}
{"author": "dle2005", "file": "Algorithm__n_Coloring_v2.1.c", "original_string": "void m_coloring(int i) {\n    for(int color = 1; color <= n; color++)\n        printf(\"%d \", vcolor[color]);\n    printf(\"\\n\");\n    if(promising(i)) {\n        if(i == n) {\n            printf(\"volor = \");\n            for(int color = 1; color <= n; color++)\n                printf(\"%d \", vcolor[color]);\n            printf(\"\\n\");\n        }\n        else {\n            for(int color = 1; color <= m; color++) {\n                vcolor[i+1] = color;\n                m_coloring(i+1);\n            }\n        }\n    }\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad10.0.c", "original_string": "int main()\n{\n    float a, c, x1, x2, delta;\n    printf(\"Prosz\\251 poda\\206 warto\\230\\206 wsp\\242\\210czynnika a: \");\n    scanf(\"%f\", &a);\n    printf(\"Prosz\\251 poda\\206 warto\\230\\206 wsp\\242\\210czynnika c: \");\n    scanf(\"%f\", &c);\n    delta = (2*2) - 4*3*a*c;\n    if(a == 0){\n        printf(\"\\n'a' = 0!. Pierwiastek wynosi:\");\n        x1 = (-3*c)/2;\n        printf(\"\\nX1= %.2f\\n\", x1);\n    }else if(delta < 0){\n        printf(\"Rownanie nie ma rozwiazan.\");\n    } else {\n        x1 = (-2-sqrt(delta))/(2*a);\n        x2 = (-2+sqrt(delta))/(2*a);\n        printf(\"\\nX1= %.2f\\n\", x1);\n        printf(\"X1= %.2f\\n\", x2);\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example11.0.c", "original_string": "int main()\n{\n    int toplam=0,i,arr[BOYUT];\n    for(i=0;i<BOYUT;i++)\n    {\n        printf(\"%d. de\u011feri giriniz:\",i+1);\n        scanf(\"%d\",&arr[i]);\n    }\n    arr[BOYUT]=0;\n    for(i=0;i<BOYUT;i+=2)\n    {   \n        toplam+=mutDeger(arr[i],arr[i+1]);\n    } \n     printf(\"%d\\n\",toplam);\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__BubbleSort.2.c", "original_string": "void putdata(int x[50], int n)\n       {\n          int k;\n          for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n         }\n          printf(\"\\n\");\n       }"}
{"author": "augustogunsch", "file": "jackc__parser-tree.13.c", "original_string": "void freeclassvardecs(CLASSVARDEC* cvd) {\n    freevardec(cvd->base);\n    CLASSVARDEC* next = cvd->next;\n    free(cvd);\n    if(next != NULL)\n        freeclassvardecs(next);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__doublyLL.6.c", "original_string": "int main()\n{\n    nptr head = NULL;\n    printf(\"1. insertLeft 2. insertRight 3. deleteLeft 4. deleteRight 5. display 6. exit\\n\");\n    int ch,  ele;\n    do\n    {\n        printf(\"Command: \"); scanf(\"%d\", &ch);\n        switch(ch)\n        {\n            case 1: \n                    scanf(\"%d\", &ele);\n                    head = insertLeft(head, ele);\n                    break;\n            case 2: \n                    scanf(\"%d\", &ele);\n                    head = insertRight(head, ele);\n                    break;\n            case 3: head = deleteLeft(head);\n                    break;\n            case 4: head = deleteRight(head);\n                    break;\n            case 5: display(head);\n        }\n    }while(ch != 6);\n}"}
{"author": "behergue", "file": "Computer_Structure__main0.1.c", "original_string": "void button_ISR(void)\n{\n    unsigned int whicheint = rEXTINTPND;\n    unsigned int buttons = (whicheint >> 2) & 0x3;\n    if (buttons & ~BUT1) {\n        led1_off();\n        led2_off();\n        if(RL.direction == 0)\n        {\n            RL.direction = 1;\n        }\n        else\n        {\n            RL.direction = 0;\n        }\n    }\n    if (buttons & ~BUT2) {\n        led1_switch();\n        led2_switch();\n        if (RL.moving == 0)\n        {\n            RL.moving= 1;\n        }\n        else\n        {\n            RL.moving= 0;\n        }\n    }\n    Delay(2000);\n    rEXTINTPND &= ~(0x03 << 2);\n}"}
{"author": "kalpa96", "file": "Struct__comple.3.c", "original_string": "struct complex multiply(struct complex n1, struct complex n2) {\n    struct complex temp2;\n    temp2.real = n1.real * n2.real;\n    temp2.imag = n1.imag * n2.imag;\n    return (temp2);\n}"}
{"author": "sdukesameer", "file": "dsa__list-by-stack.1.c", "original_string": "void push(node** head, int n)\n{\n    node* linklist=createNode();\n    linklist->data=n;\n    linklist->next=*head;\n    *head=linklist;\n    printf(\"%d pushed to stack\\n\",n);\n}"}
{"author": "Theemiss", "file": "simple_shell__more_fun.4.c", "original_string": "char *_strdup(char *str)\n{\n    size_t len, i;\n    char *str2;\n    len = _strlen(str);\n    str2 = malloc(sizeof(char) * (len + 1));\n    if (!str2)\n    {\n        return (NULL);\n    }\n    for (i = 0; i <= len; i++)\n    {\n        str2[i] = str[i];\n    }\n    return (str2);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q3.0.c", "original_string": "node* newNode(int v)\n{\n    node *temp = (node*)malloc(sizeof(node));\n    temp->left = temp->right = NULL;\n    temp->data = v;\n    return temp;\n}"}
{"author": "Oryx-Embedded", "file": "Common__path.5.c", "original_string": "void pathCanonicalize(char_t *path)\n{\n   size_t i;\n   size_t j;\n   size_t k;\n   i = 0;\n   k = 0;\n   while(path[i] != '\\0')\n   {\n      if(path[i] == '/' || path[i] == '\\\\')\n      {\n         path[k++] = '/';\n         while(path[i] == '/' || path[i] == '\\\\') i++;\n      }\n      else\n      {\n         path[k++] = path[i++];\n      }\n   }\n   path[k] = '\\0';\n   i = 0;\n   j = 0;\n   k = 0;\n   do\n   {\n      if(path[i] == '/' || path[i] == '\\0')\n      {\n         if((i - j) == 1 && !osStrncmp(path + j, \".\", 1))\n         {\n            if(k == 0)\n            {\n               if(path[i] == '\\0')\n               {\n                  path[k++] = '.';\n               }\n               else if(path[i] == '/' && path[i + 1] == '\\0')\n               {\n                  path[k++] = '.';\n                  path[k++] = '/';\n               }\n            }\n            else if(k > 1)\n            {\n               if(path[i] == '\\0')\n                  k--;\n            }\n         }\n         else if((i - j) == 2 && !osStrncmp(path + j, \"..\", 2))\n         {\n            if(k == 0)\n            {\n               path[k++] = '.';\n               path[k++] = '.';\n               if(path[i] == '/')\n                  path[k++] = '/';\n            }\n            else if(k > 1)\n            {\n               for(j = 1; j < k; j++)\n               {\n                  if(path[k - j - 1] == '/')\n                     break;\n               }\n               if(j < k)\n               {\n                  if(!osStrncmp(path + k - j, \"..\", 2))\n                  {\n                     path[k++] = '.';\n                     path[k++] = '.';\n                  }\n                  else\n                  {\n                     k = k - j - 1;\n                  }\n                  if(k == 0 && path[0] == '/')\n                     path[k++] = '/';\n                  else if(path[i] == '/')\n                     path[k++] = '/';\n               }\n               else\n               {\n                  if(k == 3 && !osStrncmp(path, \"..\", 2))\n                  {\n                     path[k++] = '.';\n                     path[k++] = '.';\n                     if(path[i] == '/')\n                        path[k++] = '/';\n                  }\n                  else if(path[i] == '\\0')\n                  {\n                     k = 0;\n                     path[k++] = '.';\n                  }\n                  else if(path[i] == '/' && path[i + 1] == '\\0')\n                  {\n                     k = 0;\n                     path[k++] = '.';\n                     path[k++] = '/';\n                  }\n                  else\n                  {\n                     k = 0;\n                  }\n               }\n            }\n         }\n         else\n         {\n            osMemmove(path + k, path + j, i - j);\n            k += i - j;\n            if(path[i] == '/')\n               path[k++] = '/';\n         }\n         while(path[i] == '/') i++;\n         j = i;\n      }\n   } while(path[i++] != '\\0');\n   path[k] = '\\0';\n}"}
{"author": "sdukesameer", "file": "dsa__list-by-stack.3.c", "original_string": "void pop(node** head)\n{\n    if(isempty(*head))\n        printf(\"STACK EMPTY\\n\");\n    else\n    {\n        node* temp=*head;\n        *head=(*head)->next;\n        printf(\"%d popped from stack\\n\",temp->data);\n        free(temp);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q32.3.c", "original_string": "Ans find(QUEUE* q,int e)\n{\n    QUEUE q1;\n    QUEUE* nq=&q1;\n    int num;\n    Ans f=False;\n    init(nq);\n    while(q->front!=q->rear)\n    {\n        num=del(q);\n        if(num==e)\n        {\n            f=True;\n            add(num,nq);\n        }\n        else\n            add(num,nq);\n    }\n    while(nq->front!=nq->rear)\n    {\n        add(del(nq),q);\n    }\n    return f;\n}"}
{"author": "2security", "file": "Matrix__39CheckSparseMatrix.0.c", "original_string": "void displayMat(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__UARTDrv0.1.c", "original_string": "void uart_recvTask(void)\n{\n  size_t rxDataLen = 0;\n  if (uart_get_buffered_data_len(uartUnit, &rxDataLen) != ESP_OK) \n  {\n    return;\n  }\n  if (rxDataLen == 0) \n  {\n    return;\n  }\n  uint8_t *data = ((uint8_t *)(malloc(rxDataLen)));\n  uart_read_bytes(uartUnit, data, ((uint32_t)(rxDataLen)), 100 / portTICK_RATE_MS);\n  for ( int64_t __i = 0 ; __i < rxDataLen; __i++ )\n  {\n    firmwareUpdateInfoReader_onCharacterReceived(*(data + __i));\n  }\n  if (data != NULL) \n  {\n    free(data);\n  }\n}"}
{"author": "flora0110", "file": "hw03git__4108056029_1-1.2.c", "original_string": "void modify(int x,int value,int l,int r,node* ptr){\n    if(l==r){\n        ptr->sum=value;\n        ptr->ls=value;\n        ptr->rs=value;\n        ptr->max=value;\n        return;\n    }\n    int m=(r+l)/2;\n    if(x<=m){\n        modify(x,value,l,m,ptr->left);\n    }\n    else{\n        modify(x,value,m+1,r,ptr->right);\n    }\n    ptr->sum=ptr->left->sum+ptr->right->sum;\n    ptr->ls=max(ptr->left->ls,ptr->left->sum+ptr->right->ls);\n    ptr->rs=max(ptr->right->rs,ptr->right->sum+ptr->left->rs);\n    ptr->max=max(max(ptr->right->max,ptr->left->max),ptr->left->rs+ptr->right->ls);\n    return;\n}"}
{"author": "sdukesameer", "file": "dsa__bfs-dfs.0.c", "original_string": "void input(graph* g){\n    int i,j,f,x=1;\n    while(x){\n        printf(\"\\nEnter the number of vertices: \");\n        scanf(\"%d\",&g->n);\n        if(g->n>0)\n            x=0;\n        else\n            printf(\"Invalid input. Try again.\\n\");\n    }\n    g->arr=(int**) malloc(sizeof(int*)*g->n);\n    for(i=0;i<g->n;i++)\n        g->arr[i]=(int*)malloc(sizeof(int)*g->n);\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++)\n            g->arr[i][j]=-1;\n    for(i=0;i<g->n;i++)\n        for(j=0;j<g->n;j++){\n            if(g->arr[i][j]==1 || g->arr[i][j]==0)\n                continue;\n            if(i==j){\n                g->arr[i][j]=0;\n                continue;\n            }\n            x=1;\n            while(x){\n                printf(\"Is there an edge between %c and %c (Yes=1 & No=0): \",'A'+i,'A'+j);\n                scanf(\"%d\",&f);\n                if(f==0 || f==1){\n                    g->arr[i][j]=f;\n                    g->arr[j][i]=f;\n                    x=0;\n                }\n                else\n                    printf(\"Invalid input. Try again.\\n\");\n            }\n        }\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_07.5.c", "original_string": "void insertionSort(int arr[], int n)\n{\n    int i, key, j;\n    for (i = 1; i < n; i++)\n    {\n        key = arr[i];\n        j = i - 1;\n        while (j >= 0 && arr[j] > key)\n        {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n }"}
{"author": "mehedi9021", "file": "Data_Structure__stack_pallindrom_string.4.c", "original_string": "int main() {\n    char inputString[100], c;\n    int i, length;\n    printf(\"Enter a string\\n\");\n    gets(inputString);\n    length = strlen(inputString);\n    for(i = 0; i < length; i++){\n        push(inputString[i]);\n    }\n    for(i = 0; i < length; i++){\n        if(pop() != inputString[i]) {\n            printf(\"Not a Palindrome String\\n\");\n            return 0;\n        }\n    }\n    printf(\"Palindrome String\\n\");\n    return 0;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_6.3.c", "original_string": "void print(node head,int n,FILE *fp2)\n{\n  node temp=head;\n  int count=0;\n  node p=head;\n  if(head==NULL)\n    {\n      fprintf(fp2,\"-1\\n\");\n      return;\n    }\n  int size=find_size(head);\n  if(n==0 || n>size)\n  {\n    while(temp!=NULL)\n   {\n    fprintf(fp2,\"%d\",temp->data);\n    temp=temp->next;\n    if(temp==NULL)\n    {\n      if(n>size)\n        fprintf(fp2,\" END\");\n      fprintf(fp2,\"\\n\");\n    }\n    else\n      fprintf(fp2,\" \");\n   }\n   return;\n  }\n  if(n>0 && n<=size)\n   {\n    while(count<n)\n    {\n      fprintf(fp2,\"%d\",p->data);\n      p=p->next;\n      count++;\n      if(count==n)\n        fprintf(fp2,\"\\n\");\n      else \n        fprintf(fp2,\" \");\n    }   \n   }\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zadOsmi.10.c", "original_string": "int Path(Position current, StackPosition stackHead)\n{\n    char stringToPrint[MAX_DIR_LENGTH] = \"\";\n    while (stackHead)\n    {\n            strcat(stringToPrint, stackHead->data->name);\n            strcat(stringToPrint, \"\\\\\");\n            stackHead = stackHead->next;\n    }\n    strcat(stringToPrint, \">\");\n    printf(\"%s \", stringToPrint);\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-expressions.0.c", "original_string": "bool isop(TOKEN* t) {\n    for(int i = 0; i < operators.size; i++)\n        if(!strcmp(t->token, operators.items[i]))\n            return true;\n    return false;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__lz77.0.c", "original_string": "int main()\n{\n    char *str = NULL;\n    int tam, k = 6, i0;\n    str = malloc(10002 * sizeof(char)); \n    fgets(str, 10002, stdin);\n    tam = strlen(str);\n    if (*(str + tam - 1) == '\\n') \n    {\n        *(str + tam - 1) = '\\0';\n    }\n    if (*str == '(')\n    {\n        decompress(str); \n    }\n    else\n    {\n        compress(str, k); \n    }\n    free(str); \n    return 0;\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example13.0.c", "original_string": "int main ()\n{\n    int num,fact=0;\n    printf(\"fakt\u00f6riyelini \u00f6\u011frenmek istedi\u011finiz say\u0131y\u0131 giriniz:\\n\");\n    scanf(\"%d\",&num);\n    fact=faktoriyel(num);\n    if(fact>0)\n        printf(\"\\n[%d]! = [%d]\\n\",num,fact);\nreturn 0;\n}"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio3.0.c", "original_string": "void *func1 (void *arg){\n    printf(\"He entrado en la func1\\n\");\n    if (pthread_mutex_init(&my_lock1, NULL) != 0) { \n        printf(\"\\nThread 1 mutex init has failed\\n\"); \n        return 1; \n    }\n    pthread_mutex_lock(&my_lock1);\n    printf(\"Soy el mutex thread y voy a introducir en aux todos 1\\n\");\n    for(int i = 0; i < 100; i++){\n        aux[i]=1;\n    }\n    printf(\"Thread 1:   El nuevo valor de aux es:\\n\");\n    for(int i = 0; i<100 ;i++){\n        printf(\"%d, \",aux[i]);\n    }\n    pthread_mutex_unlock(&my_lock1);\n    pthread_exit(NULL);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__reverse_the_DLL.1.c", "original_string": "void creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__arrayADT.1.c", "original_string": "void show(struct myArray *a){\n     for (int i = 0; i < a->usedSize; i++)\n     {\n          printf(\"%d\\n\", (a->ptr)[i]);\n     }\n}"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__map_utils.1.c", "original_string": "void        fill_map(char **map)\n{\n    int i;\n    int j;\n    int x;\n    int y;\n    i = 1;\n    j = 1;\n    x = 0;\n    y = 0;\n    while (x < g_map_height)\n    {\n        while (y < g_map_width)\n        {\n            if (y < ft_strlen(g_map_array[x]))\n                map[i][j] = g_map_array[x][y];\n            else\n                map[i][j] = ' ';\n            y++;\n            j++;\n        }\n        i++;\n        x++;\n        j = 1;\n        y = 0;\n    }\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__19_While.0.c", "original_string": "void Columna(int pibote)\n{\n    int j = 0;\n    while(j <= 40){\n        if(j >= 40 - pibote)\n            printf(\"A\");\n        else\n            printf(\" \");\n    ++j;\n    }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e8.0.c", "original_string": "int main(int argc, char *argv[]) {\n    char opcaoMenu;\n    char opcaoJogarNovamnt;\n    char opcaoJogador1;\n    char opcaoJogador2;\n    int opcaoJogador3;\n    int opcaoComputador;\n    char nomeJogador1[15];\n    char nomeJogador2[15];\n    char nomeJogador3[15];\n    char nomeComputador[15];\n    int empates = 0;\n    float vitoriasJogador1 = 0;\n    float vitoriasJogador2 = 0;\n    float vitoriasJogador3 = 0;\n    float vitoriasComputador = 0;\n    float percentVitJog1;\n    float percentVitJog2;\n    float percentVitJog3;\n    float percentVitComp;\n    int totalPartidas = 0;\n    system (\"COLOR 0F\");\n    system (\"cls\");\n    printf (\"Bem vindo ao jogo JOKENPO!\");\n    printf (\"\\n\\nDigite 1 para o modo Humano X Humano.\");\n    printf (\"\\nDigite 2 para o modo Humano X Computador.\");\n    printf (\"\\nDigite 3 para sair do jogo.\");\n    printf (\"\\n\\nEscolha o modo de jogar: \");\n    opcaoMenu = getch();\n    switch (opcaoMenu)\n        {\n        case '1':\n            system(\"cls\");\n            system (\"COLOR 0E\");\n            printf (\"Jogo Jokenpo: Modo Humano X Humano.\");\n            printf (\"\\n\\nJogador 1 - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador1);\n            printf (\"\\nJogador 2 - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador2);\n            do\n            {\n                system(\"cls\");\n                printf (\"Jogo Jokenpo - Modo Humano X Humano.\");\n                printf (\"\\n\\nDigite 1 para PEDRA.\");\n                printf (\"\\nDigite 2 para PAPEL.\");\n                printf (\"\\nDigite 3 para TESOURA.\");\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador1);\n                opcaoJogador1 = getch();\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador2);\n                opcaoJogador2 = getch();\n                if (opcaoJogador1 == opcaoJogador2)\n                {\n                    printf (\"\\n\\n%s e %s, voces EMPATARAM!\", nomeJogador1,nomeJogador2);\n                    empates++;\n                }else\n                {\n                    if (opcaoJogador1 == '1' && opcaoJogador2 == '3')\n                    {\n                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador1);\n                        vitoriasJogador1++;                         \n                    }else\n                    {\n                        if (opcaoJogador1 == '2' && opcaoJogador2 == '1')\n                        {\n                            printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador1);\n                            vitoriasJogador1++; \n                        }else\n                        {\n                            if (opcaoJogador1 == '3' && opcaoJogador2 == '2')\n                            {\n                                printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador1);\n                                vitoriasJogador1++;\n                            }else\n                            {\n                                if (opcaoJogador1 == '1' && opcaoJogador2 == '2')\n                                {\n                                    printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador2);\n                                    vitoriasJogador2++;\n                                }else\n                                {\n                                    if (opcaoJogador1 == '2' && opcaoJogador2 == '3')\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador2);\n                                        vitoriasJogador2++;\n                                    }else\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador2);\n                                        vitoriasJogador2++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }   \n                sleep(2);\n                totalPartidas++;\n                printf (\"\\n\\n\\nDeseja jogar novamente? S/N\");\n                opcaoJogarNovamnt = getch();\n            }\n            while (opcaoJogarNovamnt == 's');\n            break;\n        case '2':\n            system (\"COLOR 0A\");\n            system(\"cls\");\n            printf (\"Jogo Jokenpo - Modo Humano X Computador.\");\n            printf (\"\\n\\nJogador - Digite seu nome: \");\n            scanf (\"%s\", &nomeJogador3);\n            printf (\"\\n%s - Digite um nome para o computador: \",nomeJogador3);\n            scanf (\"%s\", &nomeComputador);\n            do\n            {\n                system(\"cls\");\n                printf (\"Jogo Jokenpo - Modo Humano X Computador.\");\n                printf (\"\\n\\nDigite 1 para PEDRA.\");\n                printf (\"\\nDigite 2 para PAPEL.\");\n                printf (\"\\nDigite 3 para TESOURA.\");\n                printf (\"\\n\\n%s - Escolha o que vai jogar: \", nomeJogador3);\n                scanf (\"%d\", &opcaoJogador3);\n                printf (\"\\n%s: Escolha o que vai jogar:\", nomeComputador);\n                sleep (2);\n                srand((unsigned)time(NULL));\n                opcaoComputador = (rand() % 3 + 1);\n                if (opcaoJogador3 == opcaoComputador)\n                {\n                    printf (\"\\n\\n%s e %s, voces EMPATARAM!\", nomeJogador3,nomeComputador);\n                    empates++;\n                }else\n                {\n                    if (opcaoJogador3 == 1 && opcaoComputador == 3)\n                    {\n                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeJogador3);\n                        vitoriasJogador3++;                         \n                    }else\n                    {\n                        if (opcaoJogador3 == 2 && opcaoComputador == 1)\n                        {\n                            printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeJogador3);\n                            vitoriasJogador3++; \n                        }else\n                        {\n                            if (opcaoJogador3 == 3 && opcaoComputador == 2)\n                            {\n                                printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeJogador3);\n                                vitoriasJogador3++;\n                            }else\n                            {\n                                if (opcaoJogador3 == 1 && opcaoComputador == 2)\n                                {\n                                printf (\"\\n\\nVitoria %s! Papel embrulha a pedra.\", nomeComputador);\n                                vitoriasComputador++;\n                                }else\n                                {\n                                    if (opcaoJogador3 == 2 && opcaoComputador == 3)\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Tesoura corta o papel.\", nomeComputador);\n                                        vitoriasComputador++;\n                                    }else\n                                    {\n                                        printf (\"\\n\\nVitoria %s! Pedra quebra a tesoura.\", nomeComputador);\n                                        vitoriasComputador++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                sleep (2);\n                totalPartidas++;\n                printf (\"\\n\\n\\nDeseja jogar novamente? S/N\");\n                opcaoJogarNovamnt = getch();\n            }\n            while (opcaoJogarNovamnt == 's');\n            break;\n        case '3':\n            system (\"COLOR 0F\");\n            printf (\"\\n\\nSaindo do jogo...\");\n            return 0;\n        default:\n            system (\"COLOR 0F\");\n            printf (\"\\n\\nOpcao invalida. Saindo do jogo...\");\n            return 0;\n        }\n    system(\"cls\");\n    system (\"COLOR 0F\");\n    if (totalPartidas == 1 && empates == 1)\n    {\n        printf (\"Jogo Jokenpo. Resultados: Modo Humano X Humano.\");\n        printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);\n        printf (\"\\nTotal de empates: %d\", empates);\n        printf (\"\\n\\nNao houve ganhador.\");\n    }else\n    {\n        if (opcaoMenu == '1')\n        {\n            printf (\"Jogo Jokenpo. Resultados: Modo Humano X Humano.\");\n            printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);            printf (\"\\nTotal de empates: %d\", empates);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\", nomeJogador1,percentVitJog1 = (vitoriasJogador1 / (totalPartidas - empates)) * 100);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\\n\\n\", nomeJogador2,percentVitJog2 = (vitoriasJogador2 / (totalPartidas - empates)) * 100);   \n        }\n        else\n        {\n            if (opcaoMenu == '2')\n            printf (\"Jogo Jokenpo. Resultados: Modo Humano X Computador.\");\n            printf (\"\\n\\nTotal de partidas: %d\", totalPartidas);\n            printf (\"\\nTotal de empates: %d\", empates);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\", nomeJogador3,percentVitJog3 = (vitoriasJogador3 / (totalPartidas - empates)) * 100);\n            printf (\"\\n\\n%s:\\nPercentual de vitorias: %.1f\\n\\n\", nomeComputador,percentVitComp = (vitoriasComputador / (totalPartidas - empates)) * 100);\n        }\n    }\nreturn 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__stack_using_array.0.c", "original_string": "int main()\n{\n    printf(\"THE STACK USING THE ARRAY\\n\");\n    printf(\"enter the size of the array(max size of the array is 50)= \\n\");\n    scanf(\"%d\",&N);\n    printf(\"1.push\\n2.pop\\n3.peek\\n4.display\\n5.is full\\n6.is empty\\n7.exit\\n\");\n    int choice;\n    do\n    {\n        printf(\"enter the choice= \");\n        scanf(\"%d\",&choice);\n        switch(choice)\n        {\n            case 1:printf(\"insert the element to the stack\\n\");\n            push();\n            break;\n            case 2:printf(\"delete the element from the stack\\n\");\n            pop();\n            break;\n            case 3:printf(\"display the top element in the stack\\n\");\n            peek();\n            break;\n            case 4:printf(\"display all the element in the stack\\n\");\n            display();\n            break;\n            case 5:printf(\"checking the stack is full or not\\n\");\n            isfull();\n            break;\n            case 6:printf(\"checking the stack is empty or not\\n\");\n            isempty();\n            break;\n            case 7:printf(\"exit \\n\");\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n    }while(choice!=7);\n    return 0;\n}"}
{"author": "earth429", "file": "mulpre__mulprec.9.c", "original_string": "int setInt(struct NUMBER *a, int x) {\n    int digit = 1; \n    int i;\n    for (int i = x; i >= 10; i /= 10) { \n        digit++;\n        if(digit > KETA) {\n            return -1;\n        }\n    }\n    clearByZero(a);\n    if(x > 0){\n        setSign(a, 1);\n    } else {\n        setSign(a, -1);\n    }\n    x = abs(x);\n    for (i = 0; i < KETA;i++){\n        a->n[i] = x % 10;\n        x /= 10;\n    }\n    return 0;\n}"}
