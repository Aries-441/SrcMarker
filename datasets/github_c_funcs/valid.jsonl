{"author": "JeyaramanOfficial", "file": "ARM_Batch212__i2c_MasterTxMode.1.c", "original_string": "void i2c_init(void)\n{\n    PINSEL0 |= (1<<4)|(1<<6);\n    PINSEL0 &= ~((1<<5)|(1<<7));        \n    I2CONSET = 1<<6;                                \n    I2SCLH = 75;                                        \n    I2SCLL = 75;\n}"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__cub2d_utils.1.c", "original_string": "void        draw_cube(int x, int y)\n{\n    int i;\n    int j;\n    i = x;\n    j = y;\n    while (j < g_tile_size + y)\n    {\n        while (i < g_tile_size + x)\n        {\n            my_mlx_pixel_put(&g_image, j, i, 0xFF0000);\n            i++;\n        }\n        i = x;\n        j++;\n    }\n}"}
{"author": "dishanp", "file": "DSA__q60.0.c", "original_string": "int main()\n{\n    int arr1[100], arr2[100], arr3[200];\n    int n1, n2, n3;\n    int i, k;\n       printf(\"number of elements to be stored in the first array :\");\n       scanf(\"%d\",&n1);\n       printf(\"Input %d elements in the array :\\n\",n1);\n       for(i=0;i<n1;i++)\n            {\n          printf(\"element - %d : \",i);\n          scanf(\"%d\",&arr1[i]);\n        }\n       printf(\"Input the number of elements to be stored in the second array :\");\n       scanf(\"%d\",&n2);\n       printf(\"Input %d elements in the array :\\n\",n2);\n       for(i=0;i<n2;i++)\n            {\n          printf(\"element - %d : \",i);\n          scanf(\"%d\",&arr2[i]);\n        }\n    n3 = n1 + n2;\n    for(i=0;i<n1; i++)\n        {\n            arr3[i] = arr1[i];\n        }\n       int j = 0 ;\n     while(j<n2)\n        {\n            arr3[i] = arr2[j];\n            i++;\n            j++;\n        }\n   for(i=0;i<n3; i++)\n        {\n           for(k=0;k<n3-1;k++)\n             {\n                if(arr3[k]<=arr3[k+1])\n                 {\n                   j=arr3[k+1];\n                   arr3[k+1]=arr3[k];\n                   arr3[k]=j;\n                 }\n              }\n         }\n     printf(\"\\nThe merged array in decending order is :\\n\");\n    for(i=0; i<n3; i++)\n    {\n        printf(\"%d   \", arr3[i]);\n    }\n    printf(\"\\n\");\n}"}
{"author": "sdukesameer", "file": "dsa__list-ins-seq-sor.4.c", "original_string": "int main()\n{\n    int ch;\n    while(1)\n    {\n        printf(\"\\n1. SORTED ORDER\\n\");\n        printf(\"2. SEQUENTIAL ORDER\\n\");\n        printf(\"3. EXIT PROGRAM\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            node* head=NULL;\n            while(1)\n            {\n                printf(\"\\n1. INSERT\\n\");\n                printf(\"2. PRINT\\n\");\n                printf(\"3. EXIT\\n\");\n                printf(\"Enter choice: \");\n                scanf(\"%d\",&n);\n                if (n==1)\n                {\n                    int inp;\n                    printf(\"Enter the element: \");\n                    scanf(\"%d\",&inp);\n                    sorted_insert(&head,inp);\n                }\n                else if (n==2)\n                    print(&head);\n                else if (n==3)\n                {\n                    printf(\"Exitting, Thank you.\\n\");\n                    break;\n                }\n                else\n                    printf(\"INVALID CHOICE, TRY AGAIN\\n\");\n            }\n        }\n        else if(ch==2)\n        {\n            int n;\n            node* head=NULL;\n            while(1)\n            {\n                printf(\"\\n1. INSERT\\n\");\n                printf(\"2. PRINT\\n\");\n                printf(\"3. EXIT\\n\");\n                printf(\"Enter choice: \");\n                scanf(\"%d\",&n);\n                if(n==1)\n                {\n                    int inp;\n                    printf(\"Enter the element: \");\n                    scanf(\"%d\",&inp);\n                    sequential_insert(&head,inp);\n                }\n                else if(n==2)\n                    print(&head);\n                else if(n==3)\n                {\n                    printf(\"Exitting, Thank you.\\n\");\n                    break;\n                }\n                else\n                    printf(\"INVALID CHOICE, TRY AGAIN!\\n\");\n            }\n        }\n        else if(ch==3)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"SORRY, INVALID CHOICE, TRY AGAIN!\\n\");\n    }\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-structure.10.c", "original_string": "PARAMETER* parseparameter(PARSER* p) {\n    if(equals(p, \")\"))\n        return NULL;\n    PARAMETER* param = (PARAMETER*)malloc(sizeof(PARAMETER));\n    param->debug = getdebug(p);\n    param->primitive = isprimitive(p->current);\n    param->type = parsetype(p);\n    param->name = parseidentifier(p);\n    return param;\n}"}
{"author": "dle2005", "file": "File_Structure__ftlmgr.5.c", "original_string": "void copyBlock(int from, int to, int except) {\n    for(int i = 0; i < PAGE_NUM; i++) {\n        int fromPpn = from * PAGE_NUM + i;\n        int toPpn = to * PAGE_NUM + i;\n        if(fromPpn == except) i++;\n        copyPage(fromPpn, toPpn);\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__display_the_DCLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    temp=head;\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d \",temp->data);\n    printf(\"\\n\");\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__words_count.0.c", "original_string": "int main()\n{\n    pthread_t thread1,thread2;\n    printf(\"enter the source file path\\n\");\n    scanf(\"%s\",s);\n    pthread_create(&thread1,NULL,read_char,NULL);\n    pthread_join(thread1,NULL);\n    pthread_create(&thread1,NULL,read_lines,NULL);\n    pthread_join(thread1,NULL);\n    return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__4.3.c", "original_string": "bool intersecao(rect_t retangulo_1, rect_t retangulo_2)\n{\n    bool sup_esq = false, inf_dir = false;\n    if ((((retangulo_2.sup_esq.x > retangulo_1.sup_esq.x) && (retangulo_2.sup_esq.x < retangulo_1.inf_dir.x)) || ((retangulo_2.sup_esq.y < retangulo_1.sup_esq.y) && (retangulo_2.sup_esq.y > retangulo_1.inf_dir.y))) == true)\n    {\n        sup_esq = true;\n    }\n    if ((((retangulo_2.inf_dir.x < retangulo_1.inf_dir.x) && (retangulo_2.inf_dir.x > retangulo_1.sup_esq.x)) || ((retangulo_2.inf_dir.y > retangulo_1.inf_dir.y) && (retangulo_2.inf_dir.y < retangulo_1.sup_esq.y))) == true)\n    {\n        inf_dir = true;\n    }\n    if ((sup_esq || inf_dir) == true)\n    {\n        return true;\n    }\n    else return false;\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.13.c", "original_string": "void handlevarsymbol(ASSEMBLER* a, STRINGLIST* ln) {\n    char* afterat = ln->content+sizeof(char);\n    if(isvar(afterat)) {\n        int val = getsymbol(a, afterat);\n        if(val == -1) {\n            if(a->varsramind == RAM_LIMIT) {\n                eprintf(\"Variable amount reached RAM limit (%i)\\n\", RAM_LIMIT);\n                exit(1);\n            }\n            SYMBOL* var = mksymbol(afterat, strlen(afterat)+1, a->varsramind);\n            a->varsramind++;\n            pushsymbol(a->vars, var);\n            val = var->value;\n        }\n        replacevar(a, ln, val);\n    }\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-2new0.8.c", "original_string": "int main(){\n    move[0].vert=-1;\n    move[0].horiz=0;\n    move[0].hei=0;\n    move[1].vert=0;\n    move[1].horiz=1;\n    move[1].hei=0;\n    move[2].vert=1;\n    move[2].horiz=0;\n    move[2].hei=0;\n    move[3].vert=0;\n    move[3].horiz=-1;\n    move[3].hei=0;\n    move[4].vert=0;\n    move[4].horiz=0;\n    move[4].hei=1;\n    move[5].vert=0;\n    move[5].horiz=0;\n    move[5].hei=-1;\n    char y;\n    int i,j,k;\n    FILE *pfile;\n    char name[50];\n    int control;\n    FILE *wfile;\n    wfile = fopen( \"4108056029output.txt\",\"w\" );\n    if( NULL == wfile ){\n        printf( \"wfile open failure\" );\n        return 1;\n    }\n    else{\n        for(control=58;control<=58;control++){\n            min = 100000;\n            sprintf(name,\"test%d.txt\",control);\n            pfile = fopen(name,\"r\");\n            if(NULL==pfile){\n                printf(\"Open failure\");\n                return 1;\n            }\n            else{\n                printf(\"reading %s\\n\",name);\n                char* bottom = make1darr(MAXLEN);\n                n=0;\n                char y;\n                bottom[n]=fgetc(pfile);\n                while(bottom[n]!='\\n'){\n                    fgetc(pfile);\n                    bottom[++n]=fgetc(pfile);\n                }\n                char ***maze=make3darr(n/2+1,n+2,n+2);\n                char ***road=make3darr(n/2+1,n+2,n+2);\n                char ***mark=make3darr(n/2+1,n+2,n+2);\n                int ***d=make3darrint(n/2+1,n+2,n+2);\n                int len=0;\n                int sr,sc,sh;\n                for(i=0;i<n/2+1;i++){\n                    for(j=0;j<n+2;j++){\n                        for(k=0;k<n+2;k++){\n                            if(j==0 || k==0 || j==n+1 || k==n+1){\n                                maze[i][j][k]='X';\n                            }\n                            else if(i==0 && j==1){\n                                maze[i][j][k]=bottom[k-1];\n                            }\n                            else if(j > len && j <= n-len && k > len && k <= n-len){\n                                fscanf(pfile,\"%c \",&maze[i][j][k]);\n                            }\n                            else{\n                                maze[i][j][k]='X';\n                            }\n                            if(maze[i][j][k]=='S'){\n                                sh=i;\n                                sr=j;\n                                sc=k;\n                            }\n                            road[i][j][k]=maze[i][j][k];\n                            mark[i][j][k]=maze[i][j][k];\n                        }\n                    }\n                    len++;\n                }\n                fprintf(wfile, \"test %d starts now.\\n\",control );\n                if(bfs(maze,d,sr,sc,sh)){\n                    mark[sh][sr][sc]='X';\n                    pathnum=0;\n                    dfs(maze,mark,road,sr,sc,sh,0);\n                    printf(\"Sortest path : %d, Limit: %d, The number of different paths: %d\\n\\n\",min,min+5,pathnum);\n                    fprintf(wfile,\"Shortest path: %d, Limit: %d, The number of different paths: %d\\n\\n\",min,min+5,pathnum);\n                }\n                else fprintf(wfile,\"The maze does not have a path\\n\" );\n                free(bottom);\n                free(maze);\n                free(mark);\n                free(road);\n                free(d);\n            }\n            fclose(pfile);\n        }\n    }\n    fclose(wfile);\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__count_the_elem_in_DLL.1.c", "original_string": "void creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "augustogunsch", "file": "jack-compiler__compiler-util.7.c", "original_string": "LINE* mksimpleln(char** tokens, int count) {\n    LINE* ln = mkline(count);\n    for(int i = 0; i < count; i++)\n        addtoken(ln, ezheapstr(tokens[i]));\n    ln->next = NULL;\n    return ln;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__os.14.c", "original_string": "SUBROUTDEC* getsubroutdecinclass(CLASS* c, const char* name) {\n    SUBROUTDEC* curr = c->subroutdecs;\n    while(curr != NULL) {\n        if(!strcmp(curr->name, name))\n            return curr;\n        curr = curr->next;\n    }\n    return NULL;\n}"}
{"author": "earth429", "file": "mulpre__power.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a, b, c;\n    int x, y;\n    int i;\n    srandom(time(NULL));\n    for (i = 0; i < TRY;i++){\n        x = (random() % 10);\n        y = (random() % 10);\n        setInt(&a, x);\n        setInt(&b, y);\n        power(&a, &b, &c);\n        setText(&c, pow(x, y));\n        checkText();\n    }\n    return 0;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__catavento.4.c", "original_string": "void anima()\n{\n    switch (opcao) {\n        case 1:\n            if(velocidade<0.075013){\n                velocidade = velocidade + 0.000001;\n                angulo= angulo + velocidade;\n                printf(\"\\n%f\\n\", velocidade);\n            }else{\n                angulo = angulo + velocidade;\n            }\n            break;\n        case 2:\n            if(velocidade>0.000000){\n                velocidade = velocidade - 0.000001;\n                angulo = angulo + velocidade;\n            }\n            break;\n        case 3:\n            angulo= angulo + velocidade;\n            printf(\"\\n%f\\n\", velocidade);\n            break;\n        case 4:\n            if(velocidade>0.000000){\n                angulo = angulo + velocidade;\n                printf(\"\\n%f\\n\", velocidade);\n            }\n            break;\n        default:\n            break;\n    }\n    glutPostRedisplay();\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.14.c", "original_string": "SUBROUTDEC* getsubroutdecfromcall(SCOPE* s, SUBROUTCALL* call, VAR** varret) {\n    SUBROUTDEC* d;\n    *varret = NULL;\n    if(call->parentname != NULL)\n        d = getsubroutdecwithparent(s, call, varret);\n    else\n        d = getsubroutdecwithoutparent(s, call);\n    if(d == NULL)\n        notdeclared(call->name, call->debug);\n    return d;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__doublyLinkedList.2.c", "original_string": "struct Node *insertAtIndex(struct Node *head, int data, int index)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     struct Node *p = head;\n     int i = 0;\n     while (i != index - 1) \n     {\n          p = p->next; \n          i++;\n     }\n     ptr->data = data;\n     ptr->next = p->next;\n     p->next = ptr;\n     p->next->prev = ptr;\n     ptr->prev = p;\n     return head; \n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__strlen.1.c", "original_string": "void *count_vowels(void *string)\n{\n    char *b=(char *)string;\n    int n,i,vowel=0;\n    char ch;\n    n=strlen(b);\n    while(i<=n)\n        {\n            ch=b[i];\n            if(ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u'||ch=='A'||ch=='E'||ch=='I'||ch=='O'||ch=='U')\n            {vowel++;}\n            i++;\n        }\n        printf(\"the number of vowels in the strings is  %d\\n\",vowel);\n        return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_ppm.1.c", "original_string": "void rstpPpmFsm(RstpBridgePort *port)\n{\n   switch(port->ppmState)\n   {\n   case RSTP_PPM_STATE_CHECKING_RSTP:\n      if(port->mdelayWhile == 0)\n      {\n         rstpPpmChangeState(port, RSTP_PPM_STATE_SENSING);\n      }\n      else if(port->mdelayWhile != rstpMigrateTime(port->context) &&\n         !port->portEnabled)\n      {\n         rstpPpmChangeState(port, RSTP_PPM_STATE_CHECKING_RSTP);\n      }\n      else\n      {\n      }\n      break;\n   case RSTP_PPM_STATE_SELECTING_STP:\n      if(port->mdelayWhile == 0 || !port->portEnabled || port->mcheck)\n      {\n         rstpPpmChangeState(port, RSTP_PPM_STATE_SENSING);\n      }\n      break;\n   case RSTP_PPM_STATE_SENSING:\n      if(port->sendRstp && port->rcvdStp)\n      {\n         rstpPpmChangeState(port, RSTP_PPM_STATE_SELECTING_STP);\n      }\n      else if(!port->portEnabled || port->mcheck ||\n         (rstpVersion(port->context) && !port->sendRstp && port->rcvdRstp))\n      {\n         rstpPpmChangeState(port, RSTP_PPM_STATE_CHECKING_RSTP);\n      }\n      else\n      {\n      }\n      break;\n   default:\n      rstpFsmError(port->context);\n      break;\n   }\n}"}
{"author": "2security", "file": "Star__DiamondStar.0.c", "original_string": "int main()\n    {\n        int n,i,j,k,c=1;\n        printf(\"Enter no of rows\");\n        scanf(\"%d\",&n);\n        for(i=1;i<=2*n-1;i++)\n            {\n                if(i<=n)\n                    {\n                        for(j=1;j<=n-i;j++)\n                            printf(\" \");\n                        for(j=1;j<=2*i-1;j++)\n                            printf(\"*\");\n                    }\n                else\n                    {\n                    for(j=i-n;j>=1;j--) \n                        printf(\" \");\n                    for(j=1;j<=2*(i-2*c)-1;j++)\n                        printf(\"*\");\n                    c++;\n                    }\n            printf(\"\\n\");\n            }\n    printf(\"\\n\\n\");\n    return 0;\n    }"}
{"author": "shengelenge", "file": "wp-lab3__zad14.1.c", "original_string": "int main()\n{\n    double x, y;\n    printf(\"Podaj liczbe, z ktorej chcesz wyznaczyc pierwiastek: \");\n    scanf(\"%2lf\", &x);\n    y = pierwiastek(x, E);\n    printf(\"Pierwiastek = %.3lf\", y);\n    return 0;\n}"}
{"author": "254Odeke", "file": "OpeartingSystems__paging.0.c", "original_string": "void main(){\n    int memory_size,page_size;\n    printf(\"Enter Memory Size:\");\n    scanf(\"%d\",&memory_size);\n    printf(\"Enter Page Size:\");\n    scanf(\"%d\",&page_size);\n    int n=memory_size/page_size;\n    printf(\"No.of Pages available=%d\\n\",n);\n    int m[n],i,j;\n    for(i=0;i<n;i++){\n        m[i]=0;\n    }\n    int p;\n    printf(\"\\nEnter No.of Processes:\");\n    scanf(\"%d\",&p);\n    int rem_pages=n;\n    int req_pages,process_size;\n    for(i=0;i<p;i++){\n        printf(\"Enter Process %d size:\",i+1);\n        scanf(\"%d\",&process_size);\n        req_pages=(process_size/page_size);\n        if(process_size%page_size!=0) req_pages++;\n        if(req_pages>rem_pages){\n            printf(\"Memory is lower than asked\");\n            continue;\n        }\n        int temp[req_pages];\n        printf(\"Enter %d page numbers that are to be assigned to process %d:\",req_pages,i+1);\n        for(j=0;j<req_pages;j++){\n            scanf(\"%d\",&temp[j]);\n        }\n        for(j=0;j<req_pages;j++){\n            if(m[temp[j]]!=0){\n                printf(\"Page %d is already allocated\",temp[j]);\n                break;\n            }\n            m[temp[j]]=i+1;\n            rem_pages--;\n        }\n    }\n    printf(\"Main Memory:\\n\");\n    printf(\"------------\\n\");\n    for(i=0;i<n;i++){\n        if(m[i]==0)\n            printf(\"\\tframe %d -- EMPTY\\n\",i);\n        else    \n            printf(\"\\tframe %d -- process %d\\n\",i,m[i]);\n    }\n}"}
{"author": "kalpa96", "file": "Struct__less.2.c", "original_string": "int main(){\n    int n,i,j;\n    printf(\"Enter the number of customers : \");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        c[i].no = i+1;\n        printf(\"\\nCustomer 0%d\\n\",c[i].no);\n        printf(\"Enter name : \");\n        scanf(\"%s\",c[i].name);\n        printf(\"Enter Account Number : \");\n        scanf(\"%d\",&c[i].accNmbr);\n        printf(\"Enter balance : \");\n        scanf(\"%d\",&c[i].balance);\n    }\n    printf(\"\\nCustomers having balance less than Rs.200\\n\");\n    for(j=0;j<n;j++){\n        minimumAcc(c[j].balance,c[j].name);\n    }\n    printf(\"\\nCustomers having balanace greater than Rs.1000 are increased acc balance..\\n\");\n    for(j=0;j<n;j++){\n        maximumAcc(c[j].balance,c[j].name);\n    }\n    return 0;\n}"}
{"author": "tadeograch", "file": "sorting_algorithms__101-cocktail_sort_list.1.c", "original_string": "listint_t **swap(listint_t *temp_sort, listint_t *swapper, listint_t **list)\n{\n    listint_t *aux_prev, *aux_next = temp_sort->next;\n    if (temp_sort->next == NULL && swapper->prev == NULL)\n    {\n        temp_sort->next = temp_sort->prev;\n        temp_sort->prev = NULL;\n        swapper->prev = swapper->next;\n        swapper->next = NULL;\n        *list = temp_sort;\n    }\n    else if (swapper->prev == NULL)\n    {\n        temp_sort->prev = NULL;\n        temp_sort->next = swapper;\n        swapper->prev = temp_sort;\n        swapper->next = aux_next;\n        aux_next->prev = swapper;\n        *list = temp_sort;\n    }\n    else if (temp_sort->next == NULL)\n    {\n        aux_prev = swapper->prev;\n        aux_prev->next = temp_sort;\n        temp_sort->prev = aux_prev;\n        temp_sort->next = swapper;\n        swapper->prev = temp_sort;\n        swapper->next = NULL;\n    }\n    else\n    {\n        aux_prev = swapper->prev;\n        aux_prev->next = temp_sort;\n        temp_sort->prev = aux_prev;\n        temp_sort->next = swapper;\n        swapper->next = aux_next;\n        swapper->prev = temp_sort;\n        aux_next->prev = swapper;\n    }\n    return (list);\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise9.1.c", "original_string": "long RecursiveFibonacci(long index){\n    if(index == 0 || index == 1){\n        return 1;\n    }\n    else{\n        return RecursiveFibonacci(index-2) + RecursiveFibonacci(index-1);\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.5.c", "original_string": "SYMBOL* mksymbol(char* name, int namesize, int val) {\n    SYMBOL* s = (SYMBOL*)malloc(sizeof(SYMBOL));\n    char* heapname = (char*)malloc(namesize);\n    strcpy(heapname, name);\n    s->name = heapname;\n    s->value = val;\n    return s;\n}"}
{"author": "dle2005", "file": "Algorithm__Kruskal.5.c", "original_string": "int compare(const void *a, const void *b) {\n    edge *u = (edge *)a;\n    edge *v = (edge *)b;\n    if(u->distance < v->distance) return -1;\n    if(u->distance > v->distance) return 1;\n    return 0;\n}"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__map_manager.4.c", "original_string": "void        error_redirect(int error)\n{\n    if (error == 0)\n        ft_putstr(\"Error:\\nmap has an unknown character\\n\");\n    else if (error == 1)\n        ft_putstr(\"Error:\\nthe map isnt closed\");\n    exit(0);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__LLstack.4.c", "original_string": "int main()\n{\n    printf(\"1. Push    2. Pop    3. Display    0.Exit\\n\");\n    int ch, ele;\n    nptr stack = NULL;\n    do\n    {\n        printf(\"Command: \"); scanf(\"%d\", &ch);\n        switch(ch)\n        {\n            case 1:     \n                    printf(\"Element: \"); scanf(\"%d\", &ele);\n                    push(stack, ele);\n                    break;\n            case 2:\n                    ele = pop(stack);\n                    if(ele == -1)\n                        printf(\"Stack empty!\\n\");\n                    else\n                        printf(\"%d popped!\\n\", ele);\n                    break;\n            case 3:\n                    display(stack);\n        }\n    }while(ch != 0);\n}"}
{"author": "Theemiss", "file": "simple_shell__more_fun.2.c", "original_string": "char *_strchr(char *s, char c)\n{\n    do      {\n        if (*s == c)\n            {\n            break;\n            }\n        }   while (*s++);\nreturn (s);\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__14sorting.0.c", "original_string": "void main()\n{\n    int a[90],i,n;\n    printf(\"enter the limit\");\n    scanf(\"%d\",&n);\n    printf(\"enter the array elements\");\n    for(i=0;i<n;i++)\n        scanf(\"%d\",&a[i]);\n    sorting(a,n);\n}"}
{"author": "sdukesameer", "file": "c__seq_search.0.c", "original_string": "void inputArray(int arr[], int len) {   \n    int i;\n    for (i = 0; i < len; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__parser-expressions.13.c", "original_string": "TERM* parseexpressionnullified(PARSER* p) {\n    TERM* head = parsetermnullified(p);\n    TERM* current = head;\n    TERM* nextt;\n    while(isop(p->current)) {\n        current->op = p->current->token[0]; \n        next(p);\n        nextt = parseterm(p);\n        current->next = nextt;\n        current = nextt;\n    }\n    if(current != NULL)\n        current->next = NULL;\n    return head;\n}"}
{"author": "ria3999", "file": "cbnst__SIMPSON_ONE-THIRD.1.c", "original_string": "int main()\n{\n    float x0,xn;\n    int n;\n    float h,s=0,sume=0,sumo=0;\n    printf(\"\\n\\n***INPUT***\\n\\n\");\n    printf(\"Enter value of n\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter x0 and xn\\n\");\n    scanf(\"%f%f\",&x0,&xn);\n    h=(xn-x0)/n;\n    s=fun(x0)+fun(xn);\n    for(int i=1;i<n;i++)\n    {\n        if(i%2==0)\n            s=s+2*fun(x0+i*h);\n        else\n            s=s+4*fun(x0+i*h);\n    }\n    s=s*h/3;\n    printf(\"\\n\\n***OUTPUT***\\n\\n\");\n    printf(\"Result is %f\",s);\n    return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__J.0.c", "original_string": "int main ()\n{\n    int n, qtd;\n    scanf (\"%i\", &qtd);\n    for (int i=0; i<qtd; i++)\n    {\n        scanf (\"%i\", &n);\n        while (n>=1000)\n        {\n            putchar ('M');\n            n -= 1000;\n        }\n        if ((900<=n)&&(n<=999))\n        {\n            printf (\"CM\");\n            n -= 900;\n        }\n        else if ((800<=n)&&(n<=899))\n        {\n            printf (\"DCCC\");\n            n -= 800;\n        }\n        else if ((700<=n)&&(n<=799))\n        {\n            printf (\"DCC\");\n            n -= 700;\n        }\n        else if ((600<=n)&&(n<=699))\n        {\n            printf (\"DC\");\n            n -= 600;\n        }\n        else if ((500<=n)&&(n<=599))\n        {\n            printf (\"D\");\n            n -= 500;\n        }\n        else if ((400<=n)&&(n<=499))\n        {\n            printf (\"CD\");\n            n -= 400;\n        }\n        else if ((300<=n)&&(n<=399))\n        {\n            printf (\"CCC\");\n            n -= 300;\n        }\n        else if ((200<=n)&&(n<=299))\n        {\n            printf (\"CC\");\n            n -= 200;\n        }\n        else if ((100<=n)&&(n<=199))\n        {\n            printf (\"C\");\n            n -= 100;\n        }\n        if ((90<=n)&&(n<=99))\n        {\n            printf (\"XC\");\n            n -= 90;\n        }\n        else if ((80<=n)&&(n<=89))\n        {\n            printf (\"LXXX\");\n            n -= 80;\n        }\n        else if ((70<=n)&&(n<=79))\n        {\n            printf (\"LXX\");\n            n -= 70;\n        }\n        else if ((60<=n)&&(n<=69))\n        {\n            printf (\"LX\");\n            n -= 60;\n        }\n        else if ((50<=n)&&(n<=59))\n        {\n            printf (\"L\");\n            n -= 50;\n        }\n        else if ((40<=n)&&(n<=49))\n        {\n            printf (\"XL\");\n            n -= 40;\n        }\n        else if ((30<=n)&&(n<=39))\n        {\n            printf (\"XXX\");\n            n -= 30;\n        }\n        else if ((20<=n)&&(n<=29))\n        {\n            printf (\"XX\");\n            n -= 20;\n        }\n        else if ((10<=n)&&(n<=19))\n        {\n            printf (\"X\");\n            n -= 10;\n        }\n        switch (n)\n        {\n            case 9:\n                printf (\"IX\");\n                n -= 9;\n                break;\n            case 8:\n                printf (\"VIII\");\n                n -= 8;\n                break;\n            case 7:\n                printf (\"VII\");\n                n -= 7;\n                break;\n            case 6:\n                printf (\"VI\");\n                n -= 6;\n                break;\n            case 5:\n                printf (\"V\");\n                n -= 5;\n                break;\n            case 4:\n                printf (\"IV\");\n                n -= 4;\n                break;\n            case 3:\n                printf (\"III\");\n                n -= 3;\n                break;\n            case 2:\n                printf (\"II\");\n                n -= 2;\n                break;\n            case 1:\n                printf (\"I\");\n                n -= 1;\n                break;\n        }\n        printf (\"\\n\");\n    }\n    return 0;\n}"}
{"author": "haon1026", "file": "linux-programming__pipe_multwrite.1.c", "original_string": "int main()\n{\n    int fd[2];\n    int ret = pipe(fd);\n    if(ret == -1)\n        sys_error(\"pipe error\");\n    int i;\n    for(i = 0; i < 2; i++)\n    {\n        pid_t pid = fork();\n        if(pid == -1)\n            sys_error(\"fork error\");\n        else if(pid == 0)\n            break;\n    }\n    char buf[1024];\n    if (i == 0)\n    {\n        close(fd[0]);\n        write(fd[1], \"1.hello\\n\", strlen(\"1.hello\\n\"));\n    }\n    else if (i == 1)\n    {\n        close(fd[0]);\n        write(fd[1], \"2.world\\n\", strlen(\"2.world\\n\"));\n    }\n    else if(i == 2)\n    {\n        close(fd[1]);\n        int n = read(fd[0], buf, 1024);\n        write(STDOUT_FILENO, buf, n);\n        wait(NULL);\n        wait(NULL);\n    }\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-statements.7.c", "original_string": "STATEMENT* parsedo(PARSER* p) {\n    next(p);\n    STATEMENT* s = mkstatement(p, dostatement);\n    s->dostatement = parsesubroutcall(p);\n    checkcontent(p, \";\");\n    return s;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_c_extended.7.c", "original_string": "static uint32_t cccd_configure(uint16_t conn_handle, uint16_t handle_cccd, bool enable)\n{\n    NRF_LOG_DEBUG(\"Configuring CCCD. CCCD Handle = %d, Connection Handle = %d\",\n        handle_cccd,conn_handle);\n    tx_message_t * p_msg;\n    uint16_t       cccd_val = enable ? BLE_GATT_HVX_NOTIFICATION : 0;\n    p_msg              = &m_tx_buffer[m_tx_insert_index++];\n    m_tx_insert_index &= TX_BUFFER_MASK;\n    p_msg->req.write_req.gattc_params.handle   = handle_cccd;\n    p_msg->req.write_req.gattc_params.len      = WRITE_MESSAGE_LENGTH;\n    p_msg->req.write_req.gattc_params.p_value  = p_msg->req.write_req.gattc_value;\n    p_msg->req.write_req.gattc_params.offset   = 0;\n    p_msg->req.write_req.gattc_params.write_op = BLE_GATT_OP_WRITE_REQ;\n    p_msg->req.write_req.gattc_value[0]        = LSB_16(cccd_val);\n    p_msg->req.write_req.gattc_value[1]        = MSB_16(cccd_val);\n    p_msg->conn_handle                         = conn_handle;\n    p_msg->type                                = WRITE_REQ;\n    tx_buffer_process();\n    return NRF_SUCCESS;\n}"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post.6.c", "original_string": "int main()\n{\n    int ch;\n    node* root=NULL;\n    while (1)\n    {\n        printf(\"\\n1. RECURSIVE INSERTION\\n\");\n        printf(\"2. ITERATIVE INSERTION\\n\");\n        printf(\"3. IN-ORDER TRAVERSAL\\n\");\n        printf(\"4. PRE-ORDER TRAVERSAL\\n\");\n        printf(\"5. POST-ORDER TRAVERSAL\\n\");\n        printf(\"6. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if(ch==1)\n        {\n            int n;\n            printf(\"Please enter an element: \");\n            scanf(\"%d\",&n);\n            root=rec_insertion(root,n);\n            printf(\"%d inserted in BINARY SEARCH TREE using Recursive Insertion\\n\",n);\n        }\n        else if(ch==2)\n        {\n            int n;\n            printf(\"Please enter an element: \");\n            scanf(\"%d\",&n);\n            iter_insertion(&root,n);\n            printf(\"%d inserted in BINARY SEARCH TREE using Iterative Insertion\\n\",n);\n        }\n        else if(ch==3)\n        {\n            printf(\"\\n     IN-ORDER\\n\");\n            rec_inorder(root);\n        }\n        else if(ch==4)\n        {\n            printf(\"\\n     PRE-ORDER\\n\");\n            rec_preorder(root);\n        }\n        else if(ch==5)\n        {\n            printf(\"\\n     POST-ORDER\\n\");\n            rec_postorder(root);\n        }\n        else if(ch==6)\n        {\n            printf(\"Exitting Program, Thank You.\\n\");\n            break;\n        }\n        else\n            printf(\"INVALID CHOICE! TRY AGAIN\\n\");\n    }\n    return 0;\n}"}
{"author": "2security", "file": "String__35TrimLeadingWhiteSpace.2.c", "original_string": "int main()\n    {\n        int i,n;\n        char str[50];\n        printf(\"\\n Enter the string\");\n        gets(str);\n        printf(\"\\n Before trimming::\");\n        printf(\"%s\",str);\n        printf(\"\\n After trimming::\");\n        printf(\"%s\",Trimleading(str));\n        return 0;\n    }"}
{"author": "mehedi9021", "file": "Data_Structure__create_list_with_function.2.c", "original_string": "void displaylist()\n    {\n        struct node*temp;\n        temp=head;\n        while(temp!=NULL)\n        {\n            printf(\"%d\\n\", temp->data);\n            temp=temp->next;\n        }\n    }"}
{"author": "HakNinja", "file": "C-Advance__2str2.0.c", "original_string": "int main()\n{int i,n;\n    struct student x[100];\n    printf(\"Enter number of students:\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter Details:\\n\");\n    for(i=0;i<n;i++)\n    {\n    printf(\"Enter roll number:\");\n    scanf(\"%d\",&x[i].rno);\n    printf(\"Enter name of student:\");\n    scanf(\"%s\",x[i].name);\n    printf(\"Percentage:\");\n    scanf(\"%f\",&x[i].per);\n    }\n    printf(\"\\n------------------------------------------\");\n    printf(\"Enter Details are:\\n\");\n    for(i=0;i<n;i++)\n    {\n    printf(\"\\nRoll number:%d\\n\",x[i].rno);\n    printf(\"\\nName:%s\\n\",x[i].name);\n    printf(\"Percentage:%f\\n\",x[i].per);\n    }  \n    return(0);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_prx.1.c", "original_string": "void rstpPrxFsm(RstpBridgePort *port)\n{\n   if((port->rcvdBpdu || port->edgeDelayWhile != rstpMigrateTime(port->context)) &&\n      !port->portEnabled)\n   {\n      rstpPrxChangeState(port, RSTP_PRX_STATE_DISCARD);\n   }\n   else\n   {\n      switch(port->prxState)\n      {\n      case RSTP_PRX_STATE_DISCARD:\n         if(port->rcvdBpdu && port->portEnabled)\n         {\n            rstpPrxChangeState(port, RSTP_PRX_STATE_RECEIVE);\n         }\n         break;\n      case RSTP_PRX_STATE_RECEIVE:\n         if(port->rcvdBpdu && port->portEnabled && !port->rcvdMsg)\n         {\n            rstpPrxChangeState(port, RSTP_PRX_STATE_RECEIVE);\n         }\n         break;\n      default:\n         rstpFsmError(port->context);\n         break;\n      }\n   }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__circularlinkedlist.0.c", "original_string": "void insert(int tar)\n{\n    struct list* p=(struct list*)malloc(sizeof(struct list));\n    p->val=tar;\n    p->next=NULL;\n    if(rear==NULL)\n    {\n        front=rear=p;\n    }\n    else\n    {\n        rear->next=p;\n        rear=p;\n        rear->next=front;\n    }\n}"}
{"author": "SugumaranEvil", "file": "TLPI__P_msgq_rcv.0.c", "original_string": "int main()\n{\n    int mq_op_ret,mq_rcv_ret;\n    struct mq_attr my_mq_attr;\n    unsigned int msg_pri = 10;\n    my_mq_attr.mq_flags    = 0;\n    my_mq_attr.mq_maxmsg  = 10;\n    my_mq_attr.mq_msgsize = 8192;\n    mq_op_ret = mq_open(\"/P_msgq\", O_RDONLY);\n    perror(\"mq_open\");\n    printf(\"ret value of mq_open = %d\\n\",mq_op_ret);\n    mq_rcv_ret = mq_receive(mq_op_ret, buffer, 8192,&msg_pri);\n    perror(\"mq_receive\");\n    printf(\"ret value of mq_receive = %d\\n\",mq_rcv_ret);\n    printf(\"Data from sender ==> %s\\n\",buffer);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__CC.1.c", "original_string": "int main()\n{\n    int N[1000][1000], n, maybe[1000], busca, busca_p, k = 0;\n    scanf(\"%i\", &n);\n    for (int i = 0; i < n; i++)\n    {\n        busca = true;\n        for (int j = 0; j < n; j++)\n        {\n            scanf(\"%i\", &N[i][j]);\n            if ((j != i) && (N[i][j] != 0)) busca = false;\n            else if ((j == i) && (N[i][j] != 1)) busca = false;\n        }\n        if (busca == true)\n        {\n            maybe[k] = i;\n            k++;\n        }\n    }\n    if (k == 0)\n    {\n        printf(\"Nao ha popstar.\\n\");\n        return 0;\n    }\n    for (int i = 0; i < k; i++)\n    {\n        busca_p = popstar(N, maybe[i], n);\n        if (busca_p == true) printf(\"Popstar: aluno #%i\\n\", maybe[i] + 1);\n    }\n    return 0;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__functions.2.c", "original_string": "int InputStudentsFromFile(char* fileName, pointerHash hashTable)\n{\n    FILE* fp = NULL;\n    fp = fopen(fileName, \"r\");\n    if (!fp)\n    {\n        printf(\"Can't open file!\\n\");\n        return fp;\n    }\n    char fileFirstName[MAX_STRING_LENGTH];\n    char fileLastName[MAX_STRING_LENGTH];\n    char fileRegistrationNumber[MAX_STRING_LENGTH];\n    while (!feof(fp))\n    {\n        fscanf(fp, \"%s %s %s\\n\", fileFirstName, fileLastName, fileRegistrationNumber);\n        AddToHashTable(AllocateMemoryForStudent(fileFirstName, fileLastName, fileRegistrationNumber), hashTable);\n    }\n    fclose(fp);\n    return 0;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__22_max_nd_min.0.c", "original_string": "int main()\n{\n  int i,j,k,array1[100],array2[100],no=0, min = 0, max = 0;\n  printf(\"Enter number of Digit you want to use in Array\\n\");\n  scanf(\"%d\",&no);  \n  for(i=0; i<no; i++)\n  {\n    scanf(\"%d\",&array1[i]);\n  }\n  for(i=0; i<no; i++)\n  {\n    printf(\"%d \",array1[i]);\n  }\n  min = array1[0];\n  max = array1[0];\n  printf(\"Min Value Befor is %d\\n\",min);\n  printf(\"Max Value Befor is %d\\n\",max);\n  for(i=1; i<no; i++)\n  {\n    if(min > array1[i])\n    {\n      min = array1[i];    \n    }\n    if(max < array1[i])\n    {\n      max = array1[i];    \n    }\n  }\n  printf(\"Min Value After is %d\\n\",min);\n  printf(\"Max Value After is %d\\n\",max);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q11.3.c", "original_string": "char pop(stack* ps)\n{\n    if(ps->top > -1)\n        return ps->item[(ps->top)--];\n    else\n    {\n        isEmpty();  \n        return '\\0';\n    }\n}"}
{"author": "behergue", "file": "Operating_Systems__simulator.2.c", "original_string": "void * thread_usuario(int i) {\n    int id_usuario, a, b;\n    id_usuario = i;\n    while (1) {\n        a=rand() % N_PARADAS;\n        do{\n            b=rand() % N_PARADAS;\n        } while(a==b);\n        printf(\"Usuario %d se quiere subir en la parada %d y bajar en la %d \\n\", id_usuario, a, b);\n        Usuario(id_usuario,a,b);\n    }\n}"}
{"author": "gokulsreekumar", "file": "Client-Server-Programs__client_thread.2.c", "original_string": "void* send_msg_handler(void* pclient)\n{\n    int sockfd = *((int* ) pclient);\n    char message[LENGTH] = {};\n    char buffer[LENGTH + 32] = {};\n    while (1)\n    {\n        str_overwrite_stdout();\n        fgets(message, LENGTH, stdin);\n        str_trim_lf(message, LENGTH);\n        if (strcmp(message, \"exit\") == 0)\n        {\n            break;\n        }\n        else\n        {\n            sprintf(buffer, \"%s: %s\\n\", name, message);\n            send(sockfd, buffer, strlen(buffer), 0);\n        }\n        bzero(message, LENGTH);\n        bzero(buffer, LENGTH + 32);\n    }\n    catch_ctrl_c_and_exit(2);\n    return NULL;\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes2.10.c", "original_string": "void imprimir_menu_calificaciones(){\n    printf(\"1. Modificar calificaci\u00f3n 1:\\n\");\n    printf(\"2. Modificar calificaci\u00f3n 2:\\n\");\n    printf(\"3. Modificar calificaci\u00f3n 3:\\n\");\n    printf(\"4. Modificar calificaci\u00f3n f:\\n\");\n    printf(\"5. Salir:\\n\");\n    printf(\"Ingresa una opci\u00f3n:\");\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q2_set1.4.c", "original_string": "int main()\n{\n    nodeptr a,b;\n    int n,m,i,t;\n    a=NULL;\n    b=NULL;\n    printf(\"\\nEnter number elements of first set: \");\n    scanf(\"%d\",&n);\n    printf(\"\\nEnter elements: \");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&t);\n        add(&a,t);\n    }\n    printf(\"\\nEnter number elements of second set: \");\n    scanf(\"%d\",&m);\n    printf(\"\\nEnter elements: \");\n    for(i=0;i<m;i++)\n    {\n        scanf(\"%d\",&t);\n        add(&b,t);\n    }\n    printf(\"\\nList one: \");\n    display(a);\n    printf(\"\\nList two: \");\n    display(b);\n    nodeptr u,in;\n    u=set_union(a,b);\n    in=intersection(a,b);\n    printf(\"\\nUnion: \");\n    display(u);\n    printf(\"\\nIntersection: \");\n    display(in);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__SinglePartitionDemoFirmwareUpdateInfoFileReader0.3.c", "original_string": "static bool createFirmwareUpdateInfoFile(void)\n{\n  FILE *updateInfoFile = fopen(DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, \"w\");\n  if (updateInfoFile == NULL) \n  {\n    printf(\"Failed to create %s: %s (error code: %i)\\n\", DEMO_PRODUCT_UPDATE_INFO_FILE_NAME, strerror(errno), errno);\n    return false;\n  }\n  fclose(updateInfoFile);\n  return true;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__onlyRow.3.c", "original_string": "void rows(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(ROW);\n        IODIR1 = IODIR1 | (COL);\n        val = (IOPIN1 & ROW); \n        val = val >> 17;\n        if(val == 0x0E)\n        {\n            lcd_str(\"row1\");\n            delay(500);\n        }\n        if(val == 0x0D)\n        {\n            lcd_str(\"row2\");\n            delay(500);\n        }\n        if(val == 0x0B)\n        {\n            lcd_str(\"row3\");\n            delay(500);\n        }\n        if(val == 0x07)\n        {\n            lcd_str(\"Row4\");\n            delay(500);\n        }\n        delay(1000);\n        lcd_cmd(0x01);\n}"}
{"author": "andi-s0106", "file": "sorting_algorithms__1-main.1.c", "original_string": "int main(void)\n{\n    listint_t *list;\n    int array[] = {17, 41, 5, 22, 28, 6, 5, 3, 5};\n    size_t n = sizeof(array) / sizeof(array[0]);\n    list = create_listint(array, n);\n    if (!list)\n        return (1);\n    print_list(list);\n    printf(\"\\n\");\n    insertion_sort_list(&list);\n    printf(\"\\n\");\n    print_list(list);\n    return (0);\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__menu.4.c", "original_string": "float minimo(float c1, float c2, float c3, float cf){\n    float min = c1; \n    if (c1 > c2) { \n        min = c2; \n    }\n    if (min > c3){ \n        min = c3; \n    }\n    if (min > cf) { \n        min = cf;\n    }\n    return min;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__os.3.c", "original_string": "CLASS* mkstringclass(CLASS* os) {\n    CLASS* strclass = mkosclass(os, \"String\");\n    adddec(strclass, constructor, \"String\", \"new\");\n    adddec(strclass, method, \"int\", \"dispose\");\n    adddec(strclass, method, \"int\", \"length\");\n    adddec(strclass, method, \"char\", \"charAt\");\n    adddec(strclass, method, \"void\", \"setCharAt\");\n    adddec(strclass, method, \"String\", \"appendChar\");\n    adddec(strclass, method, \"void\", \"eraseLastChar\");\n    adddec(strclass, method, \"int\", \"intValue\");\n    adddec(strclass, method, \"void\", \"setInt\");\n    adddec(strclass, function, \"char\", \"backSpace\");\n    adddec(strclass, function, \"char\", \"doubleQuote\");\n    adddec(strclass, function, \"char\", \"newLine\");\n    return strclass;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es2.1.c", "original_string": "int main(void) {\n    int dim; \n    printf(\"inserire dimensione array: \"); \n    scanf(\"%d\", &dim);\n    int a[dim];\n    for(int i=0; i<dim; i++){\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\n\");\n    printf(\"----------------------------\\n\");\n    isPrime(dim,a);\n  return 0;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__M-1.0.c", "original_string": "int main()\n{\n    int n, av[10000], bv[10000], cv[10000], xyz[100000], a, b, c, x, y, z, k = 0, solucao, solucao2, aux;\n    scanf(\"%i\", &n);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%i\", &av[i]);\n        scanf(\"%i\", &bv[i]);\n        scanf(\"%i\", &cv[i]);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        a = av[i];\n        b = bv[i];\n        c = cv[i];\n        solucao2 = false;\n        for (y = (-c); y <= c; y++)\n        {\n            for (z = y; z <= c; z++)\n            {\n                x = a - y - z;\n                if (((y * z * x) == b) && (((x * x) + (y * y) + (z * z)) == c))\n                {\n                    solucao = true;\n                    if (k != 0)\n                    {\n                        for (int j=0; j<=(k-3); j++)\n                        {\n                            if ((x == xyz[j])||(y == xyz[j])||(z == xyz[j]))\n                            {\n                                solucao = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (solucao == true)\n                    {\n                        printf(\"%i %i %i\\n\", y, z, x);\n                        solucao2 = true;\n                        xyz[k] = x;\n                        xyz[k+1] = y;\n                        xyz[k+2] = z;\n                        k += 3;\n                    }\n                }\n            }\n        }\n        if (solucao2 == false)\n            printf(\"Sem solucao\\n\");\n    }\n    return 0;\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal.1.c", "original_string": "HAL_StatusTypeDef HAL_DeInit(void)\n{\n  __HAL_RCC_APB1_FORCE_RESET();\n  __HAL_RCC_APB1_RELEASE_RESET();\n  __HAL_RCC_APB2_FORCE_RESET();\n  __HAL_RCC_APB2_RELEASE_RESET();\n  __HAL_RCC_AHB1_FORCE_RESET();\n  __HAL_RCC_AHB1_RELEASE_RESET();\n  __HAL_RCC_AHB2_FORCE_RESET();\n  __HAL_RCC_AHB2_RELEASE_RESET();\n  __HAL_RCC_AHB3_FORCE_RESET();\n  __HAL_RCC_AHB3_RELEASE_RESET();\n  HAL_MspDeInit();\n  return HAL_OK;\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__sender_mian.1.c", "original_string": "int main(){\n    unsigned int length;\n    welcome();\n    length = frame_construction(frame, sta_addr, des_addr, protocol, data, sizeof(data));\n    send_frame(frame, length);\n    return 0;\n}"}
{"author": "behergue", "file": "Operating_Systems__leds_user.2.c", "original_string": "void cont_binario(){\n    char leds[] = \"000\";\n    FILE * file;\n    int i = 0;\n    while(1){\n        int num = i;\n        file = fopen(PATH, \"r+\");\n        if(num >= 4){\n            leds[0] = '1';\n            num = num -4;\n        }\n        if (num >= 2){\n            leds[1] = '2';\n            num = num -2;\n        }\n        if(num >= 1){\n            leds[2] = '3';\n        }\n        fwrite(leds, sizeof(char), strlen(leds), file);\n        printf(\"He encendido los leds %s\\n\", leds);\n        fclose(file);\n        sleep(1);\n        i = (i+1)%8;\n        leds[0] = '0';\n        leds[1] = '0';\n        leds[2] = '0';\n    }\n}"}
{"author": "ankitraj311", "file": "Socket-thread__second_thread.1.c", "original_string": "int main()\n{\n  int  i;\n  pthread_t tid;\n  for(i = 0; i<3; i++)\n  {\n    pthread_create(&tid, NULL, thread_fun, (void*)&i);\n  }\n    pthread_exit(NULL);\n    return 0;\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__105-radix_sort.1.c", "original_string": "void radix_sort(int *array, size_t size)\n{\n    int max, exp;\n    size_t i = 0;\n    if (array == NULL || size < 2)\n        return;\n    max = array[0];\n    while (i < size)\n    {\n        if (array[i] > max)\n            max = array[i];\n        i++;\n    }\n    exp = 1;\n    while (max / exp >= 1)\n    {\n        countingSort(array, 10, exp, size);\n        exp *= 10;\n        print_array(array, size);\n    }\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_print_comb.0.c", "original_string": "void comb(int i, int j,int k, int *datos){\n    if( i <= 7){\n        if(j <= 8){\n            if(k <= 9 ){\n                if(datos[i] != datos[j] && datos[i] != datos[k] && datos[j] != datos[k]){\n                    if(datos[i] < datos[j] && datos[i] < datos[k] && datos[j] < datos[k]){\n                        printf(\"%i%i%i  \", datos[i], datos[j], datos[k]);\n                    }               \n                }\n                comb(i, j, k+1, datos);\n            }else\n                comb(i, j+1, 2, datos);\n        }else\n           comb(i+1, 1, k, datos);\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__queue_using_linked_list.2.c", "original_string": "void dequeue()\n{\n    struct node *temp;\n    temp=front;\n    if(front==0 && rear==0)\n    {\n        printf(\"the queue is empty\\n\");\n    }\n    else if(front==rear)\n    {\n        printf(\"the delete element is %d \\n\",temp->data);\n        front=rear=0;\n        free(temp);\n    }\n    else\n    {\n        printf(\"the delete element is %d \\n\",temp->data);\n        front=front->next;\n        free(temp);\n    }\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.1.c", "original_string": "void imprimir_menu(){\n    char mensaje[MAX] = \"SISTEMA DE CONTROL DE CALIFICACIONES\";\n    system(\"clear\");\n    printf(\"----------------------------------------------\\n\");\n    printf(\"%s\\n\", mensaje);\n    printf(\"----------------------------------------------\\n\");\n    printf(\"Menu de opciones\\n\");\n    printf(\"----------------------------------------------\\n\");\n    printf(\"1. Agregar alumno\\n\");\n    printf(\"2. Modificar alumno\\n\");\n    printf(\"3. Modificar calificaciones\\n\");\n    printf(\"4. Imprimir datos del alumno\\n\");\n    printf(\"5. Lista de alumnos\\n\");\n    printf(\"6. Pase de lista\\n\");\n    printf(\"7. Salir\\n\");\n    printf(\"Ingresa una opci\u00f3n: \\n\");\n}"}
{"author": "Cz8rT", "file": "ProgramowanieStrukturalne__Zad_4_2_7_a.1.c", "original_string": "void copyArrays(unsigned int n, int * array1, int * array2, int * array3){\n    int i = 0;\n    for(i; i < n; i++){\n        array3[i] = array1[i] + array2[i];\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-structure.6.c", "original_string": "LINEBLOCK* compileconstructor(SCOPE* s, CLASS* cl, SUBROUTDEC* con) {\n    LINE* label = mksubdeclabel(cl, con);\n    LINEBLOCK* blk = mklnblk(label);\n    char* size[] = { \"push\", \"constant\", itoa(getobjsize(cl)) };\n    char* memalloc[] = { \"call\", \"Memory.alloc\", \"1\" };\n    char* poppointer[] = { \"pop\", \"pointer\", \"0\" };\n    appendln(blk, mkln(size));\n    appendln(blk, mkln(memalloc));\n    appendln(blk, mkln(poppointer));\n    free(size[2]);\n    if(con->body != NULL)\n        return mergelnblks(blk, compilefunbody(s, cl, con));\n    else\n        return blk;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__rostring.2.c", "original_string": "int     main(int ac, char **av)\n{\n    int i;\n    char    **word;\n    i = 1;\n    if(ac == 2)\n    {\n        word = ft_split(av[1]);\n        while (word[i] != 0)\n        {\n            ft_putstr(word[i++]);\n            write(1, \" \", 1);\n        }\n        ft_putstr(word[0]);\n    }\n    write(1, \"\\n\",1);\n    return (0);\n}"}
{"author": "Theemiss", "file": "simple_shell__excute.1.c", "original_string": "int check_cmd(char **cmd, char *input, int c, char **argv)\n{\n    int status;\n    pid_t pid;\n    if (*cmd == NULL)\n    {\n        return (-1);\n    }\n    pid = fork();\n    if (pid == -1)\n    {\n        perror(\"Error\");\n        return (-1);\n    }\n    if (pid == 0)\n    {\n        if (_strncmp(*cmd, \"./\", 2) != 0 && _strncmp(*cmd, \"/\", 1) != 0)\n        {\n            path_cmd(cmd);\n        }\n        if (execve(*cmd, cmd, environ) == -1)\n        {\n            print_error(cmd[0], c, argv);\n            free(input);\n            free(cmd);\n            exit(EXIT_FAILURE);\n        }\n        return (EXIT_SUCCESS);\n    }\n    wait(&status);\n    return (0);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__vic.0.c", "original_string": "int main()\n{\n        IODIR1 = IODIR1| LED_ALL;\n        T0PR = 14;\n        T0MR0 = 2000000;\n        T0MCR = (1<<0)|(1<<1);\n        T0TCR = (1<<0);\n        VICIntSelect = VICIntSelect & ~(1<<4); \n        VICVectCntl1 = (1<<5)|4;   \n        VICVectAddr1 = (long)&timer0_isr;       \n        VICIntEnable = (1<<4);   \n        while(1)\n        {\n            blink_led(17);\n        }\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__strcmp_ser.2.c", "original_string": "void choice_zero(char b[10])\n{\n        char r[10]=\"MCISFFF\";\n        if (strcmp(b,r)==0)\n        {printf(\"the value is matching with MCIS\\n\");}\n        else{\n        printf(\"the  string is not matching with MCIS\\n\");\n        }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q33.0.c", "original_string": "void enqueueright(queue *q,char n)\n{\n    if (q->rear == CAPACITY)\n        printf(\"Side Full\\n\");\n    else\n        q->c[(q->rear)++]=n;\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad6MatrixCopy.2.c", "original_string": "void copyArrayPointer(int sourceArray[], int outputArray[], int size){\n    int * pointerSource = sourceArray;\n    int * pointerOutput = outputArray;\n    for(int i = 0; i < size; i++){\n        *pointerOutput = *pointerSource;\n        pointerSource++;\n        pointerOutput++;\n    }\n}"}
{"author": "rgautam320", "file": "Data-Structure__main21.0.c", "original_string": "int main()\n{\n    int final_answer;\n    printf(\"Enter Expression to Evaluate : \\n\");\n    scanf(\"%s\", postfix_expression);\n    final_answer = evaluation();\n    printf(\"Evaluation of Postfix Expression : %d\", final_answer);\n    return 0;\n}"}
{"author": "flora0110", "file": "hw04git__4108056029_30.0.c", "original_string": "int main(){\n    FILE* rptr;\n    FILE* wptr;\n    rptr=fopen(\"test4.txt\",\"r\");\n    if(rptr==NULL){\n        printf(\"error\\n\");\n        return 0;\n    }\n    orien[0].row=1;\n    orien[0].col=0;\n    orien[1].row=0;\n    orien[1].col=-1;\n    orien[2].row=-1;\n    orien[2].col=0;\n    orien[3].row=0;\n    orien[3].col=1;\n    int v,z,g;\n    fscanf(rptr,\"%d %d %d\\n\",&v,&z,&g);\n    fscanf(rptr,\"%d\\n\",&n);\n    int** see=(int**)malloc((n*4)*sizeof(int*));\n    int i,j;\n    for(i=0;i<n*4;i++){\n        see[i]=(int*)malloc(4*sizeof(int));\n        fscanf(rptr,\"%d \",&see[i][0]);\n        if(i<n){\n            see[i][1]=1;\n            see[i][2]=i+1;\n            see[i][3]=0;\n        }\n        else if(i<2*n){\n            see[i][1]=n;\n            see[i][2]=i-n+1;\n            see[i][3]=2;\n        }\n        else if(i<3*n){\n            see[i][1]=i-2*n+1;\n            see[i][2]=1;\n            see[i][3]=3;\n        }\n        else{\n            see[i][1]=i-n*3+1;\n            see[i][2]=n;\n            see[i][3]=1;\n        }\n    }\n    char **ans=(char**)malloc((n+2)*sizeof(char*));\n    for(i=0;i<n+2;i++){\n        ans[i]=(char*)malloc((n+2)*sizeof(char));\n        for(j=0;j<n+2;j++){\n            if(i==0 || j==0 || i==n+1 || j==n+1){\n                ans[i][j]='x';\n            }\n            else{\n                fscanf(rptr,\"%c\",&ans[i][j]);\n            }\n        }\n        if(i!=0 &&i!=n+1){\n            fgetc(rptr);\n        }\n    }\n    mark(ans,see,0,v,z,g,see[0][0],1,1,0,0);\n    free(see);\n    free(ans);\n    for(i=0;i<n+2;i++){\n        free(ans[i]);\n    }\n    for(i=0;i<3;i++){\n        free(see[i]);\n    }\n    fclose(rptr);\n}"}
{"author": "mandarvu", "file": "msc__problem3.1.c", "original_string": "void insertion(int *source, int *target, int number, int position) {\n  int j = 0;\n  for (j = 0; j < MAX + 1; j++) { \n    if (j < position - 1){\n      *(target + j) = *(source + j);\n      continue;\n    }\n    else if (j == position - 1) \n      *(target + j) = number;\n    else { \n      *(target + j) = *(source + j - 1);\n    }\n  }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__stp_operation.3.c", "original_string": "void stpMessageAgeTimerExpiry(StpBridgePort *port)\n{\n   bool_t rootBridge;\n   StpBridgeContext *context;\n   context = port->context;\n   rootBridge = stpRootBridge(context);\n   stpBecomeDesignatedPort(port);\n   stpConfigUpdate(context);\n   stpPortStateSelection(context);\n   if(!rootBridge && stpRootBridge(context))\n   {\n      context->maxAge = context->bridgeMaxAge;\n      context->helloTime = context->bridgeHelloTime;\n      context->forwardDelay = context->bridgeForwardDelay;\n      stpTopologyChangeDetection(context);\n      stpStopTimer(&context->tcnTimer);\n      stpConfigBpduGeneration(context);\n      stpStartTimer(&context->helloTimer, 0);\n   }\n}"}
{"author": "2security", "file": "Star__Hollowsquare.0.c", "original_string": "int main()\n    {\n    int n,i,j;\n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n        {\n        for(j=1;j<=n;j++)   \n            {\n            if(i==1||i==n||j==1||j==n)\n                printf(\"*\");\n            else\n                printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }"}
{"author": "augustogunsch", "file": "jackc__compiler-statements.2.c", "original_string": "char* mkcondlabel(char* name, int count) {\n    int sz = (strlen(name) + countplaces(count) + 1) * sizeof(char);\n    char* result = (char*)malloc(sz);\n    sprintf(result, \"%s%i\", name, count);\n    return result;\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_6.10.c", "original_string": "int search(int value)\n{\n    struct node *p = root;\n    while(p != NULL)\n    {\n        if(p->data == value)\n        {\n            return 1;\n        }\n        else\n        {\n            p = p->right;\n        }\n    }\n    return 0;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__DemoFOTAUpdateWorkflow0.3.c", "original_string": "void fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(char *updateVersion)\n{\n  char *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg = updateVersion;\n  void *___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args[1] = { &___DemoFOTAUpdateWorkflowEngine_updateVersionChanged_updateVersion__arg };\n  DemoFOTAUpdateWorkflowEngine__execute(&updateWorkflowEngine, DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event, ___DemoFOTAUpdateWorkflowEngine_updateVersionChanged__args);\n}"}
{"author": "flora0110", "file": "hw01git__4108056029_2-1.12.c", "original_string": "void path(char*** maze,char*** road,char*** mark,int*** d,int sr,int sc,int sh){\n    top=-1;\n    top2=-1;\n    element position;\n    position.row = sr;\n    position.col = sc;\n    position.hei = sh;\n    position.dir = 0 ;\n    push(position);\n    int i,j,k;\n    int nr,nc,nh;\n    int row,col,hei,dir;\n    int found=1;\n    while(top>-1){\n        position = pop();\n        row = position.row;\n        col = position.col;\n        hei = position.hei;\n        dir = position.dir;\n        if(!found){\n            while(top2>-1){\n                element lastposition = pop2();\n                int lr=lastposition.row;int lc=lastposition.col;int lh=lastposition.hei;int ld=lastposition.dir;\n                if(lr+move[dir].vert==row && lc+move[dir].horiz==col && lh+move[dir].hei==hei ){\n                    push2(lastposition);\n                    break;\n                }\n                road[lh][lr][lc]=maze[lh][lr][lc];\n                mark[lh][lr][lc]=maze[lh][lr][lc];\n            }\n        }\n        road[hei][row][col]='*';\n        mark[hei][row][col]='X';\n        push2(position);\n        if(maze[hei][row][col]=='F'){\n            break;\n        }\n        found=0;\n        for(i=0;i<4;i++){\n            nr = row+move[i].vert;\n            nc = col+move[i].horiz;\n            nh = hei+move[i].hei;\n            if ((mark[nh][nr][nc]!='X' && ((d[nh][nr][nc]==d[hei][row][col]+1)&& mark[nh][nr][nc]!='T') || (d[nh][nr][nc]==d[hei][row][col]+3 && mark[nh][nr][nc]=='T'))){\n                found=1;\n                element nextposition;\n                nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;nextposition.dir=i;\n                push(nextposition);\n            }\n        }\n        if(maze[hei][row][col]=='U' || maze[hei][row][col]=='D'){\n            int upanddown=-1;\n            if(maze[hei][row][col]=='U'){\n                upanddown=1;\n            }\n            nr = row;\n            nc = col;\n            nh = hei+upanddown;\n            if(nh>=0){\n                if ((mark[nh][nr][nc]!='X' && ((d[nh][nr][nc]==d[hei][row][col]+1)&& mark[nh][nr][nc]!='T') || (d[nh][nr][nc]==d[hei][row][col]+3 && mark[nh][nr][nc]=='T'))){\n                    found=1;\n                    element nextposition;\n                    nextposition.row=nr;nextposition.col=nc;nextposition.hei=nh;\n                    if(upanddown==1) nextposition.dir=4;\n                    else nextposition.dir=5;\n                    push(nextposition);\n                }\n            }\n        }\n    }\n}"}
{"author": "2security", "file": "File__3WriteEvenOddPrimeNumSepFile.1.c", "original_string": "int isPrime(int n)\n    {\n        int i,flag=0;\n        for(i=2;i<n/2;i++)\n            {\n                if(n%i==0)\n                    {\n                        return 0;\n                    }\n            }\n        return 1;\n    }"}
{"author": "RaigoXD", "file": "Parcial-2__ft_putbr.1.c", "original_string": "void llenar_string(char *str, int numero, int longitud_N){\n    if(numero > 0){\n        str[longitud_N - 1] = (numero%10)+48;\n        llenar_string(str, numero/10, longitud_N-1);\n    }\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__29_math_ploygon.0.c", "original_string": "int main()\n{\n  int i,j,k,choice;\n  printf(\"Enter the choice to find the Area \\n1. Triangle \\n2. Circle \\n3. Rectangle \\n4. Square \\n5. Parallelogram\\n\");\n  scanf(\"%d\",&choice);\n  switch(choice)\n  {\n    case 1:\n      {\n        int a, b, c;\n    float Area;\n    printf(\"Enter the sides of the triangle\");\n    scanf(\"%d%d%d\",&a,&b,&c);\n    Area = (a*b*c);\n    printf(\"Area of the triangle is %.2f\",Area);\n    break;\n      }\n    case 2:\n      {\n        int r;\n    float Area;\n    printf(\"Enter the radius of circle\");\n    scanf(\"%d\",&r);\n    Area = (3.14 * r * r);\n    printf(\"Area of the circle is %.2f\",Area);\n    break;\n      }\n    case 3:\n      {\n        int a, b;\n    float Area;\n    printf(\"Enter the sides of the Rectangle\");\n    scanf(\"%d%d\",&a,&b);\n    Area = (a*b);\n    printf(\"Area of the Rectangle is %.2f\",Area);\n    break;\n      }\n    case 4:\n      {\n        int a;\n    float Area;\n    printf(\"Enter the side of square\");\n    scanf(\"%d\",&a);\n    Area = (a*a);\n    printf(\"Area of the square is %.2f\",Area);\n    break;\n      }\n    case 5:\n      {\n        int breath, height;\n    float Area;\n    printf(\"Enter the sides of the Parallelogram\");\n    scanf(\"%d%d\",&breath,&height);\n    Area = (breath*height);\n    printf(\"Area of the  Parallelogram is %.2f\",Area);\n    break;\n      }\n    default :\n      {\n        printf(\"Invalid Result\");\n    break;\n      }\n  }\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__hidenp.0.c", "original_string": "int     main(int ac, char **av)\n{\n    int     i;\n    int     j;\n    int     count;\n    count = 0;\n    i = 0;\n    j = 0;\n    if (ac == 3)\n    {\n        while (av[1][i] != '\\0')\n        {\n            while (av[2][j] != '\\0')\n            {\n                if (av[1][i] == av[2][j])\n                {\n                    count++;\n                    break;\n                }\n                j++;\n            }\n            i++;\n        }\n        if (av[1][count] == '\\0')\n            write(1, \"1\", 1);\n        else\n            write(1, \"0\", 1);\n    }\n    write(1, \"\\n\", 1);\n    return (0);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__stackTopStackBottom.3.c", "original_string": "int pop(struct stack*ptr){\n    if(isEmpty(ptr)){\n        printf(\"Stack Underflow! Cannot pop from the stack\\n\");\n        return -1;\n    }\n    else{\n        int val = ptr->arr[ptr->top];\n        ptr->top--;\n        return val;\n    }\n}"}
{"author": "revathy16296", "file": "rtos_assignment_b__sum1.0.c", "original_string": "int main()\n{\n    printf(\"enter the array numbers\\n\");\n    for(i=0;i<SIZE;i++)\n    {\n        scanf(\"%d\",&(array[i]));\n    }\n    pthread_t thread1, thread2;\n    printf(\"the thread is created\\n\");\n    pthread_create(&thread1, NULL, sum_array, &array);\n    pthread_create(&thread2, NULL, product_of_elements,&array );\n    pthread_join(thread1,NULL);\n    pthread_join (thread2,NULL);\n    pthread_mutex_destroy(&mutex);\nreturn 0;\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_gpio.3.c", "original_string": "void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)\n{\n  assert_param(IS_GPIO_PIN(GPIO_Pin));\n  assert_param(IS_GPIO_PIN_ACTION(PinState));\n  if(PinState != GPIO_PIN_RESET)\n  {\n    GPIOx->BSRR = GPIO_Pin;\n  }\n  else\n  {\n    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;\n  }\n}"}
{"author": "mandarvu", "file": "msc__problem45.0.c", "original_string": "struct point complex_add(struct point A, struct point B) {\n    struct point C;\n    C.re = A.re + B.re;\n    C.im = A.im + B.im;\n    return C;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__rpn_calc.0.c", "original_string": "int     operation(int a, int b, char op)\n{\n    if (op == '+')\n        return (a + b);\n    if (op == '-')\n        return (a - b);\n    if (op == '*')\n        return (a * b);\n    if (op == '/')\n    {\n        if (b == 0)\n            return (99);\n        return (a / b);\n    }\n    if (op == '%')\n    {\n        if (b == 0)\n            return (99);\n        return (a % b);\n    }\n    return (99);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__ip2.2.c", "original_string": "NODE lintersection(NODE l1, NODE l2)\n{\n    NODE in=NULL;\n    while (l1!=NULL)\n    {\n        NODE pl2=l2;\n        while(pl2!=NULL)\n        {\n            if (l1->data==pl2->data)\n            {\n                in=insert(in,l1->data,0);\n                break;\n            }\n            pl2=pl2->next;\n        }\n        l1=l1->next;\n    }\n    return in;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__atividade1.1.c", "original_string": "void imprime(int *vec, int tam)\n{\n    for (int i = 0; i < tam; i++)\n    {\n        printf(\"%d\", vec[i]);\n    }\n}"}
{"author": "Qu-Xiangjun", "file": "Ethernet_frame_project10__test1.4.c", "original_string": "static unsigned int crc32(unsigned char *buffer, unsigned int size)\n{\n    unsigned int crc = 0xFFFFFFFF;\n    unsigned int i;\n    for (i = 0; i < size; i++) {\n        crc = crc_table[(crc ^ buffer[i]) & 0xff] ^ (crc >> 8);\n    }\n    return crc ;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es1.2.c", "original_string": "int main(){\n  int dim_a, dim_b;\n  printf(\"Inserire dimensione a: \");\n  scanf(\"%d\", &dim_a);\n  printf(\"Inserire dimansione b: \");\n  scanf(\"%d\", &dim_b);\n  int *a;\n  a = malloc(sizeof(int)*dim_a);\n  int *b;\n  b = malloc(sizeof(int)*dim_b);\n  for(int i=0; i<dim_a; i++){\n    printf(\"a[%d] = \", i);\n    scanf(\"%d\", &a[i]);\n  }\n  printf(\"\\n\");\n  for(int i=0; i<dim_b; i++){\n    printf(\"b[%d] = \", i);\n    scanf(\"%d\", &b[i]);\n  }\n  printf(\"\\n\");\n  int verifica = check(a, dim_a, b, dim_b);\n  if(verifica==1){\n    printf(\"In a esiste un elemento uguale alla somma degli elementi di b\\n\");\n  }\n  if(verifica==0){\n    printf(\"In a NON esiste un elemento uguale alla somma degli elementi di b\\n\");\n  }\n  free(a);\n  free(b);\n  return(0);\n}"}
{"author": "mehedi9021", "file": "Data_Structure__queue_with_linkedlist.4.c", "original_string": "int main()\n{\n    int i,n,p,m;\n    printf(\"How many number do you want to enqueue ? \");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    {\n        printf(\"Enter the value :\");\n        scanf(\"%d\",&p);\n        Enqueue(p);\n        printf(\"List is :\\n\");\n        Print();\n    }\n    printf(\"How many number do you want to dequeue ? \");\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++)\n    {\n        Dequeue();\n        printf(\"List is :\\n\");\n        Print();\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSL__tls_cache.0.c", "original_string": "TlsCache *tlsInitCache(uint_t size)\n{\n   size_t n;\n   TlsCache *cache;\n   if(size < 1)\n      return NULL;\n   n = sizeof(TlsCache) + size * sizeof(TlsSessionState);\n   cache = tlsAllocMem(n);\n   if(cache == NULL)\n      return NULL;\n   osMemset(cache, 0, n);\n   if(!osCreateMutex(&cache->mutex))\n   {\n      tlsFreeMem(cache);\n      return NULL;\n   }\n   cache->size = size;\n   return cache;\n}"}
{"author": "haon1026", "file": "linux-programming__wait.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    pid_t pid = fork();\n    if(pid == -1)\n    {\n        perror(\"fork error\");\n        exit(1);\n    }\n    else if(pid == 0)\n    {\n        printf(\"I'm child, pid = %d, going to sleep 10s\\n\", getpid());\n        sleep(10);\n        printf(\"--------child die---------\\n\");\n    }\n    else if(pid > 0)\n    {\n        int wpid;\n        int status;\n        wpid = wait(&status);       \n        if(wpid == -1)\n        {\n            perror(\"wait error\");\n            exit(1);\n        }\n        if(WIFEXITED(status))       \n        {\n            printf(\"child exit with %d\\n\", WEXITSTATUS(status));\n        }\n        if(WIFSIGNALED(status))     \n        {  \n            printf(\"child bekill with signal %d\\n\", WTERMSIG(status));\n        }\n        printf(\"-----parent wait child %d finish-----\\n\", wpid);\n    }\n    return 0;\n}"}
{"author": "dishanp", "file": "DSA__q4.0.c", "original_string": "void printPoly(int poly[], int n)\n{\n    for (int i = 0 ; i < n ; i++)\n    {\n        printf(\"%d\", poly[i]);\n        if (i != 0)\n            printf(\"x^%d\", i) ;\n        if (i != n-1)\n            printf(\" + \");\n    }\n    printf(\"\\n\");\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-structure.3.c", "original_string": "LINE* mksubdeclabel(CLASS* c, SUBROUTDEC* sd) {\n    char* labelstrs[] = { \"function\", dotlabel(c->name, sd->name), itoa(countlocalvars(sd->body->vardecs)) };\n    LINE* label = mkln(labelstrs);\n    free(labelstrs[1]);\n    free(labelstrs[2]);\n    label->next = NULL;\n    return label;\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.23.c", "original_string": "void freeassembler(ASSEMBLER* a) {\n    freesymbols(a->vars);\n    freesymbols(a->labels);\n    freeasmlns(a->lns);\n    freeasmlns(a->garbage);\n    free(a);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__sftp_server_directory.0.c", "original_string": "error_t sftpServerCreateDir(SftpServerSession *session,\n   const SshString *path, const SftpFileAttrs *attributes)\n{\n   error_t error;\n   uint_t perm;\n   SftpServerContext *context;\n   context = session->context;\n   error = sftpServerGetPath(session, path, context->path,\n      SFTP_SERVER_MAX_PATH_LEN);\n   if(error)\n      return error;\n   perm = sftpServerGetFilePermissions(session, context->path);\n   if((perm & SFTP_FILE_PERM_WRITE) == 0)\n      return ERROR_ACCESS_DENIED;\n   error = fsCreateDir(context->path);\n   return error;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__38_matrix_multiplication.0.c", "original_string": "int main()\n{\n  int i,j,k,r1,c1,r2,c2;\n  printf(\"Enter Value of r1, c1, r2, c2\\n\");\n  scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n  int m1[r1][c1], m2[r2][c2], sum = 0, mul[r1][c2];\n  if( c1 == r2)\n  {\n    printf(\"Enter value of Matrix1\\n\");\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        scanf(\"%d\",&m1[i][j]);\n      }\n    }\n    printf(\"Enter value of Matrix2\\n\");\n    for(i=0; i<r2; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        scanf(\"%d\",&m2[i][j]);\n      }\n    }\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        printf(\"%d \",m1[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    printf(\"\\n\") ;\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n        printf(\"%d \",m2[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c2; j++)\n      {\n        for(k=0; k<r2; k++)\n        {\n          sum = sum + m1[i][k] * m2[k][j];  \n        }  \n        mul[i][j] = sum;\n        sum = 0;\n      }\n      printf(\"\\n\");\n    } \n    printf(\"Mutiplication of Matrix is -: \\n\");\n    for(i=0; i<r1; i++)\n    {\n      for(j=0; j<c1; j++)\n      {\n       printf(\"%d \",mul[i][j]);\n      }\n      printf(\"\\n\");\n    }\n  }\n  else\n  {\n    printf(\"Multiplication is Not Possible\");\n  } \n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSL__tls_ticket.1.c", "original_string": "error_t tlsEncryptTicket(TlsContext *context, const uint8_t *plaintext,\n   size_t plaintextLen, uint8_t *ciphertext, size_t *ciphertextLen, void *param)\n{\n   error_t error;\n   uint8_t *iv;\n   uint8_t *data;\n   uint8_t *tag;\n   systime_t time;\n   TlsTicketContext *ticketContext;\n   TlsTicketEncryptionState *state;\n   if(context == NULL || param == NULL)\n      return ERROR_INVALID_PARAMETER;\n   if(plaintext == NULL || ciphertext == NULL || ciphertextLen == NULL)\n      return ERROR_INVALID_PARAMETER;\n   error = NO_ERROR;\n   iv = NULL;\n   data = NULL;\n   tag = NULL;\n   ticketContext = (TlsTicketContext *) param;\n   osAcquireMutex(&ticketContext->mutex);\n   tlsCheckTicketKeyLifetime(&ticketContext->encryptionState);\n   tlsCheckTicketKeyLifetime(&ticketContext->prevEncryptionState);\n   state = &ticketContext->encryptionState;\n   if(state->valid)\n   {\n      time = osGetSystemTime();\n      if((time - state->timestamp) >= TLS_TICKET_LIFETIME)\n      {\n         ticketContext->prevEncryptionState = ticketContext->encryptionState;\n         ticketContext->encryptionState.valid = FALSE;\n      }\n   }\n   if(!state->valid)\n   {\n      error = tlsGenerateTicketKeys(ticketContext, context->prngAlgo,\n         context->prngContext);\n   }\n   if(!error)\n   {\n      iv = ciphertext + TLS_TICKET_KEY_NAME_SIZE;\n      data = iv + TLS_TICKET_IV_SIZE;\n      tag = data + plaintextLen;\n      osMemmove(data, plaintext, plaintextLen);\n      osMemcpy(ciphertext, state->keyName, TLS_TICKET_KEY_NAME_SIZE);\n      error = context->prngAlgo->read(context->prngContext, iv,\n         TLS_TICKET_IV_SIZE);\n   }\n   if(!error)\n   {\n      error = aesInit(&ticketContext->aesContext, state->key,\n         TLS_TICKET_KEY_SIZE);\n   }\n   if(!error)\n   {\n      error = gcmInit(&ticketContext->gcmContext, AES_CIPHER_ALGO,\n         &ticketContext->aesContext);\n   }\n   if(!error)\n   {\n      *ciphertextLen = plaintextLen + TLS_TICKET_KEY_NAME_SIZE +\n         TLS_TICKET_IV_SIZE + TLS_TICKET_TAG_SIZE;\n      error = gcmEncrypt(&ticketContext->gcmContext, iv, TLS_TICKET_IV_SIZE,\n         state->keyName, TLS_TICKET_KEY_NAME_SIZE, data, data, plaintextLen,\n         tag, TLS_TICKET_TAG_SIZE);\n   }\n   osReleaseMutex(&ticketContext->mutex);\n   return error;\n}"}
{"author": "sdukesameer", "file": "dsa__list-by-stack.4.c", "original_string": "int main()\n{\n    int ch;\n    node* head=NULL;\n    while(1)\n    {\n        printf(\"\\n\");\n        printf(\"1. PUSH\\n\");\n        printf(\"2. POP\\n\");\n        printf(\"3. EXIT\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\",&ch);\n        if (ch==1)\n        {\n            int n;\n            scanf(\"%d\",&n);\n            push(&head,n);\n        }\n        else if (ch==2)\n            pop(&head);\n        else if (ch==3)\n        {\n            printf(\"Exitting program, Thank you.\\n\");\n            break;\n        }\n        else\n            printf(\"Invalid, choice try again.\\n\");\n    }\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__stp_conditions.3.c", "original_string": "bool_t stpDesignatedPort(StpBridgePort *port)\n{\n   bool_t res;\n   StpBridgeContext *context;\n   context = port->context;\n   if(stpCompareBridgeId(&port->designatedBridge, &context->bridgeId) == 0 &&\n      port->designatedPort == port->portId)\n   {\n      res = TRUE;\n   }\n   else\n   {\n      res = FALSE;\n   }\n   return res;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q3_merge.2.c", "original_string": "void merge(nodeptr a,nodeptr b){\n    nodeptr trail1,trail2,temp1,temp2,i;\n    trail1=a;\n    trail2=b;\n    temp1=trail1->link;\n    temp2=trail2->link;\n    while(temp1!=a&&temp2!=b){\n        if(temp1->data<temp2->data){\n            trail1=trail1->link;\n            temp1=temp1->link;\n        }\n        else if(temp1->data==temp2->data){\n            trail2->link=temp2->link;\n            temp2->link=temp1->link;\n            temp1->link=temp2;\n            temp2=trail2->link;\n            trail1=trail1->link->link;\n            temp1=temp1->link->link;\n        }\n        else{\n            trail2->link=temp2->link;\n            trail1->link=temp2;\n            temp2->link=temp1;\n            temp2=trail2->link;\n            trail1=trail1->link;\n        }\n    }\n    if(temp2!=b){\n    trail1->link=temp2;\n    for(i=temp2;i->link!=b;i=i->link);\n    i->link=temp1;\n    free(trail2);\n}\n}"}
{"author": "mehedi9021", "file": "Data_Structure__create_single_linked_list.1.c", "original_string": "void createlist(int n)\n{\n    struct node*mehedi;\n    struct node*temp;\n    int i, data;\n    head=(struct node*)malloc(sizeof(struct node));\n    printf(\"Enter data:\");\n    scanf(\"%d\", &data);\n    head->data=data;\n    head->next=NULL;\n    temp=head;\n    for(i=2;i<=n;i++)\n    {\n        mehedi=(struct node*)malloc(sizeof(struct node));\n        printf(\"Enter data:\");\n        scanf(\"%d\", &data);\n        mehedi->data=data;\n        mehedi->next=NULL;\n        temp->next=mehedi;\n        temp=mehedi;\n    }\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_timebase_TIM.0.c", "original_string": "HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)\n{\n  RCC_ClkInitTypeDef    clkconfig;\n  uint32_t              uwTimclock = 0;\n  uint32_t              uwPrescalerValue = 0;\n  uint32_t              pFLatency;\n  HAL_NVIC_SetPriority(TIM6_DAC_IRQn, TickPriority ,0); \n  HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn); \n  __HAL_RCC_TIM6_CLK_ENABLE();\n  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);\n  uwTimclock = 2*HAL_RCC_GetPCLK1Freq();\n  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);\n  htim6.Instance = TIM6;\n  htim6.Init.Period = (1000000 / 1000) - 1;\n  htim6.Init.Prescaler = uwPrescalerValue;\n  htim6.Init.ClockDivision = 0;\n  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;\n  if(HAL_TIM_Base_Init(&htim6) == HAL_OK)\n  {\n    return HAL_TIM_Base_Start_IT(&htim6);\n  }\n  return HAL_ERROR;\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.2.c", "original_string": "char* atraw(VMTRANSLATOR* t, char* n, int len) {\n    int sz = sizeof(char) * (len + 2);\n    char* atstr = (char*)malloc(sz);\n    sprintf(atstr, \"@%s\", n);\n    togarbage(t, atstr);\n    return atstr;\n}"}
{"author": "2security", "file": "String__37TrimWhiteSpace.1.c", "original_string": "char* Trim(char *str)\n    {\n        int i=0,j,c=0,n,d;\n        char *temp;\n        n=Mystrlen(str);\n        while(str[c]==' '||str[c]=='\\t'||str[c]=='\\n')\n            {\n                c++;\n            }\n        for(j=c;j<=n-1;j++)\n            {\n                str[i]=str[j];  \n                i++;\n            }\n        str[i]='\\0';\n        c=Mystrlen(str)-1;\n        while(str[c]==' '||str[c]=='\\t'||str[c]=='\\n')\n            {\n                c--;\n            }\n        str[c+1]='\\0';\n        return str;\n        return str;\n    }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_07.0.c", "original_string": "void read(int A[],int n)\n{\n  int i;\n  for(i=0;i<n;i++)\n   fscanf(F1,\"%d\",&A[i]);\n}"}
{"author": "earth429", "file": "mulpre__sqrt_newton.1.c", "original_string": "int sqrt_newton(struct NUMBER *a, struct NUMBER *b) {\n    struct NUMBER x, ox, tx, zero, one, two, quotient, sum, rest; \n    clearByZero(b);\n    setInt(&zero, 0);\n    setInt(&one, 1);\n    setInt(&two, 2);\n    quickDivide(a, &two, &x, &rest);\n    if(isZero(&x) != -1 || numComp(&x, &one) == 0){ \n        copyNumber(a, b);\n        return 0;\n    }\n    if (numComp(&x, &zero) == -1){ \n        return -1;\n    }\n    copyNumber(&x, &ox);\n    while(1){\n        copyNumber(&ox, &tx);\n        copyNumber(&x, &ox);\n        quickDivide(a, &ox, &quotient, &rest);\n        add(&ox, &quotient, &sum);\n        quickDivide(&sum, &two, &x, &rest);\n        if(numComp(&x, &ox) == 0){ \n            break;\n        }\n        if(numComp(&x, &tx) == 0){ \n            if(numComp(&ox, &x) == -1){ \n                copyNumber(&ox, &x);\n            }\n            break;\n        }\n    }\n    copyNumber(&x, b);\n    return 0;\n}"}
{"author": "SugumaranEvil", "file": "TLPI__read_shm.0.c", "original_string": "int main()\n{\n   int open_fd, munmap_ret, msync_ret;\n   ssize_t read_fd;\n   char *mmap_ret;\n   char buff[50];\n   open_fd = shm_open(\"/posix\" , O_RDWR , 0644);\n   if(open_fd == -1){\n       perror(\"shm_open\");\n       printf(\"Return value of shm_open %d\\n\",open_fd);\n   }else {\n       perror(\"shm_open\");\n       printf(\"Return value of shm_open %d\\n\",open_fd);\n   }\n   read_fd = read(open_fd,buff,4096);\n   if(read_fd == -1){\n    perror(\"read\");\n   }else {\n    perror(\"read\");\n   }\n   mmap_ret = mmap(NULL , 4096 , PROT_READ | PROT_WRITE, MAP_SHARED ,open_fd ,0);\n   perror(\"mmap\");\n   msync_ret = msync(mmap_ret, 4096, MS_SYNC);\n   if(msync_ret == -1){\n       perror(\"msync\");\n   }else {\n       perror(\"msync\");\n   }\n   printf(\"%s\\n\",buff);\n   munmap_ret = munmap(mmap_ret, 4096);\n   if(munmap_ret == -1) {\n       perror(\"munmap\");\n   }else {\n       perror(\"munmap\");\n   }\n}"}
{"author": "earth429", "file": "mulpre__zerosuppress.0.c", "original_string": "void dispNumber(struct NUMBER *a){\n    int i;\n    if(a->sign == 1){\n        printf(\"+\");\n    } else {\n        printf(\"-\");\n    }\n    for (i = KETA - 1; i >= 0;i--){\n        printf(\"%2d\", a->n[i]);\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__A.0.c", "original_string": "int main()\n{\n    int n,num,aux,condicao = true, maior, smaior, smenor, menor, maior0, smaior0, menor0, smenor0;\n    scanf (\"%i\", &n);\n    for (int i=0; i<n; i++)\n    {\n        scanf (\"%i\", &num);\n        if (i==0)\n        {\n            maior = num;\n            menor = num;\n            smaior = num;\n            smenor = num;\n        }\n        else\n        {\n            if (num > maior)\n            {\n                aux = maior;\n                maior = num;\n                smaior = aux;\n            }\n            else if (num < menor)\n            {\n                aux = menor;\n                menor = num;\n                smenor = aux;\n            }\n            if ((maior == smaior)&&(num < smaior)&&(num > smenor)&&(num > menor))\n            {\n                smaior = num;\n            }\n            else if ((menor == smenor)&&(num > smenor)&&(num < smaior)&&(num < maior))\n            {\n                smenor = num;\n            }\n            else if ((maior == smaior)&&(num < smaior))\n            {\n                smaior = num;\n            }\n            else if ((menor == smenor)&&(num > smenor))\n            {\n                smenor = num;\n            }\n            if ((maior == smaior)&&(maior == smenor)&&(num < smenor)&&(num > menor))\n            {\n                smaior = num;\n                smenor = num;\n            }\n            else if ((menor == smenor)&&(menor == smaior)&&(num > smaior)&&(num < maior))\n            {\n                smenor = num;\n                smaior = num;\n            }\n            if ((num < maior)&&(num > smaior))\n            {\n                smaior = num;\n            }\n            else if ((num > menor)&&(num < smenor))\n            {\n                smenor = num;\n            }\n        }\n    }\n        if ((maior == smaior)&&(smaior == smenor)&&(smenor == menor))\n            printf (\"%i\\n%i\\nnao definido\\nnao deifnido\\n\", maior, menor);\n        else\n            printf (\"%i\\n%i\\n%i\\n%i\\n\", maior, menor, smaior, smenor);\n    return 0;\n}"}
{"author": "dle2005", "file": "Algorithm__n_Coloring_v2.0.c", "original_string": "bool promising(int i) {\n    bool swtch = true;\n    int j = 1;\n    while(j < i && swtch) {\n        if(W[i][j] && vcolor[i] == vcolor[j]) swtch = false;\n        j++;\n    }\n    return swtch;\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__stack.3.c", "original_string": "void Display(PNODE Head)    \n{\n    while(Head != NULL)\n    {\n        printf(\"|%d|->\",Head->data);\n        Head = Head->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q1.1.c", "original_string": "nptr insertNode(nptr root, char path[])\n{\n    int i = 0;\n    nptr parent = NULL, curr = root;\n    while(curr && path[i])\n    {\n        parent = curr;\n        if (path[i] == 'L')\n            curr = parent -> lchild;\n        else if (path[i] == 'R')\n            curr = parent -> rchild;\n        i++;\n    }\n    if (curr == NULL && path[i] == '\\0')\n    {\n        printf(\"Path Found! Enter element: \");\n        int x; scanf(\"%d\", &x);\n        if (path[i - 1] == 'R')\n            parent -> rchild = createNode(x);\n        else if (path[i - 1] == 'L')\n            parent -> lchild = createNode(x);\n    }\n    else\n        printf(\"Path error!\");\n    return root;\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.4.c", "original_string": "void freesymbols(SYMBOLARRAY* a) {\n    for(int i = 0; i < a->count; i++)\n        freesymbol(a->items[i]);\n    free(a->items);\n    free(a);\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "2lista_de_C__main1.0.c", "original_string": "int main()\n{\n    int a;\n    int b;\n    float c;\n    int d =0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    printf(\"Digite o tamanho da sequencia: \");\n    scanf(\"%d\",&a);\n    for(b = 0; b < a; b++)\n    {\n        printf(\"Digite os numeros: \");\n        scanf(\"%f\",&c);\n        if(c >= 0 && c <= 25)\n        {\n            d++;\n        }else if(c >= 26 && c <= 50)\n        {\n            e++;\n        }else if(c >= 51 && c <= 75)\n        {\n            f++;\n        }else if(c >= 76 && c <= 100)\n        {\n            g++;\n        }\n    }\n        printf(\"[0...25]: %d\\n\",d);\n        printf(\"[26...50]: %d\\n\",e);\n        printf(\"[51...75]: %d\\n\",f);\n        printf(\"[76...100]: %d\\n\",g);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__position_biton_off.0.c", "original_string": "BOOL CheckBit(int iNo, int iPos)\n{\n    int iMask = 0x00000001;\n    int iResult = 0;\n    if(iNo < 0)\n    {\n        iNo = -iNo;\n    }\n    if((iPos < 1) || (iPos > 32))\n    {\n        return FALSE;\n    }\n    iMask = iMask << (iPos -1);\n    iResult = iNo & iMask;\n    if(iResult == iMask)\n    {\n        return TRUE;\n    }\n    else\n    {\n        return FALSE;\n    }\n}"}
{"author": "revathy16296", "file": "rtos_lab_asssignment_1__2_sum999.0.c", "original_string": "int main()\n{\n    int array[SI],n=0,sum;\n    float product,average;\n    printf(\"enter the array elements\\n\");\n    while(array[i]!=999)\n    {\n    for(i=0;i<SI;i++)\n    {\n        scanf(\"%d\",&array[i]);\n        n=i;\n        if(array[i]==999)\n        break;\n    }\n    }\n    sum=sum_of_num(array,n);\n    printf(\"the sum of number is %d\\n\",sum);\n    average=average_of_num(sum,n);\n    printf(\"the average is %f\\n\",average);\n    product=product_of_num(array,n);\n    printf(\"product of number is %f\",product);\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__week_1.4.c", "original_string": "int main()\n{\n    int ch;\n    do\n    {\n        printf(\"1. Add array elements\\n\");\n        printf(\"2. Linear Search\\n\");\n        printf(\"3. Multiply Matrices\\n\");\n        printf(\"4. Find second largest element in an array\\n\");\n        printf(\"5. Exit\\n\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &ch);\n        int size1; double arr1[50];                         \n        int size2, arr2[50], x;                             \n        int m, n, p, q, first[10][10], second[10][10];      \n        int size3, arr3[50];                                \n        switch(ch)\n        {\n            case 1:\n                    printf(\"Enter size: \");\n                    scanf(\"%d\", &size1);\n                    printf(\"Enter elements: \");\n                    for(int i = 0 ; i < size1 ; i++)\n                        scanf(\"%lf\", &arr1[i]);\n                    printf(\"Sum of elements is %lf \\n\\n\", add(arr1, size1));\n                    break;\n            case 2:\n                    printf(\"Enter size: \");\n                    scanf(\"%d\", &size2);\n                    printf(\"Enter elements: \");\n                    for(int i = 0 ; i < size2 ; i++)\n                        scanf(\"%d\", &arr2[i]);\n                    printf(\"Enter element to be searched: \");\n                    scanf(\"%d\", &x);\n                    printf(\"Element found at %dth position.\\n\\n\", Lsearch(arr2, size2, x));\n                    break;\n            case 3:\n                    printf(\"Enter order of first matrice: \");\n                    scanf(\"%d %d\", &m, &n);\n                    printf(\"Enter elements: \\n\");\n                    for(int i = 0 ; i < m ; i++)\n                        for(int j = 0 ; j < n ; j++)\n                            scanf(\"%d\", &first[i][j]);\n                    printf(\"Enter order of second matrice: \");\n                    scanf(\"%d %d\", &p, &q);\n                    printf(\"Enter elements: \\n\");\n                    for(int i = 0 ; i < p ; i++)\n                        for(int j = 0 ; j < q ; j++)\n                            scanf(\"%d\", &second[i][j]);\n                    multiply(first, second, m, n, p, q);\n                    break;\n            case 4: \n                    printf(\"Enter size: \");\n                    scanf(\"%d\", &size3);\n                    printf(\"Enter elements: \");\n                    for(int i = 0 ; i < size3 ; i++)\n                        scanf(\"%d\", &arr3[i]);\n                    printf(\"Second largest element is %d.\\n\\n\", secLar(arr3, size3));\n                    break;\n            case 5: \n                    break;\n            default:\n                    printf(\"Invalid input. Please try again!\\n\\n\");\n        }\n    }while(ch != 5);\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__16_For.0.c", "original_string": "void Columna(int pibote)\n{\n    for(int j = 1; j <= 20; ++j)\n    {\n        if(j >= (10 - pibote) && j <= (10 + pibote))\n        printf(\"Z\");\n    else\n        printf(\" \");\n    }\n}"}
{"author": "shengelenge", "file": "wstep-do-programowania__zad12.0.c", "original_string": "int main()\n{\n    char ch;\n    printf(\"Podaj jeden znak: \");\n    scanf(\"%c\", &ch);\n    switch (ch)\n    {\n        case 65:\n            printf(\"S\");\n            break;\n        case 66:\n            printf(\"N\");\n            break;\n        case 67:\n            printf(\"V\");\n            break;\n        case 68:\n            printf(\"F\");\n            break;\n        case 69:\n            printf(\"R\");\n            break;\n        case 70:\n            printf(\"G\");\n            break;\n        case 71:\n            printf(\"H\");\n            break;\n        case 72:\n            printf(\"J\");\n            break;\n        case 73:\n            printf(\"O\");\n            break;\n        case 74:\n            printf(\"K\");\n            break;\n        case 75:\n            printf(\"L\");\n            break;\n        case 76:\n            printf(\":\");\n            break;\n        case 77:\n            printf(\"<\");\n            break;\n        case 78:\n            printf(\"M\");\n            break;\n        case 79:\n            printf(\"P\");\n            break;\n        case 80:\n            printf(\"{\");\n            break;\n        case 81:\n            printf(\"W\");\n            break;\n        case 82:\n            printf(\"T\");\n            break;\n        case 83:\n            printf(\"D\");\n            break;\n        case 84:\n            printf(\"Y\");\n            break;\n        case 85:\n            printf(\"I\");\n            break;\n        case 86:\n            printf(\"B\");\n            break;\n        case 87:\n            printf(\"E\");\n            break;\n        case 88:\n            printf(\"C\");\n            break;\n        case 89:\n            printf(\"U\");\n            break;\n        case 90:\n            printf(\"X\");\n            break;\n        case 97:\n            printf(\"s\");\n            break;\n        case 98:\n            printf(\"n\");\n            break;\n        case 99:\n            printf(\"v\");\n            break;\n        case 100:\n            printf(\"f\");\n            break;\n        case 101:\n            printf(\"r\");\n            break;\n        case 102:\n            printf(\"g\");\n            break;\n        case 103:\n            printf(\"h\");\n            break;\n        case 104:\n            printf(\"j\");\n            break;\n        case 105:\n            printf(\"o\");\n            break;\n        case 106:\n            printf(\"k\");\n            break;\n        case 107:\n            printf(\"l\");\n            break;\n        case 108:\n            printf(\";\");\n            break;\n        case 109:\n            printf(\",\");\n            break;\n        case 110:\n            printf(\"m\");\n            break;\n        case 111:\n            printf(\"p\");\n            break;\n        case 112:\n            printf(\"[\");\n            break;\n        case 113:\n            printf(\"w\");\n            break;\n        case 114:\n            printf(\"t\");\n            break;\n        case 115:\n            printf(\"d\");\n            break;\n        case 116:\n            printf(\"y\");\n            break;\n        case 117:\n            printf(\"i\");\n            break;\n        case 118:\n            printf(\"b\");\n            break;\n        case 119:\n            printf(\"e\");\n            break;\n        case 120:\n            printf(\"c\");\n            break;\n        case 121:\n            printf(\"u\");\n            break;\n        case 122:\n            printf(\"x\");\n            break;\n        default:\n            printf(\"Podany znak nie jest litera.\");\n            break;\n    }\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "Common__path.7.c", "original_string": "void pathRemoveSlash(char_t *path)\n{\n   char_t *end;\n   if(pathIsAbsolute(path))\n      path++;\n   for(end = NULL; *path != '\\0'; path++)\n   {\n      if(*path != '/' && *path != '\\\\')\n         end = NULL;\n      else if(!end)\n         end = path;\n   }\n   if(end)\n      *end = '\\0';\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__DemoFOTAUpdateWorkflowFilePersistence.1.c", "original_string": "int16_t loadState(void)\n{\n  FILE *file = fopen(DEMO_PRODUCT_UPDATE_STATE_FILE_NAME, \"rb\");\n  if (file == NULL) \n  {\n    return 0;\n  }\n  int16_t state = 0;\n  if (fread(&state, sizeof(state), 1, file) != 1) \n  {\n    fclose(file);\n    return 0;\n  }\n  fclose(file);\n  return state;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_9.4.c", "original_string": "int length(queue Q)\n{\n    int l;\n    if (Q.front == -1)\n       return 0;\n    if (Q.rear >= Q.front)\n        l=Q.rear-Q.front+1;\n    else\n        l=Q.size-Q.front+2+Q.rear;\n    return l;\n}"}
{"author": "2security", "file": "Star__HollowInvertedPyramidStar.0.c", "original_string": "int main()\n    {\n    int n,i,j,k;\n    printf(\"Enter how many row\");\n    scanf(\"%d\",&n);\n    for(i=n;i>=1;i--)\n        {\n        for(j=n;j>i;j--)\n            printf(\" \");\n        for(j=1;j<=2*i-1;j++)\n            {\n                if(j==2*i-1||j==1||i==n)\n                    printf(\"*\");\n                else\n                    printf(\" \");\n            }\n        printf(\"\\n\");\n        }\n    printf(\"\\n\\n\");\n        return 0;\n    }"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedInsertion.1.c", "original_string": "struct Node * insertAtFirst(struct Node *head, int data){\n     struct Node * ptr = (struct Node *) malloc(sizeof(struct Node));\n     ptr->next = head;\n     ptr->data = data;\n     return ptr;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-statements.4.c", "original_string": "CONDSTATEMENT* parsecond(PARSER* p) {\n    checkcontent(p, \"(\");\n    CONDSTATEMENT* st = (CONDSTATEMENT*)malloc(sizeof(CONDSTATEMENT));\n    st->expression = parseexpression(p);\n    checkcontent(p, \")\");\n    checkcontent(p, \"{\");\n    st->statements = parsestatements(p);\n    checkcontent(p, \"}\");\n    return st;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e92.3.c", "original_string": "float pagarDinheiroMeia(int contSelec, float pagamento, struct evento show[])\n{\n    float troco;\n    show[contSelec].lucro += (show[contSelec].valorIngresso * 0.9) / 2;\n    troco = pagamento - (show[contSelec].valorIngresso * 0.9) / 2;\n    show[contSelec].disponiveis--;\n    show[contSelec].meia++;\n    return troco;\n}"}
{"author": "sdukesameer", "file": "dsa__n-queen-a.2.c", "original_string": "int main(){\n    int n=1;\n    while(n){\n        printf(\"Enter valid N i.e no of rows and columns: \");\n        scanf(\"%d\",&N);\n        if(N>0)\n            n=0;\n    }\n    int arr[N][N];\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < N; j++)\n            arr[i][j]=0;\n    }\n    int ans=queens(arr,0);\n    if(ans==0)\n        printf(\"\\nSolution doesn't exist.\\n\");\n    else{\n        printf(\"\\nSolution by placing queens at:\");\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                if(arr[i][j])\n                    printf(\" %d,%d\",i,j);\n        printf(\".\\n\");\n    }\n    return 0;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__pushPopInStack.1.c", "original_string": "int isFull(struct stack*ptr){\n    if(ptr->top == ptr->size-1){\n        printf(\"Stack is Full(overflow)..\\n\");\n        return 1;\n    }\n    else{\n        return 0;\n    }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_extended.1.c", "original_string": "void ble_lbs_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context)\n{\n    ble_lbs_t * p_lbs = (ble_lbs_t *)p_context;\n    switch (p_ble_evt->header.evt_id)\n    {\n        case BLE_GATTS_EVT_WRITE:\n            on_write(p_lbs, p_ble_evt);\n            break;\n        default:\n            break;\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__BinHexConverter0.2.c", "original_string": "size_t convertBinValueToHexString8(uint8_t inputValue, char *outputStr, size_t outputStrSize, bool upperCase)\n{\n  if (outputStrSize < 2) \n  {\n    return 0;\n  }\n  outputStr[0] = convertBinValueToHexDigit(((inputValue & 0xF0u) >> 4), upperCase);\n  outputStr[1] = convertBinValueToHexDigit((inputValue & 0x0Fu), upperCase);\n  return 2;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__circularqueue.2.c", "original_string": "void search(int val)\n{\n    i=0;\n    if((f==-1 && r==-1))\n    printf(\"\\nQueue is Empty\");\n    else if(f==(r+1)%MAX && queue[f]==-1)\n    printf(\"\\nQueue is Empty\");\n    else\n    {   \n        i=f;\n        while(i!=r)\n        {\n            if(queue[i]==val)\n            {\n                printf(\"\\nvalue found\");\n                x++;\n            }\n            i=(i+1)%MAX;\n        }\n        if(queue[i]==val)\n        {\n            printf(\"\\nvalue found\");\n            x++;\n        }\n        if(x==0)\n        printf(\"\\nthe value is not found in the queue\");\n    }\n}"}
{"author": "RafaelFelisbino-hub", "file": "WHILE-exercices__Exercicio8WHILE.0.c", "original_string": "int main() \n{\n    int  numeroDivisivel = 0, inicioIntervalo = 0, fimIntervalo = 0, qtdDivisoesExatas = 0,soma = 0;\n    setlocale(LC_ALL, \"Portuguese\");\n    system(\"color 17\");\n    printf(\"Digite o n\u00famero que queira dividir:  \");\n    scanf_s(\"%i\", &numeroDivisivel);\n    printf(\"Digite o primeiro intervalo:  \");\n    scanf_s(\"%i\", &inicioIntervalo);\n    printf(\"Digite o segundo intervalo:  \");\n    scanf_s(\"%i\", &fimIntervalo);\n    while (inicioIntervalo <= fimIntervalo)\n    {\n        if (inicioIntervalo % numeroDivisivel == 0)\n        {\n            qtdDivisoesExatas++;\n            soma += inicioIntervalo;\n        }\n        inicioIntervalo++;\n    }\n    printf(\"\\n\\nO n\u00famero pode ser dividido por %i n\u00fameros inteiros\\n\\n\", qtdDivisoesExatas);\n    printf(\"A soma dos n\u00fameros inteiros divididos por %i \u00e9:  %i\\n\\n\",numeroDivisivel, soma);\n    system(\"pause\");\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__employee.0.c", "original_string": "void InsertFirst(PPNODE Head)\n{\n    PNODE newn = (PNODE)malloc(sizeof(NODE));\n    printf(\"Enter employee ID\\n\");\n    scanf(\"%d\",&(newn->Eno));\n    printf(\"Enter name\\n\");\n    scanf(\" %[^'\\n']s\",newn->EName);\n    if(*Head == NULL)\n    {\n        *Head = newn;\n    }\n    else\n    {\n        newn->next = *Head;\n        *Head = newn;\n    }\n}"}
{"author": "Oryx-Embedded", "file": "Common__cpu_endian.7.c", "original_string": "uint64_t reverseInt64(uint64_t value)\n{\n   value = ((value & 0xFFFFFFFF00000000ULL) >> 32) | ((value & 0x00000000FFFFFFFFULL) << 32);\n   value = ((value & 0xFFFF0000FFFF0000ULL) >> 16) | ((value & 0x0000FFFF0000FFFFULL) << 16);\n   value = ((value & 0xFF00FF00FF00FF00ULL) >> 8) | ((value & 0x00FF00FF00FF00FFULL) << 8);\n   value = ((value & 0xF0F0F0F0F0F0F0F0ULL) >> 4) | ((value & 0x0F0F0F0F0F0F0F0FULL) << 4);\n   value = ((value & 0xCCCCCCCCCCCCCCCCULL) >> 2) | ((value & 0x3333333333333333ULL) << 2);\n   value = ((value & 0xAAAAAAAAAAAAAAAAULL) >> 1) | ((value & 0x5555555555555555ULL) << 1);\n   return value;\n}"}
{"author": "Dhruvik-Chevli", "file": "DAALab__graphAdjacencyList.2.c", "original_string": "void printGraph(struct Graph* graph)\n{\n    for(int i=0;i<graph->V;i++)\n    {\n        struct adjLNode* temp=graph->arr[i].head;\n        printf(\"The connected vertices to the vertex %d are- \\n\",i);\n        while(temp)\n        {\n            printf(\"%d \",temp->dest);\n            temp=temp->next;\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__reverse.2.c", "original_string": "int main()\n{\n    int value = 0;\n    printf(\"Enter number\\n\");\n    scanf(\"%d\",&value);     \n    DisplayR(value);\n    printf(\"End of main\");\n    return 0;\n}"}
{"author": "2security", "file": "Pointer__11MultiplicationTwoMatrix.2.c", "original_string": "int main()\n    {\n        int i,j;\n        int **mat1,**mat2,**mat3;\n        printf(\"Enter the row & col. of the first matrix \");\n        scanf(\"%d%d\",&r,&c);\n        printf(\"Enter the row & col. of the second matrix \");\n        scanf(\"%d%d\",&m,&n);\n        if(c==m)\n            {\n                mat1=(int **)malloc(r*sizeof(int *));       \n                mat2=(int **)malloc(m*sizeof(int *));\n                mat3=(int **)malloc(r*sizeof(int *));       \n                for(i=0;i<r;i++)\n                mat1[i]=(int *)malloc(c*sizeof(int));   \n                for(j=0;j<m;j++)\n                mat2[j]=(int *)malloc(n*sizeof(int));\n                for(j=0;j<r;j++)\n                mat3[j]=(int *)malloc(n*sizeof(int));\n                printf(\"\\n Enter the first matrix \");\n                for(i=0;i<r;i++)\n                    {\n                    for(j=0;j<c;j++)\n                    scanf(\"%d\",&mat1[i][j]);\n                    }\n                printf(\"\\n Enter the second matrix\");\n                for(i=0;i<m;i++)\n                    {\n                    for(j=0;j<n;j++)\n                    scanf(\"%d\",&mat2[i][j]);\n                    }\n                Product(mat1,mat2,mat3);\n                printf(\"\\n The Resultant matrix is \\n\");\n                Display(mat3);\n                free(mat1);\n                free(mat2);\n                free(mat3);\n                }\n        else\n        printf(\"OOPS!!Multiplication not possible..\");\n    return 0;\n    }"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2B_B180575CS_GOKUL_03.2.c", "original_string": "int main(int argc,char *argv[])\n{\n    char s;\n    int m,n,x,p,k;\n    int *X,*Y;\n    int count=0;\n    F1=fopen(argv[1],\"r\");\n    F2=fopen(argv[2],\"w\");\n    if(F1==NULL)\n        printf(\"cant open file\");\n    else\n        {\n        while(1)\n         {\n            fscanf(F1,\"%c\",&s);\n            if(s=='r')\n                {\n                    count++;\n                    if(count%2!=0)\n                     { \n                         fscanf(F1,\" %d\",&m);\n                         X = (int*) malloc(m* sizeof(int));\n                         read(X,m);\n                     }\n                    else\n                     {\n                         fscanf(F1,\" %d\",&n);\n                         Y = (int*) malloc(n* sizeof(int));\n                         read(Y,n);\n                     }\n                 }    \n            else if(s=='c')\n                 {        \n                      checkSubset(X,m,Y,n);\n                 }\n            else if(s=='t')\n                break;\n            }\n         }\n    fclose(F1);\n    fclose(F2);\n}"}
{"author": "earth429", "file": "mulpre__curt.1.c", "original_string": "int curt(struct NUMBER *a, struct NUMBER *b) {\n    struct NUMBER x, ox, tx, px, dx, zero, one, two, three, quotient, sum, rest; \n    setInt(&zero, 0);\n    setInt(&one, 1);\n    setInt(&two, 2);\n    setInt(&three, 3);\n    quickDivide(a, &two, &x, &rest);\n    if(isZero(&x) != -1 || numComp(&x, &one) == 0){ \n        copyNumber(a, b);\n        return 0;\n    }\n    if (numComp(&x, &zero) == -1){ \n        return -1;\n    }\n    copyNumber(&x, &ox);\n    while(1){\n        copyNumber(&ox, &tx); \n        copyNumber(&x, &ox); \n        power(&ox, &two, &px); \n        quickDivide(a, &px, &quotient, &rest);\n        multiple(&ox, &two, &dx); \n        add(&dx, &quotient, &sum);\n        quickDivide(&sum, &three, &x, &rest);\n        if(numComp(&x, &ox) == 0){ \n            break;\n        }\n        if(numComp(&x, &tx) == 0){ \n            if(numComp(&ox, &x) == -1){ \n                copyNumber(&ox, &x);\n            }\n            break;\n        }\n    }\n    copyNumber(&x, b);\n    return 0;\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_cortex.8.c", "original_string": "void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)\n{\n  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));\n  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));\n  MPU->RNR = MPU_Init->Number;\n  if ((MPU_Init->Enable) != RESET)\n  {\n    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));\n    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));\n    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));\n    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));\n    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));\n    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));\n    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));\n    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));\n    MPU->RBAR = MPU_Init->BaseAddress;\n    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |\n                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |\n                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |\n                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |\n                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |\n                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |\n                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |\n                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |\n                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);\n  }\n  else\n  {\n    MPU->RBAR = 0x00U;\n    MPU->RASR = 0x00U;\n  }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__keypad_assign.5.c", "original_string": "void col_key4(void)\n{\n        int val;\n        IODIR1 = IODIR1 & ~(COL);  \n        IODIR1 = IODIR1 | (ROW);  \n        val = (IOPIN1 & COL); \n        val = val >> 17;\n        switch(val)\n        {\n            case 0x0E: \n                lcd_data('#');\n                delay(500);\n                break;\n            case 0x0D:\n                lcd_data('0');\n                delay(500);\n                break;\n            case 0x0B:\n                lcd_data('=');\n                delay(500);\n                break;\n            case 0x07:\n                lcd_data('/');\n                delay(500);\n                break;\n        }\n}"}
{"author": "theuwis", "file": "AdventOfCode2016__main8.0.c", "original_string": "int main(void){\n    int count = 0, total_len = 0;\n    int chars = 0, times = 0;\n    while(input[count] != '\\0'){\n        if(input[count] == '('){\n            count++;\n            while(input[count] != 'x'){\n                chars = chars * 10 + (input[count] - '0'); \n                count++;\n            }\n                count++;\n            while(input[count] != ')'){\n                times = times * 10 + (input[count] - '0'); \n                count++;\n            }\n            total_len = total_len + (chars * times); \n            count = count + chars;  \n            chars = 0; \n            times = 0;\n        }\n        else{\n            total_len++;\n        }\n        count++;\n    }\n    printf(\"answer=%d\\n\", total_len);\n    return EXIT_SUCCESS;\n}"}
{"author": "dishanp", "file": "DSA__q62.2.c", "original_string": "void colsort(int **mat, int m , int n)\n{\n    for (int j = 0 ; j < n ; j++)\n    {\n        for (int i = 0 ; i < m - 1 ; i++)\n        {\n            for (int k = i + 1 ; k < m ; k++)\n            {\n                if (mat[i][j] < mat[k][j])\n                swap(&mat[i][j], &mat[k][j]);\n            }\n        }\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__ca3.2.c", "original_string": "BS_TREE* deleteQueue (QUEUE *aq){\n     BS_TREE *p;\n    if (aq->front != aq->rear){\n        p= aq->elements [++(aq->front)];\n        if (aq->front == aq->rear)\n        initialiseQueue (aq);\n        return p; \n    }\n    else \n        return NULL; \n}"}
{"author": "SugumaranEvil", "file": "Linux_programming__fstat.0.c", "original_string": "int main()\n{\n    int fst,file_des;\n    struct stat detail;\n    file_des = open(\"./text\",O_RDONLY);\n    perror(\"open\");\n    printf(\"fd %d\\n\",file_des);\n    fst = fstat(file_des,&detail);\n    perror(\"fstat\");\n    printf(\"fst %d\\n\",fst);\n    printf(\"inode number %lu\\n\",detail.st_ino);\n    printf(\"hard link  %lu\\n\",detail.st_nlink);\n    printf(\"user id %lu\\n\",detail.st_uid);\n    printf(\"group id %lu\\n\",detail.st_gid);\n    printf(\"size %lu\\n\",detail.st_size);\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es3.1.c", "original_string": "int main(void) {\n    int dim_a;\n    printf(\"Inserire dimensione a: \");\n    scanf(\"%d\", &dim_a);\n    int *a = malloc(sizeof(int)*dim_a);\n    for(int i=0; i<dim_a; i++){\n        printf(\"a[%d] = \", i);\n        scanf(\"%d\", &a[i]);\n    }\n    printf(\"\\n\");\n    rimuovi(a, &dim_a);\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__MatrixOperations.2.c", "original_string": "void subtract_matrices(int m1[R][C], int m2[R][C])\n{\n    int i, j = 0;\n    int output[R][C];\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            output[i][j] = m1[i][j] - m2[i][j];\n        }\n    }\n    printf(\"\\nResultant Matrix after SUBTRACTION:- \\n\");\n    display_matrix(output);\n}"}
{"author": "behergue", "file": "Operating_Systems__myFS.2.c", "original_string": "int findFreeFile(MyFileSystem *myFileSystem)\n{\n    int i;\n    for(i = 0; i < MAX_FILES_PER_DIRECTORY; i++) {\n        if(myFileSystem->directory.files[i].freeFile == true)\n            return i;\n    }\n    return -1;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_07.3.c", "original_string": "void bubbleSort(int arr[], int n) \n{ \n   int i, j; \n   for (i = 0; i < n-1; i++)       \n       for (j = 0; j < n-i-1; j++)\n    { \n       if(arr[j]>=0 && arr[j+1]>=0)\n       {\n           if (arr[j] > arr[j+1]) \n              swap(&arr[j], &arr[j+1]);\n       } \n       else if(arr[j]>0 && arr[j+1]<0)\n       {\n          for(int m = 0; m<n-j; m++)\n          {\n            if(arr[j+m]<arr[j] && arr[j+m]>=0)\n            {\n              swap(&arr[j+m], &arr[j]);\n              break;\n            }\n          }\n       }\n       else if(arr[j]<0)\n          continue;\n   }\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__palhaco.5.c", "original_string": "void desenhaCabeloDireita(){\n    glPushMatrix();\n        glColor3f(1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(2.5, 0.0, 0.0);\n        glutWireSphere(0.5, 10, 10);\n    glPopMatrix();\n    glPushMatrix();\n        glColor3f(1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(2.2, 0.7 , 0.0);\n        glutWireSphere(0.5, 10, 10);\n    glPopMatrix();\n    glPushMatrix();\n        glColor3f(1.0, 0.0, 0.0);\n        glRotatef(angulo,0.0,1.0,0.0);\n        glTranslatef(2.2, -0.7, 0.0);\n        glutWireSphere(0.5, 10, 10);\n    glPopMatrix();\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_msp.1.c", "original_string": "static void HAL_FMC_MspInit(void){\n  GPIO_InitTypeDef GPIO_InitStruct;\n  if (FMC_Initialized) {\n    return;\n  }\n  FMC_Initialized = 1;\n  __HAL_RCC_FMC_CLK_ENABLE();\n  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 \n                          |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_11|GPIO_PIN_12 \n                          |GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;\n  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;\n  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);\n  GPIO_InitStruct.Pin = GPIO_PIN_0;\n  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;\n  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);\n  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5 \n                          |GPIO_PIN_8|GPIO_PIN_15;\n  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;\n  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);\n  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 \n                          |GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 \n                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;\n  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;\n  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);\n  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 \n                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;\n  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;\n  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);\n  GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;\n  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n  GPIO_InitStruct.Pull = GPIO_NOPULL;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;\n  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;\n  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);\n}"}
{"author": "mandarvu", "file": "msc__problem9.0.c", "original_string": "int main()\n{\n  int mat1[MAX][MAX], mat2[MAX][MAX], addition[MAX][MAX];\n  printf(\"Give values in the matrix1 row-wise.\\n\");\n  for (int i = 0; i < MAX; i++)\n  {\n    for (int j = 0; j < MAX; j++)\n    {\n      scanf(\"%d\",&mat1[i][j]);\n    }\n  }\n  printf(\"Give values in the matrix2 row-wise.\\n\");\n  for (int ii = 0; ii < MAX; ii++)\n  {\n    for (int jj = 0; jj < MAX; jj++)\n    {\n      scanf(\"%d\", &mat2[ii][jj]);\n    }\n  }\n  printf(\"\\nThe matrix1 is\\n\");\n  for (int ii = 0; ii < MAX; ii++)\n  {\n    for (int jj = 0; jj < MAX; jj++)\n    {\n      printf(\"%d\\t\",mat1[ii][jj]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\nThe matrix2 is\\n\");\n  for (int ii = 0; ii < MAX; ii++)\n  {\n    for (int jj = 0; jj < MAX; jj++)\n    {\n      printf(\"%d\\t\",mat2[ii][jj]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\nThe matrix1 + matrix2 is\\n\");\n  for (int ii = 0; ii < MAX; ii++)\n  {\n    for (int jj = 0; jj < MAX; jj++)\n    {\n      printf(\"%d\\t\",mat1[ii][jj] + mat2[ii][jj]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_30.0.c", "original_string": "void criarVetorIntersecao() {\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            if (vet1[i] == vet2[j]) {\n                intersecao[i] = vet1[i];\n            }\n        }\n    }\n}"}
{"author": "MFarid94", "file": "Assignment4__Exercise12.0.c", "original_string": "int OddRepetitionNumberInArray(int *arr,int arr_size)\n{\n    int i,j;\n    int count = 0;\n    int index = 0;\n    for(i=0;i<arr_size;i++)\n    {\n        for(j = 0; j < arr_size;j++)\n        {\n            if(arr[i] == arr[j])\n            {\n                index = i;\n                count++;\n            }\n        }\n        if(count%2 != 0)\n        {\n            break;\n        }\n        count = 0;\n    }\n    return arr[index];\n}"}
{"author": "dle2005", "file": "Algorithm__Kruskal.2.c", "original_string": "void merge(set_pointer p, set_pointer q) {\n    if(U[p].depth == U[q].depth) {\n        U[p].depth += 1;\n        U[q].parent = p;\n    }\n    else if(U[p].depth < U[q].depth) U[p].parent = q;\n    else U[q].parent = p;\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__61.0.c", "original_string": "int main(void)\n{\n    int vetor[tamanho], aux, pivo, n, busca = false;\n    printf(\"\\nInforme os n\u00fameros do vetor:\\n\");\n    for (int i = 0; i < tamanho; i++)\n    {\n        scanf(\"%i\", &vetor[i]);\n        for (int j = i; j > 0; j--)\n        {\n            if (vetor[j] < vetor[j - 1])\n            {\n                aux = vetor[j];\n                vetor[j] = vetor[j - 1];\n                vetor[j - 1] = aux;\n            }\n        }\n    }\n    printf(\"\\nVetor: \");\n    for (int i = 0; i < tamanho; i++)\n    {\n        printf(\"%i \", vetor[i]);\n    }\n    pivo = tamanho / 2;\n    printf(\"\\nInforme qual n\u00famero deseja buscar no vetor: \");\n    scanf(\"%i\", &n);\n    for (int i = 0; i < (tamanho / 2); i++)\n    {\n        if (n == vetor[pivo])\n        {\n            busca = true;\n        }\n        else if (n < vetor[pivo - 1])\n        {\n            if ((pivo % 2) == 0)\n            {\n                pivo = pivo / 2;\n            }\n            else\n            {\n                pivo = (pivo + 1) / 2;\n            }\n        }\n        else if (n > vetor[pivo - 1])\n        {\n            if ((pivo % 2) == 0)\n            {\n                pivo = pivo + (pivo / 2);\n            }\n            else\n            {\n                pivo = pivo + ((pivo + 1) / 2);\n            }\n        }\n        else if (n == vetor[pivo - 1])\n        {\n            busca = true;\n        }\n    }\n    if (busca == true)\n    {\n        printf(\"\\nO n\u00famero est\u00e1 no vetor\\n\");\n    }\n    else\n    {\n        printf(\"\\nO n\u00famero n\u00e3o est\u00e1 no vetor\\n\");\n    }\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"author": "dishanp", "file": "DSA__q35.1.c", "original_string": "void display(struct node *p)\n{\n    while(p)\n    {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad2-CharInColumns.1.c", "original_string": "void rzad_zn(char ch, int i, int j) {\n    char space = ' ';\n    for(int k = i; k > 1; k--){\n        putchar(space);\n    }\n    for(int k = i; k <= j; k++){\n        putchar(ch);\n    }\n    return;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__23_Dowhile.2.c", "original_string": "int main()\n{\n    int X = 0;\n    int veces = 0;\n    printf(\"\\nPrograma para calcular Cosh(x) mediante sumas de Taylor\\nIngresa X:\");\n    scanf(\"%i\", &X);\n    printf(\"\\nIngrse el numero de sumas: \");\n    scanf(\"%i\", &veces);\n    double Suma_total = 0.0;\n    int i=1;\n    {\n        Suma_total += Exp(X,(i*2)) / Fac((i*2));\n        ++i;\n    }while(i <= veces);\n    printf(\"Cosh(%i) es igual a %lf\", X, (Suma_total + 1));\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__os.11.c", "original_string": "void freeossubroutdecs(SUBROUTDEC* d) {\n    free(d->name);\n    free(d->type);\n    SUBROUTDEC* next = d->next;\n    free(d);\n    if(next != NULL)\n        freeossubroutdecs(next);\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__stack1.0.c", "original_string": "void push(int stack[],int val)\n{\n    if(top==MAX-1)\n    printf(\"\\nstack is full\");\n    else\n    {\n        top=top+1;\n        stack[top]=val;\n    }\n}"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__map_utils.2.c", "original_string": "void        longuest_line(void)\n{\n    int i;\n    int j;\n    int max;\n    i = 0;\n    j = 0;\n    max = 0;\n    while (g_map_array[i])\n    {\n        while (g_map_array[i][j] != '\\0')\n            j++;\n        i++;\n        if (j > max)\n            max = j;\n        j = 0;\n    }\n    g_map_width = max;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__pll_36MHz.5.c", "original_string": "void delay_ms(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es7.1.c", "original_string": "NumeroComplesso prodotto(NumeroComplesso x, NumeroComplesso y){\n  NumeroComplesso p;\n  p.reale = x.reale*y.reale - x.immaginaria*y.immaginaria;\n  p.immaginaria = x.reale*y.immaginaria + x.immaginaria*y.reale;\n  return p;\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad14.1.c", "original_string": "bool nextCalculation(void) {\n    char userResponse;\n    printf(\"Czy chcesz przeliczyc czas ponownie? y/n: \");\n    scanf(\"%c\", &userResponse);\n    if (userResponse != 121) {\n            return true;\n    }\n    fflush(stdin);\n    return false;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_10.5.c", "original_string": "int checkParantheses(char* exp,struct stack* stk)\n{\n    int i;char popped;\n    for(i=0;i<stk->cap;i++)\n    {\n        if(exp[i]=='('||exp[i]=='{'||exp[i]=='[')\n        {\n            push(stk,exp[i]);\n        }\n        else if(exp[i]==')'||exp[i]=='}'||exp[i]==']')\n        {\n            popped=pop(stk);\n            if(!(isMatchingPair(popped,exp[i])))\n            {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_client_certificate.3.c", "original_string": "error_t acmeClientSendRevokeCertRequest(AcmeClientContext *context,\n   const char_t *cert, size_t certLen, AcmeReasonCode reason)\n{\n   error_t error;\n   error = NO_ERROR;\n   while(!error)\n   {\n      if(context->requestState == ACME_REQ_STATE_INIT)\n      {\n         TRACE_DEBUG(\"\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"## REVOKE CERTIFICATE #########################################################\\r\\n\");\n         TRACE_DEBUG(\"###############################################################################\\r\\n\");\n         TRACE_DEBUG(\"\\r\\n\");\n         context->requestState = ACME_REQ_STATE_FORMAT_BODY;\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_BODY)\n      {\n         error = acmeClientFormatRevokeCertRequest(context, cert, certLen, reason);\n         if(!error)\n         {\n            context->requestState = ACME_REQ_STATE_FORMAT_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_FORMAT_HEADER)\n      {\n         error = acmeClientFormatRequestHeader(context, \"POST\",\n            context->directory.revokeCert);\n         if(!error)\n         {\n            context->requestState = ACME_REQ_STATE_SEND_HEADER;\n         }\n      }\n      else if(context->requestState == ACME_REQ_STATE_SEND_HEADER ||\n         context->requestState == ACME_REQ_STATE_SEND_BODY ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_HEADER ||\n         context->requestState == ACME_REQ_STATE_PARSE_HEADER ||\n         context->requestState == ACME_REQ_STATE_RECEIVE_BODY ||\n         context->requestState == ACME_REQ_STATE_CLOSE_BODY)\n      {\n         error = acmeClientSendRequest(context);\n      }\n      else if(context->requestState == ACME_REQ_STATE_PARSE_BODY)\n      {\n         error = acmeClientParseRevokeCertResponse(context);\n         context->requestState = ACME_REQ_STATE_INIT;\n         break;\n      }\n      else\n      {\n         error = ERROR_WRONG_STATE;\n      }\n   }\n   return error;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__adc_sw_cntl.2.c", "original_string": "void adc_temp(void)\n{\n    int res,done = 1;\n    ADCR = (1<<1)|(4<<8)|(1<<21)|(1<<24); \n    while(!(ADDR & (done<<31)));\n    res = ADDR & (0x3FF<<6);   \n    res = res>>6;       \n}"}
{"author": "paawankohli", "file": "DSA-LAB__q23.0.c", "original_string": "void enqueueright(queue *q,char* n)\n{\n    if (q->rear == 20)\n        printf(\"Side Full\\n\");\n    else\n        q->c[(q->rear)++]=n;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG2A_B180575CS_GOKUL_07.1.c", "original_string": "void display(int arr2[], int n)\n{\n        int i;\n        for(i = 0; i<n; i++)\n        {\n                fprintf(F2, \"%d \", arr2[i]);\n        }\n}"}
{"author": "augustogunsch", "file": "jackc__vm-translator.9.c", "original_string": "char* switchsegment(VMTRANSLATOR* t) {\n    if(eq(t, 1, \"local\"))\n        return mkstr(t, \"@LCL\");\n    if(eq(t, 1, \"argument\"))\n        return mkstr(t, \"@ARG\");\n    if(eq(t, 1, \"this\"))\n        return mkstr(t, \"@THIS\");\n    return mkstr(t, \"@THAT\");\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Triangular_Matrix.2.c", "original_string": "void display_lower_triangular(int matrix[R][C])\n{\n    int i, j = 0;\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            if(i > j)\n                printf(\"%d\\t\", matrix[i][j]);\n            else\n                continue;\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__count_digit_string.1.c", "original_string": "int main()\n{\n    char arr[30] = {'\\0'};\n    int iRet = 0;\n    printf(\"Please enter string\\n\");\n    scanf(\"%[^'\\n']s\",arr);\n    iRet = DigitCount(arr);\n    printf(\"Number of digits are %d\\n\",iRet);\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__SRTF_Pr.0.c", "original_string": "void main()\n{\n    int n,i,j,sum=0,temp,init_temp,k=0,k1,min;\n    char s[10];\n    float Waiting_time;\n    printf(\"\\nEnter the number of processess : \");\n    scanf(\"%d\",&n);\n    struct process p[n];\n    for(i=0;i<n;i++)\n    {\n        printf(\"\\nEnter name : \");\n        scanf(\"%s\",p[i].name);\n        printf(\"\\nEnter AT : \");\n        scanf(\"%d\",&p[i].AT);\n        printf(\"\\nEnter BT : \");\n        scanf(\"%d\",&p[i].BT);\n        printf(\"\\nEnter priority : \");\n        scanf(\"%d\",&p[i].Pr);\n        p[i].status=0;\n        p[i].BT1=p[i].BT;\n        p[i].CT=0;\n    }\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            if(p[i].Pr>p[j].Pr)\n            {\n                temp=p[i].AT;\n                p[i].AT=p[j].AT;\n                p[j].AT=temp;\n                temp=p[i].BT;\n                p[i].BT=p[j].BT;\n                p[j].BT=temp;\n                temp=p[i].BT1;\n                p[i].BT1=p[j].BT1;\n                p[j].BT1=temp;\n                temp=p[i].Pr;\n                p[i].Pr=p[j].Pr;\n                p[j].Pr=temp;\n                strcpy(s,p[i].name);\n                strcpy(p[i].name,p[j].name);\n                strcpy(p[j].name,s);\n            }   \n        }\n    }\n    k=0;\n    temp=0;\n    while(k<n)\n    {\n        init_temp=temp;\n        for(i=0;i<n;i++)\n        {\n            if(p[i].AT<=temp && p[i].status==0)\n            {\n                p[i].BT1--;\n                temp++;\n                p[i].CT=temp;\n                break;\n            }\n        }\n        for(i=0;i<n;i++)\n        {\n            printf(\"\\nr\");\n            if(p[i].BT1==0 && p[i].status==0)\n            {\n                k=k+1;\n                p[i].status=k;\n            }\n        }\n        if(init_temp==temp)\n            temp++;\n    }\n    printf(\"\\nstatus : \");\n    for(i=0;i<n;i++)\n        printf(\"\\t%d\",p[i].status);\n    printf(\"\\nprocess\\tAT\\tBT\\tCT\\tTAT\\tWT\");\n    k1=1;\n    while(k1<=k)\n    {\n        for(i=0;i<n;i++)\n        {\n            if(p[i].status==k1)\n            {\n                p[i].TAT=p[i].CT-p[i].AT;\n                p[i].WT=p[i].TAT-p[i].BT;\n                sum=sum+p[i].WT;\n                printf(\"\\n%s\\t%d\\t%d\\t%d\\t%d\\t%d\",p[i].name,p[i].AT,p[i].BT,p[i].CT,p[i].TAT,p[i].WT);\n                k1++;\n            }\n        }\n    }\n    Waiting_time=(sum*1.0)/n;\n    printf(\"\\nAverage Waiting_time : %f\",Waiting_time);\n}"}
{"author": "sahadipanjan6", "file": "Programs-in-C__Perfect_Numbers_Within_Range.0.c", "original_string": "void main()\n{\n    int lower = 0;\n    int upper = 0;\n    int i = 0;\n    printf(\"\\nEnter lower bound: \");\n    scanf(\"%d\", &lower);\n    printf(\"\\nEnter upper bound: \");\n    scanf(\"%d\", &upper);\n    printf(\"\\nPerfect Numbers within %d and %d are as follows:- \\n\", lower, upper); \n    for(i=lower; i<=upper; i++)\n    {\n        if(isPerfect(i) == 1)\n            printf(\"%d\\t\", i);\n    }\n    printf(\"\\n\");\n}"}
{"author": "flora0110", "file": "hw01git__4108056041-hw1.3.c", "original_string": "int bfs(char *maze,int *d,int n)\n{\n    printf(\"haha\\n\");\n    int row,col,nr,nc,i,j;\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<n;j++)\n        {\n            d[i*n+j]=401;\n            if(maze[i*n+j]=='F')\n            {\n                d[i*n+j] = 0;\n            }\n        }\n    }\n    while(front!=rear){\n        printf(\"haha\\n\");\n        for(i=0;i<n;i++)\n        {\n            for(j=0;j<n;j++)\n            {\n                printf(\"%3d \", d[i*n+j]);\n            }\n            printf(\"\\n\");\n        }\n        printf(\"\\n\");\n        position = deleteq();\n        row=position.row;\n        col=position.col;\n        if(maze[row*n+col] == 'F')\n            return 1;\n        for(i=0;i<4;i++)\n        {\n            nr=row+move[i].vert;\n            nc=col+move[i].horiz;\n            if(maze[nr*n+nc] != 'X' && d[nr*n+nc] > d[row*n+col]+1)\n            {\n                d[nr*n+nc]=  d[row*n+col]+1;\n                position.row = nr;\n                position.col = nc;\n                addq(position);\n            }\n        }\n    }\n    return 0;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__22_no_prime_all_no.0.c", "original_string": "int main()\n{\n  int i,j,k,x,y,no,count=0;\n  printf(\"Enter the number, upto which you want to find out prime or not\");\n  scanf(\"%d\",&no);\n  for(j=1; j<=no; j++)\n  {\n      count = 0;\n      for(i=1; i<=j; i++)\n      {\n        if( j%i == 0)\n        {\n          count++;\n        }\n      }\n      if( count == 2)\n      {\n        printf(\"%d \\n\",j);\n      }\n  }\n}"}
{"author": "theuwis", "file": "project-euler__main2.0.c", "original_string": "int main(void){\n    int num1, num2, product, i, str_len, answer;\n    char numb_str[18];\n    bool palindromic = true;\n    for(num1 = 0; num1 < 1000; num1++){\n        for(num2 = 0; num2 < 1000; num2++){\n            product = num1 * num2;\n            sprintf(numb_str, \"%d\", product);\n            str_len = strlen(numb_str);\n            for(i = 0; i < str_len / 2; i++){\n                if(numb_str[i] != numb_str[str_len - 1 - i]){\n                    palindromic = false;\n                    break;\n                }\n            }\n            if(palindromic && product > answer){\n                answer = product;\n            }\n            palindromic = true;\n        }\n    }\n    printf(\"answer=%d\\n\", answer);\n    return EXIT_SUCCESS;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__brainfuck.1.c", "original_string": "void    brainfuck(char *src)\n{\n    char    *str;\n    int     pointer;\n    int     ctrl;\n    ctrl = 0;\n    pointer = 0;\n    str = (char*)malloc(sizeof(char) * 2048);\n    while (src[ctrl])\n    {\n        if (src[ctrl] == '>')\n            pointer++;\n        else if (src[ctrl] == '<')\n            pointer--;\n        else if (src[ctrl] == '+')\n            str[pointer]++;\n        else if (src[ctrl] == '-')\n            str[pointer]--;\n        else if ((src[ctrl] == '[' && !str[pointer]) || (src[ctrl] == ']' && str[pointer]))\n                ctrl = counter(src, ctrl);\n        else if (src[ctrl] == '.')\n            write(1, &str[pointer], 1);\n        ctrl++;\n    }\n}"}
{"author": "HakNinja", "file": "C-Advance__6time.0.c", "original_string": "int main()\n{\nprintf(\"____________________________________________________________________\\n\");\nprintf(\"\\nEnter Duration 1\");\nprintf(\"\\nin sec:\");\nscanf(\"%d\",&x.s);\nprintf(\"\\nin min:\");\nscanf(\"%d\",&x.m);\nprintf(\"\\nin hours:\");\nscanf(\"%d\",&x.h);\nprintf(\"\\nEnter Duration 2\");\nprintf(\"\\nin sec:\");\nscanf(\"%d\",&y.s);\nprintf(\"\\nin min:\");\nscanf(\"%d\",&y.m);\nprintf(\"\\nin hours:\");\nscanf(\"%d\",&y.h);\nz.h=x.h+y.h;\nz.m=x.m+y.m;\nz.s=x.s+y.s;\nif(z.s>=60)\n{z.s=z.s-60;\nz.m=z.m+1;\n}\nif(z.m>=60)\n{z.m=z.m-60;\nz.h=z.h+1;\n}\nprintf(\"Final Value of time:\");\nprintf(\"in hours:%d\",z.h);\nprintf(\"in min:%d\",z.m);\nprintf(\"in sec:%d\",z.s);\nreturn 0;\n}"}
{"author": "kalpa96", "file": "Struct__final.0.c", "original_string": "int main(){\n    int flag =0;\n    while(flag != 1){\n        flag = 1;\n        printf(\"Year : \");\n        scanf(\"%d\",&d.year);\n        printf(\"Month : \");\n        scanf(\"%d\",&d.month);\n        printf(\"Day : \");\n        scanf(\"%d\",&d.day);\n        if(d.month >12 || d.month<=0 ){\n            printf(\"Invalide Month...\\n\");\n            if(d.day >30 || d.day<=0 ){\n            printf(\"Invalide Date...\\n\");\n            flag =0;\n            }\n        }else{\n            if(d.day >30 || d.day<=0 ){\n            printf(\"Invalide Date...\\n\");\n            flag =0;\n            }\n        }\n    }\n    d.day = d.day + 45;\n    if(d.day>30 && d.day<60){\n        d.day = d.day - 30;\n        d.month = d.month + 1;\n        if(d.month>12){\n            d.month = d.month-12;\n            d.year = d.year + 1;\n        }\n    }\n    else if(d.day>60){\n        d.day = d.day - 60;\n        d.month = d.month + 2;\n        if(d.month>12){\n            d.month = d.month-12;\n            d.year = d.year + 1;\n        }\n    }\n    printf(\"\\nAdd 45 days...\\n\");\n    printf(\"\\nUpdated date is : %d %d %d\", d.year, d.month, d.day);\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-structure.11.c", "original_string": "PARAMETER* parseparameters(PARSER* p) {\n    PARAMETER* head = parseparameter(p);\n    PARAMETER* curr = head;\n    PARAMETER* nextp;\n    while(equals(p, \",\")) {\n        next(p);\n        nextp = parseparameter(p);\n        if(nextp == NULL)\n            unexpected(p);\n        curr->next = nextp;\n        curr = curr->next;\n    }\n    if(curr != NULL)\n        curr->next = NULL;\n    return head;\n}"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal_cortex.8.c", "original_string": "void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)\n{\n  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));\n  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));\n  MPU->RNR = MPU_Init->Number;\n  if ((MPU_Init->Enable) != RESET)\n  {\n    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));\n    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));\n    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));\n    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));\n    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));\n    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));\n    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));\n    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));\n    MPU->RBAR = MPU_Init->BaseAddress;\n    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |\n                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |\n                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |\n                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |\n                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |\n                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |\n                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |\n                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |\n                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);\n  }\n  else\n  {\n    MPU->RBAR = 0x00U;\n    MPU->RASR = 0x00U;\n  }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q30.0.c", "original_string": "void multiply(int **arr1, int **arr2, int m, int n, int p, int q, int **product)\n{\n    int sum = 0;\n    for(int c = 0 ; c < m ; c++)\n        for(int d  = 0 ; d < q; d++)\n        {\n            for(int k = 0 ; k < p ; k++)\n                sum += arr1[c][k] * arr2[k][d];\n            product[c][d] = sum;\n            sum = 0;\n        }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__string_copy.0.c", "original_string": "void StrcpyX(char Src[], char Dest[])\n{\n    int i = 0;\n    if( (Src == NULL) ||(Dest == NULL))\n    {\n        return;\n    }\n    while(Src[i] != '\\0')\n    {\n        Dest[i] = Src[i];\n        i++;\n    }\n    Dest[i] = '\\0';\n}"}
{"author": "2security", "file": "Array__Orthogonal.0.c", "original_string": "int main()\n    {\n    int i,j,r,c,**mat1,**mat2,**temp;\n    printf(\"Enter the row & col. for the matrix\");\n    scanf(\"%d%d\",&r,&c);\n    mat1=(int **)malloc(r*sizeof(int *));   \n    mat2=(int **)malloc(r*sizeof(int *));   \n    temp=(int **)malloc(r*sizeof(int *));                                       \n    for(i=0;i<r;i++)\n        mat1[i]=(int *)malloc(c*sizeof(int ));\n    for(i=0;i<r;i++)\n        mat2[i]=(int *)malloc(c*sizeof(int ));\n    for(i=0;i<r;i++)\n        temp[i]=(int *)malloc(c*sizeof(int ));\n    printf(\"\\n Enter the matrix \\n\");\n    for(i=0;i<r;i++)\n    for(j=0;j<c;j++)                \n    scanf(\"%d\",&mat1[i][j]);\n    Transpose(mat1,mat2,r,c);\n    MultiMat(mat1,mat2,temp,r,c,c);\n    if(IsIdentity(temp,r,c))\n        printf(\"\\nOrthogonal matrix\");\n    else\n        printf(\"Matrix is not orthogonal matrix\");\n    return 0;\n    }"}
{"author": "paawankohli", "file": "DSA-LAB__q4.1.c", "original_string": "void inorder(node *t)\n{\n    if (t == NULL)\n        return;\n    inorder(t->left);\n    printf(\"%d \", t->data);\n    inorder(t->right);\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__Odd_Even_Sort.0.c", "original_string": "void main()\n{\n    int i = 0;\n    int size = 0;\n    printf(\"\\nEnter number of elements: \\n\");\n    scanf(\"%d\", &size);\n    int input_array[size];\n    printf(\"\\nEnter the array elements...\\n\");\n    for(i=0; i<size; i++)\n        scanf(\"%d\", &input_array[i]);\n    printf(\"\\nOriginal Array is as follows:- \\n\");\n    display(input_array, size);\n    odd_even_sort(input_array, size);\n    printf(\"\\nAfter Odd-Even Sorting:- \\n\");\n    display(input_array, size);\n    printf(\"\\n\");\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSL__tls_ffdhe.2.c", "original_string": "error_t tlsLoadFfdheParameters(DhParameters *params,\n   const TlsFfdheGroup *ffdheGroup)\n{\n   error_t error;\n   if(ffdheGroup != NULL)\n   {\n      error = mpiImport(&params->p, ffdheGroup->p, ffdheGroup->pLen,\n         MPI_FORMAT_BIG_ENDIAN);\n      if(!error)\n      {\n         error = mpiSetValue(&params->g, ffdheGroup->g);\n      }\n   }\n   else\n   {\n      error = ERROR_FAILURE;\n   }\n   return error;\n}"}
{"author": "2security", "file": "Matrix__25ScalarMultiplication.2.c", "original_string": "int main()\n    {\n    int i,j,r,c,mat1[20][20],s;\n    printf(\"\\n Enter the row & col. for two matrix(Both should be same): \");\n    scanf(\"%d%d\",&r,&c);\n    if(r!=c)\n        printf(\"\\n For Addition matrix should be square\");\n    else\n        {       \n        printf(\"\\n Enter the first matrix \\n\");\n        for(i=0;i<r;i++)\n        for(j=0;j<c;j++)                \n        scanf(\"%d\",&mat1[i][j]);\n        printf(\"\\n Enter the scalar to be multiplied: \");\n        scanf(\"%d\",&s);\n        printf(\"\\n The addtion of two matrix is:\\n\");\n        ScalarProduct(mat1,r,c,s);\n        }\n    return 0;\n    }"}
{"author": "revathy16296", "file": "rtos_lab_asssignment_1__6_dates.1.c", "original_string": "void comp_dat(date d1,date d2)\n{\n    if((d1.year==d2.year)&&(d1.month==d2.month)&&(d1.day==d2.day))\n    {printf(\"\\nBoth the dates are same\");}\n    else if(d1.year>d2.year||(d1.year==d2.year&&d1.month>d2.month)||(d1.year==d2.year&&d1.month==d2.month&&d1.day>d2.day))\n    {printf(\"\\nThe latest date is %d-%d-%d\",d1.day,d1.month,d1.year);}\n    else\n        {printf(\"\\nThe latest date is %d-%d-%d\",d2.day,d2.month,d2.year);}\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes2.2.c", "original_string": "void agregar_alumno(){\n    if(siguiente_alumno == MAX_ALUMNOS){\n        printf(\"No se puede agregar nuevo alumno, espacio insuficiente...\");\n        puts(\"Presiona cualquier tecla para continuar...\");\n        fflush(stdin);\n        getchar();\n    } else {\n        estudiante nuevo_alumno;\n        printf(\"Ingresa la matr\u00edcula:\");\n        scanf(\"%d\", &nuevo_alumno.matricula);\n        fflush(stdin);\n        printf(\"Ingresa el nombre del alumno:\");\n        fgets(nuevo_alumno.nombre, 60, stdin);\n        nuevo_alumno.calificaciones[0] = 0.0;\n        nuevo_alumno.calificaciones[1] = 0.0;\n        nuevo_alumno.calificaciones[2] = 0.0;\n        nuevo_alumno.calificaciones[3] = 0.0;\n        puts(\"Datos almacenado correctamente...\");\n        puts(\"Presiona cualquier tecla para continuar...\");\n        fflush(stdin);\n        getchar();\n        lista_estudiantes[siguiente_alumno] = nuevo_alumno;\n        siguiente_alumno++;\n    } \n}"}
{"author": "haon1026", "file": "linux-programming__client.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    int clnt_sock = Socket(AF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9999);\n    inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr.s_addr);\n    Connect(clnt_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n    int ret;\n    int counter = 10;\n    char buf[BUFSIZ];\n    while(counter--)\n    {\n        Write(clnt_sock, \"hello\\n\", 6);\n        ret = Read(clnt_sock, buf, sizeof(buf));\n        if(ret == 0)\n        {\n            break;\n        }\n        Write(STDOUT_FILENO, buf, ret);\n        sleep(1);\n    }\n    Close(clnt_sock);\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q31.0.c", "original_string": "void push1(stack *s)\n{\n    if(s->tos2 - s->tos1 == 1)\n        printf(\"Array Full\");\n    else\n    {\n        printf(\"Push: \");\n        int ele;\n        scanf(\"%d\", &ele);\n        s->a[++(s->tos1)] = ele;\n    }\n}"}
{"author": "tadeograch", "file": "sorting_algorithms__105-radix_sort.1.c", "original_string": "void arr_cpy(int *array1, int *array2, int size)\n{\n    int i;\n    for(i = 0; i < size; i++)\n    {\n        array2[i] = array1[i];\n    }\n}"}
{"author": "ankitraj311", "file": "450_babbar__6_union_array_Geek_sorted_array.1.c", "original_string": "void union_array(int arr1[], int arr2[], int size_arr1, int size_arr2)\n{\n  int i = 0, j = 0;\n  while(i<size_arr1 && j<size_arr2)\n  {\n    if(arr1[i] < arr2[j])\n    { \n      printf(\"%d \",arr1[i++]); \n    }\n    if(arr1[i] > arr2[j])\n    {\n      printf(\"%d \",arr2[j++]); \n    }\n    if(arr1[i] == arr2[j])\n    {\n      printf(\"%d \",arr2[j++]); \n      i++;\n    }\n  }\n  while(i<size_arr1)\n    printf(\"%d \",arr1[i++]);\n  while(j<size_arr2)\n    printf(\"%d \",arr2[j++]);\n}"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal.22.c", "original_string": "void HAL_GetUID(uint32_t *UID)\n{\n  UID[0] = (uint32_t)(READ_REG(*((uint32_t *)UID_BASE)));\n  UID[1] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 4U))));\n  UID[2] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 8U))));\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.0.c", "original_string": "int main(){\n    int opcion;\n    while (1) {\n        imprimir_menu();\n        scanf(\"%d\", &opcion);\n        switch (opcion) {\n            case 1: agregar_alumno();\n                break;\n            case 2: modificar_alumno();\n                break;\n             case 3: menu_modificacion_calificaciones();\n                 break;\n            case 4: imprimir_alumno();\n                 break;\n            case 5: imprimir_alumnos_en_tabla();\n                break;\n            case 6: pase_asistencia();\n                 break;\n            case 7:\n                return 0;\n                break;\n            default:\n                break;\n        }\n    }\n    return 0;\n}"}
{"author": "2security", "file": "Pointer__8Search.0.c", "original_string": "void Display(int *a,int n)\n    {\n        int i;\n        for(i=0;i<n;i++)\n            printf(\"%d \",*(a+i));\n    }"}
{"author": "sdukesameer", "file": "dsa__bst-del_int-iter_in-pre.2.c", "original_string": "int search(node* root, int key)\n{\n    if (root==NULL)\n        return 0;\n    else\n    {\n        if (key<root->data)\n            search(root->left,key);\n        else if(key>root->data)\n            search(root->right,key);\n        else\n            return 1;\n    }\n}"}
{"author": "sahadipanjan6", "file": "Programs-in-C__P4.1.c", "original_string": "int isPalindrome(int number)\n{\n    int copy=number;\n    int sum=0;\n    while(copy != 0)\n    {\n        sum = sum*10 + (copy%10);\n        copy /= 10;\n    }\n    if(sum == number)\n        return 1;\n    else\n        return 0;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__print_memory.1.c", "original_string": "void    print_char(unsigned char c)\n{\n    if (c >= ' ' && c <= '~')\n        write(1, &c, 1);\n    else\n        write(1, \".\", 1);\n}"}
{"author": "theuwis", "file": "project-euler__main9.0.c", "original_string": "int main(void){\n    int answer = 0, i, j;\n    int product = 1;\n    int input[20][20] = {\n        { 8,  2, 22, 97, 38, 15,  0, 40,  0, 75,  4,  5,  7, 78, 52, 12, 50, 77, 91,  8},\n        {49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48,  4, 56, 62,  0},\n        {81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30,  3, 49, 13, 36, 65},\n        {52, 70, 95, 23,  4, 60, 11, 42, 69, 24, 68, 56,  1, 32, 56, 71, 37,  2, 36, 91},\n        {22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80},\n        {24, 47, 32, 60, 99, 03, 45,  2, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50},\n        {32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70},\n        {67, 26, 20, 68,  2, 62, 12, 20, 95, 63, 94, 39, 63,  8, 40, 91, 66, 49, 94, 21},\n        {24, 55, 58,  5, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72},\n        {21, 36, 23,  9, 75,  0, 76, 44, 20, 45, 35, 14,  0, 61, 33, 97, 34, 31, 33, 95},\n        {78, 17, 53, 28, 22, 75, 31, 67, 15, 94,  3, 80,  4, 62, 16, 14,  9, 53, 56, 92},\n        {16, 39,  5, 42, 96, 35, 31, 47, 55, 58, 88, 24,  0, 17, 54, 24, 36, 29, 85, 57},\n        {86, 56,  0, 48, 35, 71, 89,  7,  5, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58},\n        {19, 80, 81, 68,  5, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77,  4, 89, 55, 40},\n        { 4, 52,  8, 83, 97, 35, 99, 16,  7, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66},\n        {88, 36, 68, 87, 57, 62, 20, 72,  3, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69},\n        { 4, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18,  8, 46, 29, 32, 40, 62, 76, 36},\n        {20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74,  4, 36, 16},\n        {20, 73, 35, 29, 78, 31, 90,  1, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57,  5, 54},\n        { 1, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52,  1, 89, 19, 67, 48}\n    };\n    for(i = 0; i < 20; i++){\n        for(j = 0; j < 17; j++){\n            product = input[i][j] * input[i][j + 1] * input[i][j + 2] * input[i][j + 3];\n            if(product > answer) answer = product;\n        }\n    }\n    for(i = 0; i < 17; i++){\n        for(j = 0; j < 20; j++){\n            product = input[i][j] * input[i + 1][j] * input[i + 2][j] * input[i + 3][j];\n            if(product > answer) answer = product;\n        }\n    }\n    for(i = 0; i < 17; i++){\n        for(j = 0; j < 17; j++){\n            product = input[i][j] * input[i + 1][j + 1] * input[i + 2][j + 2] * input[i + 3][j + 3];\n            if(product > answer) answer = product;  \n        }\n    }\n    for(i = 0; i < 17; i++){\n        for(j = 0; j < 17; j++){\n            product = input[i][j + 3] * input[i + 1][j + 2] * input[i + 2][j + 1] * input[i + 3][j];\n            if(product > answer) answer = product;  \n        }\n    }\n    printf(\"answer=%d\\n\", answer);\n    return EXIT_SUCCESS;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q3_merge.3.c", "original_string": "void display(nodeptr a){\n    nodeptr t=a;\n    printf(\"\\n\");\n    for(a=a->link;a!=t;a=a->link){\n        printf(\"\\t%d\",a->data);\n    }\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q3.7.c", "original_string": "int isOperator(char c)\n{\n    if (c == '+' || c == '-' || c == '*' || c == '/' || c == '^')\n        return 1;\n    else\n        return 0;\n}"}
{"author": "haon1026", "file": "linux-programming__2client.1.c", "original_string": "int main(int argc, char *argv[])\n{\n    int clnt_sock = socket(AF_INET, SOCK_STREAM, 0);\n    if(clnt_sock == -1)\n    {\n        sys_err(\"socket() error\");\n    }\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9999);\n    inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr.s_addr);\n    int ret = connect(clnt_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n    if(ret != 0)\n    {\n        sys_err(\"connect() error\");\n    }\n    int counter = 10;\n    char buf[BUFSIZ];\n    while(counter--)\n    {\n        write(clnt_sock, \"hello\\n\", 6);\n        ret = read(clnt_sock, buf, sizeof(buf));\n        write(STDOUT_FILENO, buf, ret);\n        sleep(1);\n    }\n    close(clnt_sock);\n    return 0;\n}"}
{"author": "DanielSalis", "file": "AED1__teste5.3.c", "original_string": "int existeNaListaII(TipoLista *l, char nome)\n{\n  int contador = l->tamanho;\n  if(contador == 0)\n    return 2;\n  TipoElemento *p = l->primeiro;\n  while(contador != 0)\n  {\n    if(p->nome == nome)\n      return 1;\n    p = p->prox;\n    contador--;\n  }\n  return 3;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSL__tls_ticket.4.c", "original_string": "void tlsCheckTicketKeyLifetime(TlsTicketEncryptionState *state)\n{\n   systime_t time;\n   time = osGetSystemTime();\n   if(state->valid)\n   {\n      if((time - state->timestamp) >= (2 * TLS_TICKET_LIFETIME))\n      {\n         osMemset(state, 0, sizeof(TlsTicketEncryptionState));\n      }\n   }\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__14_.1.c", "original_string": "void Columnas(int contador, int pibote){\n    if(contador <= 13){\n        if(contador >= (1 + pibote) && contador <= (13 - pibote))\n                        printf(\"P\");\n                else\n                        printf(\" \");\n                Columnas(++contador, pibote);\n        }\n}"}
{"author": "254Odeke", "file": "Operating-Systems_Lab__Virtual_to_Physical_Address_Conversion_Simulation.0.c", "original_string": "void info(){\n    printf(\"Enter the Size of Physical memory: \");\n    scanf(\"%d\",&pmsize);\n    printf(\"Enter the size of Logical memory: \");\n    scanf(\"%d\",&lmsize);\n    printf(\"Enter the partition size: \");\n    scanf(\"%d\",&psize);\n    no_of_frames=pmsize/psize;\n    no_of_pages=lmsize/psize;\n    printf(\"The physical memory is divided into %d no.of frames\\n\",no_of_frames);\n    printf(\"The Logical memory is divided into %d no.of pages\\n\",no_of_pages);\n}"}
{"author": "Dhruvik-Chevli", "file": "PPLab__p1.0.c", "original_string": "int main(int argc,char* argv[]){\n    int rank,size;\n    char st[10];\n    char res[10];\n    MPI_Init(&argc,&argv);\n    MPI_Comm_rank(MPI_COMM_WORLD,&rank);\n    MPI_Comm_size(MPI_COMM_WORLD,&size);\n    if(size!=2){\n        printf(\"\\nUse 2 processes\\n\");\n        MPI_Abort(MPI_COMM_WORLD,EXIT_FAILURE);\n    }\n    if(rank==0){\n        printf(\"Enter string to toggle\\n\");\n        gets(st);\n        printf(\"\\nProcess[%d]: Sending string %s\\n\",rank,st);\n        MPI_Ssend(st,9,MPI_CHAR,1,0,MPI_COMM_WORLD);\n        MPI_Recv(res,9,MPI_CHAR,1,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);\n        printf(\"\\nProcess[%d]: Received string %s\\n\",rank,res);\n    }else{\n        MPI_Recv(st,9,MPI_CHAR,0,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);\n        printf(\"\\nProcess[%d]: Received string %s\\n\",rank,st);\n    for(int i=0;i<strlen(st);i++){\n        if(st[i]>='a'&&st[i]<='z') st[i]-=32;\n        else if(st[i]>='A'&&st[i]<='Z') st[i]+=32;\n    }\n    printf(\"\\nProcess[%d]: Sending string %s\\n\",rank,st);\n        MPI_Ssend(st,9,MPI_CHAR,0,0,MPI_COMM_WORLD);\n    }\n    MPI_Finalize();\n    return 0;\n}"}
{"author": "haon1026", "file": "linux-programming__4client_afterwrap.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    int clnt_sock = Socket(AF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(9999);\n    inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr.s_addr);\n    Connect(clnt_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n    int ret;\n    int counter = 10;\n    char buf[BUFSIZ];\n    while(counter--)\n    {\n        Write(clnt_sock, \"hello\\n\", 6);\n        ret = Read(clnt_sock, buf, sizeof(buf));\n        if(ret == 0)\n        {\n            break;\n        }\n        Write(STDOUT_FILENO, buf, ret);\n        sleep(1);\n    }\n    Close(clnt_sock);\n    return 0;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__HeapSort.0.c", "original_string": "void RestoreHeapUp(int HEAP[],int index)\n{\n    int val=HEAP[index];\n    while(index>1 && (HEAP[index/2]<val))\n    {\n        HEAP[index]=HEAP[index/2];\n        index=index/2;\n    }\n    HEAP[index]=val;\n}"}
{"author": "sdukesameer", "file": "c__mult_mat.2.c", "original_string": "void multMat(int r1,int c1,int mat1[][NCOLS],int r2,int c2,int mat2[][NCOLS],int sum[][NCOLS])\n{\n    if(c1!=r2)\n    {\n        printf(\"ERROR: Number of columns in 1st matrix must equal number of rows in 2nd Matrix\");\n        exit(1);\n    }\n    else\n    {\n    for(int i=0;i<r1;i++)\n    {\n        for(int j=0;j<c2;j++)\n        {\n            sum[i][j]=0;\n        }\n    }\n    for(int i=0;i<r1;i++)\n    {\n        for(int j=0;j<c2;j++)\n        {\n            for(int k=0;k<c1;k++)\n            {\n                sum[i][j]+=mat1[i][k]*mat2[k][j];\n            }\n        }\n    }\n    }\n}"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__map_manager.2.c", "original_string": "char        **map_manager(void)\n{\n    char    **map_array;\n    int     i;\n    int     j;\n    j = 0;\n    i = 0;\n    map_array = (char**)malloc((g_map_height + 3) * sizeof(char*));\n    while (i < g_map_height + 2)\n    {\n        map_array[i] = (char*)malloc((g_map_width + 3) * sizeof(char));\n        i++;\n    }\n    map_array[i] = NULL;\n    surrend_by_spaces(map_array);\n    fill_map(map_array);\n    map_errors(map_array);\n    if (g_player.x == -1 || g_player.y == -1)\n    {\n        ft_putstr(\"Error:\\nPlayer or map missing\\n\");\n        exit(0);\n    }\n    return (map_array);\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-structure.5.c", "original_string": "CLASSVARDEC* parseclassvardec(PARSER* p) {\n    CLASSVARTYPE classvartype = parseclassvartype(p);\n    if(classvartype == -1)\n        return NULL;\n    next(p);\n    CLASSVARDEC* classvardec = (CLASSVARDEC*)malloc(sizeof(CLASSVARDEC));\n    classvardec->type = classvartype;\n    classvardec->base = (VARDEC*)malloc(sizeof(VARDEC));\n    parsevardeccommon(p, classvardec->base);\n    return classvardec;\n}"}
{"author": "sahadipanjan6", "file": "Data-Structure-Algorithms-DAA-__MatrixOperations.3.c", "original_string": "void multiply_matrices(int m1[R][C], int m2[R][C])\n{\n    int i, j, k = 0;\n    int sum = 0;\n    int output[R][C];\n    for(i=0; i<R; i++)\n    {\n        for(j=0; j<C; j++)\n        {\n            for(k=0; k<R; k++)\n            {\n                sum += m1[i][k] * m2[k][j];\n            }\n            output[i][j] = sum;\n            sum = 0;\n        }\n    }\n    printf(\"\\nResultant Matrix after MULTIPLICATION:- \\n\");\n    display_matrix(output);\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__RandomizedQuickSort.5.c", "original_string": "void quick_sort(int a[50],int p,int r)\n{   \n    int q;\n    count++;\n    if(p<r)\n    {\n        count++;\n        q=partition(a,p,r);\n        count++;\n        quick_sort(a,p,q-1);\n        count++;\n        quick_sort(a,q+1,r);\n        count++;\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__DemoFOTAUpdateWorkflow0.5.c", "original_string": "static bool DemoFOTAUpdateWorkflowEngine__execute(DemoFOTAUpdateWorkflowEngine__data_t *instance, DemoFOTAUpdateWorkflowEngine__inevents_t event, void **arguments)\n{\n  switch (instance->__currentState)\n  {\n    case DemoFOTAUpdateWorkflowEngine_idle__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) >= CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          printf(\"Cannot handle firmware over-the-air update request (missing network connection)\\n\");\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_connected__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_connectionStatusChanged__event:\n        {\n          if ((*((ConnectionStatus_t *)((arguments[0])))) < CONNECTION_STATUS_CONNECTIVITY_AVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n          }\n          break;\n        }\n        case DemoFOTAUpdateWorkflowEngine_updateVersionChanged__event:\n        {\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) != 0) \n          {\n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_downloading__state;\n            instance->updateInfo.version = (*((char **)((arguments[0]))));\n            if (!fotahub_downloadFirmwareUpdate(&instance->updateInfo)) \n            {\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_connected__state) \n            {\n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if (strcmp((*((char **)((arguments[0])))), DEMO_PRODUCT_FIRMWARE_VERSION) == 0) \n          {\n            printf(\"Ignoring firmware over-the-air update request to version %s as this version is already running\\n\", (*((char **)((arguments[0])))));\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_downloading__state:\n    {\n      switch (event)\n      {\n        case DemoFOTAUpdateWorkflowEngine_updateStatusChanged__event:\n        {\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED) \n          {\n            bool __transitionResult = true;\n            DemoFOTAUpdateWorkflowEngine__states_t __targetState = DemoFOTAUpdateWorkflowEngine_restarting__state;\n            if (!fotahub_activateFirmwareUpdate(&instance->updateInfo)) \n            {\n              __targetState = DemoFOTAUpdateWorkflowEngine_connected__state;\n              __transitionResult = false;\n            }\n            if (instance->__currentState == DemoFOTAUpdateWorkflowEngine_downloading__state) \n            {\n              instance->__currentState = __targetState;\n              switch (__targetState)\n              {\n                case DemoFOTAUpdateWorkflowEngine_restarting__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_restarting_EntryAction(instance);\n                  break;\n                }\n                case DemoFOTAUpdateWorkflowEngine_connected__state:\n                {\n                  DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            }\n            if (!__transitionResult) \n            {\n              return false;\n            }\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) == FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_idle__state;\n            break;\n          }\n          if ((*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_DOWNLOAD_SUCCEEDED || (*((FOTAUpdateStatus_t *)((arguments[0])))) != FOTA_UPDATE_STATUS_CONNECTIVITY_UNAVAILABLE) \n          {\n            instance->__currentState = DemoFOTAUpdateWorkflowEngine_connected__state;\n            DemoFOTAUpdateWorkflowEngine_connected_EntryAction(instance);\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    case DemoFOTAUpdateWorkflowEngine_restarting__state:\n    {\n      switch (event)\n      {\n        default: {\n          break;\n        }\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return true;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__packet_error_rate.1.c", "original_string": "void timer_2_init()\n{\n        NRF_TIMER_RX_CRCOK->TASKS_CLEAR = 1;\n        NRF_TIMER_RX_CRCOK->BITMODE = TIMER_BITMODE_BITMODE_32Bit << TIMER_BITMODE_BITMODE_Pos;\n        NRF_TIMER_RX_CRCOK->PRESCALER = 4;\n        NRF_TIMER_RX_CRCOK->SHORTS = TIMER_SHORTS_COMPARE0_CLEAR_Msk << TIMER_SHORTS_COMPARE0_CLEAR_Pos;\n        NRF_TIMER_RX_CRCOK->MODE = TIMER_MODE_MODE_LowPowerCounter << TIMER_MODE_MODE_Pos;\n        NRF_TIMER_RX_CRCOK->CC[TIMER_RELOAD_CC_NUM] = TIMER_RELOAD;\n        NRF_TIMER_RX_CRCOK->TASKS_START = 1;\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-linux__DemoFOTAUpdateWorkflowFilePersistence.0.c", "original_string": "void saveState(int16_t state)\n{\n  FILE *file = fopen(DEMO_PRODUCT_UPDATE_STATE_FILE_NAME, \"wb\");\n  if (file == NULL) \n  {\n    printf(\"Failed to open %s for writing\\n\", DEMO_PRODUCT_UPDATE_STATE_FILE_NAME);\n    return;\n  }\n  if (fwrite(&state, sizeof(state), 1, file) != 1) \n  {\n    printf(\"Failed to write statemachine state %hi to %s\\n\", state, DEMO_PRODUCT_UPDATE_STATE_FILE_NAME);\n    fclose(file);\n    return;\n  }\n  fclose(file);\n}"}
{"author": "ankitraj311", "file": "450_babbar__13_kadanes_algorithms.1.c", "original_string": "int cyclic_rotate(int arr1[], int size_arr1)\n{\n  int meh = 0, msf = 0; \n  for(int i = 0; i<size_arr1;i++)\n  {\n    meh = meh + arr1[i]; \n    if(msf<meh) \n    {\n      msf = meh;\n    }\n    if(meh<0) \n    { \n      meh = 0;\n    }\n  }\n  return meh;  \n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_any_pos_DLL.1.c", "original_string": "void creat()\n{\nstruct node *newnode,*temp;\nint choice;\n    while(choice)\n    {\n        newnode=(struct node *)malloc(sizeof(struct node));\n            printf(\"enter the data =\");\n            scanf(\"%d\",&newnode->data);\n            newnode->pre=0;\n            newnode->next=0;\n        if(head==0)\n        {\n            head=temp=newnode;\n        }\n        else\n        {\n            temp->next=newnode;\n            newnode->pre=temp;\n            temp=newnode;\n        }\n        printf(\"do you need to continue(0,1)?\\n enter 0 to stop  enter 1 to continue = \");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_chibios.13.c", "original_string": "bool_t osWaitForEvent(OsEvent *event, systime_t timeout)\n{\n   msg_t msg;\n   if(timeout == 0)\n   {\n      msg = chBSemWaitTimeout(event, TIME_IMMEDIATE);\n   }\n   else if(timeout == INFINITE_DELAY)\n   {\n      msg = chBSemWaitTimeout(event, TIME_INFINITE);\n   }\n   else\n   {\n      msg = chBSemWaitTimeout(event, OS_MS_TO_SYSTICKS(timeout));\n   }\n   if(msg == MSG_OK)\n      return TRUE;\n   else\n      return FALSE;\n}"}
{"author": "ankitraj311", "file": "450_babbar__13_kadanes_algorithms.0.c", "original_string": "void array_print(int arr[], int no)  \n{\n  for(int i = 0; i<no; i++)\n  {\n    printf(\"%d \",arr[i]);\n  }\n  printf(\"\\n\");\n}"}
{"author": "shengelenge", "file": "wp-lab3__zad10.0.c", "original_string": "int main()\n{\n    long double min, max, kolejna, suma = 0, srednia;\n    printf(\"Podaj liczby rzeczywsite, po wpisaniu 0 program zakonczy wczytywanie.\\nLiczby:\\n\");\n    scanf(\"%Lf\", &kolejna);\n    suma += kolejna;\n    if (kolejna != 0)\n    {\n        int i = 1;\n        min = kolejna;\n        max = kolejna;\n        scanf(\"%Lf\", &kolejna);\n        suma += kolejna;\n        srednia = suma / i++;\n        while (kolejna)\n        {\n            if (kolejna > max)\n                max = kolejna;\n            else {\n                if (kolejna < min)\n                    min = kolejna;\n            }\n            scanf(\"%Lf\", &kolejna);\n            suma += kolejna;\n            srednia = suma / i++;\n        }\n        printf(\"min = %.2Lf, max = %.2Lf\\n\", min, max);\n        printf(\"suma = %.2Lf, \", suma);\n        printf(\"srednia = %.2Lf, \", srednia);\n    }\n    else\n        printf(\"Ciag wejsciowy jest pusty.\\n\");\n    return 0;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__insert_a_node_in_circular_linked_list.0.c", "original_string": "int main()\n{\n    int n, data, choice=1;\n    head = NULL;\n                printf(\"Enter the total number of nodes in list: \");\n                scanf(\"%d\", &n);\n                createList(n);\n                displayList();\n                printf(\"Enter node position: \");\n                scanf(\"%d\", &n);\n                printf(\"Enter data you want to insert at %d position: \", n);\n                scanf(\"%d\", &data);\n                insertAtN(data, n);\n                displayList();\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__scp_server.4.c", "original_string": "error_t scpServerSetRootDir(ScpServerSession *session, const char_t *rootDir)\n{\n   ScpServerContext *context;\n   if(session == NULL || rootDir == NULL)\n      return ERROR_INVALID_PARAMETER;\n   context = session->context;\n   pathCopy(session->rootDir, context->rootDir, SCP_SERVER_MAX_ROOT_DIR_LEN);\n   pathCombine(session->rootDir, rootDir, SCP_SERVER_MAX_ROOT_DIR_LEN);\n   pathCanonicalize(session->rootDir);\n   pathRemoveSlash(session->rootDir);\n   pathCopy(session->homeDir, session->rootDir, SCP_SERVER_MAX_HOME_DIR_LEN);\n   return NO_ERROR;\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__sender_mian0.1.c", "original_string": "int main(){\n    unsigned int length;\n    welcome();\n    length = frame_construction(frame,sta_addr,des_addr,protocol,data,sizeof(data));\n    frame[length-10] = ~frame[length-10];    \n    send_frame(frame,length);\n    return 0;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_29.1.c", "original_string": "void imprimirResultados() {\n    printf(\"Soma total numeros pares digitados: %d\\n\\n\", quantidadeTotalPar);\n    printf(\"Valores pares digitados: \\n\");\n    for (int i = 0; i < 6; i++) {\n        if (pares[i] > 0) {\n            printf(\"%d\\n\", pares[i]);\n        }\n    }\n    printf(\"Soma total numeros impares digitados: %d\\n\\n\", quantidadeTotalImpar);\n    printf(\"Valores impares digitados: \\n\");\n    for (int i = 0; i < 6; i++) {\n        if (impares[i] > 0) {\n            printf(\"%d\\n\", impares[i]);\n        }\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__delete_at_end_DCLL.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.delete the element at the last position in the linked list\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4: printf(\"delete the element at the last position in the linked list\\n\");\n            delete_end();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__list-del-rev.3.c", "original_string": "node* rec_reverse(node* head)\n{\n    if(head == NULL || head->next == NULL)\n        return head;\n    node* revHead = rec_reverse(head->next);\n    head->next->next = head;\n    head->next = NULL; \n    return revHead;\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__matrixSum.0.c", "original_string": "int main()\n{\n    int m1[BOYUT][BOYUT];\n    int m2[BOYUT][BOYUT];\n    int toplam[BOYUT][BOYUT];\n    int i,j;\n    for(i=0;i<BOYUT;i++)\n        for(j=0;j<BOYUT;j++)\n        {\n            printf(\"%s\",\"de\u011fer giriniz:\\n\");\n            scanf(\"%d\",&m1[i][j]);\n        }\n    for(i=0;i<BOYUT;i++)\n        for(j=0;j<BOYUT;j++)\n        {\n            printf(\"%s\",\"de\u011fer giriniz:\\n\");\n            scanf(\"%d\",&m2[i][j]);\n        }\n    for(i=0;i<BOYUT;i++)\n        for(j=0;j<BOYUT;j++)\n            toplam[i][j]=m1[i][j] + m2[i][j];\n    for(i=0;i<BOYUT;i++)\n        for(j=0;j<BOYUT;j++)\n            printf(\"toplam[%d][%d]=%d\\n\",i,j,toplam[i][j]);\n    return 0;\n}"}
{"author": "theuwis", "file": "AdventOfCode2016__main.0.c", "original_string": "int main() {\n   while (str[current_char] != '\\0') {\n      c = str[current_char];\n      if(c != ',') {\n         if(c == 'R'){\n            (coord_prev == WEST) ? coord_next = NORTH : coord_next++;\n         }\n         else if(c == 'L') {\n            (coord_prev == NORTH) ? coord_next = WEST : coord_next--;\n         }\n         else {\n            current_step = c - '0';\n            dummy_step = dummy_step * 10 + current_step;\n            if( (str[current_char + 1] == ',') || (str[current_char + 1] == '\\0') ) {\n               if(dummy_step != 0){\n                  current_step = dummy_step;\n                  dummy_step = 0;\n               }\n               coord_prev = coord_next;\n               switch(coord_next){\n                  case NORTH :\n                     y += current_step;\n                     break;\n                  case EAST :\n                     x += current_step;\n                     break;\n                  case SOUTH :\n                     y -= current_step;\n                     break;\n                  case WEST :\n                     x -= current_step;\n                     break;\n                  }\n            }\n         }\n      }\n      current_char++;\n   }\n   printf(\"done! (x=%d, y=%d => total=%d)\\n\", x, y, abs(x) + abs(y));\n   return 0;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__epur_str.0.c", "original_string": "int     main(int ac, char **av)\n{\n    int     i;\n    i = 0;\n    if (ac == 2)\n    {\n        while (av[1][i] == ' ' || av[1][i] == '\\t')\n            i++;\n        while(av[1][i])\n        {\n            if (av[1][i] > 32)\n                write(1, &av[1][i], 1);\n            if (av[1][i] <= 32 && av[1][i + 1] > 32)\n                write(1, \" \", 1);\n            i++;\n        }\n    }\n    write(1, \"\\n\", 1);\n    return (0);\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__if-else3.0.c", "original_string": "int main()\n{\n    int max,min,s1,s2,s3;\n    printf(\"l\u00fctfen \u00fc\u00e7 tane say\u0131 giriniz:\");\n    scanf(\"%d %d %d\",&s1,&s2,&s3);\n    min=s1;\n    max=s1;\n    if(max<s2)\n        max=s2;\n    if(max<s3)\n        max=s3;\n    if(min>s2)\n        min=s2;\n    if(min>s3)\n        min=s3;\n    printf(\"en b\u00fcy\u00fck : %d\\nen k\u00fc\u00e7\u00fck: %d\",max,min);\n    return 0;\n    }"}
{"author": "chandanXP", "file": "Datastructure-using-C__circularLinkedList.6.c", "original_string": "struct Node *deleteLastNode(struct Node *head)\n{\n     struct Node *p = head;\n     struct Node *q = head->next;\n     while (q->next != head)\n     { \n          p = p->next;\n          q = q->next;\n     }\n     p->next = head; \n     free(q);        \n     return head;    \n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__unique2.0.c", "original_string": "int main(){\n  int t, x;\n  scanf(\"%d\", &t);\n  for(int i = 1; i <= t; i++){\n    int numbers[9] = {0};\n    scanf(\"%d\", &x);\n    if(x < 10)\n      printf(\"%d\\n\", x);\n      else{\n    if(get_numbers(x, 9, numbers, 0)){\n      quicksort(numbers, 0, 9);\n      imprime(numbers);\n    }\n    else\n      printf(\"-%d\\n\", 1);\n      }\n  }\n}"}
{"author": "sdukesameer", "file": "dsa__pol-add-sub-mul.3.c", "original_string": "void display(node* res)\n{\n    int f=0;\n    while(res)\n    {\n        if(res->coeff>0)\n        {\n            if(f==0)\n                printf(\" %dx^%d \",res->coeff,res->pow);\n            else\n                printf(\"+ %dx^%d \",res->coeff,res->pow);\n        }\n        else if(res->coeff<0)\n            printf(\"- %dx^%d \",-res->coeff,res->pow);\n        f=1;\n        res=res->next;\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.15.c", "original_string": "SUBROUTDEC* getsubroutdec(SCOPE* s, const char* name) {\n    SUBROUTDEC* curr = s->subroutines;\n    while(curr != NULL) {\n        if(!strcmp(curr->name, name))\n            return curr;\n        curr = curr->next;\n    }\n    if(s->previous != NULL)\n        return getsubroutdec(s->previous, name);\n    return NULL;\n}"}
{"author": "fikepaci", "file": "monty__stack.1.c", "original_string": "int init_stack(stack_t **stack)\n{\n    stack_t *s;\n    s = malloc(sizeof(stack_t));\n    if (s == NULL)\n        return (malloc_error());\n    s->n = STACK;\n    s->prev = NULL;\n    s->next = NULL;\n    *stack = s;\n    return (EXIT_SUCCESS);\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__MatrixChainMultiplication.0.c", "original_string": "void matrix_chain_multiplication(int p[11],int n,int M[11][11],int S[11][11])\n{\n int i,j,k,l,q;\n for(l=2;l<=n;l++)\n {\n  for(i=1;i<=n-l+1;i++)\n  {\n   j=i+l-1;\n   M[i][j]=inf;\n   for(k=i;k<=j-1;k++)\n   {\n    q=M[i][k]+M[k+1][j]+p[i-1]*p[k]*p[j];\n    if(q<M[i][j])\n    {\n     M[i][j]=q;\n     S[i][j]=k;\n    }\n   }\n  }\n }\n}"}
{"author": "henrique-tavares", "file": "IFB-Algoritmos-e-Programacao-de-Computadores__50.0.c", "original_string": "int main()\n{\n    float a, b, c, x1, x2, x, delta, real, im1, im2;\n    printf(\"\\nDe acordo com o modelo de equa\u00e7\u00e3o: ax\u00b2+bx+c\\n\\n\");\n    printf(\"Informe 'a': \");\n    scanf(\"%f\", &a);\n    printf(\"Informe 'b': \");\n    scanf(\"%f\", &b);\n    printf(\"Informe 'c': \");\n    scanf(\"%f\", &c);\n    delta = pow(b, 2) - 4 * a * c;\n    if (delta == 0)\n    {\n        x = (-b) / (2 * a);\n        printf(\"\\nA equa\u00e7\u00e3o tem raiz dupla\\nx = %.2f\\n\\n\", x);\n    }\n    else if (delta < 0)\n    {\n        delta = -delta;\n        real = (-b) / (2 * a);\n        im1 = sqrt(delta) / (2 * a);\n        im2 = (-sqrt(delta)) / (2 * a);\n        printf(\"\\nA equa\u00e7\u00e3o tem raiz imagin\u00e1ria\\nParte real = %.2f\\nParte imagin\u00e1ria = %.2fi e %.2fi\\n\\n\", real, im1, im2);\n    }\n    else\n    {\n        x1 = (-b + sqrt(delta)) / (2 * a);\n        x2 = (-b - sqrt(delta)) / (2 * a);\n        printf(\"\\nA equa\u00e7\u00e3o tem raizes reais\\nx1 = %.2f\\nx2 = %.2f\\n\\n\", x1, x2);\n    }\n    return 0;\n}"}
{"author": "RobertoBenjami", "file": "stm32_multiregion_heap_driver__stm32f4xx_hal_pwr_ex.15.c", "original_string": "HAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry)\n{\n  uint32_t tmpreg1 = 0U;\n  assert_param(IS_PWR_REGULATOR_UNDERDRIVE(Regulator));\n  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));\n  __HAL_RCC_PWR_CLK_ENABLE();\n  __HAL_PWR_CLEAR_ODRUDR_FLAG();\n  __HAL_PWR_UNDERDRIVE_ENABLE();\n  tmpreg1 = PWR->CR;\n  tmpreg1 &= (uint32_t)~(PWR_CR_PDDS | PWR_CR_LPDS | PWR_CR_LPUDS | PWR_CR_MRUDS);\n  tmpreg1 |= Regulator;\n  PWR->CR = tmpreg1;\n  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;\n  if(STOPEntry == PWR_SLEEPENTRY_WFI)\n  {   \n    __WFI();\n  }\n  else\n  {\n    __WFE();\n  }\n  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);\n  return HAL_OK;  \n}"}
{"author": "christiane-millan", "file": "UTM2020B-102A-025011-Structured-Programming__primos.0.c", "original_string": "int main(){\n    int primos = 0, no_primos = 0;\n    for (int numero = 1; numero <= 10000; numero++)\n    {   \n        if(es_primo(numero)==1){\n            primos++;\n        } else {\n            no_primos++;\n        }\n    }\n    printf(\"Numero de primos %d, numero no primos %d\", primos, no_primos);\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__tokenizer.1.c", "original_string": "void append(STRING* s, char c) {\n    int targsize = sizeof(char) * (s->count + 1);\n    if(s->size <= targsize) {\n        s->size = targsize * 2;\n        s->str = (char*)realloc(s->str, s->size);\n    }\n    s->str[s->count] = c;\n    s->count++;\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__a1.2.c", "original_string": "bool **get_trees(char *filename, size_t n, size_t m) {\n    FILE *f = fopen(filename, \"r\");\n    bool **trees = calloc(sizeof(bool*), n);\n    for (size_t i = 0; i < n; i++)\n        trees[i] = calloc(sizeof(bool), m);\n    char c;\n    for (size_t i = 0; i < n; i++)\n        for (size_t j = 0; j < m; j++) {\n            c = fgetc(f);\n            if (c == '\\n') c = fgetc(f);\n            if (c == '#') trees[i][j] = true;\n        }\n    fclose(f);\n    return trees;\n}"}
{"author": "rgautam320", "file": "Data-Structure-Lab-Assignment__19BCP101_LAB_6.3.c", "original_string": "void addafter()\n{\n    struct node* temp, *p = root, *q;\n    int key, i = 1;\n    printf(\"Enter the location where you want to insert : \");\n    scanf(\"%d\", &key);\n    if(key > len)\n    {\n        printf(\"Unable to insert \\n\\n\");\n    }\n    else\n    {\n        while(i < key)\n        {\n            p = p->right;\n            i++;\n        }\n        q = p->right;\n        temp = (struct node*)malloc(sizeof(struct node));\n        printf(\"Enter an element to insert : \");\n        scanf(\"%d\", &temp->data);\n        printf(\"%d inserted\\n\\n\", temp->data);\n        temp->left = NULL;\n        temp->right = NULL;\n        temp->right = q;\n        q->left = temp;\n        p->right = temp;\n        temp->left = p;\n    }\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__frequency_character.0.c", "original_string": "int Frequency(char str[], char ch)\n{\n    int iCnt = 0, i = 0;\n    if(str == NULL)\n    {\n        return -1;\n    }\n    while(str[i] != '\\0')\n    {\n        if(str[i] == ch)\n        {\n            iCnt++;\n        }\n        i++;\n    }\n    for(i = 0; str[i] != '\\0'; i++)\n    {\n        if(str[i] == ch)\n        {\n            iCnt++;\n        }\n    }\n    while(*str != '\\0')\n    {\n        if(*str == ch)\n        {\n            iCnt++;\n        }\n        str++;\n    }\n    return iCnt;\n}"}
{"author": "Theemiss", "file": "simple_shell__finding_path.0.c", "original_string": "int path_cmd(char **cmd)\n{\n    char *path, *value, *cmd_path;\n    struct stat buf;\n    path = _getenv(\"PATH\");\n    value = _strtok(path, \":\");\n    while (value != NULL)\n    {\n        cmd_path = build(*cmd, value);\n        if (stat(cmd_path, &buf) == 0)\n        {\n            *cmd = _strdup(cmd_path);\n            free(cmd_path);\n            free(path);\n            return (0);\n        }\n        free(cmd_path);\n        value = _strtok(NULL, \":\");\n    }\n    free(path);\n    return (1);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__displayReversedList.2.c", "original_string": "int main(){\n     struct Node *head;\n     struct Node *second;\n     struct Node *third;\n     struct Node *fourth;\n     head = (struct Node *)malloc(sizeof(struct Node));\n     second = (struct Node *)malloc(sizeof(struct Node));\n     third = (struct Node *)malloc(sizeof(struct Node));\n     fourth = (struct Node *)malloc(sizeof(struct Node));\n     head->data=100;\n     head->next=second;\n     second ->data=200;\n     second->next=third;\n     third->data=300;\n     third->next=fourth;\n     fourth->data=400;\n     fourth->next=NULL;\n     printf(\"---Linked list before reverse---\\n\");\n     linkedListTreversal(head);\n     head = reversedList(head);\n     printf(\"%d\\n\", head->data);\n     printf(\"---Linked list after reverse---\\n\");\n     linkedListTreversal(head);\n     return 0;\n}"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__2-3.3.c", "original_string": "int get_decimal(int hexa[], int cont){\n  int res = 0;\n  int exp = cont-1;\n  for(int i = 0; i < cont; i++){\n    res += hexa[i] * eleva(16, exp--);\n  }\n  return res;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__q13.0.c", "original_string": "void insertq(que* pq, char* item)\n{\n    if ((pq->front == 0 && pq->rear == size - 1) || (pq->front == pq->rear + 1))\n    {\n        printf(\"queue is full\");\n        return;\n    }\n    else if (pq->rear ==  -1)\n    {\n        pq->rear++;\n        pq->front++;\n    }\n    else if (pq->rear == size - 1 && pq->front > 0)\n    {\n        pq->rear = 0;\n    }\n    else\n    {\n        pq->rear++;\n    }\n    pq->queue[pq->rear] = item;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-expressions.7.c", "original_string": "TERM* parseunaryopterm(PARSER* p) {\n    TERM* t = mkterm(unaryopterm);\n    t->unaryop = p->current->token[0];\n    next(p);\n    t->expression = parseterm(p);\n    t->expression->next = NULL;\n    return t;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__Boyre_MooreMethod.1.c", "original_string": "int Boyre_Moore(char S[],char P[],int n,int m)\n{\n    int i=m-1,j=m-1,l;\n    while(i<n && i>=0)\n    {\n        if(P[j]==S[i])\n        {\n            if(j==0)\n            return(i);\n            else\n            {\n                i=i-1;\n                j=j-1;\n            }\n        }\n        else\n        {\n            l=Last_Occurence(P,m,S[i]);\n            i=i+m-(l+1);\n            j=m-1;\n        }\n    }\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__sender_mian.1.c", "original_string": "int main(){\n    unsigned int length;\n    welcome();\n    length = frame_construction(frame, sta_addr, des_addr, protocol, data, sizeof(data));\n    send_frame(frame, length);\n    return 0;\n}"}
{"author": "DanielSalis", "file": "AED1__teste4.6.c", "original_string": "int main(){\n    int flag;\n    int op = 1;\n    int IDcidade;\n    int distancia;\n    TipoLista lista;\n    iniciarLista(&lista);\n    while(op==1){\n        scanf(\"%d\", &op);\n        if(op==1){\n            scanf(\"%d %d\", &IDcidade, &distancia);\n            inserir(&lista, IDcidade, distancia);\n        }\n            else if(distancia != 0){\n                printf(\"trajeto invalido\");\n                return 0;\n            }\n        else if(op==2){\n            scanf(\"%d\", &IDcidade);\n            flag = jaPercorri(&lista, IDcidade);\n            if(flag==0){\n                break;\n            }\n        }\n        else if(op==3){\n            scanf(\"%d\", &IDcidade);\n            flag = faltamPercorrer(&lista, IDcidade);\n            if(flag==0){\n                break;\n            }\n        }\n        else if(op==4){\n            calculaTrajetoTotal(&lista);\n            break;\n        }\n        else{\n            printf(\"opcao invalida\");\n            break;\n        }\n    }\n    return 0;    \n}"}
{"author": "paawankohli", "file": "DSA-LAB__createTrees.1.c", "original_string": "nptr createBT()\n{\n    int x;    printf(\"Insert Element: \");    scanf(\"%d\", &x);\n    if(x == -1)\n        return NULL;\n    nptr temp = createNode(x);\n    temp -> lchild = createBT();\n    temp -> rchild = createBT();\n    return temp;\n}"}
{"author": "2security", "file": "If-else__ElectricityBillCal.0.c", "original_string": "int main()\n    {\n    int unit;\n    float pay,Surpay;\n    printf(\"\\nEnter the unit consumed\\n\");\n    scanf(\"%d\",&unit);\n    if(unit<=50)\n        {\n        pay=unit * 0.50;\n        unit=unit-50;\n        }\n    if(unit<=150)\n        {       \n        pay=pay+unit*0.75;\n        unit=unit-100;\n        }\n    if(unit<=250)\n        {\n        pay=pay+unit*1.20;\n        unit=unit-100;\n        }\n    else\n        {\n        pay=pay+unit*1.50;\n        }\n    Surpay=pay*0.2;\n    pay=pay+Surpay;\n    printf(\"\\nPay of %f\\n\",pay);    \n    printf(\"\\n\");   \n    return 0;\n    }"}
{"author": "augustogunsch", "file": "jack-compiler__parser-structure.13.c", "original_string": "void parsevardeccommon(PARSER* p, VARDEC* v) {\n    v->typeclass = p->current->type;\n    v->primitive = isprimitive(p->current);\n    v->type = parsetype(p);\n    STRINGLIST* currstr = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n    v->names = currstr;\n    v->debug = getdebug(p);\n    v->names->content = parseidentifier(p);\n    while(!strcmp(p->current->token, \",\")) {\n        next(p);\n        STRINGLIST* nextstr = (STRINGLIST*)malloc(sizeof(STRINGLIST));\n        nextstr->content = parseidentifier(p);\n        currstr->next = nextstr;\n        currstr = nextstr;\n    }\n    currstr->next = NULL;\n    checkcontent(p, \";\");\n}"}
{"author": "dishanp", "file": "DSA__q20.1.c", "original_string": "int main()\n{\n      int i, j, n,*data;\n      printf(\"No of elements : \");\n      scanf(\"%d\", &n);\n      data = (int*) calloc(n, sizeof(int));\n      if(data == NULL)\n      {\n            printf(\"Error\");\n            return 1 ;\n      }\n      printf(\"\\n\");\n      for(i = 0; i < n; ++i)\n      {\n            printf(\"Enter Number %d: \", i + 1);\n            scanf(\"%d\", data + i);\n      }\n      reverse(data, n);\n      printf(\"\\n\");\n      for(i = 0; i < n; ++i)\n      {\n            printf(\"%d \", *(data + i));\n      }\n            printf(\"\\n\");\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_rtx.4.c", "original_string": "void osDeleteTask(OsTask *task)\n{\n   uint_t i;\n   OS_TID tid;\n   if(task == NULL)\n      tid = os_tsk_self();\n   else\n      tid = task->tid;\n   osSuspendAllTasks();\n   for(i = 0; i < OS_PORT_MAX_TASKS; i++)\n   {\n      if(taskTable[i].tid == tid)\n      {\n         taskTable[i].tid = 0;\n      }\n   }\n   osResumeAllTasks();\n   if(task == NULL)\n   {\n      os_tsk_delete_self();\n   }\n   else\n   {\n      os_tsk_delete(tid);\n   }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-central-scanner-with-whitelist__nrf_dfu_flash.2.c", "original_string": "ret_code_t nrf_dfu_flash_store(uint32_t dest,\n                               void const * p_src,\n                               uint32_t len,\n                               nrf_dfu_flash_callback_t callback)\n{\n        ret_code_t rc;\n        NRF_LOG_DEBUG(\"nrf_fstorage_write(addr=%p, src=%p, len=%d bytes), queue usage: %d\",\n                      dest, p_src, len, m_flash_operations_pending);\n        rc = nrf_fstorage_write(&m_fs, dest, p_src, len, (void *)callback);\n        if ((NRF_LOG_ENABLED) && (rc == NRF_SUCCESS))\n        {\n                m_flash_operations_pending++;\n        }\n        else\n        {\n                NRF_LOG_WARNING(\"nrf_fstorage_write() failed with error 0x%x.\", rc);\n        }\n        return rc;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__20.0.c", "original_string": "int main(int argc, char *argv[])\n{\n    FILE *arq;\n    char aux, *texto;\n    if (argc < 2)\n    {\n        printf(\"\\nErro! N\u00e3o foi informado o nome do arquivo.\\n\\n\");\n        return 0;\n    }\n    arq = fopen(argv[1], \"r+\");\n    if (arq == NULL)\n    {\n        printf(\"\\nErro ao abrir o arquivo.\\n\\n\");\n        return 0;\n    }\n    int i = 0;\n    while (fscanf(arq, \"%c\", &aux) != EOF)\n    {\n        i++;\n    }\n    texto = malloc((i+1) * sizeof(char));\n    rewind(arq);\n    i = 0;\n    while (fscanf(arq, \"%c\", &aux) != EOF)\n    {\n        texto[i] = aux;\n        i++;\n    }\n    texto[i] = '\\0';\n    for (int j = 0; j < i; j++)\n    {\n        switch (texto[j])\n        {\n            case 'a':\n                texto[j] = 'A';\n                break;\n            case 'e':\n                texto[j] = 'E';\n                break;\n            case 'i':\n                texto[j] = 'I';\n                break;\n            case 'o':\n                texto[j] = 'O';\n                break;\n            case 'u':\n                texto[j] = 'U';\n                break;\n            default:\n                break;\n        }\n    }\n    rewind(arq);\n    fprintf(arq, \"%s\", texto);\n    fclose(arq);\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-statements.3.c", "original_string": "LINEBLOCK* compileret(SCOPE* s, STATEMENT* st) {\n    TERM* e = st->retstatement;\n    LINE* ret = onetoken(\"return\");\n    LINEBLOCK* blk = mklnblk(ret);\n    if(e == NULL) {\n        char* tokens[] = { \"push\", \"constant\", \"0\" };\n        appendlnbefore(blk, mkln(tokens));\n    } else\n        blk = mergelnblks(compileexpression(s, st->debug, e), blk);\n    return blk;\n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__dnsserver.0.c", "original_string": "void main(int argc,char* argv[])\n{\n    struct sockaddr_in dnss,dnsc;\n    int rval,sockid,flag=0,clen;\n    char sym[20],IP[20],dnsFile[20],dnsName[20];\n    FILE *fptr;\n    system(\"clear\");\n    if(argc<3)\n    {\n        printf(\"\\nUSAGE : %s IP_ADDR PORT#\\n\",argv[0]);\n        exit(1);\n    }\n    dnss.sin_family=AF_INET;\n    dnss.sin_port=htons(atoi(argv[2]));\n    dnss.sin_addr.s_addr=inet_addr(argv[1]);\n    sockid=socket(AF_INET,SOCK_DGRAM,0);\n    if(sockid==-1)\n    {\n        perror(\"SOCK-CRE-ERR:\");\n        exit(1);\n    }\n    rval=bind(sockid,(struct sockaddr*)&dnss,sizeof(dnss));\n    if(rval==-1)\n    {\n        perror(\"BIND-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    printf(\"\\nDNS Server waiting for request\\n\");\n    printf(\"\\nEnter the DNS file name : \");\n    scanf(\"%s\",dnsFile);\n    fptr=fopen(dnsFile,\"r\");\n    if(fptr==NULL)\n    {\n        perror(\"FILE-OPEN-ERR:\");\n        close(sockid);\n        exit(1);\n    }\n    clen=sizeof(dnsc);\n    rval=recvfrom(sockid,sym,sizeof(sym),0,(struct sockaddr*)&dnsc,&clen);\n    if(rval==-1)\n    {\n        perror(\"MSG-RCV-ERR:\");\n        close(sockid);\n        fclose(fptr);\n        exit(1);\n    }\n    printf(\"\\nIP requested for %s\\n\",sym);\n    while((fscanf(fptr,\"%s%s\",dnsName,IP) != EOF) )\n    {\n        if(strcmp(dnsName,sym)==0)\n        {\n            rval=sendto(sockid,IP,sizeof(IP),0,(struct\n            sockaddr*)&dnsc,clen);\n            if(rval==-1)\n            {\n                perror(\"MSG-SND-ERR:\");\n                fclose(fptr);\n                close(sockid);\n                exit(1);\n            }\n            flag=1;\n        }\n        printf(\"\\n flag value in loop is %d\\n\",flag);\n        if(flag==1) \n        break;\n    }\n    if(flag==0)\n    {\n        printf(\"\\n invalid domain name case\\n\");\n        rval=sendto(sockid,\"NOT FOUND\",sizeof(\"NOT FOUND\"),0,(struct\n        sockaddr*)&dnsc,clen);\n        if(rval==-1)\n        {\n            perror(\"MSG-SND-ERR:\");\n            fclose(fptr);\n            close(sockid);\n            exit(1);\n        }\n    }\n    fclose(fptr);\n    close(sockid);\n}"}
{"author": "2security", "file": "String__13ReverseOrderOfWord.2.c", "original_string": "int main()\n    {\n        char str[20],*temp;\n        int n,s,d,k=0;\n        printf(\"\\n Enter the string:: \");\n        gets(str);\n        temp=ReverseWord(str);\n        printf(\"Reverse Ordered words is::%s\",temp);\n        return 0;\n    }"}
{"author": "augustogunsch", "file": "jack-compiler__parser-tree.6.c", "original_string": "void freeexpressionlist(EXPRESSIONLIST* el) {\n    freeexpression(el->expression);\n    EXPRESSIONLIST* next = el->next;\n    free(el);\n    if(next != NULL)\n        freeexpressionlist(next);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__ssh_exchange_hash.1.c", "original_string": "error_t sshUpdateExchangeHash(SshConnection *connection, const void *data,\n   size_t length)\n{\n   error_t error;\n   uint8_t temp[4];\n   error = NO_ERROR;\n   if(connection->hashAlgo != NULL)\n   {\n      STORE32BE(length, temp);\n      connection->hashAlgo->update(connection->hashContext, temp, sizeof(temp));\n      connection->hashAlgo->update(connection->hashContext, data, length);\n   }\n   else\n   {\n      error = ERROR_FAILURE;\n   }\n   return error;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e62.2.c", "original_string": "int selecionarEvento()\n{\n    int contadorLista, existeEvento;\n    printf(\"\\t\\t\\t\\t\\t\\tEventos Cadastrados: \\n\");\n    printf(\"\\n\\t\\t\\tNOME\\t\\t \\t\\tCAPACIDADE\\t\\t \\t\\tPRECO\\n\\n\");\n    for(contadorLista = 0; contadorLista < 31; contadorLista++)\n    {\n        if(capacidade[contadorLista] != 0)\n        {\n            printf(\"%d)\\t%s\\t\\t\\t\\t\\t\\t%d pessoa(s)\\t\\t\\t\\tR$%.2f\\n\", contadorLista, nomeEvento[contadorLista], capacidade[contadorLista], preco[contadorLista]);\n        }\n    }\n        printf(\"\\n\\n Digite o numero do evento desejado: \");\n        scanf(\"%d\", &evento);\n        if(capacidade[evento] != 0)\n        {\n            capacidadeMax = capacidade[evento];\n            valorIngresso = preco[evento];\n            capacidadeInteira = capacidadeI[evento];\n            capacidadeMeia = capacidadeM[evento];\n            existeEvento = 1;\n        }\n            else\n            {\n                existeEvento = 0;\n            }\n    return existeEvento;\n}"}
{"author": "ankitraj311", "file": "450_babbar__6_union_array_SELF_with_warning.1.c", "original_string": "void union_array(int arr1[], int arr2[])\n{\n  int size_arr1 = (sizeof(arr1)/sizeof(int)), size_arr2 = (sizeof(arr2)/sizeof(int));\n  int arr3[size_arr1+size_arr2], j = 0;\n  for(int i = 0; i<size_arr1; i++)\n  {\n    arr3[j] = arr1[i];\n    j++;\n  }\n  for(int i = 0; i<size_arr2; i++)\n  {\n    arr3[j] = arr1[i];\n    j++;\n  }\n  array_print(arr3,size_arr1+size_arr2);\n}"}
{"author": "davibernardos", "file": "DB-Projetos__e16.0.c", "original_string": "int main(void) {\n    int jogadorUm, jogadorDois, nEmpatesUm, nEmpatesDois, nDerrotasUm , nDerrotasDois;\n    int opcao, menu;\n    float nVitoriasUm, nVitoriasDois, pVitoriasUm, pVitoriasDois, nJogadas;\n    opcao = 1;\n    nVitoriasDois = 0;\n    nDerrotasUm = 0;\n    printf(\"------------------------------------\\n-------------bem vindo!-------------\\n------------------------------------\\n\\n\");\n    while(opcao != 3){\n    printf(\"Selecione seu modo de jogo: \\n\\n\");\n    printf(\"1- PvC - Player vs Computer \\n\");\n    printf(\"2- PvP - Player vs Player \\n\");\n    printf(\"3- sair\\n\");\n    fflush(stdin);\n    scanf(\"%d\", &opcao);\n    switch(opcao){\n        case 1: \n         jogadorUm = 0;\n         jogadorDois = 0;\n         nVitoriasUm = 0;\n         nVitoriasDois = 0;\n         nEmpatesUm = 0;\n         nEmpatesDois = 0;\n         nJogadas = 0;\n         nDerrotasUm  = 0;\n         nDerrotasDois = 0;\n         pVitoriasUm = 0;\n         pVitoriasDois = 0;\n        while(menu !=4){\n           printf(\"\\nSelecione sua opcao: \\n\");\n           printf(\"1- Pedra\\n 2- Papel \\n 3- Tesoura. \\n\");\n           scanf(\"%d\", &jogadorUm);\n           srand(time(NULL));\n           jogadorDois = 1 + rand() %3;\n           printf(\"\\nOpcao jogadorDois = %d \", jogadorDois, (jogadorDois % 4));\nif(jogadorUm == 1 && jogadorDois == 1){\n            printf(\"\\nDeu Empate!\\n\");\n            nEmpatesUm = nEmpatesUm + 1;\n            nEmpatesDois = nEmpatesDois + 1; \n            nJogadas = nJogadas + 1;\n      }else{\n          if(jogadorUm == 1 && jogadorDois == 2){  \n                       printf(\"\\nO jogador Dois ganhou\\n\");\n                       nDerrotasUm = nDerrotasUm + 1;\n                       nVitoriasDois = nVitoriasDois + 1;\n                       nJogadas = nJogadas + 1;                   \n         }else{\n              if(jogadorUm == 1 && jogadorDois == 3){\n                           printf(\"\\nO Jogador Um ganhou\\n\");\n                           nDerrotasDois = nDerrotasDois + 1;\n                           nVitoriasUm = nVitoriasUm + 1;\n                           nJogadas = nJogadas + 1;\n              }else{\n                    if(jogadorUm == 2 && jogadorDois == 1){ \n                                 printf(\"\\nO jogador Dois ganhou\\n\");\n                                 nDerrotasUm = nDerrotasUm + 1;\n                                 nVitoriasDois = nVitoriasDois + 1;\n                                 nJogadas = nJogadas + 1;\n                    }else{\n                          if(jogadorUm == 2 && jogadorDois == 2){\n                                       printf(\"\\nDeu empate\\n\");\n                                       nEmpatesUm = nEmpatesUm + 1;\n                                       nEmpatesDois = nEmpatesDois + 1;\n                                       nJogadas = nJogadas + 1;\n                         }else{\n                               if(jogadorUm == 2 && jogadorDois == 3){  \n                                            printf(\"\\nO jogador dois ganhou\\n\");\n                                            nVitoriasDois = nVitoriasDois + 1;\n                                            nDerrotasUm = nDerrotasUm + 1;\n                                            nJogadas = nJogadas + 1;\n                              }else{\n                                    if (jogadorUm == 3 && jogadorDois == 1){\n                                                  printf(\"\\nO jogador Dois ganhou\\n\");\n                                                  nVitoriasDois = nVitoriasDois + 1;\n                                                  nDerrotasUm = nDerrotasUm + 1;\n                                                  nJogadas = nJogadas + 1;\n                                    }else{\n                                          if(jogadorUm == 3 && jogadorDois == 2){\n                                                       printf(\"\\nO jogador Um ganhou\\n\");\n                                                       nDerrotasDois = nDerrotasDois + 1;\n                                                       nVitoriasUm = nVitoriasUm + 1;\n                                                       nJogadas = nJogadas + 1;\n                                            }else{\n                                                  if(jogadorUm == 3 && jogadorDois == 3){\n                                                               printf(\"\\nDeu Empate\\n\");\n                                                               nEmpatesUm = nEmpatesUm + 1;\n                                                               nEmpatesDois = nEmpatesDois + 1;\n                                                               nJogadas = nJogadas + 1;\n                                                  }else{\n                                                       printf(\"\\nJogada Invalida\\n\");\n                                                  } \n}}}}}}}}\n            if(nVitoriasUm == 0)\n            {\n                   pVitoriasUm = 0;\n                   }else \n                   {\n                          pVitoriasUm = ( nVitoriasUm/ nJogadas ) * 100;\n                   }\n                                if(nVitoriasDois == 0)\n                                {\n                                        pVitoriasDois = 0;\n                                        }else\n                                        {\n                                                pVitoriasDois = ( nVitoriasDois / nJogadas ) * 100;\n            }\n            printf(\"\\nJOGADOR 1: \\n\");\n            printf(\"\\nQuantidade de Vitorias: %.0f\", nVitoriasUm);\n            printf(\"\\nQuantidade de Derrotas: %d\", nDerrotasUm);\n            printf(\"\\nQuantidade de Empates: %d\", nEmpatesUm);\n            printf(\"\\nPercentual de Vitorias: %.2f %%\", pVitoriasUm );\n            printf(\"\\n------------------------------------------------------------------\");\n            printf(\"\\nJOGADOR 2: \\n\");\n            printf(\"\\nQuantidade de Vitorias: %.0f\", nVitoriasDois);\n            printf(\"\\nQuantidade de Derrotas: %d\", nDerrotasDois);\n            printf(\"\\nQuantidade de Empates: %d\", nEmpatesDois);\n            printf(\"\\nPercentual de Vitorias: %.2f %%\", pVitoriasDois);\n            printf(\"\\n------------------------------------------------------------------\");\n            printf(\"\\nGERAL: \\n\");\n            printf(\"Quantidade de Jogadas Total: %.0f\", nJogadas);\n            printf(\"\\ndeseja jogar novamente?\\n\");\n            scanf(\"%d\", &menu);\n            system(\"cls\");\n    }\n        break;\n        case 2:  \n         jogadorUm = 0;\n         jogadorDois = 0;\n         nVitoriasUm = 0;\n         nVitoriasDois = 0;\n         nEmpatesUm = 0;\n         nEmpatesDois = 0;\n         nJogadas = 0;\n         nDerrotasUm  = 0;\n         nDerrotasDois = 0;\n         pVitoriasUm = 0;\n         pVitoriasDois = 0;\n        while(opcao != 3){\n           printf(\"\\nSelecione sua opcao: \\n\");\n           printf(\"1- Pedra\\n 2- Papel \\n 3- Tesoura. \\n\");\n           scanf(\"%d\", &jogadorUm);\n           printf(\"\\nSelecione sua opcao: \\n\");\n           printf(\"1- Pedra\\n 2- Papel \\n 3- Tesoura. \\n\");\n           scanf(\"%d\", &jogadorDois);\n           system(\"cls\");\nif(jogadorUm == 1 && jogadorDois == 1){\n            printf(\"\\nDeu Empate!\\n\");\n            nEmpatesUm = nEmpatesUm + 1;\n            nEmpatesDois = nEmpatesDois + 1; \n            nJogadas = nJogadas + 1;\n      }else{\n          if(jogadorUm == 1 && jogadorDois == 2){  \n                       printf(\"\\nO jogador Dois ganhou\\n\");\n                       nDerrotasUm = nDerrotasUm + 1;\n                       nVitoriasDois = nVitoriasDois + 1;\n                       nJogadas = nJogadas + 1;                   \n         }else{\n              if(jogadorUm == 1 && jogadorDois == 3){\n                           printf(\"\\nO Jogador Um ganhou\\n\");\n                           nDerrotasDois = nDerrotasDois + 1;\n                           nVitoriasUm = nVitoriasUm + 1;\n                           nJogadas = nJogadas + 1;\n              }else{\n                    if(jogadorUm == 2 && jogadorDois == 1){ \n                                 printf(\"\\nO jogador Dois ganhou\\n\");\n                                 nDerrotasUm = nDerrotasUm + 1;\n                                 nVitoriasDois = nVitoriasDois + 1;\n                                 nJogadas = nJogadas + 1;\n                    }else{\n                          if(jogadorUm == 2 && jogadorDois == 2){\n                                       printf(\"\\nDeu empate\\n\");\n                                       nEmpatesUm = nEmpatesUm + 1;\n                                       nEmpatesDois = nEmpatesDois + 1;\n                                       nJogadas = nJogadas + 1;\n                         }else{\n                               if(jogadorUm == 2 && jogadorDois == 3){  \n                                            printf(\"\\nO jogador dois ganhou\\n\");\n                                            nVitoriasDois = nVitoriasDois + 1;\n                                            nDerrotasUm = nDerrotasUm + 1;\n                                            nJogadas = nJogadas + 1;\n                              }else{\n                                    if (jogadorUm == 3 && jogadorDois == 1){\n                                                  printf(\"\\nO jogador Dois ganhou\\n\");\n                                                  nVitoriasDois = nVitoriasDois + 1;\n                                                  nDerrotasUm = nDerrotasUm + 1;\n                                                  nJogadas = nJogadas + 1;\n                                    }else{\n                                          if(jogadorUm == 3 && jogadorDois == 2){\n                                                       printf(\"\\nO jogador Um ganhou\\n\");\n                                                       nDerrotasDois = nDerrotasDois + 1;\n                                                       nVitoriasUm = nVitoriasUm + 1;\n                                                       nJogadas = nJogadas + 1;\n                                            }else{\n                                                  if(jogadorUm == 3 && jogadorDois == 3){\n                                                               printf(\"\\nDeu Empate\\n\");\n                                                               nEmpatesUm = nEmpatesUm + 1;\n                                                               nEmpatesDois = nEmpatesDois + 1;\n                                                               nJogadas = nJogadas + 1;\n                                                        }else{\n                                                                 printf(\"\\nJogada Invalida\\n\");\n}}}}}}}}}\n            if(nVitoriasUm == 0)\n            {\n                   pVitoriasUm = 0;\n                 }\n                 else\n                     {\n                        pVitoriasUm = ( nVitoriasUm / nJogadas ) * 100;\n                     }\n                             if(nVitoriasDois == 0){\n                                    pVitoriasDois = 0;\n                                    }\n                                     else\n                                     {\n                                               pVitoriasDois = ( nVitoriasDois / nJogadas ) * 100;\n            }\n            printf(\"\\nJOGADOR 1: \\n\");\n            printf(\"\\nQuantidade de Vitorias: %.0f\", nVitoriasUm);\n            printf(\"\\nQuantidade de Derrotas: %d\", nDerrotasUm);\n            printf(\"\\nQuantidade de Empates: %d\", nEmpatesUm);\n            printf(\"\\nPercentual de Vitorias: %.2f\", pVitoriasUm );\n            printf(\"\\n------------------------------------------------------------------\");\n            printf(\"\\nJOGADOR 2: \\n\");\n            printf(\"\\nQuantidade de Vitorias: %.0f\", nVitoriasDois);\n            printf(\"\\nQuantidade de Derrotas: %d\", nDerrotasDois);\n            printf(\"\\nQuantidade de Empates: %d\", nEmpatesDois);\n            printf(\"\\nPercentual de Vitorias: %.2f %%\", pVitoriasDois);\n            printf(\"\\n------------------------------------------------------------------\");\n            printf(\"\\nGERAL: \\n\");\n            printf(\"Quantidade de Jogadas Total: %.0f\", nJogadas);\n            printf(\"\\ndeseja jogar novamente?\\n\");\n            scanf(\"%d\", &menu);\n            system(\"cls\");      \n        }\n           break;\n        case 3:\n           printf(\"Cansou de jogar? \\n\");\n           system(\"exit\");\n           break;\n        default:           \n            printf(\"opcao invalida\");\n            break;\n        }\n}\n    if(menu == 2){\n        printf(\"Voce saira do jogo!\");\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.18.c", "original_string": "void transa(STRINGLIST* ln) {\n    int add = atoi(ln->content+sizeof(char));\n    char* out = (char*)malloc(sizeof(char) * INST_SIZE);\n    int lastbit = 1 << 15;\n    for(int i = INST_SIZE-2; i > 0; i--) {\n        if(add & (lastbit >> i))\n            out[i] = '1';\n        else\n            out[i] = '0';\n    }\n    out[INST_SIZE-1] = '\\0';\n    out[0] = '0';\n    ln->content = out;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__i2c.2.c", "original_string": "void i2c_start(void)\n{\n    I2CONCLR = 1<<3;\n    I2CONSET = 1<<5;        \n    while(!(I2CONSET & (1<<3)));    \n    I2CONCLR = 1<<3;        \n    I2CONCLR = 1<<5;        \n}"}
{"author": "bgmanuel99", "file": "PracticasSistemasOperativos__ejercicio11.2.c", "original_string": "int main(int argc, char const *argv[])\n{\n    pthread_t hilo1,hilo2;\n    pthread_attr_t attr;\n    pthread_mutex_init(&count_mutex, NULL);   \n    pthread_cond_init (&count_threshold_cv, NULL);\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n    while(1){\n        pthread_create(&hilo1,&attr, *productor,NULL);\n        pthread_create(&hilo2,&attr, *consumidor,NULL);\n        pthread_join(hilo1,NULL);\n        pthread_join(hilo2,NULL);\n    }\n    pthread_attr_destroy(&attr);   \n    pthread_mutex_destroy(&count_mutex);   \n    pthread_cond_destroy(&count_threshold_cv);   \n    pthread_exit (NULL);\n    return 0;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneACME__acme_dns_client_misc.1.c", "original_string": "error_t acmeDnsClientParseRegisterResponse(AcmeDnsClientContext *context)\n{\n   error_t error;\n   const char_t *username;\n   const char_t *password;\n   const char_t *subDomain;\n   const char_t *fullDomain;\n   json_t *rootObj;\n   json_t *usernameObj;\n   json_t *passwordObj;\n   json_t *subDomainObj;\n   json_t *fullDomainObj;\n   if(!HTTP_STATUS_CODE_2YZ(context->statusCode))\n      return ERROR_UNEXPECTED_STATUS;\n   if(context->bufferLen >= ACME_DNS_CLIENT_BUFFER_SIZE)\n      return ERROR_RESPONSE_TOO_LARGE;\n   error = ERROR_INVALID_RESPONSE;\n   context->username[0] = '\\0';\n   context->password[0] = '\\0';\n   context->subDomain[0] = '\\0';\n   context->fullDomain[0] = '\\0';\n   rootObj = json_loads(context->buffer, 0, NULL);\n   if(json_is_object(rootObj))\n   {\n      usernameObj = json_object_get(rootObj, \"username\");\n      passwordObj = json_object_get(rootObj, \"password\");\n      subDomainObj = json_object_get(rootObj, \"subdomain\");\n      fullDomainObj = json_object_get(rootObj, \"fulldomain\");\n      if(json_is_string(usernameObj) &&\n         json_is_string(passwordObj) &&\n         json_is_string(subDomainObj) &&\n         json_is_string(fullDomainObj))\n      {\n         username = json_string_value(usernameObj);\n         password = json_string_value(passwordObj);\n         subDomain = json_string_value(subDomainObj);\n         fullDomain = json_string_value(fullDomainObj);\n         if(osStrlen(username) <= ACME_DNS_CLIENT_MAX_USERNAME_LEN &&\n            osStrlen(password) <= ACME_DNS_CLIENT_MAX_PASSWORD_LEN &&\n            osStrlen(subDomain) <= ACME_DNS_CLIENT_MAX_SUB_DOMAIN_LEN &&\n            osStrlen(fullDomain) <= ACME_DNS_CLIENT_MAX_FULL_DOMAIN_LEN)\n         {\n            osStrcpy(context->username, username);\n            osStrcpy(context->password, password);\n            osStrcpy(context->subDomain, subDomain);\n            osStrcpy(context->fullDomain, fullDomain);\n            error = NO_ERROR;\n         }\n      }\n   }\n   json_decref(rootObj);\n   return error;\n}"}
{"author": "RafaelFelisbino-hub", "file": "FOR-exercices__Exercicio5FOR.0.c", "original_string": "int main()\n{\n    int N1, N2, impar = 0, n3,i,r;\n    setlocale(LC_ALL, \"Portuguese\");\n    system(\"color 17\");\n    printf(\"Digite o valor de N1:  \");\n    scanf_s(\"%i\", &N1);\n    printf(\"\\nDigite o valor de N2:  \");\n    scanf_s(\"%i\", &N2);\n    for (i =N1++ ; i < N2; i++)\n    {\n        if (i % 2 == 1) \n        {\n            impar++;\n        }\n    }\n    printf(\"\\nExistem %i numeros \u00edmpares entre N1 e N2 mano, \u00c9OBIXO\\n\", impar);\n    system(\"pause\");\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__timer_assign1.2.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)\n        {}\n    }\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es10.0.c", "original_string": "int main(void) {\n  int a, b;\n  int risultato;\n  printf(\"Base: \");\n  scanf(\"%d\", &a);\n  printf(\"Esponente: \");\n  scanf(\"%d\", &b);\n  if (b > 0) {\n    risultato = potenza(a,b);\n    printf( \"Risultato: %d\\n\", risultato ); \n  } else {\n    printf(\"Inserisci una potenza maggiore di 0\");\n  }\n  return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.27.c", "original_string": "void freescope(SCOPE* s) {\n    freevars(s->fields);\n    freevars(s->staticvars);\n    freevars(s->localvars);\n    freevars(s->parameters);\n    free(s);\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__a1.1.c", "original_string": "size_t num_cols(char *filename) {\n    size_t m = 0;\n    FILE *f = fopen(filename, \"r\");\n    for (char c = fgetc(f); c != '\\n'; c = fgetc(f))\n        m++;\n    fclose(f);\n    return m;\n}"}
{"author": "2security", "file": "String__19FindNoOfMinOccurrence.1.c", "original_string": "int main()\n    {\n        int freq[size],i,c=0,t;\n        char str[size],ch;\n        printf(\"\\n Enter the string\");\n        gets(str);\n        for(i=0;i<size;i++)\n                freq[i]=0;\n        for(i=0;i<str[i]!='\\0';i++)\n            {\n                t=(int)str[i];\n                freq[t]=freq[t]+1;\n            }\n        for(i=0;i<size;i++)\n            printf(\"%d \",freq[i]);\n        i=MyMin(freq,size);\n        printf(\"\\n No of occurrence of '%c' is =%d\",i,freq[i]);\n        return 0;\n    }"}
{"author": "chandanXP", "file": "Datastructure-using-C__insertion.1.c", "original_string": "int indInsertion(int arr[], int size, int element, int capacity, int index){ \n     if(size >= capacity){\n          printf(\"Insertion failed!\");\n          return 0;\n     }\n     for(int i = size-1; i >= index; i-- ){\n          arr[i+1] = arr[i];\n     }\n     arr[index] = element;\n     size +=1;\n     display(arr, size);\n}"}
{"author": "sahadipanjan6", "file": "Programs-in-C__Prime_Numbers_Within_Range.0.c", "original_string": "void main()\n{\n    int lower = 0;\n    int upper = 0;\n    int count = 0;\n    int i, j = 0;\n    printf(\"\\nEnter the lower bound: \");\n    scanf(\"%d\", &lower);\n    printf(\"\\nEnter the upper bound: \");\n    scanf(\"%d\", &upper);\n    printf(\"\\nPrime Numbers within %d and %d are as follows:- \\n\", lower, upper);\n    for(i=lower; i<=upper; i++)\n    {\n        if(isPrime(i) == 1)\n            printf(\"%d\\t\", i);\n        else\n            continue;\n    }\n    printf(\"\\n\");\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__DAG1.0.c", "original_string": "void add_dir(char dir)\n{\n    int i,flag=-1;\n    char root[10];\n    struct graph* p=(struct graph*)malloc(sizeof(struct graph));\n    p->name=dir;\n    p->id=1;\n    printf(\"\\nEnter root directory : \");\n    scanf(\"%s\",root);\n    p->parent=root[0];\n    p->next=NULL;\n    if(root[0]=='!')\n    {\n        G[pos]=p;\n        pos=pos+1;\n    }\n    else\n    {\n        for(i=0;i<pos;i++)\n        {\n            temp=G[i];\n            q=temp->next;\n            while(temp!=NULL)\n            {\n                if(temp->name==root[0])\n                {\n                    p->next=temp->next;\n                    temp->next=p;\n                    flag=1;\n                    break;\n                }\n                else\n                {\n                    temp=temp->next;\n                    q=temp->next;\n                }\n            }\n            if(flag==1)\n                break;\n        }\n    }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__LP.2.c", "original_string": "void delete(int key,int value)\n{\n    int index=H(key);\n    int ct=0,i;\n    if(HASH[index]==value)\n    {\n        HASH[index]=-1;\n        printf(\"\\nValue deleted\");\n        ct++;\n    }\n    else\n    {\n        for(i=index+1;i<10;i++)\n        {\n            if(HASH[i]==value)\n            {\n                HASH[i]=-1;\n                printf(\"\\nValue deleted\");\n                ct++;\n                break;\n            }\n        }\n    }\n    if(ct==0)\n    {\n        printf(\"\\nThe key with that value is not found\");\n    }\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__5_Tablas.1.c", "original_string": "void Tablas(int numero)\n{\n    if(numero <= 10){\n        printf(\"\\n*** Tabla del %i ***\", numero);\n        Multipli(numero, 1);\n        Tablas(++numero);\n    }else{\n        printf(\"\\n***Fin del ciclo***\");\n    }\n}"}
{"author": "2security", "file": "File__6CopyFile.0.c", "original_string": "void main()\n    {\n    int cf  ;\n    cf=copyfile(\"File6To.txt\",\"File6From.txt\");\n    if(cf==1)\n        printf(\"Copy done\");\n    else\n        printf(\"Copy not done\");\n    getch();\n    }"}
{"author": "Sowmyamithra", "file": "Data-Structures__queue1.1.c", "original_string": "void dequeue(int queue[])\n{\n    if(front==-1 || front>rear)\n    {\n        printf(\"\\nqueue is empty\");\n    }\n    else\n    {\n        printf(\"\\nThe value popped is : %d\",queue[front]);\n        front=front+1;\n    }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_beg_CLL.2.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=head;\n    if(head==0)\n    {\n        printf(\"the list is empty\\n\");\n    }\n    while(temp->next!=head)\n    {\n        printf(\"%d \",temp->data);\n        temp=temp->next;\n    }\n    printf(\"%d\",temp->data);\n    printf(\"\\n\");\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_rtx.2.c", "original_string": "bool_t osCreateStaticTask(OsTask *task, const char_t *name, OsTaskCode taskCode,\n   void *param, void *stack, size_t stackSize, int_t priority)\n{\n   task->tid = os_tsk_create_user_ex(taskCode, priority, stack,\n      stackSize * sizeof(uint_t), param);\n   if(task->tid != 0)\n      return TRUE;\n   else\n      return FALSE;\n}"}
{"author": "Theemiss", "file": "simple_shell__more_charfun.0.c", "original_string": "int _strcmp(char *s1, char *s2)\n{\nint cmp = 0, i, len1, len2;\nlen1 = _strlen(s1);\nlen2 = _strlen(s2);\n    if (s1 == NULL || s2 == NULL)\n        return (1);\n    if (len1 != len2)\n        return (1);\n    for (i = 0; s1[i]; i++)\n    {\n        if (s1[i] != s2[i])\n        {\n            cmp = s1[i] - s2[i];\n            break;\n        }\n        else\n            continue;\n    }\n    return (cmp);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSSH__ssh_server.8.c", "original_string": "error_t sshServerStart(SshServerContext *context)\n{\n   error_t error;\n   OsTask *task;\n   if(context == NULL)\n      return ERROR_INVALID_PARAMETER;\n   TRACE_INFO(\"Starting SSH server...\\r\\n\");\n   if(context->running)\n      return ERROR_ALREADY_RUNNING;\n   do\n   {\n      context->socket = socketOpen(SOCKET_TYPE_STREAM, SOCKET_IP_PROTO_TCP);\n      if(context->socket == NULL)\n      {\n         error = ERROR_OPEN_FAILED;\n         break;\n      }\n      error = socketSetTimeout(context->socket, 0);\n      if(error)\n         break;\n      error = socketBindToInterface(context->socket, context->interface);\n      if(error)\n         break;\n      error = socketBind(context->socket, &IP_ADDR_ANY, context->port);\n      if(error)\n         break;\n      error = socketListen(context->socket, 0);\n      if(error)\n         break;\n      context->stop = FALSE;\n      context->running = TRUE;\n      task = osCreateTask(\"SSH Server\", (OsTaskCode) sshServerTask, context,\n         SSH_SERVER_STACK_SIZE, SSH_SERVER_PRIORITY);\n      if(task == OS_INVALID_HANDLE)\n      {\n         error = ERROR_OUT_OF_RESOURCES;\n         break;\n      }\n   } while(0);\n   if(error)\n   {\n      context->running = FALSE;\n      socketClose(context->socket);\n   }\n   return error;\n}"}
{"author": "jose120918", "file": "binary_trees__16-binary_tree_is_perfect.0.c", "original_string": "int _pow(int x, int y)\n{\n    if (y < 0)\n        return (-1);\n    if (y == 0)\n        return (1);\n    if (y > 1)\n    {\n        y = _pow(x, y - 1);\n    }\n    else\n    {\n        return (x * y);\n    }\n    return (x * y);\n}"}
{"author": "qtgeo1248", "file": "AdventofCode2020__b2.2.c", "original_string": "bool is_hair_color(char *field, size_t n) {\n    if (field[0] != '#') return false;\n    for (size_t i = 1; i < n; i++)\n        if ((field[i] < '0' || '9' < field[i])\n            && (field[i] < 'a' || 'f' < field[i]))\n            return false;\n    return true;\n}"}
{"author": "sdukesameer", "file": "dsa__n-rooks_castle-a.0.c", "original_string": "void printboard(int arr[N][N]){\n    static int n=1;\n    printf(\"\\nSolution No. %d: \\n\",n++);\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < N; j++){\n            if(arr[i][j])\n                printf(\" R \");\n            else\n                printf(\" - \");\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "2security", "file": "Matrix__39CheckSparseMatrix.1.c", "original_string": "int CheckSparse(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n            for(j=0;j<c;j++)\n                {\n                    if(mat[i][j]==0)\n                        count++;\n                }\n        }\n    if(count>=(r*c)/2)\n        return 1;\n    else\n        return 0;   \n    }"}
{"author": "dishanp", "file": "DSA__q35.3.c", "original_string": "int main()\n{\n    int n, m;\n    printf(\"Number of elements : \");\n    scanf(\"%d\", &n);\n    int A[n];\n    printf(\"Enter elements : \");\n    for(int i = 0 ; i < n ; i++)\n        scanf(\"%d\", &A[i]);\n    create(A, n);\n    printf(\"Enter value of m : \");\n    scanf(\"%d\", &m);\n    reverse_m(first, m);\n    display(first);\n}"}
{"author": "deepaliajabsingjadhav", "file": "program_in_c_language__check_bit_on_off.1.c", "original_string": "int main()\n{\n    int iNo = 0;\n    BOOL bRet = FALSE;\n    printf(\"Enter number\\n\");\n    scanf(\"%d\",&iNo);\n    bRet = CheckBit(iNo);\n    if(bRet == TRUE)\n    {\n        printf(\"Fourth bit is on\\n\");\n    }\n    else\n    {\n        printf(\"Fourth bit is Off\\n\");\n    }\n    return 0;\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "4lista_de_C__Exercicio_26.0.c", "original_string": "int main()\n{\n        int i;\n        float vet[10];\n        for (i = 0; i < 10; ++i){\n            printf(\"Digite um numero: \");\n            scanf(\"%f\", &vet[i]);\n        }\n            printf(\"\\n Desvio Padrao = %.6f\", calculaDesvioPadrao(vet));\n            system(\"PAUSE\");\n            return 0;\n}"}
{"author": "davibernardos", "file": "DB-Projetos__e6.0.c", "original_string": "int main(int argc, char *argv[]) \n{\n    int modoJogo, jogada1, jogada2, partidas, empates, vencimento1, vencimento2, jogarNovamente, aleatorio, totalPartidas; \n    float vitorias1, vitorias2;\n    empates=0;\n    partidas=0;\n    vencimento1=0;\n    vencimento2=0;\n    jogarNovamente=1; \n    printf (\"*************************\\n | Vamos Jogar Jokempo!| \\n*************************\\n \\nPara iniciar, escolha o modo de jogo: \\n 1- Para Jogar com outra pessoa \\n 2- Para jogar com o computador \\n \");\n    scanf (\"%d\" , &modoJogo);\n    while (modoJogo<1 || modoJogo>2)\n                {\n                    printf(\"Modo de Jogo Invalido! Tente novamnete:\");\n                    scanf(\"%d\" , &modoJogo);\n                }\n    switch (modoJogo)\n    {\n        case 1 :   \n            printf (\"\\n Modo de Jogo 1 \\n\");\n            while ( jogarNovamente == 1)\n            {\n                 printf (\"\\n \\n  Escolhas: \\n 1- Para Pedra \\n 2- Para Papel \\n 3- Para Tesoura \\n \");\n                 printf (\"\\n \\n Vez do Jogador 1:\");\n                 scanf (\"%d\" , &jogada1);\n                    while (jogada1>3 || jogada1<1)\n                {\n                    printf(\"Opcao Invalida! Tente novamnete:\");\n                    scanf(\"%d\" , &jogada1);\n                }\n                 printf (\"\\n \\n Vez do Jogador 2:\");\n                 scanf (\"%d\" , &jogada2);\n                 while (jogada2>3 || jogada2<1)\n                {\n                    printf(\"Opcao Invalida! Tente novamnete:\");\n                    scanf(\"%d\" , &jogada2);\n                }\n                    if ( jogada1 == 1 && jogada2 == 2 )\n                    {\n                       printf(\"\\n RESULTADO: Papel ganha da pedra, Ganhador: Jogador 2\");\n                       partidas++;\n                       vencimento2++;\n                    }else{\n                        if ( jogada1 == 2 && jogada2 == 1 )\n                        {\n                       printf(\"\\n RESULTADO: Papel ganha da pedra, Ganhador: Jogador 1\");\n                       partidas++; \n                       vencimento1++;           \n                        }else{\n                            if ( jogada1 == 1 && jogada2 == 3 )\n                            {\n                             printf(\"\\n RESULTADO: Pedra ganha da tesoura, Ganhador: Jogador 1\");\n                             partidas++;\n                             vencimento1++;\n                            }else{\n                                if ( jogada1 == 3 && jogada2 == 1 )\n                                {\n                                 printf(\"\\n RESULTADO: Pedra ganha da tesoura, Ganhador: Jogador 2\");\n                                 partidas++;\n                                 vencimento2++;\n                                }else{\n                                    if ( jogada1 == 3 && jogada2 == 2)\n                                    {\n                                     printf (\" \\n RESULTADO: Tesoura ganha do papel, Gahador: Jogador 1\");\n                                     partidas++;\n                                     vencimento1++;\n                                    }else{\n                                        if ( jogada1 == 2 && jogada2 == 3 )\n                                        {\n                                         printf(\"\\n RESULTADO: Tesoura ganha do papel, Ganhador: Jogador 2\");\n                                         partidas++;\n                                         vencimento2++;\n                                        }else{\n                                            printf (\"\\n Houve Empate!\");\n                                            empates++;\n                                            }\n                                        }\n                                     }\n                                }\n                            }\n                        }\n                printf(\"\\n \\n Para jogar novamente digite = 1 ou sair digite = 2 : \");\n                scanf(\"%d\" , &jogarNovamente );\n                while (jogarNovamente<1 || jogarNovamente>2)\n                {\n                    printf(\"Opcao Invalida! Tente novamnete:\");\n                    scanf(\"%d\" , &jogarNovamente);\n                }\n            } \n        totalPartidas=partidas+empates;\n        vitorias1=(100*vencimento1)/partidas;\n        vitorias2=(100*vencimento2)/partidas;\n        printf(\" \\n ==============\\n |ESTATISTICAS| \\n ==============\\n Quantidade de Partidas: %d | Quantidade de Empates: %d\" , totalPartidas , empates) ;\n        printf(\"\\n Percentual de Vitotias Jogador 1: %f  \\n Percentual de Votorias Jogador 2: %f \" , vitorias1 , vitorias2);\n                 break;\n        case 2 : \n          printf (\"\\n Modo de Jogo 2 \\n\");\n            while ( jogarNovamente == 1)\n            {\n                 printf (\"\\n \\n  Escolhas: \\n 1- Para Pedra \\n 2- Para Papel \\n 3- Para Tesoura \\n \");\n                 printf (\"\\n \\n Vez do Jogador :\");\n                 scanf (\"%d\" , &jogada1);\n                    while (jogada1>3 || jogada1<1)\n                {\n                    printf(\"Opcao Invalida! Tente novamnete:\");\n                    scanf(\"%d\" , &jogada1);\n                }\n                 srand(time(NULL));\n                 printf (\"\\n \\n Vez do Computador:\" , rand() % 3);\n                 jogada2 = (rand() % 3) +1;\n                 printf(\"%d\" , jogada2);\n                    if ( jogada1 == 1 && jogada2 == 2 )\n                    {\n                       printf(\"\\n RESULTADO: Papel ganha da pedra, Ganhador: Computador\");\n                       partidas++;\n                       vencimento2++;\n                    }else{\n                        if ( jogada1 == 2 && jogada2 == 1 )\n                        {\n                       printf(\"\\n RESULTADO: Papel ganha da pedra, Ganhador: Jogador \");\n                       partidas++; \n                       vencimento1++;           \n                        }else{\n                            if ( jogada1 == 1 && jogada2 == 3 )\n                            {\n                             printf(\"\\n RESULTADO: Pedra ganha da tesoura, Ganhador: Jogador \");\n                             partidas++;\n                             vencimento1++;\n                            }else{\n                                if ( jogada1 == 3 && jogada2 == 1 )\n                                {\n                                 printf(\"\\n RESULTADO: Pedra ganha da tesoura, Ganhador: Computador\");\n                                 partidas++;\n                                 vencimento2++;\n                                }else{\n                                    if ( jogada1 == 3 && jogada2 == 2)\n                                    {\n                                     printf (\" \\n RESULTADO: Tesoura ganha do papel, Gahador: Jogador \");\n                                     partidas++;\n                                     vencimento1++;\n                                    }else{\n                                        if ( jogada1 == 2 && jogada2 == 3 )\n                                        {\n                                         printf(\"\\n RESULTADO: Tesoura ganha do papel, Ganhador: Computador\");\n                                         partidas++;\n                                         vencimento2++;\n                                        }else{\n                                            printf (\"\\n Houve Empate!\");\n                                            empates++;\n                                            }\n                                        }\n                                     }\n                                }\n                            }\n                        }\n                printf(\"\\n \\n Para jogar novamente digite = 1 ou sair digite = 2 : \");\n                scanf(\"%d\" , &jogarNovamente );\n                while (jogarNovamente<1 || jogarNovamente>2)\n                {\n                    printf(\"Opcao Invalida! Tente novamnete:\");\n                    scanf(\"%d\" , &jogarNovamente);\n                }\n            } \n        totalPartidas=partidas+empates; \n        vitorias1=(100*vencimento1)/partidas;\n        vitorias2=(100*vencimento2)/partidas;\n        printf(\" \\n ==============\\n |ESTATISTICAS| \\n ==============\\n Quantidade de Partidas: %d | Quantidade de Empates: %d\" , totalPartidas , empates) ;\n        printf(\"\\n Percentual de Vitotias do Jogador: %f  \\n Percentual de Votorias do Computador: %f \" , vitorias1 , vitorias2);\n        break;\n    }\n    return 0;\n}"}
{"author": "dishanp", "file": "Data-Structures-And-Algorithms__q4.0.c", "original_string": "int main()\n{\n      int *a,n,i,j,t;\n      printf(\"Number of elements : \");\n      scanf(\"%d\",&n);\n      a=(int *)calloc(n, sizeof(int));\n      printf(\"\\nEnter %d Numbers: \\n\\n\",n);\n      for(i=0;i<=n-1;i++)\n      {\n            scanf(\"%d\", (a+i));\n      }\n      for(i=0;i<n-1;i++)\n      {\n            for(j=0;j<n-i-1;j++)\n            {\n                  if(*(a+j)>*(a+j+1))\n                  {\n                        t=*(a+j);\n                        *(a+j)=*(a+j+1);\n                        *(a+j+1)=t;\n                  }\n            }\n      }\n      printf(\"\\nAscending Order: \\n\");\n      for(i=0;i<n;i++)\n      printf(\"%d\\t\",*(a+i));\n      printf(\"\\n\") ;\n      return 0;\n}"}
{"author": "sdukesameer", "file": "dsa__dfs-a.7.c", "original_string": "int main(){\n    gph g;\n    int f=1,x;\n    input(&g);\n    printf(\"\\n\\' If\");\n    for(int i=0; i<g.n;i++)\n        printf(\" %c=%d\",'A'+i,i+1);\n    printf(\" \\'\\nEnter the initial vertex: \");\n    while(f){\n        scanf(\"%d\",&x);\n        if(x>0 && x<g.n+1)\n            f=0;\n        else\n            printf(\"Invalid input.\\n\");\n    }\n    dfs(g,x-1);\n    free_graph(&g);\n}"}
{"author": "fikepaci", "file": "monty__tokenize_string.1.c", "original_string": "int is_delim(char ch, char *delims)\n{\n    int i = 0;\n    while (delims[i])\n    {\n        if (delims[i] == ch)\n            return (1);\n        i++;\n    }\n    return (0);\n}"}
{"author": "paawankohli", "file": "DSA-LAB__inToPost.2.c", "original_string": "int infixToPostfix(char* exp, char* ans) \n{ \n    int i, k = 0; \n    stack s;\n    for (i = 0 ; exp[i] != '\\0' ; i++) \n    { \n        if (isOperand(exp[i]))      \n            ans[k++] = exp[i]; \n        else if (exp[i] == '(')     \n            push(&s, exp[i]); \n        else if (exp[i] == ')')     \n        { \n            while (!isEmpty(&s) && top(&s) != '(') \n                ans[k++] = pop(&s); \n            pop(&s);  \n        } \n        else            \n        { \n            while ( !isEmpty(&s) && prec(exp[i]) <= prec(top(&s)) ) \n                ans[k++] = pop(&s); \n            push(&s, exp[i]); \n        } \n    } \n    while (!isEmpty(&s))            \n        ans[k++] = pop(&s); \n    ans[k- 1] = '\\0';  \n}"}
{"author": "GirijalaAditya", "file": "CNP-Lab__portex.0.c", "original_string": "int main() \n{ \nint sockfd; \nstruct sockaddr_in serv_addr; \ntime_t  now; \nchar timestr[100]; \nchar a[50],a1[50]; \nsockfd=socket(AF_INET,SOCK_STREAM,0); \nif(sockfd<0) \n{ \nprintf(\"\\n Socket Failed\"); \nexit(0); \n} \nserv_addr.sin_family=AF_INET; \nserv_addr.sin_addr.s_addr=inet_addr(\"192.168.125.129\"); \nserv_addr.sin_port=htons(13); \nif(connect(sockfd,(struct sockaddr *)&serv_addr,sizeof(serv_addr))<0) \n{ \nprintf(\"\\n Connection Failed\"); \nexit(0); \n} \ntime(&now); \nsprintf(timestr,\"%s\",ctime(&now)); \nprintf(\"%s\",timestr); \nclose(sockfd); \n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__sender0.2.c", "original_string": "int frame_construction(unsigned char *sta_addr, unsigned char *des_addr,\n                        unsigned short protocol, unsigned char *payload,\n                        unsigned int payload_len)\n{   \n    if(payload_len < 46){\n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(payload_len >1500){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    memcpy(&frame[0],des_addr,6);\n    memcpy(&frame[6],sta_addr,6);\n    memcpy(&frame[12],&protocol,sizeof(protocol));\n    memcpy(&frame[14],payload,payload_len);\n    init_crc_table();\n    unsigned int crc32_result = crc32(frame,14+payload_len);\n    memcpy(&frame[14+payload_len],&crc32_result,sizeof(crc32_result));\n        unsigned char crc32_result_[4];\n    memcpy(crc32_result_,&crc32_result,sizeof(crc32_result));\n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: %x\\n\",sta_addr);\n    printf(\"Des address  : %x\\n\",des_addr);\n    printf(\"protocol     : %x\\n\",protocol);\n    printf(\"payload      : %x\\n\",payload);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result_,4);\n    printf(\"**************************************\\n\");\n    return payload_len+6+6+sizeof(protocol)+sizeof(crc32_result);\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad10-PointerFunctions.1.c", "original_string": "void printAvgYear(float pointer[][0]){\n    float * rok;        \n    float * miesiac;    \n    float podsuma, suma;\n    int licznik = 0;\n    for(rok = *pointer, suma = 0; rok <= *pointer + 48; rok = rok + 12){\n        for(miesiac = *pointer + (12*licznik) , podsuma = 0; miesiac <= *pointer + 11 + (12*licznik); miesiac++){\n            podsuma += *miesiac;\n        }\n        printf(\"%5d %12.1f\\n\", 1995 + licznik, podsuma);\n        licznik++;\n        suma += podsuma;\n    }\n    printf(\"\\nRoczna srednia wynosi %.1f cm.\\n\\n\", suma/LATA);\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__InsertionOfNodeAtEndInLL.1.c", "original_string": "int main()\n{\n    int choice = 1;\n    struct node*head,*temp;\n    head = NULL;\n    struct node*newnode;\n    while(choice)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the element in the node:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->link = NULL;\n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }   \n        else\n        {\n            temp->link = newnode;\n            temp = newnode;\n        }\n        printf(\"DO YOU WANT TO ENTER MORE NODES?(0/1)\");\n        scanf(\"%d\",&choice);\n    }\n    insert_at_end(temp);\n    temp = head;\n    int count = 0;\n    printf(\"THE ENTERED ELEMENTS IN THE NODE ARE\\n\");\n    while(temp!=NULL)\n    {\n        count++;\n        printf(\"%d\\t\",temp->data);\n        temp = temp->link; \n    }\n    printf(\"\\nCount : %d\",count);\n    return 0;\n}"}
{"author": "2security", "file": "Matrix__24SubMatrix.0.c", "original_string": "void displayMat(int mat[][20],int r,int c)\n    {\n    int i,j;\n    for(i=0;i<r;i++)\n        {\n        for(j=0;j<c;j++)\n        printf(\"%d \",mat[i][j]);\n        printf(\"\\n\");\n        }\n    }"}
{"author": "ael-bagh", "file": "cub3dXFileParsing__routing_utils.2.c", "original_string": "int     s_p(char *s, char c)\n{\n    int i;\n    i = 0;\n    while (s[i] == c && s[i])\n        i++;\n    return (i);\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__doublyLinkedList.1.c", "original_string": "struct Node *insertAtFirst(struct Node *head, int data)\n{\n     struct Node *ptr = (struct Node *)malloc(sizeof(struct Node));\n     ptr->next = head;\n     ptr->data = data;\n     head->prev = ptr;\n     ptr->prev = NULL;\n     return ptr;\n}"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__str_capitilizer.2.c", "original_string": "int     main(int ac, char **av)\n{\n    int i;\n    int j;\n    if (ac > 1)\n    {\n        i = 1;\n        while (i < ac)\n        {\n            j = 0;\n            while (av[i][j])\n            {\n                if (av[i][0] >= 'a' && av[i][0] <= 'z')\n                    av[i][0] -= 32;\n                else if (ft_tolower(av[i][j - 1], av[i][j], j - 1))\n                    av[i][j] += 32;\n                else if (ft_toupper(av[i][j - 1] , av[i][j]))\n                    av[i][j] -= 32;\n                write(1, &av[i][j], 1);\n                j++;\n            }\n            i++;\n            write(1, \"\\n\", 1);\n        }\n    }\n    else\n        write(1, \"\\n\",1);\n    return (0);\n}"}
{"author": "ria3999", "file": "Basic-C-Programs__9sumof_rows_and_columns.0.c", "original_string": "void main()\n{\n    int a[90][90],r,c,i,j;\n    printf(\"enter no. of rows and columns\");\n    scanf(\"%d%d\",&r,&c);\n    printf(\"enter array elements\");\n    for(i=0;i<r;i++)\n    {\n        for(j=0;j<c;j++)\n        {\n            scanf(\"%d\",&a[i][j]);\n        }\n    }\n}"}
{"author": "andi-s0106", "file": "sorting_algorithms__3-quick_sort.1.c", "original_string": "void quicksort(int *array, int lo, int hi, size_t size)\n{\n    int q;\n    if (lo < hi)\n    {\n        q = partition(array, lo, hi, size);\n        quicksort(array, lo, q - 1, size);\n        quicksort(array, q + 1, hi, size);\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__n-bishop-a.0.c", "original_string": "void printboard(int arr[N][N]){\n    static int n=1;\n    printf(\"\\nSolution No. %d: \\n\",n++);\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < N; j++){\n            if(arr[i][j])\n                printf(\" R \");\n            else\n                printf(\" - \");\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linearBinarySearch.0.c", "original_string": "int linearSearch(int arr[], int size, int element){\n     for (int i =0; i < size; i++){\n          if(arr[i]== element){\n               return 1;\n          }\n     }\n     return -1;\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__ledRUN.1.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_freertos.2.c", "original_string": "OsTask *osCreateTask(const char_t *name, OsTaskCode taskCode,\n   void *param, size_t stackSize, int_t priority)\n{\n   portBASE_TYPE status;\n   TaskHandle_t task = NULL;\n   status = xTaskCreate((TaskFunction_t) taskCode, name, stackSize, param,\n      priority, &task);\n   if(status == pdPASS)\n      return task;\n   else\n      return NULL;\n}"}
{"author": "gokulsreekumar", "file": "ProgrammingQuestionsReference__ASSG3_B180575CS_GOKUL_9.2.c", "original_string": "int enqueue(queue *Qref,int element)\n{\n    if(isFull(*Qref))\n        return -999;\n    else\n    {\n        if((*Qref).front == -1)\n            (*Qref).front = 0;\n        (*Qref).rear = ((*Qref).rear + 1) % (*Qref).size;\n        (*Qref).arr[(*Qref).rear] = element;\n    }\n    return 0;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__peekInStack.3.c", "original_string": "int pop(struct stack*ptr){\n    if(isEmpty(ptr)){\n        printf(\"Stack Underflow! Cannot pop from the stack\\n\");\n        return -1;\n    }\n    else{\n        int val = ptr->arr[ptr->top];\n        ptr->top--;\n        return val;\n    }\n}"}
{"author": "kalpa96", "file": "Struct__comple.0.c", "original_string": "int main()\n{\n    struct complex n1,n2,result,result1,result2;\n    printf(\"For 1st complex number \\n\");\n    printf(\"Enter the real parts : \");\n    scanf(\"%f\",&n1.real);\n    printf(\"Enter the imaginary parts : \");\n    scanf(\"%f\",&n1.imag);\n    printf(\"\\nFor 2nd complex number \\n\");\n    printf(\"Enter the real parts : \");\n    scanf(\"%f\",&n2.real);\n    printf(\"Enter the imaginary parts : \");\n    scanf(\"%f\",&n2.imag);\n    printf(\"\\n\");\n    result=add(n1,n2);\n    printf(\"Sum value = %.1f + %.1fi\\n\", result.real, result.imag);\n    result1=subtract(n1,n2);\n    printf(\"Subtraction value = %.1f - %.1fi\\n\", result1.real, result1.imag);\n    result2=multiply(n1,n2);\n    printf(\"Multiply value = %.1f - %.1fi\\n\", result2.real, result2.imag);\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__atividade1.0.c", "original_string": "void bresenham1(int x1, int y1, int x2, int y2){        \n        int slope;\n        int dx, dy, incE, incNE, d, x, y; \n        if (x1 > x2 && y1 > y2){\n            bresenham1(x2, y2, x1, y1);\n             return;\n        }        \n        dx = x2 - x1;\n        dy = y2 - y1;\n        if (dy < 0){            \n            slope = -1;\n            dy = -dy;\n        }\n        else{            \n           slope = 1;\n        }\n        incE = 2 * dy;\n        incNE = 2 * dy - 2 * dx;\n        d = 2 * dy - dx;\n        y = y1;\n    printf(\"dx = %d\\n\", dx);\n    printf(\"dy = %d\\n\",dy);\n    printf(\"2dy = %d\\n\",incE);\n    printf(\"2dy-2dx %d\\n\",incNE);\n    int tam;\n    if (x2 - x1 > 0){\n        tam = x2 - x1;\n    }\n    else if(x2-x1==0){\n        tam = y2-y1;\n    }\n    else{\n        tam = -(x2 - x1);\n    }\n    int vecX[tam];\n    int vecY[tam];\n    int vecPk[tam];\n    int i =0;\n        if(x2-x1 == 0){\n            while(y1 < y2){\n                if (d < 0){\n                  d = d + incE;\n                }\n                else{\n                  d = d + incNE;\n                  x = x + slope;\n                }\n                vecPk[i] = d;\n                vecX[i] = x1;\n                vecY[i] = y1;\n                i++;\n                y1++;\n            }\n        }else{\n            while(x1 < x2){\n                if (d < 0){\n                  d = d + incE;\n                }\n                else{\n                  d = d + incNE;\n                  y = y + slope;\n                }\n            vecPk[i] = d;\n            vecX[i] = x1;\n            vecY[i] = y;\n            i++;\n            x1++;\n            }\n        }\n    printf(\"X  | \");\n    for (int i = 0; i < tam; i++)\n    {\n        printf(\"%d \", vecX[i]);\n    }\n    printf(\"\\n\");\n    printf(\"Y  | \");\n    for (int i = 0; i < tam; i++)\n    {\n        printf(\"%d \", vecY[i]);\n    }\n    printf(\"\\n\");\n    printf(\"Pk | \");\n    for (int i = 0; i < tam; i++)\n    {\n        printf(\"%d \", vecPk[i]);\n    }\n    printf(\"\\n\");\n }"}
{"author": "seefeesaw", "file": "C-Exam-Alone-In-The-Dark__brainfuck.0.c", "original_string": "int     counter(char *src, int ctrl)\n{\n    int dir;\n    int count;\n    count = 0;\n    if (src[ctrl] == '[')\n        dir = 1;\n    if (src[ctrl] == ']')\n        dir = -1;\n    while(src[ctrl])\n    {\n        if (src[ctrl] == '[')\n            count++;\n        if (src[ctrl] == ']')\n            count--;\n        if ((src[ctrl] == '[' || src[ctrl] == ']') && count == 0)\n            return (ctrl);\n        ctrl += dir;\n    }\n    return (0);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__stp_operation.1.c", "original_string": "void stpReceivedTcnBpdu(StpBridgePort *port, const StpBpdu *bpdu)\n{\n   if(port->state != STP_PORT_STATE_DISABLED && port->macOperState)\n   {\n      if(stpDesignatedPort(port))\n      {\n         stpTopologyChangeDetection(port->context);\n         stpAckTopologyChange(port);\n      }\n   }\n}"}
{"author": "haon1026", "file": "linux-programming__pthread_cancel.1.c", "original_string": "int main()\n{\n    pthread_t tid;\n    int ret = pthread_create(&tid, NULL, thread_fun, NULL);\n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_create error:%s\\n\", strerror(errno));\n        exit(1);\n    }\n    printf(\"main:pid = %d, tid = %lu\\n\", getpid(), pthread_self());\n    sleep(5);\n    ret = pthread_cancel(tid);          \n    if(ret != 0)\n    {\n        fprintf(stderr, \"pthread_cancel error:%s\\n\", strerror(errno));\n        exit(1);\n    }\n    while(1);\n    return 0;    \n}"}
{"author": "sdukesameer", "file": "dsa__stk-push-pop.4.c", "original_string": "void pop(stack* stk)\n{\n    if(is_empty(stk))\n        printf(\"STACK EMPTY!\\n\");\n    else\n        printf(\"%d popped from stack.\\n\",stk->arr[stk->top--]);\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_prs.2.c", "original_string": "void rstpPrsChangeState(RstpBridgeContext *context, RstpPrsState newState)\n{\n   TRACE_VERBOSE(\"PRS state machine %s -> %s\\r\\n\",\n      rstpGetParamName(context->prsState, rstpPrsStates, arraysize(rstpPrsStates)),\n      rstpGetParamName(newState, rstpPrsStates, arraysize(rstpPrsStates)));\n   context->prsState = newState;\n   switch(context->prsState)\n   {\n   case RSTP_PRS_STATE_INIT_BRIDGE:\n      rstpUpdtRoleDisabledTree(context);\n      break;\n   case RSTP_PRS_STATE_ROLE_SELECTION:\n      rstpClearReselectTree(context);\n      rstpUpdtRolesTree(context);\n      rstpSetSelectedTree(context);\n      break;\n   default:\n      break;\n   }\n   context->busy = TRUE;\n}"}
{"author": "RafaelFelisbino-hub", "file": "MATRIZ-exercices__Exercicio16MATRIZ.0.c", "original_string": "int main() \n{\n    int vetorA[5], vetorB[5], matrizC[2][5], i , j;\n    for (i = 0; i < 5; i++)\n    {\n        printf(\"Informe os valores do vetor A:  \");\n        scanf_s(\"%i\", &vetorA[i]);\n    }\n    for (i = 0; i < 5; i++) \n    {\n        printf(\"Informe os valores do vetor B:  \");\n        scanf_s(\"%i\", &vetorB[i]);\n    }\n    for (j = 0; j < 5; j++)\n    {\n        matrizC[0][j] = vetorA[j];\n        matrizC[1][j] = vetorB[j];\n    }\n    for (i = 0; i < 2; i++)\n        for (j = 0; j < 5; j++)\n            printf(\"A matriz com os vetores A e B e: %d linha,  %d coluna  %i\\n\", i, j, matrizC[i][j]);\n    system(\"pause\");\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__Paging.3.c", "original_string": "void display_table()\n{\n    int i,j;\n    printf(\"\\nProgram_id\\tsize\\tpages\\n\");\n    for(i=0;i<index1;i++)\n    {\n        printf(\"\\n%d\\t%d\\t\",t[i].id,t[i].size);\n        for(j=0;j<16;j++)\n        {\n            if(t[i].indices[j]!=-1)\n            {\n                printf(\"%d \",t[i].indices[j]);\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__MergeSort.2.c", "original_string": "void putdata(int x[50], int n)\n       {\n        int k;\n        for(k=0;k<n;k++)\n         {\n          printf(\"%d\\t\",x[k]);\n         }\n          printf(\"\\n\");\n        }"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Reverse_Of_A_Single_Linked_List.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"PRESS 1 FOR CREATION OR ELSE PRESS 0 FOR TERMINATION:\");\n    scanf(\"%d\",&choice);\n    struct node*head,*temp;\n    head = temp = NULL;\n    struct node*newnode;\n    while(choice!=0)\n    {\n        newnode = (struct node*) malloc (sizeof(struct node));\n        printf(\"Enter the data:\");\n        scanf(\"%d\",&newnode->data);\n        newnode->ptr = NULL;\n        if(head == NULL)\n        {\n            head = temp = newnode;\n        }\n        else\n        {\n            temp->ptr = newnode;\n            temp = newnode;\n        }\n        printf(\"DO YOU WANT TO ENTER MORE?(1/0)\");\n        scanf(\"%d\",&choice);\n    }\n    temp = head;\n    display_node(temp);\n    reverse_node(head,temp);\n    getch();    \n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__lcd_func.3.c", "original_string": "void delay(int ct)\n{\n    int i,j;\n    for(i=0;i<ct;++i)\n    {\n        for(j=0;j<6000;++j)             \n        {}\n    }\n}"}
{"author": "ankitraj311", "file": "450_babbar__4_0_1_2_array_GEEk.3.c", "original_string": "int main()\n{\n  int arr[] = {0,1,1,0,1,2,1,2,0,0,0,1};\n  int no = 12;\n  printf(\"Array is :- \");\n  array_print(arr,no);\n  sort(arr,no);\n  printf(\"\\n\");\n  array_print(arr,no);\n}"}
{"author": "DiegoMendezMedina", "file": "The-C-Programming-Language__3-1.2.c", "original_string": "int binsearchv2(int x, int v[], int n){\n  int low, high, mid;\n  low = 0;\n  high = n-1;\n  while(low < high){\n    mid = (low+high)/2;\n    if(x < v[mid])\n      high = mid-1;\n    else\n      low = mid+1;\n  }\n  if(v[low-1] == x)\n    return low-1;\n  else if(v[low] == x)\n    return low;\n  else if(v[low+1] == x)\n    return low+1;\n  return -1; \n}"}
{"author": "2security", "file": "Array__TraceNormMat.0.c", "original_string": "int main()\n    {\n    int i,j,r,c,**mat,sum=0;\n    printf(\"Enter the row & col. of the matrix \");\n    scanf(\"%d%d\",&r,&c);\n    if(r!=c)\n        printf(\"For determinant matrix should be square\");\n    else\n        {\n        mat=(int **)malloc(r*sizeof(int *));        \n        for(i=0;i<r;i++)\n            mat[i]=(int *)malloc(c*sizeof(int ));   \n        printf(\"\\n Enter the matrix \\n\");\n        for(i=0;i<r;i++)\n            {\n            for(j=0;j<c;j++)\n                {\n                scanf(\"%d\",&mat[i][j]);\n                sum=sum+mat[i][j]*mat[i][j];\n                }\n            }\n        printf(\"The matrix is:\\n\");\n        displayMat(mat,r,c);\n        printf(\"\\nTrace of the matrix is= %d\",traceMat(mat,r,c));\n        printf(\"\\nNorm of the matrix is=%f\",sqrt((double)sum));\n        }\n    return 0;\n    }"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes.14.c", "original_string": "void imprimir_alumno_por_fila(int posicion){\n    printf(\"%d\\t\\t%s\\t\", lista_estudiantes[posicion].matricula, lista_estudiantes[posicion].nombre);\n    for (int i = 0; i < MAX_CALIFICACIONES; i++){\n        printf(\"%.2f\\t\", lista_estudiantes[posicion].calificaciones[i]);\n    }\n    printf(\"\\n\");\n}"}
{"author": "mandarvu", "file": "msc__problem7.0.c", "original_string": "void reverse_array(int *origin, int *rev) {\n  int j = 0;\n  for (int i = MAX - 1; i >= 0; i--)\n    {\n        *(rev + j) = *(origin + i);\n        j++;\n    }\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_rtx.17.c", "original_string": "bool_t osWaitForSemaphore(OsSemaphore *semaphore, systime_t timeout)\n{\n   uint16_t n;\n   OS_RESULT res;\n   if(timeout == INFINITE_DELAY)\n   {\n      res = os_sem_wait(semaphore, 0xFFFF);\n   }\n   else\n   {\n      timeout = OS_MS_TO_SYSTICKS(timeout);\n      do\n      {\n         n = MIN(timeout, 0xFFFE);\n         res = os_sem_wait(semaphore, n);\n         timeout -= n;\n      } while(res == OS_R_TMO && timeout > 0);\n   }\n   if(res == OS_R_OK || res == OS_R_SEM)\n      return TRUE;\n   else\n      return FALSE;\n}"}
{"author": "kbtomic", "file": "StrukturePodataka__zad9.2.c", "original_string": "treePointer InsertElement(int element, treePointer root)\n{\n    if (!root)\n        return AllocateMemory(element);\n    else if (element < root->data)\n        root->left = InsertElement(element, root->left);\n    else if (element > root->data)\n        root->right = InsertElement(element, root->right);\n    return root;\n}"}
{"author": "abhijeetmurmu1997", "file": "C-Programming-__NumberSeriesProgram.0.c", "original_string": "int main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    if(n%2 == 1)\n    {\n        fibonnaciSeries(n/2 + 1);\n    }\n    else\n    primeSeries(n/2);\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__70.1.c", "original_string": "int main(int argc, char **argv)\n{\n    FILE *arq;\n    aluno_t *alunos;\n    char aux;\n    int x;\n    if (argc < 2)\n    {\n        printf(\"\\nErro! N\u00e3o foi informado o nome do arquivo.\\n\\n\");\n        return 0;\n    }\n    arq  = fopen(argv[1], \"r\");\n    if (arq == NULL)\n    {\n        printf(\"\\nErro ao abrir o arquivo.\\n\\n\");\n        return 0;\n    }\n    int i = 1;\n    while (fscanf(arq, \"%c\", &aux) != EOF)\n    {\n        if (aux == '\\n')\n        {\n            i++;\n        }\n    }\n    rewind(arq);\n    if (i % 3 == 0)\n    {\n        i /= 3;\n    }\n    else\n    {\n        printf(\"\\nInforma\u00e7\u00f5es insuficientes.\\n\\n\");\n        return 0;\n    }\n    alunos = malloc(i * sizeof(aluno_t));\n    for (int j = 0; j < i; j++)\n    {\n        fscanf(arq, \"%s\", alunos[j].nome);\n        fscanf(arq, \"%i\", &alunos[j].semestre);\n        fscanf(arq, \"%f\", &alunos[j].ra);\n    }\n    printf(\"\\nDigite um semestre: \");\n    scanf(\"%i\", &x);\n    getchar();\n    imprime_sem(alunos, x, i);\n    fclose(arq);\n    return 0;\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es4.0.c", "original_string": "int main(void) {\n  double x, y;\n    int risultato;\n  printf(\"Inserisci il primo numero: \");\n  scanf(\"%lf\", &x);\n    printf(\"Inserisci il secondo numero: \");\n  scanf(\"%lf\", &y);\n  risultato = idk(x, y);\n  printf( \"Risultato: %d\\n\", risultato ); \n  return 0;\n}"}
{"author": "paawankohli", "file": "CN-Lab__server.0.c", "original_string": "void main () {\n    struct sockaddr_in serverAddress;\n    struct sockaddr_in clientAddress;\n    int sockaddr_len = sizeof(struct sockaddr_in);\n    int serverfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (serverfd == -1) {\n        printf(\"Couldn't create socket! Exited.\\n\");\n        exit(0);\n    } else {\n        printf(\"Socket created successfully!\\n\");\n    }\n    serverAddress.sin_family = AF_INET;\n    serverAddress.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serverAddress.sin_port = PORT;\n    int status = bind(serverfd, (struct sockaddr*) &serverAddress, sockaddr_len);\n    if (status == -1) {\n        printf(\"Couldn't bind socket! Exited.\\n\");\n        exit(0);\n    } else {\n        printf(\"Socket binded successfully!\\n\");\n    }\n    status = listen(serverfd, 5);\n    if (status == -1) {\n        printf(\"Couldn't start listening! Exited.\\n\");\n        exit(0);\n    } else {\n        printf(\"Server listening at port: PORT\\n\\n\");\n    }\n    while (1) {\n        printf(\"Server waiting for connection....\\n\");\n        int clientfd = accept(serverfd, (struct sockaddr*) &clientAddress, &sockaddr_len);\n        if (clientfd == -1) {\n            printf(\"Couldn't accept connection request! Exited.\\n\");\n            exit(0);\n        } else {\n            char *clientIP = inet_ntoa(clientAddress.sin_addr);\n            int clientPort = clientAddress.sin_port;\n            printf(\"Connection request accepted from \");\n            printf(\"%s : %d\\n\", clientIP, clientPort);\n        }\n        char ch;\n        read(clientfd, &ch, 1);\n        ch++;\n        write(clientfd, &ch, 1);\n        close(clientfd);\n        printf(\"Connection closed\\n\");\n    }\n}"}
{"author": "sdukesameer", "file": "dsa__bst-ins-seq-rec-in-pre-post-a.0.c", "original_string": "list *newNode(int item) \n{ \n    list *temp = (list *)malloc(sizeof(list)); \n    temp->key = item; \n    temp->left = temp->right = NULL; \n    return temp; \n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__primos.1.c", "original_string": "int es_primo(int numero){\n    for (int i = 2; i <= sqrt(numero); i++){\n        if ( numero % i == 0){\n            return 0;\n        }\n    }\n    return 1;\n}"}
{"author": "sdukesameer", "file": "c__rec_quick_sort.0.c", "original_string": "void printArray(int arr[])\n{\n    int i;\n    for (i=0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_rtx.25.c", "original_string": "void osFreeMem(void *p)\n{\n   if(p != NULL)\n   {\n      TRACE_DEBUG(\"Freeing memory at 0x%08X\\r\\n\", (uint_t) p);\n      osSuspendAllTasks();\n      free(p);\n      osResumeAllTasks();\n   }\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad30.0.c", "original_string": "int main()\n{\n    int array[10];\n    int userNumber;\n    int licznik = 0;\n    int smallestNum;\n    int smallestIndex;\n    while(licznik < 10) {\n        printf(\"Podaj liczbe nr %d do tablicy: \", licznik + 1);\n        scanf(\"%d\", &userNumber);\n        array[licznik] = userNumber;\n        licznik++;\n    }\n    smallestNum = array[0];\n    smallestIndex = 0;\n    for(int i = 1; i < 10; i++){\n        if(array[i] < smallestNum) {\n            smallestNum = array[i];\n            smallestIndex = i;\n        }\n    }\n    printf(\"\\nNajmniejsza liczba w tablicy: %d\\n\", smallestNum);\n    printf(\"Indeks najmniejszej liczby w tablicy: %d\\n\", smallestIndex);\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "dishanp", "file": "DSA__q25.1.c", "original_string": "void count_key(struct node *p, int key)\n{\n    int counter = 0;\n    while(p)\n    {\n        if(p->data == key)\n            counter++;\n        p = p->next;\n    }\n    printf(\"Occurences of %d : %d\\n\", key, counter);\n}"}
{"author": "RobertoBenjami", "file": "stm32_character_display_drivers__stm32f1xx_hal_cortex.15.c", "original_string": "void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)\n{\n  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));\n  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)\n  {\n    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;\n  }\n  else\n  {\n    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;\n  }\n}"}
{"author": "DiegoMendezMedina", "file": "Competitive_Programming__unique.3.c", "original_string": "int valid_array(int ns[], int x){\n  int sum;\n  sum = 0;\n  for(int i = 0; i < 9; i++)\n    sum += ns[i];\n  return (sum == x)? 1 : 0;\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__stack_using_linked_list.1.c", "original_string": "void display()\n{\n    struct node *temp;\n    temp=top;\n    if(top==0)\n    {\n        printf(\"the stack is empty\\n\");\n    }\n    else\n    {\n        printf(\"the elements in the stack are\\n\");\n        while(temp!=0)\n        {\n            printf(\"%d \",temp->data);\n            temp=temp->next;\n        }\n        printf(\"\\n\");\n    }\n}"}
{"author": "MFarid94", "file": "Assignement3__Exercise16.0.c", "original_string": "void ReverseArray(int arr[] ,int size){\n    int i, temp;\n    for(i=0 ; i<size/2 ; i++){\n        temp = arr[i];\n        arr[i] = arr[size-1 - i];\n        arr[size-1 -i] = temp;\n    }\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__deletionAtGivenInfo.1.c", "original_string": "struct Node * deleteByInfo(struct Node*head, int value){\n     struct Node*ptr=head;\n     struct Node*q=head->next;\n     while(q->data!=value){\n          ptr=ptr->next;\n          q=q->next;\n     };\n     ptr->next=q->next;\n     free(q);\n     return head; \n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader0.3.c", "original_string": "void firmwareUpdateInfoReader_explain(char *programDir)\n{\n  char *sep = (strlen(programDir) > 0) ? (separator()) : (\"\");\n  printf(\"Waiting for firmware update info to be entered and saved in '%s%s%s' file\\n(if this file has not been opened automatically already, just open it manually in an editor of your choice)\\n\", programDir, sep, DEMO_PRODUCT_UPDATE_INFO_FILE_NAME);\n  printf(\"Expected firmware update info format: <new-version>:<checksum-or-signature> (e.g., 1.1:8639e6e80b089338e51fac17d5faa647c4c05368e46af5c42583fb34c0) \\n\");\n}"}
{"author": "christiane-millan", "file": "UTM2020B-131A-311013-Structured-Programming__control_estudiantes2.1.c", "original_string": "void imprimir_menu(){\n    char mensaje[MAX] = \"SISTEMA DE CONTROL DE CALIFICACIONES\";\n    system(\"clear\");\n    printf(\"----------------------------------------------\\n\");\n    printf(\"%s\\n\", mensaje);\n    printf(\"----------------------------------------------\\n\");\n    printf(\"Menu de opciones\\n\");\n    printf(\"----------------------------------------------\\n\");\n    printf(\"1. Agregar alumno\\n\");\n    printf(\"2. Modificar alumno\\n\");\n    printf(\"3. Modificar calificaciones\\n\");\n    printf(\"4. Imprimir datos del alumno\\n\");\n    printf(\"5. Lista de alumnos\\n\");\n    printf(\"6. Pase de lista\\n\");\n    printf(\"7. Salir\\n\");\n    printf(\"Ingresa una opci\u00f3n: \\n\");\n}"}
{"author": "sdukesameer", "file": "c__sort-structure.0.c", "original_string": "int enterStudents(StudentType students[]){\n    int c=0;\n    while(1)\n    {\n        if(c>NAME_SIZE){\n            printf(\"OVERFLOW\");\n            break;\n        }\n        scanf(\"%d\",&students[c].rollNo);\n        if(students[c].rollNo==0)\n            break;\n        scanf(\"%[^\\n]s\",students[c].name);\n        c++;\n    }\n    if(c==0){\n        printf(\"Empty list\");\n        exit(1);\n    }\n    return c;\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__flor.2.c", "original_string": "void retangulo(){\n  glBegin(GL_POLYGON);\n  glVertex2f(-0.05, -0.05);\n  glVertex2f(0.05, -0.05);\n  glVertex2f(0.05, -0.95);\n  glVertex2f(-0.05, -0.95);\n  glEnd();\n}"}
{"author": "DanielSalis", "file": "UNIFESP_Comp-Grafica__robo.4.c", "original_string": "void display_function()\n{\n  glClearColor(0, 0, 0, 0);\n  glClear(GL_COLOR_BUFFER_BIT);\n  glLoadIdentity();\n  glPushMatrix();\n    glColor3f(1.0, 1.0, 1.0);\n    glRectf(-0.1, 0.8, 0.1, 0.6);\n  glPopMatrix();\n  glPushMatrix();\n    glTranslatef(-0.06 , 0.75 , 0.0);\n    glColor3f(1.0, 0, 0);\n    circulo();\n  glPopMatrix();\n  glPushMatrix();\n    glTranslatef(0.06, 0.75, 0.0);\n    glColor3f(1.0, 0, 0);\n    circulo();\n  glPopMatrix();\n  glPushMatrix();\n    glColor3f(0, 0, 1);\n    triangulo(0.0,0.73, -0.05,0.68, 0.05,0.68);\n  glPopMatrix();\n  glPushMatrix();\n    glColor3f(1, 0.5, 0.5);\n    glRectf(-0.05, 0.64, 0.05, 0.62);\n  glPopMatrix();\n  glPushMatrix();\n  glTranslatef(-0.2, 0.45, 0);\n  glRotatef(thetaBraco, 0.0, 0.0, 1.0);\n  glColor3f(1, 0.1, 1);\n  glRectf(-0.4, 0.05, 0.2, -0.05);\n  glPopMatrix();\n  glPushMatrix();\n  glTranslatef(0.20, 0.45, 0);\n  glRotatef(-thetaBraco, 0.0, 0.0, 1.0);\n  glColor3f(1, 0.1, 1);\n  glRectf(-0.2, 0.05, 0.4, -0.05);\n  glPopMatrix();\n  glPushMatrix();\n    glTranslatef(0.0, 0.2, 0);\n    glColor3f(0.0, 1.0, 0.0);\n    glRectf(-0.2, 0.4, 0.2, -0.4);\n  glPopMatrix();\n  glPushMatrix();\n    glTranslatef(0.1, -0.2, 0);\n    glColor3f(0.0, 1.0, 0.0);\n    glRotatef(thetaPerna, 0.0, 0.0, 1.0);\n    glRectf(-0.05, 0.3, 0.05, -0.3);\n  glPopMatrix();\n  glPushMatrix();\n    glTranslatef(-0.1, -0.2, 0);\n    glColor3f(0.0, 1.0, 0.0);\n    glRotatef(-thetaPerna, 0.0, 0.0, 1.0);\n    glRectf(-0.05, 0.3, 0.05, -0.3);\n  glPopMatrix();\n  glFlush();\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__Main.0.c", "original_string": "int32_t main(int32_t argc, char *argv[])\n{\n  char *programDir = dirname(_strdup(argv[0]));\n  _chdir(programDir);\n  printf(\"\\n--------------------------------------------------------------------------\\n\");\n  printf(\"Running %s %s firmware\\n\", DEMO_PRODUCT_NAME, DEMO_PRODUCT_FIRMWARE_VERSION);\n  printf(\"--------------------------------------------------------------------------\\n\\n\");\n  firmwareUpdateInfoReader_init();\n  fotaUpdateWorkflow_init();\n  fotaUpdateSelfTest_init();\n  fotahub_init(argv[0], DEMO_PRODUCT_ID, DEMO_PRODUCT_NAME, &FOTA_UPDATE_CLIENT_CONFIG);\n  fotahub_notifyNetworkStatusChange(NETWORK_ADAPTER_STATUS_CONNECTED);\n  firmwareUpdateInfoReader_explain(programDir);\n  while (true)\n  {\n    firmwareUpdateInfoReader_run();\n    fotahub_run();\n  }\n}"}
{"author": "ankitraj311", "file": "Socket-thread__sum_without_thread.1.c", "original_string": "int main()\n{\n  clock_t start, end;\n  double cpu_time_used;\n  start = clock();\n  unsigned long sum = 0, i =0;\n  sum = addall();\n  end = clock();\n  cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;\n  printf(\"Sum of the numbers till 100 Crore is %lu and Time taken by Program without thread is %f\",sum,cpu_time_used);\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__test.2.c", "original_string": "void make_crc32_table() {\n    unsigned int c;\n    int i = 0;\n    int bit = 0;\n    for(i = 0; i < 256; i++)\n    {\n        c  = (unsigned int)i;\n        for(bit = 0; bit < 8; bit++)\n        {\n            if(c&1)\n            {\n                c = (c >> 1)^(0xEDB88320);\n            }\n            else\n            {\n                c =  c >> 1;\n            }\n        }\n        crc32_table[i] = c;\n    }\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__rstp_fsm.0.c", "original_string": "void rstpFsmInit(RstpBridgeContext *context)\n{\n   uint_t i;\n   RstpBridgePort *port;\n   context->bridgePriority.rootBridgeId = context->bridgeId;\n   context->bridgePriority.rootPathCost = 0;\n   context->bridgePriority.designatedBridgeId = context->bridgeId;\n   context->bridgePriority.designatedPortId = 0;\n   context->bridgePriority.bridgePortId = 0;\n   context->bridgeTimes.forwardDelay = context->params.bridgeForwardDelay;\n   context->bridgeTimes.helloTime = context->params.bridgeHelloTime;\n   context->bridgeTimes.maxAge = context->params.bridgeMaxAge;\n   context->bridgeTimes.messageAge = 0;\n   context->rootPriority = context->bridgePriority;\n   context->rootTimes = context->bridgeTimes;\n   context->ageingTime = context->params.ageingTime;\n   context->rapidAgeingWhile = 0;\n   rstpUpdateAgeingTime(context, context->params.ageingTime);\n   osMemset(&context->bpdu, 0, sizeof(RstpBpdu));\n   for(i = 0; i < context->numPorts; i++)\n   {\n      port = &context->ports[i];\n      port->designatedTimes = context->rootTimes;\n      port->designatedTimes.helloTime = context->bridgeTimes.helloTime;\n      memset(&port->msgPriority, 0, sizeof(RstpPriority));\n      memset(&port->msgTimes, 0, sizeof(RstpTimes));\n      port->disputed = FALSE;\n      port->rcvdInfo = RSTP_RCVD_INFO_OTHER;\n      port->rcvdTc = FALSE;\n      port->rcvdTcAck = FALSE;\n      port->rcvdTcn = FALSE;\n      port->tcProp = FALSE;\n      port->updtInfo = FALSE;\n   }\n   rstpPrsInit(context);\n   for(i = 0; i < context->numPorts; i++)\n   {\n      port = &context->ports[i];\n      rstpPtiInit(port);\n      rstpPrxInit(port);\n      rstpPpmInit(port);\n      rstpBdmInit(port);\n      rstpPtxInit(port);\n      rstpPimInit(port);\n      rstpPrtInit(port);\n      rstpPstInit(port);\n      rstpTcmInit(port);\n   }\n   rstpFsm(context);\n}"}
{"author": "254Odeke", "file": "Operating-Systems_Lab__Cyclic_Graph_Detection_Simulation.0.c", "original_string": "void main(){\n    printf(\"Enter the No.of Processes present in wait for graph:\");\n    scanf(\"%d\",&n);\n    printf(\"Enter the adjacency matrix:\\n\");\n    for(i=0;i<n;i++){\n        for(j=0;j<n;j++){\n            scanf(\"%d\",&matrix[i][j]);\n        }\n    }\n    for(i=0;i<n;i++){\n        visited[i]=0;\n    }\n    bool flag=false;\n    for(i=0;i<n;i++){\n        visited[i]=1;\n        for(j=0;j<n;j++){\n            if(matrix[i][j]==0) continue;\n            flag = isCyclic(j);\n            if(flag==true){\n                printf(\"Cycle is present\");\n                exit(0);\n            }\n        }\n        visited[i]=0;\n    }\n    if(flag==false){\n        printf(\"Cycle is not present\");\n    }\n}"}
{"author": "DanielSalis", "file": "AED1__teste4.1.c", "original_string": "int existeNaLista(TipoLista*l, int IDcidade){\n    TipoElemento* aux = l->primeiro;\n    while(aux!=NULL){\n        if(aux->IDcidade == IDcidade){\n            return 1;\n        }\n        aux = aux->prox;\n    }\n    return 0;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e62.4.c", "original_string": "void comprarIngresso(int ingresso, float desconto)\n{\n    float valorPago, troco;\n        switch (ingresso) \n        {\n        case 1: \n            if(capacidadeInteira > 0)\n            {           \n                printf(\"\\n\\nInsira o dinheiro: \");\n                scanf(\"%g\", &valorPago);\n                if (valorPago < (valorIngresso - (valorIngresso*desconto)))\n                {\n                    printf(\"Valor pago insuficiente!\\n\");                       \n                }\n                    else\n                    {\n                        if (valorPago > (valorIngresso -(valorIngresso*desconto)))\n                        {\n                            troco = valorPago - (valorIngresso - (valorIngresso*desconto));                                 \n                            printf(\"\\nSeu troco eh: R$%g\\n\", troco);                            \n                        }\n                    printf(\"\\nCompra concluida!\\n\");                \n                    capacidadeInteira--;\n                    capacidadeI[evento] = capacidadeInteira;\n                    printf(\"\\nevento: %d\", capacidadeI[evento]);\n                    printf(\"\\n\\tInteiros restantes: %d\\n\", capacidadeInteira);\n                    iComprados = (capacidadeMax*0.6)-capacidadeInteira;\n                    printf(\"\\n\\tInteiros comprados: %d\\n\", iComprados);\n                    }\n            }\n            else\n                {\n                    printf(\"\\t\\t\\nEntradas inteiras esgotadas!\\n\");\n                }\n        break;\n        case 2: \n            if(capacidadeMeia > 0)\n            {\n                printf(\"Insira o dinheiro: \");\n                scanf(\"%g\", &valorPago);\n                if (valorPago < (meiaEntrada - (meiaEntrada*desconto)))\n                {\n                    printf(\"Valor pago insuficiente!\\n\");                       \n                }\n                    else\n                    {\n                        if (valorPago > (meiaEntrada - (meiaEntrada*desconto)))\n                        {\n                            troco = valorPago - (meiaEntrada - (meiaEntrada*desconto));                                 \n                            printf(\"\\nSeu troco eh: R$%g\\n\", troco);                            \n                        }\n                        printf(\"\\nCompra concluida!\\n\");\n                    capacidadeMeia--;\n                    capacidadeM[evento] = capacidadeMeia;\n                    printf(\"\\n\\tMeia entrada restantes: %d\\n\", capacidadeMeia);\n                    mComprados = (capacidadeMax*0.4)-capacidadeMeia;\n                    printf(\"\\n\\tMeia entrada compradas: %d\\n\", mComprados);\n                    capacidadeM[evento] = capacidadeMeia;\n                    }   \n            }\n                else\n                {\n                    printf(\"\\t\\t\\nMeias entradas esgotadas!\\n\");\n                }\n        break; \n        default:\n            printf(\"Opcao invalida.\\n\");\n        break;\n        }\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__circularqueue.1.c", "original_string": "int dequeue()\n{\n    if((f==-1 && r==-1))\n    {\n        printf(\"\\nQueue is Empty\");\n        return(-1);\n    }\n    else\n    {\n        if(f==(r+1)%MAX && queue[f]==-1)    \n        {\n            printf(\"\\nQueue is Empty\");\n            return(-1);\n        }\n        else\n        {\n            value=queue[f];\n            queue[f]=-1;\n            f=(f+1)%MAX;\n            return(value);\n        }\n    }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__10.1.c", "original_string": "int main()\n{\n    int n;\n    do\n    {\n        printf(\"\\nDigite um inteiro n\u00e3o-negativo: \");\n        scanf(\"%i\", &n);\n        getchar();\n        system(\"clear\");\n    } while (n < 0);\n    printf(\"\\nA %i\u00aa palavra de Fibonacci:\\n\\n\", n);\n    palavra_fibonacci(n);\n    printf(\"\\n\\n\");\n    return 0;\n}"}
{"author": "fikepaci", "file": "monty__monty_funcs_2.0.c", "original_string": "void monty_add(stack_t **stack, unsigned int line_number)\n{\n    if ((*stack)->next == NULL || (*stack)->next->next == NULL)\n    {\n        set_op_tok_error(short_stack_error(line_number, \"add\"));\n        return;\n    }\n    (*stack)->next->next->n += (*stack)->next->n;\n    monty_pop(stack, line_number);\n}"}
{"author": "dle2005", "file": "Algorithm__Knapsack3.3.c", "original_string": "float bound(node u) {\n    int j, k, totweight;\n    float result;\n    if(u.weight >= W) return 0;\n    else {\n        result = u.profit; j = u.level + 1; totweight = u.weight;\n        while((j <= n) && (totweight + w[j] <= W)) {\n            totweight = totweight + w[j];\n            result = result + p[j];\n            j++;\n        }\n        k = j;\n        if(k <= n) result = result + (W - totweight) * p[k] / w[k];\n        return result;\n    }\n}"}
{"author": "behergue", "file": "Computer_Structure__main0.2.c", "original_string": "int setup(void)\n{\n    ic_enable(INT_GLOBAL);\n    leds_init();\n    D8Led_init();\n    D8Led_segment(RL.position);\n    portG_conf(6, EINT);\n    portG_conf(7, EINT);\n    portG_conf(1, EINT);\n    portG_conf_pup(6, ENABLE);\n    portG_conf_pup(7, ENABLE);\n    portG_conf_pup(1, ENABLE);\n    tmr_set_prescaler(TIMER0, 255);\n    tmr_set_divider(8, TIMER0);\n    tmr_set_count(TIMER0, 62500, 1);\n    if (RL.moving)\n        tmr_start(TIMER0);\n    pISR_TIMER0   = timer_ISR; \n    pISR_EINT4567 = button_ISR; \n    ic_conf_irq(ENABLE, VEC);\n    ic_conf_fiq(DISABLE);\n    ic_conf_line(INT_TIMER0, IRQ);\n    ic_conf_line(INT_EINT4567, IRQ);\n    ic_conf_line(INT_EINT1, IRQ);\n    ic_enable(INT_TIMER0);\n    ic_enable(INT_EINT4567);\n    ic_enable(INT_EINT1);\n    ic_init();\n    ic_conf_irq(ENABLE, VEC);\n    ic_conf_fiq(DISABLE);\n    ic_conf_line(INT_TIMER0, IRQ);\n    ic_conf_line(INT_EINT4567, IRQ);\n    ic_conf_line(INT_EINT1, IRQ);\n    ic_enable(INT_TIMER0);\n    ic_enable(INT_EINT4567);\n    ic_enable(INT_EINT1);\n    Delay(0);\n    return 0;\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_nus_c.4.c", "original_string": "uint32_t ble_nus_c_init(ble_nus_c_t * p_ble_nus_c, ble_nus_c_init_t * p_ble_nus_c_init)\n{\n        uint32_t err_code;\n        ble_uuid_t uart_uuid;\n        ble_uuid128_t nus_base_uuid = NUS_BASE_UUID;\n        VERIFY_PARAM_NOT_NULL(p_ble_nus_c);\n        VERIFY_PARAM_NOT_NULL(p_ble_nus_c_init);\n        p_ble_nus_c->conn_handle           = BLE_CONN_HANDLE_INVALID;\n        p_ble_nus_c->handles.nus_tx_handle = BLE_GATT_HANDLE_INVALID;\n        p_ble_nus_c->handles.nus_rx_handle = BLE_GATT_HANDLE_INVALID;\n        p_ble_nus_c->evt_handler           = p_ble_nus_c_init->evt_handler;\n        err_code = sd_ble_uuid_vs_add(&nus_base_uuid, &p_ble_nus_c->uuid_type);\n        VERIFY_SUCCESS(err_code);\n        uart_uuid.type = p_ble_nus_c->uuid_type;\n        uart_uuid.uuid = BLE_UUID_NUS_SERVICE;\n        return ble_db_discovery_evt_register(&uart_uuid);\n}"}
{"author": "flora0110", "file": "hw04git__4108056029_40.1.c", "original_string": "int pass(All all[300],int* test,int alln,int flyat,int pigat){\n    int i,j,allcheck=0;\n    for(i=0;i<alln;i++){\n        int check=1;\n        for(j=0;all[i].ori[j]!=-1;j++){\n            if(test[all[i].ori[j]]==0) {\n                check=0;\n                break;\n            }\n        }\n        if(check){\n            for(j=0;all[i].chan_to[j]!=-1;j++){\n                if(test[all[i].chan_to[j]]==0) allcheck=1;\n                test[all[i].chan_to[j]]=1;\n            }\n        }\n    }\n    if(test[flyat]==1 && test[pigat]==1){\n        return 2;\n    }\n    else {\n        return allcheck;\n    }\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_LPC2129__pwm_single.1.c", "original_string": "void delay(int ct)\n{\n    for(int i=0;i<ct;i++)\n    {\n        for(int j=0;j<6000;j++)\n        {\n        }\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.20.c", "original_string": "void transb(STRINGLIST* ln) {\n    bool hasjmp = false;\n    bool hasdest = false;\n    bool hascmp = false;\n    int i = 0;\n    int tmpi = 0;\n    char tmp[C_TOKEN_SIZE], dest[C_TOKEN_SIZE], cmp[C_TOKEN_SIZE], jmp[C_TOKEN_SIZE];\n    while(true) {\n        if(ln->content[i] == '\\0') {\n            tmp[tmpi] = '\\0';\n            if(hasjmp)\n                strcpy(jmp, tmp);\n            else\n                strcpy(cmp, tmp);\n            break;\n        }\n        if(ln->content[i] == '=' && !hasdest && hascmp) {\n            hascmp = false;\n            hasdest = true;\n            tmp[tmpi] = '\\0';\n            strcpy(dest, tmp);\n            tmpi = 0;\n            i++;\n            continue;\n        }\n        if(ln->content[i] == ';' && !hasjmp && hascmp) {\n            hascmp = false;\n            hasjmp = true;\n            tmp[tmpi] = '\\0';\n            strcpy(cmp, tmp);\n            tmpi = 0;\n            i++;\n            continue;\n        }\n        hascmp = 1;\n        tmp[tmpi] = ln->content[i];\n        tmpi++;\n        i++;\n    }\n    char* rawdest = lookctable(&desttable, hasdest, dest, \"dest\");\n    char* rawjmp = lookctable(&jmptable, hasjmp, jmp, \"jump\");\n    char* rawcmp = lookctable(&cmptable, 1, cmp, \"comp\");\n    int sz = sizeof(char) * INST_SIZE;\n    char* out = (char*)malloc(sz);\n    snprintf(out, sz, \"111%s%s%s\", rawcmp, rawdest, rawjmp);\n    ln->content = out;\n    free(rawdest);\n    free(rawjmp);\n    free(rawcmp);\n}"}
{"author": "ankitraj311", "file": "Socket-thread__temp.1.c", "original_string": "int main() \n{ \n    int i; \n    pthread_t tid; \n    for (i = 0; i < 3; i++) \n        pthread_create(&tid, NULL, myThreadFun, (void *)&tid); \n    pthread_exit(NULL); \n    return 0; \n}"}
{"author": "augustogunsch", "file": "jackc__compiler-scopes.23.c", "original_string": "void addclassvardecs(SCOPE* s, CLASSVARDEC* classvardecs) {\n    int i = 0;\n    while(classvardecs != NULL) {\n        addclassvardec(s, classvardecs, &i);\n        classvardecs = classvardecs->next;\n    }\n}"}
{"author": "tadeograch", "file": "monty__aux_functions.1.c", "original_string": "unsigned int _strlen(char *s)\n{\n    unsigned int n, len;\n    n = len = 0;\n    while (*(s + n) != '\\0')\n    {\n        n++;\n        len++;\n    }\n    return (len);\n}"}
{"author": "earth429", "file": "mulpre__mulprec1.0.c", "original_string": "void clearByZero(struct NUMBER *a){\n    int i;\n    for (i = 0; i < KETA;i++){\n        a->n[i] = 0;\n    }\n    a->sign = 1;\n}"}
{"author": "ael-bagh", "file": "42_cub_3d_file_parsing__rounting_utils1.1.c", "original_string": "int     wrong_resolution(int width, int height)\n{\n    int w;\n    int h;\n    w = width;\n    h = height;\n    if (width > 2560)\n        w = 2560;\n    if (height > 1400)\n        h = 1400;\n    if (width <= 100 || height <= 100)\n    {\n        ft_putstr(\"Error:\\nresolution is < 100 px!\\n\");\n        exit(0);\n    }\n    get_resolution(w, h);\n    return (1);\n}"}
{"author": "4rslanismet", "file": "C-Egitim-Kodlar__example4_1.1.c", "original_string": "int tabanDonusumu(int arr[SIZE])\n{\n    int i,j=0,ust,decimal;\n    for(i=SIZE-1;i>0;i--,j++)\n    {\n        ust=ustAlma(j);\n        decimal+=ust*arr[i];\n    }\n    return decimal;\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__lz77decode.0.c", "original_string": "void decompress(char *compressed_str)\n{\n    int pos,             \n        tam,             \n        tam_d,           \n        tam_total = 1;   \n    char letra,          \n        *decom = NULL;   \n    decom = malloc(1 * sizeof(char)); \n    while (*compressed_str)           \n    {\n        if (*compressed_str == '(')   \n        {\n            compressed_str++;\n            if (*compressed_str == '-')\n            {\n                pos = -1;\n            }\n            else\n            {\n                pos = atoi(compressed_str);\n            }\n            while (*compressed_str != ',')\n            {\n                compressed_str++;\n            }\n            compressed_str++;\n            tam = atoi(compressed_str);                       \n            tam_total += tam + 1;                             \n            decom = realloc(decom, tam_total * sizeof(char)); \n            while (*compressed_str != ',')\n            {\n                compressed_str++;\n            }\n            compressed_str++;\n            if (*compressed_str == '\\\\' && *(compressed_str + 1) == '0')\n            {\n                letra = '\\0';\n            }\n            else\n            {\n                letra = *compressed_str; \n            }\n            compressed_str++;\n            tam_d = strlen(decom);\n            if (pos == -1)\n            {\n                *decom = letra;\n                *(decom + 1) = '\\0';\n            }\n            else if (pos == 0) \n            {\n                *(decom + tam_d) = letra;\n                *(decom + tam_d + 1) = '\\0';\n            }\n            else\n            {\n                int i, \n                    j; \n                for (i = tam_d - pos, j = 0; j < tam; i++, j++)\n                {\n                    if (i == tam_d)\n                    {\n                        i = tam_d - pos;\n                    }\n                    *(decom + j + tam_d) = *(decom + i);\n                }\n                *(decom + tam_d + tam) = letra;\n                *(decom + tam_d + tam + 1) = '\\0';\n            }\n        }\n        compressed_str++;\n    }\n    tam_d = strlen(decom);\n    for (int i = 0; i < tam_d; i++)\n    {\n        printf(\"%c\", *(decom + i));\n    }\n    putchar('\\n');\n    free(decom); \n}"}
{"author": "sdukesameer", "file": "dsa__bst-height-mirror-c_nodes-dealloc.0.c", "original_string": "node* createNode(int n)\n{\n    node* newNode=(node*)malloc(sizeof(node));\n    newNode->data=n;\n    newNode->left=NULL;\n    newNode->right=NULL;\n    return newNode;\n}"}
{"author": "earth429", "file": "mulpre__doubleCos.2.c", "original_string": "int doubleCos(double *a, double theta, int n) {\n    int i;\n    for (i = 0; i < n;i++){\n        *a += pow(-1, i) / factorial(2 * i) * pow(theta, 2 * i);\n    }\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jack-compiler__tokenizer.12.c", "original_string": "TOKENTYPE gettokentype(STRING* tk, char* file, int definedat) {\n    if(iskeyword(tk)) return keyword;\n    if(issymbol(tk)) return symbol;\n    if(isintcons(tk)) return integer;\n    if(isidentifier(tk)) return identifier;\n    eprintf(\"Unexpected token '%s'; file '%s', line %i\\n\", tk->str, file, definedat);\n    exit(1);\n}"}
{"author": "MartinMarinovich", "file": "ParcialLaboratorio1GCompleto__servicio.2.c", "original_string": "int listarServicios(eServicio listaDeServicio[], int tamanioServicio)\n{\n    int error = -1;\n    if(listaDeServicio !=NULL && tamanioServicio>0)\n    {\n        system(\"cls\");\n        printf(\"\\n****  LISTADO DE SERVICIOS  ****\\n\");\n        printf(\" Id         Servicio        Precio\\n\");\n        printf(\"----------------------------------\\n\");\n        for(int i = 0 ; i<tamanioServicio; i++)\n        {\n            mostrarServicio(listaDeServicio[i]);\n        }\n        error = 0;\n    }\n    return error;\n}"}
{"author": "Ana-Morales", "file": "sorting_algorithms__2-selection_sort.0.c", "original_string": "void selection_sort(int *array, size_t size)\n{\n    size_t i, j, idx_min;\n    int tmp = 0;\n    if (array == NULL || size < 2)\n        return;\n    i = 0;\n    while (i < size - 1)\n    {\n        idx_min = i;\n        j = i + 1;\n        while (j < size)\n        {\n            if (array[j] < array[idx_min])\n                idx_min = j;\n            j++;\n        }\n        if (idx_min != i)\n        {\n            tmp = array[i];\n            array[i] = array[idx_min];\n            array[idx_min] = tmp;\n            print_array(array, size);\n        }\n        i++;\n    }\n}"}
{"author": "Qu-Xiangjun", "file": "network-project-master__sender.2.c", "original_string": "int frame_construction(unsigned char *sta_addr, unsigned char *des_addr,\n                        unsigned short protocol, unsigned char *payload,\n                        unsigned int payload_len)\n{   \n    if(payload_len < 46){\n        printf(\"[Error] Payload length too low!\\n\");\n        exit(1);\n    }else if(payload_len >1500){\n        printf(\"[Error] Payload length too long!\\n\");\n        exit(1);\n    }\n    memcpy(&frame[0],des_addr,6);\n    memcpy(&frame[6],sta_addr,6);\n    memcpy(&frame[12],&protocol,sizeof(protocol));\n    memcpy(&frame[14],payload,payload_len);\n    init_crc_table();\n    unsigned int crc32_result = crc32(frame,14+payload_len);\n    memcpy(&frame[14+payload_len],&crc32_result,sizeof(crc32_result));\n        unsigned char crc32_result_[4];\n    memcpy(crc32_result_,&crc32_result,sizeof(crc32_result));\n    printf(\"******Received frame information******\\n\");\n    printf(\"Start address: %x\\n\",sta_addr);\n    printf(\"Des address  : %x\\n\",des_addr);\n    printf(\"protocol     : %x\\n\",protocol);\n    printf(\"payload      : %x\\n\",payload);\n    printf(\"CRC32        : \");\n    output_octal(crc32_result_,4);\n    printf(\"**************************************\\n\");\n    return payload_len+6+6+sizeof(protocol)+sizeof(crc32_result);\n}"}
{"author": "RobsonRafaeldeOliveiraBasseto", "file": "2lista_de_C__main5.0.c", "original_string": "int main()\n{\n    int c; \n    int l; \n    int a;\n    int b = 1;\n    printf(\"Digite um numero: \");\n    scanf(\"%d\",&a);\n  for (l=0; l<a; l++)\n    {\n        for (c=0; c<a;c++)\n        {\n           if (l == c )\n           {\n               printf(\"%d \",b);\n               b++;\n           }else\n            {\n                printf(\"  \");\n            }\n        }\n        printf(\"\\n\");\n    }\n        printf(\"\\n\\n\\n\");\n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Delete_At_The_Beginning_Of_A_Single_Linked_List.2.c", "original_string": "void delete_at_start(struct node*head1, struct node*temp1)\n{\n    head1 = head1->ptr;\n    free(temp1);\n    printf(\"\\nAfter Deletion:\");\n    while(head1!=NULL)\n    {\n        printf(\"%d\\t\",head1->data);\n        head1 = head1->ptr;\n    }\n}"}
{"author": "dle2005", "file": "File_Structure__heapsort.8.c", "original_string": "int main(int argc, char* argv[]) {\n    FILE *fp1;\n    FILE *fp2;\n    fp1 = fopen(argv[2], \"r+\");\n    fp2 = fopen(argv[3], \"w+\");\n    char pagebuf[PAGE_SIZE + 1] = { }; \n    memset(pagebuf, (char)0xFF, PAGE_SIZE);\n    char *recordbuf = malloc(sizeof(char) * RECORD_SIZE);\n    int pageNum;\n    int recordNum;\n    int recordPerPage = PAGE_SIZE / RECORD_SIZE;\n    int recordCount = 0;\n    int recordCount_2 = 0;\n    readPage(fp1, pagebuf, 0);\n    memcpy(&pageNum, pagebuf, sizeof(int));\n    memcpy(&recordNum, pagebuf+4, sizeof(int));\n    char filebuf[PAGE_SIZE * pageNum + 1];\n    Person person[recordPerPage * pageNum];\n    Person *p = (Person*)malloc(sizeof(Person));\n    for(int i = 1; i < pageNum; i++) {\n        readPage(fp1, pagebuf, i);\n        for(int j = 0; j < recordPerPage; j++) {\n            if(recordCount == recordNum) break;\n            recordCount++;\n            int index = j * RECORD_SIZE;\n            int position = (i-1) * recordPerPage + j;\n            memcpy(recordbuf, pagebuf + index, RECORD_SIZE);\n            if(recordbuf[0] == '*' || recordbuf[0] == (char)0xFF) continue;\n            unpack(recordbuf, p);\n            insert_heap(person, p);\n            recordCount_2++;\n        }\n    }\n    recordCount = 0;\n    readPage(fp1, pagebuf, 0);\n    if(recordCount_2 % 2 == 0) pageNum = recordCount_2 / recordPerPage + 1;\n    else pageNum = recordCount_2 / recordPerPage + 2;\n    setHeadPage(pagebuf, pageNum, recordCount_2, -1, -1);\n    writePage(fp2, pagebuf, 0);\n    for(int i = 1; i < pageNum; i++) {\n        memset(pagebuf, (char)0xFF, PAGE_SIZE);\n        for(int j = 0; j < recordPerPage; j++) {\n            if(recordCount == recordCount_2) break;\n            recordCount++;\n            int index = j * RECORD_SIZE;\n            int position = (i-1) * recordPerPage + j;\n            memset(recordbuf, (char)0xFF, RECORD_SIZE);\n            Person temp = delete_heap(person);\n            pack(recordbuf, &temp);\n            memcpy(pagebuf + index, recordbuf, RECORD_SIZE);\n        }\n        writePage(fp2, pagebuf, i);\n    }\n}"}
{"author": "jimmywong2003", "file": "nrf52-ble-range-estimator__ble_lbs_c_extended.2.c", "original_string": "static void on_hvx(ble_lbs_c_t * p_ble_lbs_c, ble_evt_t const * p_ble_evt)\n{\n    if (p_ble_lbs_c->conn_handle != p_ble_evt->evt.gattc_evt.conn_handle)\n    {\n        return;\n    }\n    if (p_ble_evt->evt.gattc_evt.params.hvx.handle == p_ble_lbs_c->peer_lbs_db.button_handle)\n    {\n        if (p_ble_evt->evt.gattc_evt.params.hvx.len == 1)\n        {\n            ble_lbs_c_evt_t ble_lbs_c_evt;\n            ble_lbs_c_evt.evt_type                   = BLE_LBS_C_EVT_BUTTON_NOTIFICATION;\n            ble_lbs_c_evt.conn_handle                = p_ble_lbs_c->conn_handle;\n            ble_lbs_c_evt.params.button.button_state = p_ble_evt->evt.gattc_evt.params.hvx.data[0];\n            p_ble_lbs_c->evt_handler(p_ble_lbs_c, &ble_lbs_c_evt);\n        }\n    }\n}"}
{"author": "augustogunsch", "file": "jackc__compiler-statements.4.c", "original_string": "LINEBLOCK* compileif(SCOPE* s, STATEMENT* st) {\n    IFSTATEMENT* ifst = st->ifstatement;\n    LINEBLOCK* blk = compileexpression(s, st->debug, ifst->base->expression);\n    pthread_mutex_lock(&(s->compiler->ifmutex));\n    static int ifcount = 0;\n    int mycount = ifcount;\n    ifcount++;\n    pthread_mutex_unlock(&(s->compiler->ifmutex));\n    char* truelabel = mkcondlabel(\"IF_TRUE\", mycount);\n    char* ifgoto[] = { \"if-goto\", truelabel };\n    appendln(blk, mkln(ifgoto));\n    char* falselabel = mkcondlabel(\"IF_FALSE\", mycount);\n    char* gotofalse[] = { \"goto\", falselabel };\n    appendln(blk, mkln(gotofalse));\n    char* truelabelln[] = { \"label\", truelabel };\n    appendln(blk, mkln(truelabelln));\n    blk = mergelnblks(blk, compilestatements(s, ifst->base->statements));\n    char* endlabel;\n    bool haselse = ifst->elsestatements != NULL;\n    if(haselse) {\n        endlabel = mkcondlabel(\"IF_END\", mycount);\n        char* endgoto[] = { \"goto\", endlabel };\n        appendln(blk, mkln(endgoto));\n    }\n    char* falselabelln[] = { \"label\", falselabel};\n    appendln(blk, mkln(falselabelln));\n    if(haselse) {\n        blk = mergelnblks(blk, compilestatements(s, ifst->elsestatements));\n        char* endlabelln[] = { \"label\", endlabel };\n        appendln(blk, mkln(endlabelln));\n        free(endlabel);\n    }\n    free(falselabel);\n    free(truelabel);\n    return blk;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__search_a_node_from_list.3.c", "original_string": "void displayList()\n{\n    struct node*temp;\n    temp=head;\n    while(temp!=NULL)\n    {\n        printf(\"%d\\n\", temp->data);\n        temp=temp->next;\n    }\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad7.0.c", "original_string": "int main()\n{\n    float number1, number2;\n    int endProgram = 0;\n    while(!endProgram){\n        printf(\"Podaj pierwsz\\245 liczb\\251: \");\n        if(scanf(\"%f\", &number1) == 1) {\n            printf(\"Podaj drug\\245 liczb\\251: \");\n            if(scanf(\"%f\", &number2) == 1) {\n                float wynik = (number1 - number2) / (number1 * number2);\n                printf(\"\\nWynik: %3f\\n\\n\", wynik);\n            } else {\n            printf(\"Podano b\\210\\251dne dane. Zako\\344czenie pracy programu!\\n\");\n            endProgram = 1;\n            }\n        } else {\n            printf(\"Podano b\\210\\251dne dane. Zako\\344czenie pracy programu!\\n\");\n            endProgram = 1;\n        }\n    }\n    getchar();\n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__assembler.10.c", "original_string": "void populatevars(ASSEMBLER* a) {\n    const int firstamnt = 5;\n    const int ramvamnt = 16; \n    const int specialamt = 2;\n    const int sum = firstamnt + ramvamnt + specialamt;\n    expandsymbols(a->vars, sum);\n    a->vars->count = sum;\n    char* labels[] = { \"SP\", \"LCL\", \"ARG\", \"THIS\", \"THAT\" };\n    for(int i = 0; i < firstamnt; i++) {\n        a->vars->items[i] = mksymbol(labels[i], strlen(labels[i])+1, i);\n    }\n    const int asciioff = 48;\n    char ramvname[4];\n    ramvname[0] = 'R';\n    ramvname[2] = '\\0';\n    int tmptarg = (ramvamnt/10)*10;\n    for(int i = 0; i < tmptarg; i++) {\n        ramvname[1] = (char)(i+asciioff);\n        a->vars->items[firstamnt+i] = mksymbol(ramvname, 3, i);\n    }\n    ramvname[1] = '1';\n    ramvname[3] = '\\0';\n    for(int i = 10; i < ramvamnt; i++) {\n        ramvname[2] = (char)((i%10)+asciioff);\n        a->vars->items[firstamnt+i] = mksymbol(ramvname, 4, i);\n    }\n    a->vars->items[firstamnt+ramvamnt] = mksymbol(\"SCREEN\", 7, 16384);\n    a->vars->items[firstamnt+ramvamnt+1] = mksymbol(\"KBD\", 4, 24576);\n}"}
{"author": "Oryx-Embedded", "file": "Common__str.0.c", "original_string": "char_t *strDuplicate(const char_t *s)\n{\n   uint_t n;\n   char_t *p;\n   p = NULL;\n   if(s != NULL)\n   {\n      n = osStrlen(s) + 1;\n      p = osAllocMem(n);\n      if(p != NULL)\n      {\n         osMemcpy(p, s, n);\n      }\n   }\n   return p;\n}"}
{"author": "Oryx-Embedded", "file": "CycloneSTP__stp_bpdu.0.c", "original_string": "void stpProcessLlcFrame(NetInterface *interface, EthHeader *ethHeader,\n   const uint8_t *data, size_t length, NetRxAncillary *ancillary, void *param)\n{\n   const LlcHeader *llcHeader;\n   const StpBpdu *bpdu;\n   StpBridgeContext *context;\n   StpBridgePort *port;\n   context = (StpBridgeContext *) param;\n   if(!macCompAddr(&ethHeader->destAddr, &STP_BRIDGE_GROUP_ADDR))\n      return;\n   if(length < sizeof(LlcHeader))\n      return;\n   llcHeader = (LlcHeader *) data;\n   if(llcHeader->dsap != STP_LLC_DSAP || llcHeader->ssap != STP_LLC_SSAP ||\n      llcHeader->control != STP_LLC_CTRL)\n   {\n      return;\n   }\n   if(ancillary->port < 1 || ancillary->port > context->numPorts)\n      return;\n   port = &context->ports[ancillary->port - 1];\n   bpdu = (StpBpdu *) (data + sizeof(LlcHeader));\n   length -= sizeof(LlcHeader);\n   stpProcessBpdu(port, bpdu, length);\n}"}
{"author": "Theemiss", "file": "simple_shell__shell.1.c", "original_string": "void creat_envi(char **envi)\n{\n    int i;\n    for (i = 0; environ[i]; i++)\n        envi[i] = _strdup(environ[i]);\n    envi[i] = NULL;\n}"}
{"author": "2security", "file": "String__38RemoveExtraSpace.1.c", "original_string": "char* RemoreExSpace(char *str)\n    {\n        int i, j;\n    char * newString;\n    i=Mystrlen(str);\n    newString = (char *)malloc(i);\n    i = 0;\n    j = 0;\n    while(str[i] != '\\0')\n    {\n        if(str[i] == ' ')\n        {\n            newString[j] = ' ';\n            j++;\n            while(str[i] == ' ')\n                i++;\n        }\n        newString[j] = str[i];\n        i++;\n        j++;\n    }\n    newString[j] = '\\0';\n    return newString;\n    }"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__21_cos.3.c", "original_string": "void cos(int contador, int iteraciones, double suma, double X)\n{\n    if(contador <= iteraciones){    \n        if(contador%2 == 0){\n            printf(\"\\n%i -> %lf / %0.0lf = %0.6lf\", contador, Exp(contador*2,X), Fac(contador * 2), Exp(contador*2,X) / Fac(contador * 2));\n            suma = suma + (Exp(contador*2,X) / Fac(contador * 2));\n            printf(\"   Suma Actual: %lf\", suma);\n            cos(++contador, iteraciones,suma,X);\n        }else{\n            printf(\"\\n%i -> %lf / %0.0lf = %0.6lf\", contador, Exp(contador*2,X), Fac(contador * 2), Exp(contador*2,X) / Fac(contador * 2));\n            suma = suma - (Exp(contador*2,X) / Fac(contador * 2));\n            printf(\"  Suma Actual: %lf\", suma);\n            cos(++contador, iteraciones,suma,X);\n        }\n    }else{\n        printf(\"\\nCos(%lf) es igual a: %lf\", X, (suma + 1));\n    }\n}"}
{"author": "augustogunsch", "file": "jack-compiler__parser-structure.2.c", "original_string": "int parsepossibilities(PARSER* p, STRINGARRAY* poss) {\n    for(int i = 0; i < poss->size; i++)\n        if(equals(p, poss->items[i]))\n            return i;\n    return -1;\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__22_senh.2.c", "original_string": "int main(){\n    double X;\n    printf(\"Programa para calcular el senh(X) por medio de sumas de Taylor\\nValor de X:\");\n    scanf(\"%lf\", &X);\n    Senh(1,30,0,X);\n    return 0;\n}"}
{"author": "ankitraj311", "file": "C_Basic_programming__26_no_perfect_all.0.c", "original_string": "int main()\n{\n  int i,j,k,x,y,no,sum=0,a,b,dummy1=0, dummy2 = 0;\n  printf(\"Enter the Range to find the Perfect number between them\");\n  scanf(\"%d%d\",&a,&b);\n  for(j=a; j<=b; j++)\n  {\n    sum = 0;\n    dummy1 = j;\n    for( i=1; i<j; i++)\n    {\n      if(dummy1 % i == 0)\n      {\n        sum = sum + i;\n      }\n    }\n    if( dummy1 == sum)\n    {\n      printf(\"%d \",dummy1);\n    }\n  }\n}"}
{"author": "RaigoXD", "file": "Parcial-2__ft_atoi.1.c", "original_string": "int atoi(char *str){\n    int longitud = 0;\n    int Valores = 0;\n    int Total = 0;\n    for( longitud = 0; str[longitud] != '\\0'; ++longitud);\n    for(int i = 0; i < longitud; i++){\n        Valores = ((int)(str[i]) - 48) * potencia(10, (longitud - i - 1));\n        Total += Valores;\n    }\n    return Total;\n}"}
{"author": "earth429", "file": "mulpre__isPrime.0.c", "original_string": "int main(int argc, char **argv)\n{\n    struct NUMBER a, b, c;\n    int return_val;\n    int x, y;\n    x = 1357911;\n    y = 246810;\n    setInt(&a, x);\n    setInt(&b, y);\n    return_val = gcd(&a, &b, &c);\n    dispNumberZeroSuppress(&c);\n    printf(\"\\n\u623b\u308a\u5024 = %d\", return_val);\n    return 0;\n}"}
{"author": "paawankohli", "file": "DSA-LAB__ip2.1.c", "original_string": "NODE lunion(NODE l1, NODE l2)\n{\n    NODE uni=NULL;\n    while(l1!=NULL)\n    {\n        uni=insert(uni,l1->data,0);\n        l1=l1->next;\n    }\n    while(l2!=NULL)\n    {\n        uni=insert(uni,l2->data,0);\n        l2=l2->next;\n    }\n    return uni;\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad8AddingArrays.1.c", "original_string": "void addArraysPointer(int sourceArray1[], int sourceArray2[], int outputArray[], int size){\n    int * pointerSource1 = sourceArray1;\n    int * pointerSource2 = sourceArray2;\n    int * pointerOutput = outputArray;\n    for(int i = 0; i < size; i++){\n        *pointerOutput = *pointerSource1 + *pointerSource2;\n        pointerSource1++;\n        pointerSource2++;\n        pointerOutput++;\n    }\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-win32__SinglePartitionDemoFirmwareUpdateInfoFileReader0.2.c", "original_string": "void firmwareUpdateInfoReader_init(void)\n{\n  size_t updateVerificationDataSize = getVerificationDataSize(DEMO_PRODUCT_FIRMWARE_UPDATE_VERIFICATION_ALGORITHM);\n  updateVerificationData = ((uint8_t *)(malloc(updateVerificationDataSize)));\n  memset(updateVerificationData, 0, updateVerificationDataSize);\n  if (!createFirmwareUpdateInfoFile()) \n  {\n    return;\n  }\n  if (canOpenFirmwareUpdateInfoFile()) \n  {\n    openFirmwareUpdateInfoFile();\n  }\n}"}
{"author": "ashlyn2002", "file": "programming-using-c__insert_at_pos_DCLL.0.c", "original_string": "int main()\n{\n    int choice;\n    printf(\"function of doubly circular linked list \\n\");\n    printf(\"1.implementation \\n\");\n    printf(\"2.display the linked list\\n\");\n    printf(\"3.count the number of elements in the linked list\\n\");\n    printf(\"4.insert the element at any position in the linked list\\n\");\n    printf(\"5.exit\\n\");\n    printf(\"enter the choice =\");\n    scanf(\"%d\",&choice);\n    while(choice!=6)\n    {\n        switch(choice)\n        {\n            case 1:printf(\"implementation \\n\");\n            create();\n            break;\n            case 2:printf(\"display the linked list\\n\");\n            display();\n            break;\n            case 3:printf(\"count the number of elements in the linked list\\n\");\n            count();\n            break;\n            case 4: printf(\"insert the element at any position in the linked list\\n\");\n            insert_at_pos();\n            break;\n            case 5:printf(\"exit\\n\");\n            exit(0);\n            break;\n            default:printf(\"wrong choice\\n\");\n            break;\n        }\n        printf(\"enter the choice =\");\n        scanf(\"%d\",&choice);\n    }\n}"}
{"author": "earth429", "file": "mulpre__doubleSin.2.c", "original_string": "int doubleSin(double *a, double theta, int n) {\n    int i;\n    for (i = 0; i < n;i++){\n        *a += pow(-1, i) / factorial(2 * i + 1) * pow(theta, 2 * i + 1);\n        printf(\"now = %f\\n\", *a);\n    }\n    return 0;\n}"}
{"author": "theuwis", "file": "AdventOfCode2015__main9.0.c", "original_string": "int main(void){\n    long house_nr = 0, nr_presents = 0;\n    while(1){\n        for(long i = 1; i <= house_nr; i++){\n            if(house_nr%i == 0){\n                nr_presents += i * 10;\n            }\n        }\n        if(nr_presents >= 33100000){\n            printf(\"answer=%ld\\n\", house_nr);\n            break;\n        }\n        if(house_nr%10000 == 0)\n            printf(\"%ld - %ld\\n\", house_nr, nr_presents);\n        house_nr++;\n        nr_presents = 0;\n    }\n    return EXIT_SUCCESS;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__BTree.3.c", "original_string": "int setValueInNode(int val, int *pval,\n     struct btreeNode *node, struct btreeNode **child) {\n        int pos;\n        if (!node) {\n                *pval = val;\n                *child = NULL;\n                return 1;\n        }\n        if (val < node->val[1]) {\n                pos = 0;\n        } else {\n                for (pos = node->count;\n                        (val < node->val[pos] && pos > 1); pos--);\n                if (val == node->val[pos]) {\n                        printf(\"Duplicates not allowed\\n\");\n                        return 0;\n                }\n        }\n        if (setValueInNode(val, pval, node->link[pos], child)) {\n                if (node->count < MAX) {\n                        addValToNode(*pval, pos, node, *child);\n                } else {\n                        splitNode(*pval, pval, pos, node, *child, child);\n                        return 1;\n                }\n        }\n        return 0;\n  }"}
{"author": "revathy16296", "file": "rtos_assignment_b__words_count_client.0.c", "original_string": "int main()\n{\n     int     shmid;\n     void* shmptr;\n    const int SIZE=4096;\n    const char* name=\"vowels\";\n      shmid=shm_open(name,O_CREAT|O_RDWR,0666);\n      ftruncate(shmid,SIZE);\n      shmptr=mmap(0,SIZE,PROT_WRITE,MAP_SHARED,shmid,0);\n      printf(\"inside client\\n\");\n      printf(\"the word count  is:\\n\");\n      puts(shmptr);\n      printf(\"the character count  is:\\n\");\n      shmptr+=sizeof(int);\n      puts(shmptr);\n      shm_unlink(name);\n      return 0;\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad3.0.c", "original_string": "int main()\n{\n    float a, b, c;\n    int licznik = 0;\n    printf(\"Podaj 1 liczbe: \");\n    scanf(\"%f\", &a);\n    printf(\"Podaj 2 liczbe: \");\n    scanf(\"%f\", &b);\n    printf(\"Podaj 3 liczbe: \");\n    scanf(\"%f\", &c);\n    if(a >= b && a >= c ) {\n        printf(\"Najwieksza liczba to %.2f\\n\", a);\n        if(b >= c) {\n            printf(\"Najmniejsza liczba to %.2f\\n\", c);\n        } else {\n            printf(\"Najmniejsza liczba to %.2f\\n\", b);\n        }\n    } else if ( b >= c) {\n        printf(\"Najwieksza liczba to %.2f\\n\", b);\n        if(a >= c) {\n            printf(\"Najmniejsza liczba to %.2f\\n\", c);\n        } else {\n            printf(\"Najmniejsza liczba to %.2f\\n\", a);\n        }\n    } else {\n        printf(\"Najwieksza liczba to %.2f\\n\", c);\n        if(a >= b) {\n            printf(\"Najmniejsza liczba to %.2f\\n\", b);\n        } else {\n            printf(\"Najmniejsza liczba to %.2f\\n\", a);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}"}
{"author": "mehedi9021", "file": "Data_Structure__insert_element.3.c", "original_string": "void displayList()\n{\n    struct node*temp;\n    temp=head;\n    while(temp!=NULL)\n    {\n        printf(\"%d\\n\", temp->data);\n        temp=temp->next;\n    }\n}"}
{"author": "mehedi9021", "file": "Data_Structure__insert_value_at_doule_linked_list.2.c", "original_string": "void displayList()\n{\n    struct node *current;\n    int n = 1;\n    if(head == NULL)\n    {\n        printf(\"List is empty.\\n\");\n    }\n    else\n    {\n        current = head;\n        printf(\"DATA IN THE LIST:\\n\");\n        do {\n            printf(\"Data %d = %d\\n\", n, current->data);\n            current = current->next;\n            n++;\n        }while(current != head);\n    }\n}"}
{"author": "deessee0", "file": "EserciziCaravagnaC__es7.2.c", "original_string": "NumeroComplesso somma_array(NumeroComplesso z[],int dim){\n  NumeroComplesso s;\n  s.reale = z[0].reale;\n  s.immaginaria = z[0].immaginaria;\n  for(int i=1; i<dim; i++){\n    s = somma(s, z[i]);\n  }\n  return s;\n}"}
{"author": "apoorvasrivastava98", "file": "DAA__ImprovisedBubbleSort.1.c", "original_string": "void getdata(int x[50],int n)\n      {\n        int k;\n        printf(\"enter the value for sorting\\n\");\n        for(k=0;k<n;k++)\n        {\n         scanf(\"%d\",&x[k]);\n        } \n       }"}
{"author": "Theemiss", "file": "simple_shell__memory_mangment.4.c", "original_string": "void *_calloc(unsigned int size)\n{\n    char *a;\n    unsigned int i;\n    if (size == 0)\n    return (NULL);\n    a = malloc(size);\n    if (a == NULL)\n    return (NULL);\n    for (i = 0; i < size; i++)\n    {\n        a[i] = '\\0';\n    }\n    return (a);\n}"}
{"author": "JeyaramanOfficial", "file": "ARM_Batch212__i2c_Tx_Rx.2.c", "original_string": "void i2c_Start(void)\n{\n    I2CONCLR = (1<<3);      \n    I2CONSET = (1<<5);          \n    while(!(I2CONSET &(1<<3)));\n    I2CONCLR = (1<<5);          \n    I2CONCLR = (1<<3);          \n}"}
{"author": "SugumaranEvil", "file": "Datastructure__single_link_list.1.c", "original_string": "int main()\n{\n    insert_node(3,\"you\");\n    insert_node(1,\"i\");\n    insert_node(2,\"love\");\n    printf(\"\\nBefore sorting\\n\");\n    print_list();\n    sort_node();\n    printf(\"\\nAfter sorting\\n\");\n    print_list();\n}"}
{"author": "RaigoXD", "file": "Ciclos-anidades-lenguaje-C__16_For.1.c", "original_string": "int main()\n{\n    int contador1 = 0;\n    int contador2 = 7;\n    for(contador1 = 1; contador1 < 8; ++contador1)\n    {\n    printf(\"\\n\");\n    if(contador1 > 4)\n        Columna(contador2 - 1);\n    else\n        Columna(contador1 - 1);\n    --contador2;\n    }\n    return 0;\n}"}
{"author": "chandanXP", "file": "Datastructure-using-C__linkedListAllOperations.8.c", "original_string": "struct Node *deleteByGivenKey(struct Node *head, int value)\n{\n     struct Node *p = head;\n     struct Node *q = head->next;\n     while (q->data != value && q->next != NULL)\n     {\n          p = p->next;\n          q = q->next;\n     }\n     if (q->data == value)\n     {\n          p->next = q->next;\n          free(q);\n     }\n     return head;\n}"}
{"author": "davibernardos", "file": "DB-PJ__e71.0.c", "original_string": "int main(int argc, char *argv[]) \n{\n    int capacidadeMaxima, ingressoComprado, opcao, escolha, contInteira, tipo, contMeia, ingressosRestantes, formaPagamento;\n    float entradaInteira, meiaEntrada, valorPagar, pagamento, totalPagar;\n    char nomeEvento[30]; \n    struct data diaEvento;\n    opcao = 2;\nwhile(opcao == 2)\n{\n    printf(\"Criar evento:\\n\");\n    printf(\"\\nDigite o nome do Evento: \");\n    scanf(\"%s\", &nomeEvento);\n    printf(\"\\nDigite o data que o evento ira acontecer: \");\n    scanf(\"%d/%d/%d\", &diaEvento.dia, &diaEvento.mes, &diaEvento.ano);\n    printf(\"\\nDigite a capacidade maxima: \");\n    scanf(\"%d\", &capacidadeMaxima);\n    printf(\"\\nDigite o valor da entrada inteira: \");\n    scanf(\"%g\", &entradaInteira);   \n    contInteira = 0;\n    contMeia = 0;\n    ingressoComprado = 0;\n    system(\"cls\");\n    opcao = 0;\n    while(opcao != 2)\n    {\n        system(\"cls\");\n        printf(\"Menu\\n\");\n        printf(\"\\n(1) Comprar Ingressos \\n\");\n        printf(\"(2) Sair \\n\\n\");\n        printf(\"Digite a opcao desejada: \");\n        scanf(\"%d\", &opcao);\n        if((contInteira + contMeia) == capacidadeMaxima)\n        {\n            opcao = 0;\n            printf(\"Ingressos Esgotados !\\n\");\n            system(\"pause\");\n        }\n        system(\"cls\");\n        if(opcao == 1)\n        {\n            ingressoComprado= 0;\n            printf(\"Nome do Evento: %s\\n\", nomeEvento);\n            printf(\"Capacidade Maxima: %d\\n\", capacidadeMaxima);\n            printf(\"O Valor da Entrada Inteira: %g\\n\\n\", entradaInteira);\n            while(escolha !=1 && escolha !=2)\n            {\n                printf(\"\\nIngressos:\\n\");\n                printf(\"\\n(1) Entrada Inteira\\n\");\n                printf(\"(2) Meia Entrada\\n\\n\");\n                printf(\"Escolha a opcao desejada: \");\n                scanf(\"%d\", &escolha);\n                if(escolha == 1)\n                {\n                    valorPagar = entradaInteira;\n                    printf(\"\\nValor a pagar: %g\", valorPagar);\n                    contInteira++;\n                }\n                else if(escolha == 2)\n                {\n                    valorPagar = entradaInteira / 2;\n                    printf(\"\\nValor a pagar: %g\", valorPagar);\n                    contMeia++;\n                }else\n                {\n                    printf(\"\\nOpcao Invalida!\");\n                }\n            }\n            escolha = 0;\n            while(ingressoComprado == 0)\n            {\n                printf(\"\\n\\nEscolha a Forma de Pagamento:\\n\");\n                printf(\"\\nDigite 1 para pagar em dinheiro ou 2 para pagar com cartao:\");\n                scanf(\"%d\", &tipo);\n                while(tipo == 1 || tipo == 2)\n                {\n                    if(tipo == 1)\n                    {\n                        printf(\"\\nDigite o valor em dinheiro:\");\n                        scanf(\"%g\", &pagamento);\n                        totalPagar = pagamento - valorPagar * 0.9;\n                        if(totalPagar < 0)\n                        {\n                            printf(\"\\nValor menor que valor total do ingresso\\n\\n\");\n                            system(\"pause\");\n                        }\n                        else \n                        {\n                            printf(\"\\ntroco eh: %g\", totalPagar);\n                            ingressoComprado++;\n                            break;\n                        }               \n                    }\n                    else\n                    {\n                        if(tipo == 2)\n                        {\n                            while(formaPagamento !=1 && formaPagamento !=2)\n                            {\n                                printf(\"\\nPagamento sendo realizado no cartao!\\n\");\n                                printf(\"\\nDigite 1 para Debito!\\n\");\n                                printf(\"\\nDigito 2 para credito!\\n\");\n                                printf(\"\\nEscolha opcao desejada:\");\n                                scanf(\"%d\", &formaPagamento);\n                                if(formaPagamento == 1)\n                                {\n                                    printf(\"\\nPagamento realizado no debito!\\n\");\n                                    ingressoComprado++;\n                                }\n                                else if(formaPagamento == 2)\n                                {       \n                                    printf(\"\\nPagamento realizado no credito!\\n\");\n                                    ingressoComprado++;\n                                }else\n                                {\n                                    printf(\"\\nOpcao Invalida!\\n\");\n                                }\n                            }\n                            formaPagamento= 0;\n                        }\n                        break;\n                    }\n                }\n            }\n            printf(\"\\n\\nIngresso Comprado\\n\\n\");\n            system(\"pause\");    \n        }\n        else if(opcao == 2)\n        {\n            printf(\"Total de ingressos: %d\\n\", capacidadeMaxima);\n            ingressosRestantes = capacidadeMaxima - ingressoComprado;\n            printf(\"\\nSobraram: %d\\n\\n\", ingressosRestantes);\n            printf(\"Ingressos comprados Entrada Inteira: %d\\n\", contInteira);\n            printf(\"\\nIngressos comprados Meia Entrada: %d\\n\\n\", contMeia);\n            system(\"pause\");\n        }\n        system(\"cls\");\n    }\n}\n    return 0;\n}"}
{"author": "theuwis", "file": "AdventOfCode2016__main29.0.c", "original_string": "int main(void){\n    while(strlen(input) < DATA_TO_FILL){\n        int len = strlen(input);\n        input[len - 1] = '0';\n        for(int i = len, j = len; i >= 0; i--, j++){\n            if(input[i] == '0'){\n                input[j] = '1';\n            }\n            else{\n                input[j] = '0';\n            }\n        }\n    }\n    input[DATA_TO_FILL] = '\\0';\n    strcpy(checksum, input);\n    while((strlen(checksum))%2 == 0){\n        memset(dummy, 0, sizeof(dummy));\n        int len = strlen(checksum);\n        for(int i = 0, j = 0; i < len; i += 2, j++){\n            if(checksum[i] == checksum[i + 1]){\n                dummy[j] = '1';\n            }\n            else{\n                dummy[j] = '0';\n            }\n        }\n        strcpy(checksum, dummy);\n    }\n    printf(\"checksum=%s (len=%ld)\\n\", checksum, strlen(checksum));\n    return EXIT_SUCCESS;\n}"}
{"author": "Oryx-Embedded", "file": "Common__os_port_chibios.26.c", "original_string": "void osIdleLoopHook(void)\n{\n   uint_t i;\n   for(i = 0; i < OS_PORT_MAX_TASKS; i++)\n   {\n      if(taskTable[i].tp != NULL)\n      {\n         if(chThdTerminatedX(taskTable[i].tp))\n         {\n            osFreeMem(waTable[i]);\n            waTable[i] = NULL;\n            taskTable[i].tp = NULL;\n         }\n      }\n   }\n}"}
{"author": "henrique-tavares", "file": "IFB-Programacao-de-Computadores-1__3.4.c", "original_string": "double area(pontos_t *poligono, int n)\n{\n    double area = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (i == n-1)\n        {\n            area += (poligono[i].x * poligono[0].y) - (poligono[0].x * poligono[i].y);\n        }\n        else\n        {\n            area += (poligono[i].x * poligono[i+1].y) - (poligono[i+1].x * poligono[i].y);\n        }\n    }\n    area /= 2;\n    return (area < 0) ? area*(-1) : area;\n}"}
{"author": "SugumaranEvil", "file": "TLPI__socket_unixTCP_server.0.c", "original_string": "int main()\n{\n    int soc_fd, bind_fd;\n    int listen_fd, accept_fd;\n    ssize_t read_fd;\n    char buff[1024];\n    struct sockaddr_un addr;\n    addr.sun_family = AF_UNIX;\n    strcpy(addr.sun_path, PATHNAME);\n    perror(\"strcpy\");\n    soc_fd = socket(AF_UNIX, SOCK_STREAM, 0);\n    perror(\"socket\");\n    bind_fd = bind(soc_fd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un));\n    perror(\"bind\");\n    listen_fd = listen(soc_fd, 11);\n    perror(\"listen\");\n    accept_fd = accept(soc_fd, NULL, NULL);\n    perror(\"accept\");\n    read_fd = read(accept_fd, buff, 30);\n    perror(\"read\");\n    printf(\"Data from client\\n\");\n    printf(\"==> %s\\n\",buff);\n}"}
{"author": "fotahub", "file": "fotahub-device-sdk-esp32__SinglePartitionDemoFirmwareUpdateInfoSerialReader.1.c", "original_string": "void firmwareUpdateInfoReader_run(void)\n{\n  if ((updateInfoParser.__currentState == FirmwareUpdateInfoParser_yielding__state)) \n  {\n    printf(\"Firmware update request towards version %s received\\n\", updateVersion);\n    fotaUpdateWorkflow_onFirmwareUpdateVersionChanged(updateVersion);\n    FirmwareUpdateInfoParser__execute(&updateInfoParser, FirmwareUpdateInfoParser_updateInfoPickedUp__event, NULL);\n  }\n}"}
{"author": "mandarvu", "file": "msc__problem103.0.c", "original_string": "void main() {\n  int mat1[2][2], mat2[2][2], mat[2][2];\n  printf(\"Enter values in matrix 1(2*2) row-wise (a11, a12, a21, a22): \");\n  for (int i = 0; i < 2; i++)\n    scanf(\"%d %d\",*(mat1 + i) + 0, *(mat1 + i) + 1 );\n  printf(\"Enter values in matrix 2(2*2) row-wise (a11, a12, a21, a22): \");\n  for (int i = 0; i < 2; i++)\n    scanf(\"%d %d\",*(mat2 + i) + 0, *(mat2 + i) + 1 );\n  printf(\"\\nMatrix 1(2*2)\\n\");\n  for (int i = 0; i < 2; i++) {\n    printf(\"%d %d\",*(*(mat1 + i) + 0), *(*(mat1 + i) + 1));\n    printf(\"\\n\");\n  }\n  printf(\"\\nMatrix 2(2*2)\\n\");\n  for (int i = 0; i < 2; i++) {\n    printf(\"%d %d\",*(*(mat2 + i) + 0), *(*(mat2 + i) + 1));\n    printf(\"\\n\");\n  }\n  printf(\"\\nMatrix1 + Matrix2 = \\n\");\n  for (int i = 0; i < 2; i++) {\n    printf(\"%d %d\",mat1[i][0] + mat2[i][0], mat1[i][1] + mat2[i][1]);\n    printf(\"\\n\");\n  }\n}"}
{"author": "Cz8rT", "file": "WdPcwiczenia__Zad6-PowerFunction.1.c", "original_string": "double power(double x, int y){\n    double result = x;\n    if(x == 0) return 0;\n    if(y == 0) return 1;\n    if(y<0){\n        result = 1/x;\n       for(int i = y + 1; i < 0; i++){\n        result = result * (1/x);\n        }\n        return result;\n    }\n    for(int i = 1; i < y; i++){\n        result = result * x;\n    }\n    return result;\n}"}
{"author": "earth429", "file": "mulpre__mulprec1.1.c", "original_string": "void dispNumber(struct NUMBER *a){\n    int i;\n    if(a->sign == 1){\n        printf(\"+\");\n    } else {\n        printf(\"-\");\n    }\n    for (i = KETA - 1; i >= 0;i--){\n        printf(\"%2d\", a->n[i]);\n    }\n}"}
{"author": "davibernardos", "file": "DB-PJ__e9.0.c", "original_string": "int main(int argc, char *argv[]) {\n    float percVitoriasComputador, percVitoriasJogador, percVitoriasJogador1, percVitoriasJogador2;\n    int computador, jogador, jogador1, jogador2, opcao, jogar;\n    int vitComputador, vitJogador, vitJogador1, vitJogador2, empate, partidas;\n    srand(time(NULL));\n    vitComputador = 0;\n    vitJogador = 0;\n    vitJogador1 = 0;\n    vitJogador2 = 0;\n    empate = 0;\n    partidas = 0;\n    printf(\"\\nDigite 1 para jogar contra o computador. \\n\");\n    printf(\"Digite 2 para jogar contra outro jogador. \\n\");\n    scanf(\"%d\", &opcao);\n    while(opcao < 1 || opcao > 2)\n    {\n        printf(\"Opcao invalida. Digite novamente.\");\n        printf(\"\\nDigite 1 para jogar contra o computador. \\n\");\n        printf(\"Digite 2 para jogar contra outro jogador. \\n\");\n        scanf(\"%d\", &opcao);\n    }\n        do{\n            switch(opcao)\n            {\n                case 1:\n                    printf(\"\\nEscolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador);\n                    while(jogador < 1 || jogador > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nEscolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador);\n                    }\n                    computador = rand();\n                    printf(\"\", computador, (1 + computador % 3));\n                    printf(\"\\nComputador escolheu %d\\n\", (1 + computador % 3));\n                    if((1 + computador % 3) == 2 && jogador == 1 || (1 + computador % 3) == 3 && jogador == 2 || (1 + computador % 3) == 1 && jogador == 3)\n                    {\n                        printf(\"Computador ganhou.\\n\");\n                        vitComputador++;\n                    }else\n                    {\n                        if(jogador == (1 + computador % 3))\n                        {\n                            printf(\"Empate.\\n\");\n                            empate++;\n                        }else\n                        {\n                            printf(\"Jogador ganhou.\\n\");\n                            vitJogador++;\n                        }\n                    }\n                    partidas++;\n                    printf(\"\\nJogar novamente?\\n\");\n                    printf(\"1. Sim\\n\");\n                    printf(\"2. Nao\\n\");\n                    scanf(\"%d\", &jogar);\n                    while(jogar < 1 || jogar > 2)\n                    {\n                        printf(\"Opcao invalida. Escolha novamente.\\n\");\n                        printf(\"\\nJogar novamente?\\n\");\n                        printf(\"1. Sim\\n\");\n                        printf(\"2. Nao\\n\");\n                        scanf(\"%d\", &jogar);\n                    }\n                    break;\n                case 2:\n                    printf(\"\\nJogador 1 escolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador1);\n                    while(jogador1 < 1 || jogador1 > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nJogador 1 escolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador1);\n                    }\n                    printf(\"\\nJogador 2 escolha uma opcao: \\n\");\n                    printf(\"1. Pedra\\n\");\n                    printf(\"2. Papel\\n\");\n                    printf(\"3. Tesoura\\n\");\n                    scanf(\"%d\", &jogador2);\n                    while(jogador2 < 1 || jogador2 > 3)\n                    {\n                        printf(\"Opcao invalida. Digite novamente.\\n\");\n                        printf(\"\\nJogador 2 escolha uma opcao: \\n\");\n                        printf(\"1. Pedra\\n\");\n                        printf(\"2. Papel\\n\");\n                        printf(\"3. Tesoura\\n\");\n                        scanf(\"%d\", &jogador2);\n                    }\n                    if(jogador1 == 2 && jogador2 == 1 || jogador1 == 3 && jogador2 == 2 || jogador1 == 1 && jogador2 == 3)\n                    {\n                        printf(\"Jogador 1 ganhou.\\n\");\n                        vitJogador1++;\n                    }else\n                    {\n                        if(jogador1 == jogador2)\n                        {\n                            printf(\"Empate.\\n\");\n                            empate++;\n                        }else\n                        {\n                            printf(\"Jogador 2 ganhou.\\n\");\n                            vitJogador2++;\n                        }\n                    }\n                    partidas++;\n                    printf(\"\\nJogar novamente?\\n\");\n                    printf(\"3. Sim\\n\");\n                    printf(\"4. Nao\\n\");\n                    scanf(\"%d\", &jogar);\n                    while(jogar < 3 || jogar > 4)\n                    {\n                        printf(\"Opcao invalida. Escolha novamente.\\n\");\n                        printf(\"\\nJogar novamente?\\n\");\n                        printf(\"3. Sim\\n\");\n                        printf(\"4. Nao\\n\");\n                        scanf(\"%d\", &jogar);\n                    }\n                    break;\n            }\n            if(jogar == 1)\n            {\n            }else\n            {\n                if(jogar == 2)\n                {\n                    printf(\"\\nTotal de %d partida(s).\\n\", partidas);\n                    printf(\"\\nComputador venceu %d partida(s). \\n\", vitComputador);\n                    printf(\"Jogador venceu %d partida(s). \\n\", vitJogador);\n                    printf(\"Total de %d empate(s). \\n\", empate);\n                    percVitoriasComputador = (vitComputador * 100) / partidas;\n                    printf(\"Percentual de vitorias do computador = %.2f%%\\n\", percVitoriasComputador);\n                    percVitoriasJogador = (vitJogador * 100) / partidas;\n                    printf(\"Percentual de vitorias do jogador = %.2f%%\\n\", percVitoriasJogador);\n                    break;          \n                }else\n                {\n                    if(jogar == 3)\n                    {\n                    }else\n                    {\n                        if(jogar == 4)\n                        {\n                            printf(\"\\nTotal de %d partida(s).\\n\", partidas);\n                            printf(\"\\nJogador 1 venceu %d partida(s). \\n\", vitJogador1);\n                            printf(\"Jogador 2 venceu %d partida(s). \\n\", vitJogador2);\n                            printf(\"Total de %d empate(s). \\n\", empate);\n                            percVitoriasJogador1 = (vitJogador1 * 100) / partidas;\n                            printf(\"Percentual de vitorias do jogador 1 = %.2f%\\n\", percVitoriasJogador1);\n                            percVitoriasJogador2 = (vitJogador2 * 100) / partidas;\n                            printf(\"Percentual de vitorias do jogador 2 = %.2f%\\n\", percVitoriasJogador2);\n                            break;\n                        }\n                    }\n                }\n            }       \n        }while(opcao == 1 || opcao == 2);   \n    return 0;\n}"}
{"author": "augustogunsch", "file": "jackc__parser-expressions.1.c", "original_string": "TERM* parsetermnullified(PARSER* p) {\n    TOKENTYPE type = p->current->type;\n    if(type == integer) return parseint(p);\n    if(type == string) return parsestr(p);\n    if(type == keyword) return parsekeyword(p);\n    if(type == identifier) return parseidentifierterm(p);\n    if(equals(p, \"-\") || equals(p, \"~\")) return parseunaryopterm(p);\n    if(equals(p, \"(\")) return parseinnerexpression(p);\n    return NULL;\n}"}
{"author": "Sowmyamithra", "file": "Data-Structures__stack1.2.c", "original_string": "void search(int stack[],int val)\n{\n    int i,c=0;\n    if(top==-1)\n    printf(\"\\nstack is empty\");\n    else\n    {\n        for(i=0;i<=top;i++)\n        {\n            if(stack[i]==val)\n            {\n                printf(\"\\nvalue found\");\n                c=c+1;\n                break;\n            }\n        }\n        if(c==0)\n        printf(\"\\nvalue not found\");\n    }\n}"}
{"author": "dishanp", "file": "DSA__q31.0.c", "original_string": "int main()\n{\n    int source[100], dest[100];\n    int i, size;\n    printf(\"Enter the size of the array : \");\n    scanf(\"%d\", &size);\n    printf(\"Enter elements of source array : \");\n    for(i=0; i<size; i++)\n    {\n        scanf(\"%d  \", &source[i]);\n    }\n    for(i=0; i<size; i++)\n    {\n        dest[i] = source[i];\n    }\n    printf(\"\\nElements of source array are : \");\n    for(i=0; i<size; i++)\n    {\n        printf(\"%d. \", source[i]);\n    }\n    printf(\"\\nElements of dest array are : \");\n    for(i=0; i<size; i++)\n    {\n        printf(\"%d  \", dest[i]);\n    }\n}"}
{"author": "earth429", "file": "mulpre__mulprec.4.c", "original_string": "void copyNumber(struct NUMBER *a, struct NUMBER *b){\n    int i;\n    clearByZero(b);\n    setSign(b, getSign(a));\n    for (i = 0; i < KETA;i++){\n        b->n[i] = a->n[i];\n    }\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__DAG1.4.c", "original_string": "void display()\n{\n    int i;\n    for(i=0;i<pos;i++)\n    {\n        temp=G[i];\n        printf(\"\\nDirectory (%c) : \",temp->name);\n        while(temp!=NULL)\n        {\n            printf(\"(%c,%d,%c)\",temp->name,temp->id,temp->parent);\n            temp=temp->next;\n        }\n    }\n}"}
{"author": "dishanp", "file": "DSA__q72.0.c", "original_string": "struct node *create(int A[], int n)\n{\n    struct node *p, *t, *last;\n    p = (struct node*)malloc(sizeof(struct node));\n    p->data = A[0];\n    p->next = NULL;\n    last = p;\n    for(int i = 1 ; i < n ; i++)\n    {\n        t = (struct node*)malloc(sizeof(struct node));\n        t->data = A[i];\n        t->next = NULL;\n        last->next = t;\n        last = t;\n    }\n    return p;\n}"}
{"author": "dle2005", "file": "File_Structure__ftlmgr.2.c", "original_string": "int optionW(char *fileName, int ppn, char *sectordata, char *sparedata) {\n    char ch;\n    flashfp = fopen(fileName, \"r+t\");\n    int ppnBlock = ppn / 4;\n    fseek(flashfp, PAGE_SIZE * ppn, SEEK_SET);\n    if(ch = fgetc(flashfp) != 0xFF) {\n        int emptyBlockIndex = emptyBlock();\n        copyBlock(ppnBlock, emptyBlockIndex, ppn);\n        dd_erase(ppnBlock);\n        copyBlock(emptyBlockIndex, ppnBlock, ppn);\n        dd_erase(emptyBlockIndex);\n        insertPage(ppn, sectordata, sparedata);\n    }\n    else insertPage(ppn, sectordata, sparedata); \n}"}
{"author": "ankitraj311", "file": "450_babbar__7_intersection_array_SELF.1.c", "original_string": "void intersection_array(int arr1[], int arr2[], int size_arr1, int size_arr2)\n{\n  int total_size = size_arr1+size_arr2;\n  int arr3[total_size], arr4[total_size], j = 0, k = 0;\n  for(int i = 0; i<size_arr1; i++) \n  {\n    arr3[j] = arr1[i];\n    j++;\n  }\n  for(int i = 0; i<size_arr2; i++) \n  {\n    arr3[j] = arr2[i];\n    j++;\n  }\n  printf(\"Array befor Union :-\");\n  array_print(arr3,total_size); \n  for(int i = 0; i<size_arr1; i++) \n  {\n    for(int j = 0; j<size_arr2;j++)\n    {\n      if(arr1[i] == arr2[j])\n      {\n        arr4[k] = arr1[i];\n        k++;\n      }\n    }\n  }\n  printf(\"Array after k is %d Intersection  :-\",k);\n  array_print(arr4,k);\n  int size_arr4 = k;\n  printf(\"Array is :-\"); \n  for(int i = 0; i<size_arr4;i++) \n  {\n    for(int j = i+1; j<size_arr4;j++)\n    {\n      if(arr4[i] == arr4[j])\n      {\n        for(int k = j; k<size_arr4;k++)\n    {\n          arr4[k] = arr4[k+1];\n    }\n    size_arr4--;\n      }\n    }\n  }\n  array_print(arr4,size_arr4); \n}"}
{"author": "abhijeetmurmu1997", "file": "DSA-PROGRAMS__Calculates_the_Length_of_A_Single_Linked_List.2.c", "original_string": "int length(struct node*temp2)\n{\n    int count = 0;\n    printf(\"\\nThe Length Of The Linked List is:\");\n    while(temp2!=NULL)\n    {\n        count++;\n        temp2 = temp2->ptr;\n    }\n    printf(\"%d\",count);\n}"}
{"author": "Oryx-Embedded", "file": "Common__date_time.5.c", "original_string": "time_t convertDateToUnixTime(const DateTime *date)\n{\n   uint_t y;\n   uint_t m;\n   uint_t d;\n   uint32_t t;\n   y = date->year;\n   m = date->month;\n   d = date->day;\n   if(m <= 2)\n   {\n      m += 12;\n      y -= 1;\n   }\n   t = (365 * y) + (y / 4) - (y / 100) + (y / 400);\n   t += (30 * m) + (3 * (m + 1) / 5) + d;\n   t -= 719561;\n   t *= 86400;\n   t += (3600 * date->hours) + (60 * date->minutes) + date->seconds;\n   return t;\n}"}
{"author": "Sowmyamithra", "file": "OpeartingSystems__DAG1.2.c", "original_string": "void del_dir(char dir)\n{\n    int i;\n    for(i=0;i<pos;i++)\n    {\n        temp=G[i];\n        if(temp->name==dir)\n        {\n            temp->next=NULL;\n            free(temp);\n            break;\n        }\n        else\n        {\n            q=temp;\n            while(temp!=NULL)\n            {\n                if(temp->name==dir && temp->id==1)\n                {\n                    q->next=temp->next;\n                    temp=q->next;\n                    continue;\n                }\n                else if(temp->parent==dir && temp->id==2)\n                {\n                    q->next=temp->next;\n                    temp=q->next;\n                    continue;   \n                }\n                q=temp;\n                temp=temp->next;\n            }\n        }\n    }\n}"}
